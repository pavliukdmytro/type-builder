/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BASE_TRANSITION": () => (/* binding */ BASE_TRANSITION),
/* harmony export */   "CAMELIZE": () => (/* binding */ CAMELIZE),
/* harmony export */   "CAPITALIZE": () => (/* binding */ CAPITALIZE),
/* harmony export */   "CREATE_BLOCK": () => (/* binding */ CREATE_BLOCK),
/* harmony export */   "CREATE_COMMENT": () => (/* binding */ CREATE_COMMENT),
/* harmony export */   "CREATE_ELEMENT_BLOCK": () => (/* binding */ CREATE_ELEMENT_BLOCK),
/* harmony export */   "CREATE_ELEMENT_VNODE": () => (/* binding */ CREATE_ELEMENT_VNODE),
/* harmony export */   "CREATE_SLOTS": () => (/* binding */ CREATE_SLOTS),
/* harmony export */   "CREATE_STATIC": () => (/* binding */ CREATE_STATIC),
/* harmony export */   "CREATE_TEXT": () => (/* binding */ CREATE_TEXT),
/* harmony export */   "CREATE_VNODE": () => (/* binding */ CREATE_VNODE),
/* harmony export */   "FRAGMENT": () => (/* binding */ FRAGMENT),
/* harmony export */   "GUARD_REACTIVE_PROPS": () => (/* binding */ GUARD_REACTIVE_PROPS),
/* harmony export */   "IS_MEMO_SAME": () => (/* binding */ IS_MEMO_SAME),
/* harmony export */   "IS_REF": () => (/* binding */ IS_REF),
/* harmony export */   "KEEP_ALIVE": () => (/* binding */ KEEP_ALIVE),
/* harmony export */   "MERGE_PROPS": () => (/* binding */ MERGE_PROPS),
/* harmony export */   "NORMALIZE_CLASS": () => (/* binding */ NORMALIZE_CLASS),
/* harmony export */   "NORMALIZE_PROPS": () => (/* binding */ NORMALIZE_PROPS),
/* harmony export */   "NORMALIZE_STYLE": () => (/* binding */ NORMALIZE_STYLE),
/* harmony export */   "OPEN_BLOCK": () => (/* binding */ OPEN_BLOCK),
/* harmony export */   "POP_SCOPE_ID": () => (/* binding */ POP_SCOPE_ID),
/* harmony export */   "PUSH_SCOPE_ID": () => (/* binding */ PUSH_SCOPE_ID),
/* harmony export */   "RENDER_LIST": () => (/* binding */ RENDER_LIST),
/* harmony export */   "RENDER_SLOT": () => (/* binding */ RENDER_SLOT),
/* harmony export */   "RESOLVE_COMPONENT": () => (/* binding */ RESOLVE_COMPONENT),
/* harmony export */   "RESOLVE_DIRECTIVE": () => (/* binding */ RESOLVE_DIRECTIVE),
/* harmony export */   "RESOLVE_DYNAMIC_COMPONENT": () => (/* binding */ RESOLVE_DYNAMIC_COMPONENT),
/* harmony export */   "RESOLVE_FILTER": () => (/* binding */ RESOLVE_FILTER),
/* harmony export */   "SET_BLOCK_TRACKING": () => (/* binding */ SET_BLOCK_TRACKING),
/* harmony export */   "SUSPENSE": () => (/* binding */ SUSPENSE),
/* harmony export */   "TELEPORT": () => (/* binding */ TELEPORT),
/* harmony export */   "TO_DISPLAY_STRING": () => (/* binding */ TO_DISPLAY_STRING),
/* harmony export */   "TO_HANDLERS": () => (/* binding */ TO_HANDLERS),
/* harmony export */   "TO_HANDLER_KEY": () => (/* binding */ TO_HANDLER_KEY),
/* harmony export */   "UNREF": () => (/* binding */ UNREF),
/* harmony export */   "WITH_CTX": () => (/* binding */ WITH_CTX),
/* harmony export */   "WITH_DIRECTIVES": () => (/* binding */ WITH_DIRECTIVES),
/* harmony export */   "WITH_MEMO": () => (/* binding */ WITH_MEMO),
/* harmony export */   "advancePositionWithClone": () => (/* binding */ advancePositionWithClone),
/* harmony export */   "advancePositionWithMutation": () => (/* binding */ advancePositionWithMutation),
/* harmony export */   "assert": () => (/* binding */ assert),
/* harmony export */   "baseCompile": () => (/* binding */ baseCompile),
/* harmony export */   "baseParse": () => (/* binding */ baseParse),
/* harmony export */   "buildDirectiveArgs": () => (/* binding */ buildDirectiveArgs),
/* harmony export */   "buildProps": () => (/* binding */ buildProps),
/* harmony export */   "buildSlots": () => (/* binding */ buildSlots),
/* harmony export */   "checkCompatEnabled": () => (/* binding */ checkCompatEnabled),
/* harmony export */   "createArrayExpression": () => (/* binding */ createArrayExpression),
/* harmony export */   "createAssignmentExpression": () => (/* binding */ createAssignmentExpression),
/* harmony export */   "createBlockStatement": () => (/* binding */ createBlockStatement),
/* harmony export */   "createCacheExpression": () => (/* binding */ createCacheExpression),
/* harmony export */   "createCallExpression": () => (/* binding */ createCallExpression),
/* harmony export */   "createCompilerError": () => (/* binding */ createCompilerError),
/* harmony export */   "createCompoundExpression": () => (/* binding */ createCompoundExpression),
/* harmony export */   "createConditionalExpression": () => (/* binding */ createConditionalExpression),
/* harmony export */   "createForLoopParams": () => (/* binding */ createForLoopParams),
/* harmony export */   "createFunctionExpression": () => (/* binding */ createFunctionExpression),
/* harmony export */   "createIfStatement": () => (/* binding */ createIfStatement),
/* harmony export */   "createInterpolation": () => (/* binding */ createInterpolation),
/* harmony export */   "createObjectExpression": () => (/* binding */ createObjectExpression),
/* harmony export */   "createObjectProperty": () => (/* binding */ createObjectProperty),
/* harmony export */   "createReturnStatement": () => (/* binding */ createReturnStatement),
/* harmony export */   "createRoot": () => (/* binding */ createRoot),
/* harmony export */   "createSequenceExpression": () => (/* binding */ createSequenceExpression),
/* harmony export */   "createSimpleExpression": () => (/* binding */ createSimpleExpression),
/* harmony export */   "createStructuralDirectiveTransform": () => (/* binding */ createStructuralDirectiveTransform),
/* harmony export */   "createTemplateLiteral": () => (/* binding */ createTemplateLiteral),
/* harmony export */   "createTransformContext": () => (/* binding */ createTransformContext),
/* harmony export */   "createVNodeCall": () => (/* binding */ createVNodeCall),
/* harmony export */   "extractIdentifiers": () => (/* binding */ extractIdentifiers),
/* harmony export */   "findDir": () => (/* binding */ findDir),
/* harmony export */   "findProp": () => (/* binding */ findProp),
/* harmony export */   "generate": () => (/* binding */ generate),
/* harmony export */   "generateCodeFrame": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_0__.generateCodeFrame),
/* harmony export */   "getBaseTransformPreset": () => (/* binding */ getBaseTransformPreset),
/* harmony export */   "getConstantType": () => (/* binding */ getConstantType),
/* harmony export */   "getInnerRange": () => (/* binding */ getInnerRange),
/* harmony export */   "getMemoedVNodeCall": () => (/* binding */ getMemoedVNodeCall),
/* harmony export */   "getVNodeBlockHelper": () => (/* binding */ getVNodeBlockHelper),
/* harmony export */   "getVNodeHelper": () => (/* binding */ getVNodeHelper),
/* harmony export */   "hasDynamicKeyVBind": () => (/* binding */ hasDynamicKeyVBind),
/* harmony export */   "hasScopeRef": () => (/* binding */ hasScopeRef),
/* harmony export */   "helperNameMap": () => (/* binding */ helperNameMap),
/* harmony export */   "injectProp": () => (/* binding */ injectProp),
/* harmony export */   "isBuiltInType": () => (/* binding */ isBuiltInType),
/* harmony export */   "isCoreComponent": () => (/* binding */ isCoreComponent),
/* harmony export */   "isFunctionType": () => (/* binding */ isFunctionType),
/* harmony export */   "isInDestructureAssignment": () => (/* binding */ isInDestructureAssignment),
/* harmony export */   "isMemberExpression": () => (/* binding */ isMemberExpression),
/* harmony export */   "isMemberExpressionBrowser": () => (/* binding */ isMemberExpressionBrowser),
/* harmony export */   "isMemberExpressionNode": () => (/* binding */ isMemberExpressionNode),
/* harmony export */   "isReferencedIdentifier": () => (/* binding */ isReferencedIdentifier),
/* harmony export */   "isSimpleIdentifier": () => (/* binding */ isSimpleIdentifier),
/* harmony export */   "isSlotOutlet": () => (/* binding */ isSlotOutlet),
/* harmony export */   "isStaticArgOf": () => (/* binding */ isStaticArgOf),
/* harmony export */   "isStaticExp": () => (/* binding */ isStaticExp),
/* harmony export */   "isStaticProperty": () => (/* binding */ isStaticProperty),
/* harmony export */   "isStaticPropertyKey": () => (/* binding */ isStaticPropertyKey),
/* harmony export */   "isTemplateNode": () => (/* binding */ isTemplateNode),
/* harmony export */   "isText": () => (/* binding */ isText),
/* harmony export */   "isVSlot": () => (/* binding */ isVSlot),
/* harmony export */   "locStub": () => (/* binding */ locStub),
/* harmony export */   "makeBlock": () => (/* binding */ makeBlock),
/* harmony export */   "noopDirectiveTransform": () => (/* binding */ noopDirectiveTransform),
/* harmony export */   "processExpression": () => (/* binding */ processExpression),
/* harmony export */   "processFor": () => (/* binding */ processFor),
/* harmony export */   "processIf": () => (/* binding */ processIf),
/* harmony export */   "processSlotOutlet": () => (/* binding */ processSlotOutlet),
/* harmony export */   "registerRuntimeHelpers": () => (/* binding */ registerRuntimeHelpers),
/* harmony export */   "resolveComponentType": () => (/* binding */ resolveComponentType),
/* harmony export */   "stringifyExpression": () => (/* binding */ stringifyExpression),
/* harmony export */   "toValidAssetId": () => (/* binding */ toValidAssetId),
/* harmony export */   "trackSlotScopes": () => (/* binding */ trackSlotScopes),
/* harmony export */   "trackVForSlotScopes": () => (/* binding */ trackVForSlotScopes),
/* harmony export */   "transform": () => (/* binding */ transform),
/* harmony export */   "transformBind": () => (/* binding */ transformBind),
/* harmony export */   "transformElement": () => (/* binding */ transformElement),
/* harmony export */   "transformExpression": () => (/* binding */ transformExpression),
/* harmony export */   "transformModel": () => (/* binding */ transformModel),
/* harmony export */   "transformOn": () => (/* binding */ transformOn),
/* harmony export */   "traverseNode": () => (/* binding */ traverseNode),
/* harmony export */   "walkBlockDeclarations": () => (/* binding */ walkBlockDeclarations),
/* harmony export */   "walkFunctionParams": () => (/* binding */ walkFunctionParams),
/* harmony export */   "walkIdentifiers": () => (/* binding */ walkIdentifiers),
/* harmony export */   "warnDeprecation": () => (/* binding */ warnDeprecation)
/* harmony export */ });
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");



function defaultOnError(error) {
    throw error;
}
function defaultOnWarn(msg) {
    ( true) && console.warn(`[Vue warn] ${msg.message}`);
}
function createCompilerError(code, loc, messages, additionalMessage) {
    const msg =  true
        ? (messages || errorMessages)[code] + (additionalMessage || ``)
        : 0;
    const error = new SyntaxError(String(msg));
    error.code = code;
    error.loc = loc;
    return error;
}
const errorMessages = {
    // parse errors
    [0 /* ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT */]: 'Illegal comment.',
    [1 /* ErrorCodes.CDATA_IN_HTML_CONTENT */]: 'CDATA section is allowed only in XML context.',
    [2 /* ErrorCodes.DUPLICATE_ATTRIBUTE */]: 'Duplicate attribute.',
    [3 /* ErrorCodes.END_TAG_WITH_ATTRIBUTES */]: 'End tag cannot have attributes.',
    [4 /* ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS */]: "Illegal '/' in tags.",
    [5 /* ErrorCodes.EOF_BEFORE_TAG_NAME */]: 'Unexpected EOF in tag.',
    [6 /* ErrorCodes.EOF_IN_CDATA */]: 'Unexpected EOF in CDATA section.',
    [7 /* ErrorCodes.EOF_IN_COMMENT */]: 'Unexpected EOF in comment.',
    [8 /* ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */]: 'Unexpected EOF in script.',
    [9 /* ErrorCodes.EOF_IN_TAG */]: 'Unexpected EOF in tag.',
    [10 /* ErrorCodes.INCORRECTLY_CLOSED_COMMENT */]: 'Incorrectly closed comment.',
    [11 /* ErrorCodes.INCORRECTLY_OPENED_COMMENT */]: 'Incorrectly opened comment.',
    [12 /* ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME */]: "Illegal tag name. Use '&lt;' to print '<'.",
    [13 /* ErrorCodes.MISSING_ATTRIBUTE_VALUE */]: 'Attribute value was expected.',
    [14 /* ErrorCodes.MISSING_END_TAG_NAME */]: 'End tag name was expected.',
    [15 /* ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */]: 'Whitespace was expected.',
    [16 /* ErrorCodes.NESTED_COMMENT */]: "Unexpected '<!--' in comment.",
    [17 /* ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */]: 'Attribute name cannot contain U+0022 ("), U+0027 (\'), and U+003C (<).',
    [18 /* ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */]: 'Unquoted attribute value cannot contain U+0022 ("), U+0027 (\'), U+003C (<), U+003D (=), and U+0060 (`).',
    [19 /* ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */]: "Attribute name cannot start with '='.",
    [21 /* ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */]: "'<?' is allowed only in XML context.",
    [20 /* ErrorCodes.UNEXPECTED_NULL_CHARACTER */]: `Unexpected null character.`,
    [22 /* ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG */]: "Illegal '/' in tags.",
    // Vue-specific parse errors
    [23 /* ErrorCodes.X_INVALID_END_TAG */]: 'Invalid end tag.',
    [24 /* ErrorCodes.X_MISSING_END_TAG */]: 'Element is missing end tag.',
    [25 /* ErrorCodes.X_MISSING_INTERPOLATION_END */]: 'Interpolation end sign was not found.',
    [27 /* ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */]: 'End bracket for dynamic directive argument was not found. ' +
        'Note that dynamic directive argument cannot contain spaces.',
    [26 /* ErrorCodes.X_MISSING_DIRECTIVE_NAME */]: 'Legal directive name was expected.',
    // transform errors
    [28 /* ErrorCodes.X_V_IF_NO_EXPRESSION */]: `v-if/v-else-if is missing expression.`,
    [29 /* ErrorCodes.X_V_IF_SAME_KEY */]: `v-if/else branches must use unique keys.`,
    [30 /* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
    [31 /* ErrorCodes.X_V_FOR_NO_EXPRESSION */]: `v-for is missing expression.`,
    [32 /* ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION */]: `v-for has invalid expression.`,
    [33 /* ErrorCodes.X_V_FOR_TEMPLATE_KEY_PLACEMENT */]: `<template v-for> key should be placed on the <template> tag.`,
    [34 /* ErrorCodes.X_V_BIND_NO_EXPRESSION */]: `v-bind is missing expression.`,
    [35 /* ErrorCodes.X_V_ON_NO_EXPRESSION */]: `v-on is missing expression.`,
    [36 /* ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */]: `Unexpected custom directive on <slot> outlet.`,
    [37 /* ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE */]: `Mixed v-slot usage on both the component and nested <template>.` +
        `When there are multiple named slots, all slots should use <template> ` +
        `syntax to avoid scope ambiguity.`,
    [38 /* ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES */]: `Duplicate slot names found. `,
    [39 /* ErrorCodes.X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */]: `Extraneous children found when component already has explicitly named ` +
        `default slot. These children will be ignored.`,
    [40 /* ErrorCodes.X_V_SLOT_MISPLACED */]: `v-slot can only be used on components or <template> tags.`,
    [41 /* ErrorCodes.X_V_MODEL_NO_EXPRESSION */]: `v-model is missing expression.`,
    [42 /* ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION */]: `v-model value must be a valid JavaScript member expression.`,
    [43 /* ErrorCodes.X_V_MODEL_ON_SCOPE_VARIABLE */]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
    [44 /* ErrorCodes.X_V_MODEL_ON_PROPS */]: `v-model cannot be used on a prop, because local prop bindings are not writable.\nUse a v-bind binding combined with a v-on listener that emits update:x event instead.`,
    [45 /* ErrorCodes.X_INVALID_EXPRESSION */]: `Error parsing JavaScript expression: `,
    [46 /* ErrorCodes.X_KEEP_ALIVE_INVALID_CHILDREN */]: `<KeepAlive> expects exactly one child component.`,
    // generic errors
    [47 /* ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED */]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
    [48 /* ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED */]: `ES module mode is not supported in this build of compiler.`,
    [49 /* ErrorCodes.X_CACHE_HANDLER_NOT_SUPPORTED */]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
    [50 /* ErrorCodes.X_SCOPE_ID_NOT_SUPPORTED */]: `"scopeId" option is only supported in module mode.`,
    // just to fulfill types
    [51 /* ErrorCodes.__EXTEND_POINT__ */]: ``
};

const FRAGMENT = Symbol(( true) ? `Fragment` : 0);
const TELEPORT = Symbol(( true) ? `Teleport` : 0);
const SUSPENSE = Symbol(( true) ? `Suspense` : 0);
const KEEP_ALIVE = Symbol(( true) ? `KeepAlive` : 0);
const BASE_TRANSITION = Symbol(( true) ? `BaseTransition` : 0);
const OPEN_BLOCK = Symbol(( true) ? `openBlock` : 0);
const CREATE_BLOCK = Symbol(( true) ? `createBlock` : 0);
const CREATE_ELEMENT_BLOCK = Symbol(( true) ? `createElementBlock` : 0);
const CREATE_VNODE = Symbol(( true) ? `createVNode` : 0);
const CREATE_ELEMENT_VNODE = Symbol(( true) ? `createElementVNode` : 0);
const CREATE_COMMENT = Symbol(( true) ? `createCommentVNode` : 0);
const CREATE_TEXT = Symbol(( true) ? `createTextVNode` : 0);
const CREATE_STATIC = Symbol(( true) ? `createStaticVNode` : 0);
const RESOLVE_COMPONENT = Symbol(( true) ? `resolveComponent` : 0);
const RESOLVE_DYNAMIC_COMPONENT = Symbol(( true) ? `resolveDynamicComponent` : 0);
const RESOLVE_DIRECTIVE = Symbol(( true) ? `resolveDirective` : 0);
const RESOLVE_FILTER = Symbol(( true) ? `resolveFilter` : 0);
const WITH_DIRECTIVES = Symbol(( true) ? `withDirectives` : 0);
const RENDER_LIST = Symbol(( true) ? `renderList` : 0);
const RENDER_SLOT = Symbol(( true) ? `renderSlot` : 0);
const CREATE_SLOTS = Symbol(( true) ? `createSlots` : 0);
const TO_DISPLAY_STRING = Symbol(( true) ? `toDisplayString` : 0);
const MERGE_PROPS = Symbol(( true) ? `mergeProps` : 0);
const NORMALIZE_CLASS = Symbol(( true) ? `normalizeClass` : 0);
const NORMALIZE_STYLE = Symbol(( true) ? `normalizeStyle` : 0);
const NORMALIZE_PROPS = Symbol(( true) ? `normalizeProps` : 0);
const GUARD_REACTIVE_PROPS = Symbol(( true) ? `guardReactiveProps` : 0);
const TO_HANDLERS = Symbol(( true) ? `toHandlers` : 0);
const CAMELIZE = Symbol(( true) ? `camelize` : 0);
const CAPITALIZE = Symbol(( true) ? `capitalize` : 0);
const TO_HANDLER_KEY = Symbol(( true) ? `toHandlerKey` : 0);
const SET_BLOCK_TRACKING = Symbol(( true) ? `setBlockTracking` : 0);
const PUSH_SCOPE_ID = Symbol(( true) ? `pushScopeId` : 0);
const POP_SCOPE_ID = Symbol(( true) ? `popScopeId` : 0);
const WITH_CTX = Symbol(( true) ? `withCtx` : 0);
const UNREF = Symbol(( true) ? `unref` : 0);
const IS_REF = Symbol(( true) ? `isRef` : 0);
const WITH_MEMO = Symbol(( true) ? `withMemo` : 0);
const IS_MEMO_SAME = Symbol(( true) ? `isMemoSame` : 0);
// Name mapping for runtime helpers that need to be imported from 'vue' in
// generated code. Make sure these are correctly exported in the runtime!
const helperNameMap = {
    [FRAGMENT]: `Fragment`,
    [TELEPORT]: `Teleport`,
    [SUSPENSE]: `Suspense`,
    [KEEP_ALIVE]: `KeepAlive`,
    [BASE_TRANSITION]: `BaseTransition`,
    [OPEN_BLOCK]: `openBlock`,
    [CREATE_BLOCK]: `createBlock`,
    [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
    [CREATE_VNODE]: `createVNode`,
    [CREATE_ELEMENT_VNODE]: `createElementVNode`,
    [CREATE_COMMENT]: `createCommentVNode`,
    [CREATE_TEXT]: `createTextVNode`,
    [CREATE_STATIC]: `createStaticVNode`,
    [RESOLVE_COMPONENT]: `resolveComponent`,
    [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
    [RESOLVE_DIRECTIVE]: `resolveDirective`,
    [RESOLVE_FILTER]: `resolveFilter`,
    [WITH_DIRECTIVES]: `withDirectives`,
    [RENDER_LIST]: `renderList`,
    [RENDER_SLOT]: `renderSlot`,
    [CREATE_SLOTS]: `createSlots`,
    [TO_DISPLAY_STRING]: `toDisplayString`,
    [MERGE_PROPS]: `mergeProps`,
    [NORMALIZE_CLASS]: `normalizeClass`,
    [NORMALIZE_STYLE]: `normalizeStyle`,
    [NORMALIZE_PROPS]: `normalizeProps`,
    [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
    [TO_HANDLERS]: `toHandlers`,
    [CAMELIZE]: `camelize`,
    [CAPITALIZE]: `capitalize`,
    [TO_HANDLER_KEY]: `toHandlerKey`,
    [SET_BLOCK_TRACKING]: `setBlockTracking`,
    [PUSH_SCOPE_ID]: `pushScopeId`,
    [POP_SCOPE_ID]: `popScopeId`,
    [WITH_CTX]: `withCtx`,
    [UNREF]: `unref`,
    [IS_REF]: `isRef`,
    [WITH_MEMO]: `withMemo`,
    [IS_MEMO_SAME]: `isMemoSame`
};
function registerRuntimeHelpers(helpers) {
    Object.getOwnPropertySymbols(helpers).forEach(s => {
        helperNameMap[s] = helpers[s];
    });
}

// AST Utilities ---------------------------------------------------------------
// Some expressions, e.g. sequence and conditional expressions, are never
// associated with template nodes, so their source locations are just a stub.
// Container types like CompoundExpression also don't need a real location.
const locStub = {
    source: '',
    start: { line: 1, column: 1, offset: 0 },
    end: { line: 1, column: 1, offset: 0 }
};
function createRoot(children, loc = locStub) {
    return {
        type: 0 /* NodeTypes.ROOT */,
        children,
        helpers: [],
        components: [],
        directives: [],
        hoists: [],
        imports: [],
        cached: 0,
        temps: 0,
        codegenNode: undefined,
        loc
    };
}
function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent = false, loc = locStub) {
    if (context) {
        if (isBlock) {
            context.helper(OPEN_BLOCK);
            context.helper(getVNodeBlockHelper(context.inSSR, isComponent));
        }
        else {
            context.helper(getVNodeHelper(context.inSSR, isComponent));
        }
        if (directives) {
            context.helper(WITH_DIRECTIVES);
        }
    }
    return {
        type: 13 /* NodeTypes.VNODE_CALL */,
        tag,
        props,
        children,
        patchFlag,
        dynamicProps,
        directives,
        isBlock,
        disableTracking,
        isComponent,
        loc
    };
}
function createArrayExpression(elements, loc = locStub) {
    return {
        type: 17 /* NodeTypes.JS_ARRAY_EXPRESSION */,
        loc,
        elements
    };
}
function createObjectExpression(properties, loc = locStub) {
    return {
        type: 15 /* NodeTypes.JS_OBJECT_EXPRESSION */,
        loc,
        properties
    };
}
function createObjectProperty(key, value) {
    return {
        type: 16 /* NodeTypes.JS_PROPERTY */,
        loc: locStub,
        key: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(key) ? createSimpleExpression(key, true) : key,
        value
    };
}
function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0 /* ConstantTypes.NOT_CONSTANT */) {
    return {
        type: 4 /* NodeTypes.SIMPLE_EXPRESSION */,
        loc,
        content,
        isStatic,
        constType: isStatic ? 3 /* ConstantTypes.CAN_STRINGIFY */ : constType
    };
}
function createInterpolation(content, loc) {
    return {
        type: 5 /* NodeTypes.INTERPOLATION */,
        loc,
        content: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(content)
            ? createSimpleExpression(content, false, loc)
            : content
    };
}
function createCompoundExpression(children, loc = locStub) {
    return {
        type: 8 /* NodeTypes.COMPOUND_EXPRESSION */,
        loc,
        children
    };
}
function createCallExpression(callee, args = [], loc = locStub) {
    return {
        type: 14 /* NodeTypes.JS_CALL_EXPRESSION */,
        loc,
        callee,
        arguments: args
    };
}
function createFunctionExpression(params, returns = undefined, newline = false, isSlot = false, loc = locStub) {
    return {
        type: 18 /* NodeTypes.JS_FUNCTION_EXPRESSION */,
        params,
        returns,
        newline,
        isSlot,
        loc
    };
}
function createConditionalExpression(test, consequent, alternate, newline = true) {
    return {
        type: 19 /* NodeTypes.JS_CONDITIONAL_EXPRESSION */,
        test,
        consequent,
        alternate,
        newline,
        loc: locStub
    };
}
function createCacheExpression(index, value, isVNode = false) {
    return {
        type: 20 /* NodeTypes.JS_CACHE_EXPRESSION */,
        index,
        value,
        isVNode,
        loc: locStub
    };
}
function createBlockStatement(body) {
    return {
        type: 21 /* NodeTypes.JS_BLOCK_STATEMENT */,
        body,
        loc: locStub
    };
}
function createTemplateLiteral(elements) {
    return {
        type: 22 /* NodeTypes.JS_TEMPLATE_LITERAL */,
        elements,
        loc: locStub
    };
}
function createIfStatement(test, consequent, alternate) {
    return {
        type: 23 /* NodeTypes.JS_IF_STATEMENT */,
        test,
        consequent,
        alternate,
        loc: locStub
    };
}
function createAssignmentExpression(left, right) {
    return {
        type: 24 /* NodeTypes.JS_ASSIGNMENT_EXPRESSION */,
        left,
        right,
        loc: locStub
    };
}
function createSequenceExpression(expressions) {
    return {
        type: 25 /* NodeTypes.JS_SEQUENCE_EXPRESSION */,
        expressions,
        loc: locStub
    };
}
function createReturnStatement(returns) {
    return {
        type: 26 /* NodeTypes.JS_RETURN_STATEMENT */,
        returns,
        loc: locStub
    };
}

const isStaticExp = (p) => p.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ && p.isStatic;
const isBuiltInType = (tag, expected) => tag === expected || tag === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hyphenate)(expected);
function isCoreComponent(tag) {
    if (isBuiltInType(tag, 'Teleport')) {
        return TELEPORT;
    }
    else if (isBuiltInType(tag, 'Suspense')) {
        return SUSPENSE;
    }
    else if (isBuiltInType(tag, 'KeepAlive')) {
        return KEEP_ALIVE;
    }
    else if (isBuiltInType(tag, 'BaseTransition')) {
        return BASE_TRANSITION;
    }
}
const nonIdentifierRE = /^\d|[^\$\w]/;
const isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
const validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
const validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
const whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
/**
 * Simple lexer to check if an expression is a member expression. This is
 * lax and only checks validity at the root level (i.e. does not validate exps
 * inside square brackets), but it's ok since these are only used on template
 * expressions and false positives are invalid expressions in the first place.
 */
const isMemberExpressionBrowser = (path) => {
    // remove whitespaces around . or [ first
    path = path.trim().replace(whitespaceRE, s => s.trim());
    let state = 0 /* MemberExpLexState.inMemberExp */;
    let stateStack = [];
    let currentOpenBracketCount = 0;
    let currentOpenParensCount = 0;
    let currentStringType = null;
    for (let i = 0; i < path.length; i++) {
        const char = path.charAt(i);
        switch (state) {
            case 0 /* MemberExpLexState.inMemberExp */:
                if (char === '[') {
                    stateStack.push(state);
                    state = 1 /* MemberExpLexState.inBrackets */;
                    currentOpenBracketCount++;
                }
                else if (char === '(') {
                    stateStack.push(state);
                    state = 2 /* MemberExpLexState.inParens */;
                    currentOpenParensCount++;
                }
                else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
                    return false;
                }
                break;
            case 1 /* MemberExpLexState.inBrackets */:
                if (char === `'` || char === `"` || char === '`') {
                    stateStack.push(state);
                    state = 3 /* MemberExpLexState.inString */;
                    currentStringType = char;
                }
                else if (char === `[`) {
                    currentOpenBracketCount++;
                }
                else if (char === `]`) {
                    if (!--currentOpenBracketCount) {
                        state = stateStack.pop();
                    }
                }
                break;
            case 2 /* MemberExpLexState.inParens */:
                if (char === `'` || char === `"` || char === '`') {
                    stateStack.push(state);
                    state = 3 /* MemberExpLexState.inString */;
                    currentStringType = char;
                }
                else if (char === `(`) {
                    currentOpenParensCount++;
                }
                else if (char === `)`) {
                    // if the exp ends as a call then it should not be considered valid
                    if (i === path.length - 1) {
                        return false;
                    }
                    if (!--currentOpenParensCount) {
                        state = stateStack.pop();
                    }
                }
                break;
            case 3 /* MemberExpLexState.inString */:
                if (char === currentStringType) {
                    state = stateStack.pop();
                    currentStringType = null;
                }
                break;
        }
    }
    return !currentOpenBracketCount && !currentOpenParensCount;
};
const isMemberExpressionNode = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP
    ;
const isMemberExpression = isMemberExpressionBrowser
    ;
function getInnerRange(loc, offset, length) {
    const source = loc.source.slice(offset, offset + length);
    const newLoc = {
        source,
        start: advancePositionWithClone(loc.start, loc.source, offset),
        end: loc.end
    };
    if (length != null) {
        newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);
    }
    return newLoc;
}
function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
    return advancePositionWithMutation((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, pos), source, numberOfCharacters);
}
// advance by mutation without cloning (for performance reasons), since this
// gets called a lot in the parser
function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
    let linesCount = 0;
    let lastNewLinePos = -1;
    for (let i = 0; i < numberOfCharacters; i++) {
        if (source.charCodeAt(i) === 10 /* newline char code */) {
            linesCount++;
            lastNewLinePos = i;
        }
    }
    pos.offset += numberOfCharacters;
    pos.line += linesCount;
    pos.column =
        lastNewLinePos === -1
            ? pos.column + numberOfCharacters
            : numberOfCharacters - lastNewLinePos;
    return pos;
}
function assert(condition, msg) {
    /* istanbul ignore if */
    if (!condition) {
        throw new Error(msg || `unexpected compiler condition`);
    }
}
function findDir(node, name, allowEmpty = false) {
    for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 7 /* NodeTypes.DIRECTIVE */ &&
            (allowEmpty || p.exp) &&
            ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(name) ? p.name === name : name.test(p.name))) {
            return p;
        }
    }
}
function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
    for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 6 /* NodeTypes.ATTRIBUTE */) {
            if (dynamicOnly)
                continue;
            if (p.name === name && (p.value || allowEmpty)) {
                return p;
            }
        }
        else if (p.name === 'bind' &&
            (p.exp || allowEmpty) &&
            isStaticArgOf(p.arg, name)) {
            return p;
        }
    }
}
function isStaticArgOf(arg, name) {
    return !!(arg && isStaticExp(arg) && arg.content === name);
}
function hasDynamicKeyVBind(node) {
    return node.props.some(p => p.type === 7 /* NodeTypes.DIRECTIVE */ &&
        p.name === 'bind' &&
        (!p.arg || // v-bind="obj"
            p.arg.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */ || // v-bind:[_ctx.foo]
            !p.arg.isStatic) // v-bind:[foo]
    );
}
function isText(node) {
    return node.type === 5 /* NodeTypes.INTERPOLATION */ || node.type === 2 /* NodeTypes.TEXT */;
}
function isVSlot(p) {
    return p.type === 7 /* NodeTypes.DIRECTIVE */ && p.name === 'slot';
}
function isTemplateNode(node) {
    return (node.type === 1 /* NodeTypes.ELEMENT */ && node.tagType === 3 /* ElementTypes.TEMPLATE */);
}
function isSlotOutlet(node) {
    return node.type === 1 /* NodeTypes.ELEMENT */ && node.tagType === 2 /* ElementTypes.SLOT */;
}
function getVNodeHelper(ssr, isComponent) {
    return ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
}
function getVNodeBlockHelper(ssr, isComponent) {
    return ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
}
const propsHelperSet = new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
function getUnnormalizedProps(props, callPath = []) {
    if (props &&
        !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(props) &&
        props.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */) {
        const callee = props.callee;
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(callee) && propsHelperSet.has(callee)) {
            return getUnnormalizedProps(props.arguments[0], callPath.concat(props));
        }
    }
    return [props, callPath];
}
function injectProp(node, prop, context) {
    let propsWithInjection;
    /**
     * 1. mergeProps(...)
     * 2. toHandlers(...)
     * 3. normalizeProps(...)
     * 4. normalizeProps(guardReactiveProps(...))
     *
     * we need to get the real props before normalization
     */
    let props = node.type === 13 /* NodeTypes.VNODE_CALL */ ? node.props : node.arguments[2];
    let callPath = [];
    let parentCall;
    if (props &&
        !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(props) &&
        props.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */) {
        const ret = getUnnormalizedProps(props);
        props = ret[0];
        callPath = ret[1];
        parentCall = callPath[callPath.length - 1];
    }
    if (props == null || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(props)) {
        propsWithInjection = createObjectExpression([prop]);
    }
    else if (props.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */) {
        // merged props... add ours
        // only inject key to object literal if it's the first argument so that
        // if doesn't override user provided keys
        const first = props.arguments[0];
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(first) && first.type === 15 /* NodeTypes.JS_OBJECT_EXPRESSION */) {
            // #6631
            if (!hasProp(prop, first)) {
                first.properties.unshift(prop);
            }
        }
        else {
            if (props.callee === TO_HANDLERS) {
                // #2366
                propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
                    createObjectExpression([prop]),
                    props
                ]);
            }
            else {
                props.arguments.unshift(createObjectExpression([prop]));
            }
        }
        !propsWithInjection && (propsWithInjection = props);
    }
    else if (props.type === 15 /* NodeTypes.JS_OBJECT_EXPRESSION */) {
        if (!hasProp(prop, props)) {
            props.properties.unshift(prop);
        }
        propsWithInjection = props;
    }
    else {
        // single v-bind with expression, return a merged replacement
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
            createObjectExpression([prop]),
            props
        ]);
        // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(props))`,
        // it will be rewritten as `normalizeProps(mergeProps({ key: 0 }, props))`,
        // the `guardReactiveProps` will no longer be needed
        if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
            parentCall = callPath[callPath.length - 2];
        }
    }
    if (node.type === 13 /* NodeTypes.VNODE_CALL */) {
        if (parentCall) {
            parentCall.arguments[0] = propsWithInjection;
        }
        else {
            node.props = propsWithInjection;
        }
    }
    else {
        if (parentCall) {
            parentCall.arguments[0] = propsWithInjection;
        }
        else {
            node.arguments[2] = propsWithInjection;
        }
    }
}
// check existing key to avoid overriding user provided keys
function hasProp(prop, props) {
    let result = false;
    if (prop.key.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
        const propKeyName = prop.key.content;
        result = props.properties.some(p => p.key.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ &&
            p.key.content === propKeyName);
    }
    return result;
}
function toValidAssetId(name, type) {
    // see issue#4422, we need adding identifier on validAssetId if variable `name` has specific character
    return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
        return searchValue === '-' ? '_' : name.charCodeAt(replaceValue).toString();
    })}`;
}
// Check if a node contains expressions that reference current context scope ids
function hasScopeRef(node, ids) {
    if (!node || Object.keys(ids).length === 0) {
        return false;
    }
    switch (node.type) {
        case 1 /* NodeTypes.ELEMENT */:
            for (let i = 0; i < node.props.length; i++) {
                const p = node.props[i];
                if (p.type === 7 /* NodeTypes.DIRECTIVE */ &&
                    (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {
                    return true;
                }
            }
            return node.children.some(c => hasScopeRef(c, ids));
        case 11 /* NodeTypes.FOR */:
            if (hasScopeRef(node.source, ids)) {
                return true;
            }
            return node.children.some(c => hasScopeRef(c, ids));
        case 9 /* NodeTypes.IF */:
            return node.branches.some(b => hasScopeRef(b, ids));
        case 10 /* NodeTypes.IF_BRANCH */:
            if (hasScopeRef(node.condition, ids)) {
                return true;
            }
            return node.children.some(c => hasScopeRef(c, ids));
        case 4 /* NodeTypes.SIMPLE_EXPRESSION */:
            return (!node.isStatic &&
                isSimpleIdentifier(node.content) &&
                !!ids[node.content]);
        case 8 /* NodeTypes.COMPOUND_EXPRESSION */:
            return node.children.some(c => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(c) && hasScopeRef(c, ids));
        case 5 /* NodeTypes.INTERPOLATION */:
        case 12 /* NodeTypes.TEXT_CALL */:
            return hasScopeRef(node.content, ids);
        case 2 /* NodeTypes.TEXT */:
        case 3 /* NodeTypes.COMMENT */:
            return false;
        default:
            if ((true)) ;
            return false;
    }
}
function getMemoedVNodeCall(node) {
    if (node.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */ && node.callee === WITH_MEMO) {
        return node.arguments[1].returns;
    }
    else {
        return node;
    }
}
function makeBlock(node, { helper, removeHelper, inSSR }) {
    if (!node.isBlock) {
        node.isBlock = true;
        removeHelper(getVNodeHelper(inSSR, node.isComponent));
        helper(OPEN_BLOCK);
        helper(getVNodeBlockHelper(inSSR, node.isComponent));
    }
}

const deprecationData = {
    ["COMPILER_IS_ON_ELEMENT" /* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */]: {
        message: `Platform-native elements with "is" prop will no longer be ` +
            `treated as components in Vue 3 unless the "is" value is explicitly ` +
            `prefixed with "vue:".`,
        link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
    },
    ["COMPILER_V_BIND_SYNC" /* CompilerDeprecationTypes.COMPILER_V_BIND_SYNC */]: {
        message: key => `.sync modifier for v-bind has been removed. Use v-model with ` +
            `argument instead. \`v-bind:${key}.sync\` should be changed to ` +
            `\`v-model:${key}\`.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
    },
    ["COMPILER_V_BIND_PROP" /* CompilerDeprecationTypes.COMPILER_V_BIND_PROP */]: {
        message: `.prop modifier for v-bind has been removed and no longer necessary. ` +
            `Vue 3 will automatically set a binding as DOM property when appropriate.`
    },
    ["COMPILER_V_BIND_OBJECT_ORDER" /* CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER */]: {
        message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript ` +
            `object spread: it will now overwrite an existing non-mergeable attribute ` +
            `that appears before v-bind in the case of conflict. ` +
            `To retain 2.x behavior, move v-bind to make it the first attribute. ` +
            `You can also suppress this warning if the usage is intended.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
    },
    ["COMPILER_V_ON_NATIVE" /* CompilerDeprecationTypes.COMPILER_V_ON_NATIVE */]: {
        message: `.native modifier for v-on has been removed as is no longer necessary.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
    },
    ["COMPILER_V_IF_V_FOR_PRECEDENCE" /* CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE */]: {
        message: `v-if / v-for precedence when used on the same element has changed ` +
            `in Vue 3: v-if now takes higher precedence and will no longer have ` +
            `access to v-for scope variables. It is best to avoid the ambiguity ` +
            `with <template> tags or use a computed property that filters v-for ` +
            `data source.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
    },
    ["COMPILER_NATIVE_TEMPLATE" /* CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE */]: {
        message: `<template> with no special directives will render as a native template ` +
            `element instead of its inner content in Vue 3.`
    },
    ["COMPILER_INLINE_TEMPLATE" /* CompilerDeprecationTypes.COMPILER_INLINE_TEMPLATE */]: {
        message: `"inline-template" has been removed in Vue 3.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
    },
    ["COMPILER_FILTER" /* CompilerDeprecationTypes.COMPILER_FILTERS */]: {
        message: `filters have been removed in Vue 3. ` +
            `The "|" symbol will be treated as native JavaScript bitwise OR operator. ` +
            `Use method calls or computed properties instead.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
    }
};
function getCompatValue(key, context) {
    const config = context.options
        ? context.options.compatConfig
        : context.compatConfig;
    const value = config && config[key];
    if (key === 'MODE') {
        return value || 3; // compiler defaults to v3 behavior
    }
    else {
        return value;
    }
}
function isCompatEnabled(key, context) {
    const mode = getCompatValue('MODE', context);
    const value = getCompatValue(key, context);
    // in v3 mode, only enable if explicitly set to true
    // otherwise enable for any non-false value
    return mode === 3 ? value === true : value !== false;
}
function checkCompatEnabled(key, context, loc, ...args) {
    const enabled = isCompatEnabled(key, context);
    if (( true) && enabled) {
        warnDeprecation(key, context, loc, ...args);
    }
    return enabled;
}
function warnDeprecation(key, context, loc, ...args) {
    const val = getCompatValue(key, context);
    if (val === 'suppress-warning') {
        return;
    }
    const { message, link } = deprecationData[key];
    const msg = `(deprecation ${key}) ${typeof message === 'function' ? message(...args) : message}${link ? `\n  Details: ${link}` : ``}`;
    const err = new SyntaxError(msg);
    err.code = key;
    if (loc)
        err.loc = loc;
    context.onWarn(err);
}

// The default decoder only provides escapes for characters reserved as part of
// the template syntax, and is only used if the custom renderer did not provide
// a platform-specific decoder.
const decodeRE = /&(gt|lt|amp|apos|quot);/g;
const decodeMap = {
    gt: '>',
    lt: '<',
    amp: '&',
    apos: "'",
    quot: '"'
};
const defaultParserOptions = {
    delimiters: [`{{`, `}}`],
    getNamespace: () => 0 /* Namespaces.HTML */,
    getTextMode: () => 0 /* TextModes.DATA */,
    isVoidTag: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
    isPreTag: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
    isCustomElement: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
    decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),
    onError: defaultOnError,
    onWarn: defaultOnWarn,
    comments: ("development" !== 'production')
};
function baseParse(content, options = {}) {
    const context = createParserContext(content, options);
    const start = getCursor(context);
    return createRoot(parseChildren(context, 0 /* TextModes.DATA */, []), getSelection(context, start));
}
function createParserContext(content, rawOptions) {
    const options = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, defaultParserOptions);
    let key;
    for (key in rawOptions) {
        // @ts-ignore
        options[key] =
            rawOptions[key] === undefined
                ? defaultParserOptions[key]
                : rawOptions[key];
    }
    return {
        options,
        column: 1,
        line: 1,
        offset: 0,
        originalSource: content,
        source: content,
        inPre: false,
        inVPre: false,
        onWarn: options.onWarn
    };
}
function parseChildren(context, mode, ancestors) {
    const parent = last(ancestors);
    const ns = parent ? parent.ns : 0 /* Namespaces.HTML */;
    const nodes = [];
    while (!isEnd(context, mode, ancestors)) {
        const s = context.source;
        let node = undefined;
        if (mode === 0 /* TextModes.DATA */ || mode === 1 /* TextModes.RCDATA */) {
            if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
                // '{{'
                node = parseInterpolation(context, mode);
            }
            else if (mode === 0 /* TextModes.DATA */ && s[0] === '<') {
                // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state
                if (s.length === 1) {
                    emitError(context, 5 /* ErrorCodes.EOF_BEFORE_TAG_NAME */, 1);
                }
                else if (s[1] === '!') {
                    // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state
                    if (startsWith(s, '<!--')) {
                        node = parseComment(context);
                    }
                    else if (startsWith(s, '<!DOCTYPE')) {
                        // Ignore DOCTYPE by a limitation.
                        node = parseBogusComment(context);
                    }
                    else if (startsWith(s, '<![CDATA[')) {
                        if (ns !== 0 /* Namespaces.HTML */) {
                            node = parseCDATA(context, ancestors);
                        }
                        else {
                            emitError(context, 1 /* ErrorCodes.CDATA_IN_HTML_CONTENT */);
                            node = parseBogusComment(context);
                        }
                    }
                    else {
                        emitError(context, 11 /* ErrorCodes.INCORRECTLY_OPENED_COMMENT */);
                        node = parseBogusComment(context);
                    }
                }
                else if (s[1] === '/') {
                    // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state
                    if (s.length === 2) {
                        emitError(context, 5 /* ErrorCodes.EOF_BEFORE_TAG_NAME */, 2);
                    }
                    else if (s[2] === '>') {
                        emitError(context, 14 /* ErrorCodes.MISSING_END_TAG_NAME */, 2);
                        advanceBy(context, 3);
                        continue;
                    }
                    else if (/[a-z]/i.test(s[2])) {
                        emitError(context, 23 /* ErrorCodes.X_INVALID_END_TAG */);
                        parseTag(context, 1 /* TagType.End */, parent);
                        continue;
                    }
                    else {
                        emitError(context, 12 /* ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 2);
                        node = parseBogusComment(context);
                    }
                }
                else if (/[a-z]/i.test(s[1])) {
                    node = parseElement(context, ancestors);
                    // 2.x <template> with no directive compat
                    if (isCompatEnabled("COMPILER_NATIVE_TEMPLATE" /* CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE */, context) &&
                        node &&
                        node.tag === 'template' &&
                        !node.props.some(p => p.type === 7 /* NodeTypes.DIRECTIVE */ &&
                            isSpecialTemplateDirective(p.name))) {
                        ( true) &&
                            warnDeprecation("COMPILER_NATIVE_TEMPLATE" /* CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE */, context, node.loc);
                        node = node.children;
                    }
                }
                else if (s[1] === '?') {
                    emitError(context, 21 /* ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */, 1);
                    node = parseBogusComment(context);
                }
                else {
                    emitError(context, 12 /* ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 1);
                }
            }
        }
        if (!node) {
            node = parseText(context, mode);
        }
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node)) {
            for (let i = 0; i < node.length; i++) {
                pushNode(nodes, node[i]);
            }
        }
        else {
            pushNode(nodes, node);
        }
    }
    // Whitespace handling strategy like v2
    let removedWhitespace = false;
    if (mode !== 2 /* TextModes.RAWTEXT */ && mode !== 1 /* TextModes.RCDATA */) {
        const shouldCondense = context.options.whitespace !== 'preserve';
        for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            if (node.type === 2 /* NodeTypes.TEXT */) {
                if (!context.inPre) {
                    if (!/[^\t\r\n\f ]/.test(node.content)) {
                        const prev = nodes[i - 1];
                        const next = nodes[i + 1];
                        // Remove if:
                        // - the whitespace is the first or last node, or:
                        // - (condense mode) the whitespace is between twos comments, or:
                        // - (condense mode) the whitespace is between comment and element, or:
                        // - (condense mode) the whitespace is between two elements AND contains newline
                        if (!prev ||
                            !next ||
                            (shouldCondense &&
                                ((prev.type === 3 /* NodeTypes.COMMENT */ &&
                                    next.type === 3 /* NodeTypes.COMMENT */) ||
                                    (prev.type === 3 /* NodeTypes.COMMENT */ &&
                                        next.type === 1 /* NodeTypes.ELEMENT */) ||
                                    (prev.type === 1 /* NodeTypes.ELEMENT */ &&
                                        next.type === 3 /* NodeTypes.COMMENT */) ||
                                    (prev.type === 1 /* NodeTypes.ELEMENT */ &&
                                        next.type === 1 /* NodeTypes.ELEMENT */ &&
                                        /[\r\n]/.test(node.content))))) {
                            removedWhitespace = true;
                            nodes[i] = null;
                        }
                        else {
                            // Otherwise, the whitespace is condensed into a single space
                            node.content = ' ';
                        }
                    }
                    else if (shouldCondense) {
                        // in condense mode, consecutive whitespaces in text are condensed
                        // down to a single space.
                        node.content = node.content.replace(/[\t\r\n\f ]+/g, ' ');
                    }
                }
                else {
                    // #6410 normalize windows newlines in <pre>:
                    // in SSR, browsers normalize server-rendered \r\n into a single \n
                    // in the DOM
                    node.content = node.content.replace(/\r\n/g, '\n');
                }
            }
            // Remove comment nodes if desired by configuration.
            else if (node.type === 3 /* NodeTypes.COMMENT */ && !context.options.comments) {
                removedWhitespace = true;
                nodes[i] = null;
            }
        }
        if (context.inPre && parent && context.options.isPreTag(parent.tag)) {
            // remove leading newline per html spec
            // https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element
            const first = nodes[0];
            if (first && first.type === 2 /* NodeTypes.TEXT */) {
                first.content = first.content.replace(/^\r?\n/, '');
            }
        }
    }
    return removedWhitespace ? nodes.filter(Boolean) : nodes;
}
function pushNode(nodes, node) {
    if (node.type === 2 /* NodeTypes.TEXT */) {
        const prev = last(nodes);
        // Merge if both this and the previous node are text and those are
        // consecutive. This happens for cases like "a < b".
        if (prev &&
            prev.type === 2 /* NodeTypes.TEXT */ &&
            prev.loc.end.offset === node.loc.start.offset) {
            prev.content += node.content;
            prev.loc.end = node.loc.end;
            prev.loc.source += node.loc.source;
            return;
        }
    }
    nodes.push(node);
}
function parseCDATA(context, ancestors) {
    advanceBy(context, 9);
    const nodes = parseChildren(context, 3 /* TextModes.CDATA */, ancestors);
    if (context.source.length === 0) {
        emitError(context, 6 /* ErrorCodes.EOF_IN_CDATA */);
    }
    else {
        advanceBy(context, 3);
    }
    return nodes;
}
function parseComment(context) {
    const start = getCursor(context);
    let content;
    // Regular comment.
    const match = /--(\!)?>/.exec(context.source);
    if (!match) {
        content = context.source.slice(4);
        advanceBy(context, context.source.length);
        emitError(context, 7 /* ErrorCodes.EOF_IN_COMMENT */);
    }
    else {
        if (match.index <= 3) {
            emitError(context, 0 /* ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT */);
        }
        if (match[1]) {
            emitError(context, 10 /* ErrorCodes.INCORRECTLY_CLOSED_COMMENT */);
        }
        content = context.source.slice(4, match.index);
        // Advancing with reporting nested comments.
        const s = context.source.slice(0, match.index);
        let prevIndex = 1, nestedIndex = 0;
        while ((nestedIndex = s.indexOf('<!--', prevIndex)) !== -1) {
            advanceBy(context, nestedIndex - prevIndex + 1);
            if (nestedIndex + 4 < s.length) {
                emitError(context, 16 /* ErrorCodes.NESTED_COMMENT */);
            }
            prevIndex = nestedIndex + 1;
        }
        advanceBy(context, match.index + match[0].length - prevIndex + 1);
    }
    return {
        type: 3 /* NodeTypes.COMMENT */,
        content,
        loc: getSelection(context, start)
    };
}
function parseBogusComment(context) {
    const start = getCursor(context);
    const contentStart = context.source[1] === '?' ? 1 : 2;
    let content;
    const closeIndex = context.source.indexOf('>');
    if (closeIndex === -1) {
        content = context.source.slice(contentStart);
        advanceBy(context, context.source.length);
    }
    else {
        content = context.source.slice(contentStart, closeIndex);
        advanceBy(context, closeIndex + 1);
    }
    return {
        type: 3 /* NodeTypes.COMMENT */,
        content,
        loc: getSelection(context, start)
    };
}
function parseElement(context, ancestors) {
    // Start tag.
    const wasInPre = context.inPre;
    const wasInVPre = context.inVPre;
    const parent = last(ancestors);
    const element = parseTag(context, 0 /* TagType.Start */, parent);
    const isPreBoundary = context.inPre && !wasInPre;
    const isVPreBoundary = context.inVPre && !wasInVPre;
    if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
        // #4030 self-closing <pre> tag
        if (isPreBoundary) {
            context.inPre = false;
        }
        if (isVPreBoundary) {
            context.inVPre = false;
        }
        return element;
    }
    // Children.
    ancestors.push(element);
    const mode = context.options.getTextMode(element, parent);
    const children = parseChildren(context, mode, ancestors);
    ancestors.pop();
    // 2.x inline-template compat
    {
        const inlineTemplateProp = element.props.find(p => p.type === 6 /* NodeTypes.ATTRIBUTE */ && p.name === 'inline-template');
        if (inlineTemplateProp &&
            checkCompatEnabled("COMPILER_INLINE_TEMPLATE" /* CompilerDeprecationTypes.COMPILER_INLINE_TEMPLATE */, context, inlineTemplateProp.loc)) {
            const loc = getSelection(context, element.loc.end);
            inlineTemplateProp.value = {
                type: 2 /* NodeTypes.TEXT */,
                content: loc.source,
                loc
            };
        }
    }
    element.children = children;
    // End tag.
    if (startsWithEndTagOpen(context.source, element.tag)) {
        parseTag(context, 1 /* TagType.End */, parent);
    }
    else {
        emitError(context, 24 /* ErrorCodes.X_MISSING_END_TAG */, 0, element.loc.start);
        if (context.source.length === 0 && element.tag.toLowerCase() === 'script') {
            const first = children[0];
            if (first && startsWith(first.loc.source, '<!--')) {
                emitError(context, 8 /* ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */);
            }
        }
    }
    element.loc = getSelection(context, element.loc.start);
    if (isPreBoundary) {
        context.inPre = false;
    }
    if (isVPreBoundary) {
        context.inVPre = false;
    }
    return element;
}
const isSpecialTemplateDirective = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.makeMap)(`if,else,else-if,for,slot`);
function parseTag(context, type, parent) {
    // Tag open.
    const start = getCursor(context);
    const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
    const tag = match[1];
    const ns = context.options.getNamespace(tag, parent);
    advanceBy(context, match[0].length);
    advanceSpaces(context);
    // save current state in case we need to re-parse attributes with v-pre
    const cursor = getCursor(context);
    const currentSource = context.source;
    // check <pre> tag
    if (context.options.isPreTag(tag)) {
        context.inPre = true;
    }
    // Attributes.
    let props = parseAttributes(context, type);
    // check v-pre
    if (type === 0 /* TagType.Start */ &&
        !context.inVPre &&
        props.some(p => p.type === 7 /* NodeTypes.DIRECTIVE */ && p.name === 'pre')) {
        context.inVPre = true;
        // reset context
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(context, cursor);
        context.source = currentSource;
        // re-parse attrs and filter out v-pre itself
        props = parseAttributes(context, type).filter(p => p.name !== 'v-pre');
    }
    // Tag close.
    let isSelfClosing = false;
    if (context.source.length === 0) {
        emitError(context, 9 /* ErrorCodes.EOF_IN_TAG */);
    }
    else {
        isSelfClosing = startsWith(context.source, '/>');
        if (type === 1 /* TagType.End */ && isSelfClosing) {
            emitError(context, 4 /* ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS */);
        }
        advanceBy(context, isSelfClosing ? 2 : 1);
    }
    if (type === 1 /* TagType.End */) {
        return;
    }
    // 2.x deprecation checks
    if (( true) &&
        isCompatEnabled("COMPILER_V_IF_V_FOR_PRECEDENCE" /* CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE */, context)) {
        let hasIf = false;
        let hasFor = false;
        for (let i = 0; i < props.length; i++) {
            const p = props[i];
            if (p.type === 7 /* NodeTypes.DIRECTIVE */) {
                if (p.name === 'if') {
                    hasIf = true;
                }
                else if (p.name === 'for') {
                    hasFor = true;
                }
            }
            if (hasIf && hasFor) {
                warnDeprecation("COMPILER_V_IF_V_FOR_PRECEDENCE" /* CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE */, context, getSelection(context, start));
                break;
            }
        }
    }
    let tagType = 0 /* ElementTypes.ELEMENT */;
    if (!context.inVPre) {
        if (tag === 'slot') {
            tagType = 2 /* ElementTypes.SLOT */;
        }
        else if (tag === 'template') {
            if (props.some(p => p.type === 7 /* NodeTypes.DIRECTIVE */ && isSpecialTemplateDirective(p.name))) {
                tagType = 3 /* ElementTypes.TEMPLATE */;
            }
        }
        else if (isComponent(tag, props, context)) {
            tagType = 1 /* ElementTypes.COMPONENT */;
        }
    }
    return {
        type: 1 /* NodeTypes.ELEMENT */,
        ns,
        tag,
        tagType,
        props,
        isSelfClosing,
        children: [],
        loc: getSelection(context, start),
        codegenNode: undefined // to be created during transform phase
    };
}
function isComponent(tag, props, context) {
    const options = context.options;
    if (options.isCustomElement(tag)) {
        return false;
    }
    if (tag === 'component' ||
        /^[A-Z]/.test(tag) ||
        isCoreComponent(tag) ||
        (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||
        (options.isNativeTag && !options.isNativeTag(tag))) {
        return true;
    }
    // at this point the tag should be a native tag, but check for potential "is"
    // casting
    for (let i = 0; i < props.length; i++) {
        const p = props[i];
        if (p.type === 6 /* NodeTypes.ATTRIBUTE */) {
            if (p.name === 'is' && p.value) {
                if (p.value.content.startsWith('vue:')) {
                    return true;
                }
                else if (checkCompatEnabled("COMPILER_IS_ON_ELEMENT" /* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */, context, p.loc)) {
                    return true;
                }
            }
        }
        else {
            // directive
            // v-is (TODO Deprecate)
            if (p.name === 'is') {
                return true;
            }
            else if (
            // :is on plain element - only treat as component in compat mode
            p.name === 'bind' &&
                isStaticArgOf(p.arg, 'is') &&
                true &&
                checkCompatEnabled("COMPILER_IS_ON_ELEMENT" /* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */, context, p.loc)) {
                return true;
            }
        }
    }
}
function parseAttributes(context, type) {
    const props = [];
    const attributeNames = new Set();
    while (context.source.length > 0 &&
        !startsWith(context.source, '>') &&
        !startsWith(context.source, '/>')) {
        if (startsWith(context.source, '/')) {
            emitError(context, 22 /* ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG */);
            advanceBy(context, 1);
            advanceSpaces(context);
            continue;
        }
        if (type === 1 /* TagType.End */) {
            emitError(context, 3 /* ErrorCodes.END_TAG_WITH_ATTRIBUTES */);
        }
        const attr = parseAttribute(context, attributeNames);
        // Trim whitespace between class
        // https://github.com/vuejs/core/issues/4251
        if (attr.type === 6 /* NodeTypes.ATTRIBUTE */ &&
            attr.value &&
            attr.name === 'class') {
            attr.value.content = attr.value.content.replace(/\s+/g, ' ').trim();
        }
        if (type === 0 /* TagType.Start */) {
            props.push(attr);
        }
        if (/^[^\t\r\n\f />]/.test(context.source)) {
            emitError(context, 15 /* ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */);
        }
        advanceSpaces(context);
    }
    return props;
}
function parseAttribute(context, nameSet) {
    // Name.
    const start = getCursor(context);
    const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
    const name = match[0];
    if (nameSet.has(name)) {
        emitError(context, 2 /* ErrorCodes.DUPLICATE_ATTRIBUTE */);
    }
    nameSet.add(name);
    if (name[0] === '=') {
        emitError(context, 19 /* ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */);
    }
    {
        const pattern = /["'<]/g;
        let m;
        while ((m = pattern.exec(name))) {
            emitError(context, 17 /* ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */, m.index);
        }
    }
    advanceBy(context, name.length);
    // Value
    let value = undefined;
    if (/^[\t\r\n\f ]*=/.test(context.source)) {
        advanceSpaces(context);
        advanceBy(context, 1);
        advanceSpaces(context);
        value = parseAttributeValue(context);
        if (!value) {
            emitError(context, 13 /* ErrorCodes.MISSING_ATTRIBUTE_VALUE */);
        }
    }
    const loc = getSelection(context, start);
    if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name)) {
        const match = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name);
        let isPropShorthand = startsWith(name, '.');
        let dirName = match[1] ||
            (isPropShorthand || startsWith(name, ':')
                ? 'bind'
                : startsWith(name, '@')
                    ? 'on'
                    : 'slot');
        let arg;
        if (match[2]) {
            const isSlot = dirName === 'slot';
            const startOffset = name.lastIndexOf(match[2]);
            const loc = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match[2].length + ((isSlot && match[3]) || '').length));
            let content = match[2];
            let isStatic = true;
            if (content.startsWith('[')) {
                isStatic = false;
                if (!content.endsWith(']')) {
                    emitError(context, 27 /* ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */);
                    content = content.slice(1);
                }
                else {
                    content = content.slice(1, content.length - 1);
                }
            }
            else if (isSlot) {
                // #1241 special case for v-slot: vuetify relies extensively on slot
                // names containing dots. v-slot doesn't have any modifiers and Vue 2.x
                // supports such usage so we are keeping it consistent with 2.x.
                content += match[3] || '';
            }
            arg = {
                type: 4 /* NodeTypes.SIMPLE_EXPRESSION */,
                content,
                isStatic,
                constType: isStatic
                    ? 3 /* ConstantTypes.CAN_STRINGIFY */
                    : 0 /* ConstantTypes.NOT_CONSTANT */,
                loc
            };
        }
        if (value && value.isQuoted) {
            const valueLoc = value.loc;
            valueLoc.start.offset++;
            valueLoc.start.column++;
            valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
            valueLoc.source = valueLoc.source.slice(1, -1);
        }
        const modifiers = match[3] ? match[3].slice(1).split('.') : [];
        if (isPropShorthand)
            modifiers.push('prop');
        // 2.x compat v-bind:foo.sync -> v-model:foo
        if (dirName === 'bind' && arg) {
            if (modifiers.includes('sync') &&
                checkCompatEnabled("COMPILER_V_BIND_SYNC" /* CompilerDeprecationTypes.COMPILER_V_BIND_SYNC */, context, loc, arg.loc.source)) {
                dirName = 'model';
                modifiers.splice(modifiers.indexOf('sync'), 1);
            }
            if (( true) && modifiers.includes('prop')) {
                checkCompatEnabled("COMPILER_V_BIND_PROP" /* CompilerDeprecationTypes.COMPILER_V_BIND_PROP */, context, loc);
            }
        }
        return {
            type: 7 /* NodeTypes.DIRECTIVE */,
            name: dirName,
            exp: value && {
                type: 4 /* NodeTypes.SIMPLE_EXPRESSION */,
                content: value.content,
                isStatic: false,
                // Treat as non-constant by default. This can be potentially set to
                // other values by `transformExpression` to make it eligible for hoisting.
                constType: 0 /* ConstantTypes.NOT_CONSTANT */,
                loc: value.loc
            },
            arg,
            modifiers,
            loc
        };
    }
    // missing directive name or illegal directive name
    if (!context.inVPre && startsWith(name, 'v-')) {
        emitError(context, 26 /* ErrorCodes.X_MISSING_DIRECTIVE_NAME */);
    }
    return {
        type: 6 /* NodeTypes.ATTRIBUTE */,
        name,
        value: value && {
            type: 2 /* NodeTypes.TEXT */,
            content: value.content,
            loc: value.loc
        },
        loc
    };
}
function parseAttributeValue(context) {
    const start = getCursor(context);
    let content;
    const quote = context.source[0];
    const isQuoted = quote === `"` || quote === `'`;
    if (isQuoted) {
        // Quoted value.
        advanceBy(context, 1);
        const endIndex = context.source.indexOf(quote);
        if (endIndex === -1) {
            content = parseTextData(context, context.source.length, 4 /* TextModes.ATTRIBUTE_VALUE */);
        }
        else {
            content = parseTextData(context, endIndex, 4 /* TextModes.ATTRIBUTE_VALUE */);
            advanceBy(context, 1);
        }
    }
    else {
        // Unquoted
        const match = /^[^\t\r\n\f >]+/.exec(context.source);
        if (!match) {
            return undefined;
        }
        const unexpectedChars = /["'<=`]/g;
        let m;
        while ((m = unexpectedChars.exec(match[0]))) {
            emitError(context, 18 /* ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */, m.index);
        }
        content = parseTextData(context, match[0].length, 4 /* TextModes.ATTRIBUTE_VALUE */);
    }
    return { content, isQuoted, loc: getSelection(context, start) };
}
function parseInterpolation(context, mode) {
    const [open, close] = context.options.delimiters;
    const closeIndex = context.source.indexOf(close, open.length);
    if (closeIndex === -1) {
        emitError(context, 25 /* ErrorCodes.X_MISSING_INTERPOLATION_END */);
        return undefined;
    }
    const start = getCursor(context);
    advanceBy(context, open.length);
    const innerStart = getCursor(context);
    const innerEnd = getCursor(context);
    const rawContentLength = closeIndex - open.length;
    const rawContent = context.source.slice(0, rawContentLength);
    const preTrimContent = parseTextData(context, rawContentLength, mode);
    const content = preTrimContent.trim();
    const startOffset = preTrimContent.indexOf(content);
    if (startOffset > 0) {
        advancePositionWithMutation(innerStart, rawContent, startOffset);
    }
    const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
    advancePositionWithMutation(innerEnd, rawContent, endOffset);
    advanceBy(context, close.length);
    return {
        type: 5 /* NodeTypes.INTERPOLATION */,
        content: {
            type: 4 /* NodeTypes.SIMPLE_EXPRESSION */,
            isStatic: false,
            // Set `isConstant` to false by default and will decide in transformExpression
            constType: 0 /* ConstantTypes.NOT_CONSTANT */,
            content,
            loc: getSelection(context, innerStart, innerEnd)
        },
        loc: getSelection(context, start)
    };
}
function parseText(context, mode) {
    const endTokens = mode === 3 /* TextModes.CDATA */ ? [']]>'] : ['<', context.options.delimiters[0]];
    let endIndex = context.source.length;
    for (let i = 0; i < endTokens.length; i++) {
        const index = context.source.indexOf(endTokens[i], 1);
        if (index !== -1 && endIndex > index) {
            endIndex = index;
        }
    }
    const start = getCursor(context);
    const content = parseTextData(context, endIndex, mode);
    return {
        type: 2 /* NodeTypes.TEXT */,
        content,
        loc: getSelection(context, start)
    };
}
/**
 * Get text data with a given length from the current location.
 * This translates HTML entities in the text data.
 */
function parseTextData(context, length, mode) {
    const rawText = context.source.slice(0, length);
    advanceBy(context, length);
    if (mode === 2 /* TextModes.RAWTEXT */ ||
        mode === 3 /* TextModes.CDATA */ ||
        !rawText.includes('&')) {
        return rawText;
    }
    else {
        // DATA or RCDATA containing "&"". Entity decoding required.
        return context.options.decodeEntities(rawText, mode === 4 /* TextModes.ATTRIBUTE_VALUE */);
    }
}
function getCursor(context) {
    const { column, line, offset } = context;
    return { column, line, offset };
}
function getSelection(context, start, end) {
    end = end || getCursor(context);
    return {
        start,
        end,
        source: context.originalSource.slice(start.offset, end.offset)
    };
}
function last(xs) {
    return xs[xs.length - 1];
}
function startsWith(source, searchString) {
    return source.startsWith(searchString);
}
function advanceBy(context, numberOfCharacters) {
    const { source } = context;
    advancePositionWithMutation(context, source, numberOfCharacters);
    context.source = source.slice(numberOfCharacters);
}
function advanceSpaces(context) {
    const match = /^[\t\r\n\f ]+/.exec(context.source);
    if (match) {
        advanceBy(context, match[0].length);
    }
}
function getNewPosition(context, start, numberOfCharacters) {
    return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);
}
function emitError(context, code, offset, loc = getCursor(context)) {
    if (offset) {
        loc.offset += offset;
        loc.column += offset;
    }
    context.options.onError(createCompilerError(code, {
        start: loc,
        end: loc,
        source: ''
    }));
}
function isEnd(context, mode, ancestors) {
    const s = context.source;
    switch (mode) {
        case 0 /* TextModes.DATA */:
            if (startsWith(s, '</')) {
                // TODO: probably bad performance
                for (let i = ancestors.length - 1; i >= 0; --i) {
                    if (startsWithEndTagOpen(s, ancestors[i].tag)) {
                        return true;
                    }
                }
            }
            break;
        case 1 /* TextModes.RCDATA */:
        case 2 /* TextModes.RAWTEXT */: {
            const parent = last(ancestors);
            if (parent && startsWithEndTagOpen(s, parent.tag)) {
                return true;
            }
            break;
        }
        case 3 /* TextModes.CDATA */:
            if (startsWith(s, ']]>')) {
                return true;
            }
            break;
    }
    return !s;
}
function startsWithEndTagOpen(source, tag) {
    return (startsWith(source, '</') &&
        source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() &&
        /[\t\r\n\f />]/.test(source[2 + tag.length] || '>'));
}

function hoistStatic(root, context) {
    walk(root, context, 
    // Root node is unfortunately non-hoistable due to potential parent
    // fallthrough attributes.
    isSingleElementRoot(root, root.children[0]));
}
function isSingleElementRoot(root, child) {
    const { children } = root;
    return (children.length === 1 &&
        child.type === 1 /* NodeTypes.ELEMENT */ &&
        !isSlotOutlet(child));
}
function walk(node, context, doNotHoistNode = false) {
    const { children } = node;
    const originalCount = children.length;
    let hoistedCount = 0;
    for (let i = 0; i < children.length; i++) {
        const child = children[i];
        // only plain elements & text calls are eligible for hoisting.
        if (child.type === 1 /* NodeTypes.ELEMENT */ &&
            child.tagType === 0 /* ElementTypes.ELEMENT */) {
            const constantType = doNotHoistNode
                ? 0 /* ConstantTypes.NOT_CONSTANT */
                : getConstantType(child, context);
            if (constantType > 0 /* ConstantTypes.NOT_CONSTANT */) {
                if (constantType >= 2 /* ConstantTypes.CAN_HOIST */) {
                    child.codegenNode.patchFlag =
                        -1 /* PatchFlags.HOISTED */ + (( true) ? ` /* HOISTED */` : 0);
                    child.codegenNode = context.hoist(child.codegenNode);
                    hoistedCount++;
                    continue;
                }
            }
            else {
                // node may contain dynamic children, but its props may be eligible for
                // hoisting.
                const codegenNode = child.codegenNode;
                if (codegenNode.type === 13 /* NodeTypes.VNODE_CALL */) {
                    const flag = getPatchFlag(codegenNode);
                    if ((!flag ||
                        flag === 512 /* PatchFlags.NEED_PATCH */ ||
                        flag === 1 /* PatchFlags.TEXT */) &&
                        getGeneratedPropsConstantType(child, context) >=
                            2 /* ConstantTypes.CAN_HOIST */) {
                        const props = getNodeProps(child);
                        if (props) {
                            codegenNode.props = context.hoist(props);
                        }
                    }
                    if (codegenNode.dynamicProps) {
                        codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
                    }
                }
            }
        }
        // walk further
        if (child.type === 1 /* NodeTypes.ELEMENT */) {
            const isComponent = child.tagType === 1 /* ElementTypes.COMPONENT */;
            if (isComponent) {
                context.scopes.vSlot++;
            }
            walk(child, context);
            if (isComponent) {
                context.scopes.vSlot--;
            }
        }
        else if (child.type === 11 /* NodeTypes.FOR */) {
            // Do not hoist v-for single child because it has to be a block
            walk(child, context, child.children.length === 1);
        }
        else if (child.type === 9 /* NodeTypes.IF */) {
            for (let i = 0; i < child.branches.length; i++) {
                // Do not hoist v-if single child because it has to be a block
                walk(child.branches[i], context, child.branches[i].children.length === 1);
            }
        }
    }
    if (hoistedCount && context.transformHoist) {
        context.transformHoist(children, context, node);
    }
    // all children were hoisted - the entire children array is hoistable.
    if (hoistedCount &&
        hoistedCount === originalCount &&
        node.type === 1 /* NodeTypes.ELEMENT */ &&
        node.tagType === 0 /* ElementTypes.ELEMENT */ &&
        node.codegenNode &&
        node.codegenNode.type === 13 /* NodeTypes.VNODE_CALL */ &&
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node.codegenNode.children)) {
        node.codegenNode.children = context.hoist(createArrayExpression(node.codegenNode.children));
    }
}
function getConstantType(node, context) {
    const { constantCache } = context;
    switch (node.type) {
        case 1 /* NodeTypes.ELEMENT */:
            if (node.tagType !== 0 /* ElementTypes.ELEMENT */) {
                return 0 /* ConstantTypes.NOT_CONSTANT */;
            }
            const cached = constantCache.get(node);
            if (cached !== undefined) {
                return cached;
            }
            const codegenNode = node.codegenNode;
            if (codegenNode.type !== 13 /* NodeTypes.VNODE_CALL */) {
                return 0 /* ConstantTypes.NOT_CONSTANT */;
            }
            if (codegenNode.isBlock &&
                node.tag !== 'svg' &&
                node.tag !== 'foreignObject') {
                return 0 /* ConstantTypes.NOT_CONSTANT */;
            }
            const flag = getPatchFlag(codegenNode);
            if (!flag) {
                let returnType = 3 /* ConstantTypes.CAN_STRINGIFY */;
                // Element itself has no patch flag. However we still need to check:
                // 1. Even for a node with no patch flag, it is possible for it to contain
                // non-hoistable expressions that refers to scope variables, e.g. compiler
                // injected keys or cached event handlers. Therefore we need to always
                // check the codegenNode's props to be sure.
                const generatedPropsType = getGeneratedPropsConstantType(node, context);
                if (generatedPropsType === 0 /* ConstantTypes.NOT_CONSTANT */) {
                    constantCache.set(node, 0 /* ConstantTypes.NOT_CONSTANT */);
                    return 0 /* ConstantTypes.NOT_CONSTANT */;
                }
                if (generatedPropsType < returnType) {
                    returnType = generatedPropsType;
                }
                // 2. its children.
                for (let i = 0; i < node.children.length; i++) {
                    const childType = getConstantType(node.children[i], context);
                    if (childType === 0 /* ConstantTypes.NOT_CONSTANT */) {
                        constantCache.set(node, 0 /* ConstantTypes.NOT_CONSTANT */);
                        return 0 /* ConstantTypes.NOT_CONSTANT */;
                    }
                    if (childType < returnType) {
                        returnType = childType;
                    }
                }
                // 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0
                // type, check if any of the props can cause the type to be lowered
                // we can skip can_patch because it's guaranteed by the absence of a
                // patchFlag.
                if (returnType > 1 /* ConstantTypes.CAN_SKIP_PATCH */) {
                    for (let i = 0; i < node.props.length; i++) {
                        const p = node.props[i];
                        if (p.type === 7 /* NodeTypes.DIRECTIVE */ && p.name === 'bind' && p.exp) {
                            const expType = getConstantType(p.exp, context);
                            if (expType === 0 /* ConstantTypes.NOT_CONSTANT */) {
                                constantCache.set(node, 0 /* ConstantTypes.NOT_CONSTANT */);
                                return 0 /* ConstantTypes.NOT_CONSTANT */;
                            }
                            if (expType < returnType) {
                                returnType = expType;
                            }
                        }
                    }
                }
                // only svg/foreignObject could be block here, however if they are
                // static then they don't need to be blocks since there will be no
                // nested updates.
                if (codegenNode.isBlock) {
                    // except set custom directives.
                    for (let i = 0; i < node.props.length; i++) {
                        const p = node.props[i];
                        if (p.type === 7 /* NodeTypes.DIRECTIVE */) {
                            constantCache.set(node, 0 /* ConstantTypes.NOT_CONSTANT */);
                            return 0 /* ConstantTypes.NOT_CONSTANT */;
                        }
                    }
                    context.removeHelper(OPEN_BLOCK);
                    context.removeHelper(getVNodeBlockHelper(context.inSSR, codegenNode.isComponent));
                    codegenNode.isBlock = false;
                    context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
                }
                constantCache.set(node, returnType);
                return returnType;
            }
            else {
                constantCache.set(node, 0 /* ConstantTypes.NOT_CONSTANT */);
                return 0 /* ConstantTypes.NOT_CONSTANT */;
            }
        case 2 /* NodeTypes.TEXT */:
        case 3 /* NodeTypes.COMMENT */:
            return 3 /* ConstantTypes.CAN_STRINGIFY */;
        case 9 /* NodeTypes.IF */:
        case 11 /* NodeTypes.FOR */:
        case 10 /* NodeTypes.IF_BRANCH */:
            return 0 /* ConstantTypes.NOT_CONSTANT */;
        case 5 /* NodeTypes.INTERPOLATION */:
        case 12 /* NodeTypes.TEXT_CALL */:
            return getConstantType(node.content, context);
        case 4 /* NodeTypes.SIMPLE_EXPRESSION */:
            return node.constType;
        case 8 /* NodeTypes.COMPOUND_EXPRESSION */:
            let returnType = 3 /* ConstantTypes.CAN_STRINGIFY */;
            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(child)) {
                    continue;
                }
                const childType = getConstantType(child, context);
                if (childType === 0 /* ConstantTypes.NOT_CONSTANT */) {
                    return 0 /* ConstantTypes.NOT_CONSTANT */;
                }
                else if (childType < returnType) {
                    returnType = childType;
                }
            }
            return returnType;
        default:
            if ((true)) ;
            return 0 /* ConstantTypes.NOT_CONSTANT */;
    }
}
const allowHoistedHelperSet = new Set([
    NORMALIZE_CLASS,
    NORMALIZE_STYLE,
    NORMALIZE_PROPS,
    GUARD_REACTIVE_PROPS
]);
function getConstantTypeOfHelperCall(value, context) {
    if (value.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */ &&
        !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(value.callee) &&
        allowHoistedHelperSet.has(value.callee)) {
        const arg = value.arguments[0];
        if (arg.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
            return getConstantType(arg, context);
        }
        else if (arg.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */) {
            // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(exp))`
            return getConstantTypeOfHelperCall(arg, context);
        }
    }
    return 0 /* ConstantTypes.NOT_CONSTANT */;
}
function getGeneratedPropsConstantType(node, context) {
    let returnType = 3 /* ConstantTypes.CAN_STRINGIFY */;
    const props = getNodeProps(node);
    if (props && props.type === 15 /* NodeTypes.JS_OBJECT_EXPRESSION */) {
        const { properties } = props;
        for (let i = 0; i < properties.length; i++) {
            const { key, value } = properties[i];
            const keyType = getConstantType(key, context);
            if (keyType === 0 /* ConstantTypes.NOT_CONSTANT */) {
                return keyType;
            }
            if (keyType < returnType) {
                returnType = keyType;
            }
            let valueType;
            if (value.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
                valueType = getConstantType(value, context);
            }
            else if (value.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */) {
                // some helper calls can be hoisted,
                // such as the `normalizeProps` generated by the compiler for pre-normalize class,
                // in this case we need to respect the ConstantType of the helper's arguments
                valueType = getConstantTypeOfHelperCall(value, context);
            }
            else {
                valueType = 0 /* ConstantTypes.NOT_CONSTANT */;
            }
            if (valueType === 0 /* ConstantTypes.NOT_CONSTANT */) {
                return valueType;
            }
            if (valueType < returnType) {
                returnType = valueType;
            }
        }
    }
    return returnType;
}
function getNodeProps(node) {
    const codegenNode = node.codegenNode;
    if (codegenNode.type === 13 /* NodeTypes.VNODE_CALL */) {
        return codegenNode.props;
    }
}
function getPatchFlag(node) {
    const flag = node.patchFlag;
    return flag ? parseInt(flag, 10) : undefined;
}

function createTransformContext(root, { filename = '', prefixIdentifiers = false, hoistStatic = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP, isCustomElement = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP, expressionPlugins = [], scopeId = null, slotted = true, ssr = false, inSSR = false, ssrCssVars = ``, bindingMetadata = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJ, inline = false, isTS = false, onError = defaultOnError, onWarn = defaultOnWarn, compatConfig }) {
    const nameMatch = filename.replace(/\?.*$/, '').match(/([^/\\]+)\.\w+$/);
    const context = {
        // options
        selfName: nameMatch && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(nameMatch[1])),
        prefixIdentifiers,
        hoistStatic,
        cacheHandlers,
        nodeTransforms,
        directiveTransforms,
        transformHoist,
        isBuiltInComponent,
        isCustomElement,
        expressionPlugins,
        scopeId,
        slotted,
        ssr,
        inSSR,
        ssrCssVars,
        bindingMetadata,
        inline,
        isTS,
        onError,
        onWarn,
        compatConfig,
        // state
        root,
        helpers: new Map(),
        components: new Set(),
        directives: new Set(),
        hoists: [],
        imports: [],
        constantCache: new Map(),
        temps: 0,
        cached: 0,
        identifiers: Object.create(null),
        scopes: {
            vFor: 0,
            vSlot: 0,
            vPre: 0,
            vOnce: 0
        },
        parent: null,
        currentNode: root,
        childIndex: 0,
        inVOnce: false,
        // methods
        helper(name) {
            const count = context.helpers.get(name) || 0;
            context.helpers.set(name, count + 1);
            return name;
        },
        removeHelper(name) {
            const count = context.helpers.get(name);
            if (count) {
                const currentCount = count - 1;
                if (!currentCount) {
                    context.helpers.delete(name);
                }
                else {
                    context.helpers.set(name, currentCount);
                }
            }
        },
        helperString(name) {
            return `_${helperNameMap[context.helper(name)]}`;
        },
        replaceNode(node) {
            /* istanbul ignore if */
            if ((true)) {
                if (!context.currentNode) {
                    throw new Error(`Node being replaced is already removed.`);
                }
                if (!context.parent) {
                    throw new Error(`Cannot replace root node.`);
                }
            }
            context.parent.children[context.childIndex] = context.currentNode = node;
        },
        removeNode(node) {
            if (( true) && !context.parent) {
                throw new Error(`Cannot remove root node.`);
            }
            const list = context.parent.children;
            const removalIndex = node
                ? list.indexOf(node)
                : context.currentNode
                    ? context.childIndex
                    : -1;
            /* istanbul ignore if */
            if (( true) && removalIndex < 0) {
                throw new Error(`node being removed is not a child of current parent`);
            }
            if (!node || node === context.currentNode) {
                // current node removed
                context.currentNode = null;
                context.onNodeRemoved();
            }
            else {
                // sibling node removed
                if (context.childIndex > removalIndex) {
                    context.childIndex--;
                    context.onNodeRemoved();
                }
            }
            context.parent.children.splice(removalIndex, 1);
        },
        onNodeRemoved: () => { },
        addIdentifiers(exp) {
        },
        removeIdentifiers(exp) {
        },
        hoist(exp) {
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(exp))
                exp = createSimpleExpression(exp);
            context.hoists.push(exp);
            const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, 2 /* ConstantTypes.CAN_HOIST */);
            identifier.hoisted = exp;
            return identifier;
        },
        cache(exp, isVNode = false) {
            return createCacheExpression(context.cached++, exp, isVNode);
        }
    };
    {
        context.filters = new Set();
    }
    return context;
}
function transform(root, options) {
    const context = createTransformContext(root, options);
    traverseNode(root, context);
    if (options.hoistStatic) {
        hoistStatic(root, context);
    }
    if (!options.ssr) {
        createRootCodegen(root, context);
    }
    // finalize meta information
    root.helpers = [...context.helpers.keys()];
    root.components = [...context.components];
    root.directives = [...context.directives];
    root.imports = context.imports;
    root.hoists = context.hoists;
    root.temps = context.temps;
    root.cached = context.cached;
    {
        root.filters = [...context.filters];
    }
}
function createRootCodegen(root, context) {
    const { helper } = context;
    const { children } = root;
    if (children.length === 1) {
        const child = children[0];
        // if the single child is an element, turn it into a block.
        if (isSingleElementRoot(root, child) && child.codegenNode) {
            // single element root is never hoisted so codegenNode will never be
            // SimpleExpressionNode
            const codegenNode = child.codegenNode;
            if (codegenNode.type === 13 /* NodeTypes.VNODE_CALL */) {
                makeBlock(codegenNode, context);
            }
            root.codegenNode = codegenNode;
        }
        else {
            // - single <slot/>, IfNode, ForNode: already blocks.
            // - single text node: always patched.
            // root codegen falls through via genNode()
            root.codegenNode = child;
        }
    }
    else if (children.length > 1) {
        // root has multiple nodes - return a fragment block.
        let patchFlag = 64 /* PatchFlags.STABLE_FRAGMENT */;
        let patchFlagText = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[64];
        // check if the fragment actually contains a single valid child with
        // the rest being comments
        if (( true) &&
            children.filter(c => c.type !== 3 /* NodeTypes.COMMENT */).length === 1) {
            patchFlag |= 2048 /* PatchFlags.DEV_ROOT_FRAGMENT */;
            patchFlagText += `, ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[2048]}`;
        }
        root.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, root.children, patchFlag + (( true) ? ` /* ${patchFlagText} */` : 0), undefined, undefined, true, undefined, false /* isComponent */);
    }
    else ;
}
function traverseChildren(parent, context) {
    let i = 0;
    const nodeRemoved = () => {
        i--;
    };
    for (; i < parent.children.length; i++) {
        const child = parent.children[i];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child))
            continue;
        context.parent = parent;
        context.childIndex = i;
        context.onNodeRemoved = nodeRemoved;
        traverseNode(child, context);
    }
}
function traverseNode(node, context) {
    context.currentNode = node;
    // apply transform plugins
    const { nodeTransforms } = context;
    const exitFns = [];
    for (let i = 0; i < nodeTransforms.length; i++) {
        const onExit = nodeTransforms[i](node, context);
        if (onExit) {
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(onExit)) {
                exitFns.push(...onExit);
            }
            else {
                exitFns.push(onExit);
            }
        }
        if (!context.currentNode) {
            // node was removed
            return;
        }
        else {
            // node may have been replaced
            node = context.currentNode;
        }
    }
    switch (node.type) {
        case 3 /* NodeTypes.COMMENT */:
            if (!context.ssr) {
                // inject import for the Comment symbol, which is needed for creating
                // comment nodes with `createVNode`
                context.helper(CREATE_COMMENT);
            }
            break;
        case 5 /* NodeTypes.INTERPOLATION */:
            // no need to traverse, but we need to inject toString helper
            if (!context.ssr) {
                context.helper(TO_DISPLAY_STRING);
            }
            break;
        // for container types, further traverse downwards
        case 9 /* NodeTypes.IF */:
            for (let i = 0; i < node.branches.length; i++) {
                traverseNode(node.branches[i], context);
            }
            break;
        case 10 /* NodeTypes.IF_BRANCH */:
        case 11 /* NodeTypes.FOR */:
        case 1 /* NodeTypes.ELEMENT */:
        case 0 /* NodeTypes.ROOT */:
            traverseChildren(node, context);
            break;
    }
    // exit transforms
    context.currentNode = node;
    let i = exitFns.length;
    while (i--) {
        exitFns[i]();
    }
}
function createStructuralDirectiveTransform(name, fn) {
    const matches = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(name)
        ? (n) => n === name
        : (n) => name.test(n);
    return (node, context) => {
        if (node.type === 1 /* NodeTypes.ELEMENT */) {
            const { props } = node;
            // structural directive transforms are not concerned with slots
            // as they are handled separately in vSlot.ts
            if (node.tagType === 3 /* ElementTypes.TEMPLATE */ && props.some(isVSlot)) {
                return;
            }
            const exitFns = [];
            for (let i = 0; i < props.length; i++) {
                const prop = props[i];
                if (prop.type === 7 /* NodeTypes.DIRECTIVE */ && matches(prop.name)) {
                    // structural directives are removed to avoid infinite recursion
                    // also we remove them *before* applying so that it can further
                    // traverse itself in case it moves the node around
                    props.splice(i, 1);
                    i--;
                    const onExit = fn(node, prop, context);
                    if (onExit)
                        exitFns.push(onExit);
                }
            }
            return exitFns;
        }
    };
}

const PURE_ANNOTATION = `/*#__PURE__*/`;
const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
function createCodegenContext(ast, { mode = 'function', prefixIdentifiers = mode === 'module', sourceMap = false, filename = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssrRuntimeModuleName = 'vue/server-renderer', ssr = false, isTS = false, inSSR = false }) {
    const context = {
        mode,
        prefixIdentifiers,
        sourceMap,
        filename,
        scopeId,
        optimizeImports,
        runtimeGlobalName,
        runtimeModuleName,
        ssrRuntimeModuleName,
        ssr,
        isTS,
        inSSR,
        source: ast.loc.source,
        code: ``,
        column: 1,
        line: 1,
        offset: 0,
        indentLevel: 0,
        pure: false,
        map: undefined,
        helper(key) {
            return `_${helperNameMap[key]}`;
        },
        push(code, node) {
            context.code += code;
        },
        indent() {
            newline(++context.indentLevel);
        },
        deindent(withoutNewLine = false) {
            if (withoutNewLine) {
                --context.indentLevel;
            }
            else {
                newline(--context.indentLevel);
            }
        },
        newline() {
            newline(context.indentLevel);
        }
    };
    function newline(n) {
        context.push('\n' + `  `.repeat(n));
    }
    return context;
}
function generate(ast, options = {}) {
    const context = createCodegenContext(ast, options);
    if (options.onContextCreated)
        options.onContextCreated(context);
    const { mode, push, prefixIdentifiers, indent, deindent, newline, scopeId, ssr } = context;
    const hasHelpers = ast.helpers.length > 0;
    const useWithBlock = !prefixIdentifiers && mode !== 'module';
    // preambles
    // in setup() inline mode, the preamble is generated in a sub context
    // and returned separately.
    const preambleContext = context;
    {
        genFunctionPreamble(ast, preambleContext);
    }
    // enter render function
    const functionName = ssr ? `ssrRender` : `render`;
    const args = ssr ? ['_ctx', '_push', '_parent', '_attrs'] : ['_ctx', '_cache'];
    const signature = args.join(', ');
    {
        push(`function ${functionName}(${signature}) {`);
    }
    indent();
    if (useWithBlock) {
        push(`with (_ctx) {`);
        indent();
        // function mode const declarations should be inside with block
        // also they should be renamed to avoid collision with user properties
        if (hasHelpers) {
            push(`const { ${ast.helpers.map(aliasHelper).join(', ')} } = _Vue`);
            push(`\n`);
            newline();
        }
    }
    // generate asset resolution statements
    if (ast.components.length) {
        genAssets(ast.components, 'component', context);
        if (ast.directives.length || ast.temps > 0) {
            newline();
        }
    }
    if (ast.directives.length) {
        genAssets(ast.directives, 'directive', context);
        if (ast.temps > 0) {
            newline();
        }
    }
    if (ast.filters && ast.filters.length) {
        newline();
        genAssets(ast.filters, 'filter', context);
        newline();
    }
    if (ast.temps > 0) {
        push(`let `);
        for (let i = 0; i < ast.temps; i++) {
            push(`${i > 0 ? `, ` : ``}_temp${i}`);
        }
    }
    if (ast.components.length || ast.directives.length || ast.temps) {
        push(`\n`);
        newline();
    }
    // generate the VNode tree expression
    if (!ssr) {
        push(`return `);
    }
    if (ast.codegenNode) {
        genNode(ast.codegenNode, context);
    }
    else {
        push(`null`);
    }
    if (useWithBlock) {
        deindent();
        push(`}`);
    }
    deindent();
    push(`}`);
    return {
        ast,
        code: context.code,
        preamble: ``,
        // SourceMapGenerator does have toJSON() method but it's not in the types
        map: context.map ? context.map.toJSON() : undefined
    };
}
function genFunctionPreamble(ast, context) {
    const { ssr, prefixIdentifiers, push, newline, runtimeModuleName, runtimeGlobalName, ssrRuntimeModuleName } = context;
    const VueBinding = runtimeGlobalName;
    // Generate const declaration for helpers
    // In prefix mode, we place the const declaration at top so it's done
    // only once; But if we not prefixing, we place the declaration inside the
    // with block so it doesn't incur the `in` check cost for every helper access.
    if (ast.helpers.length > 0) {
        {
            // "with" mode.
            // save Vue in a separate variable to avoid collision
            push(`const _Vue = ${VueBinding}\n`);
            // in "with" mode, helpers are declared inside the with block to avoid
            // has check cost, but hoists are lifted out of the function - we need
            // to provide the helper here.
            if (ast.hoists.length) {
                const staticHelpers = [
                    CREATE_VNODE,
                    CREATE_ELEMENT_VNODE,
                    CREATE_COMMENT,
                    CREATE_TEXT,
                    CREATE_STATIC
                ]
                    .filter(helper => ast.helpers.includes(helper))
                    .map(aliasHelper)
                    .join(', ');
                push(`const { ${staticHelpers} } = _Vue\n`);
            }
        }
    }
    genHoists(ast.hoists, context);
    newline();
    push(`return `);
}
function genAssets(assets, type, { helper, push, newline, isTS }) {
    const resolver = helper(type === 'filter'
        ? RESOLVE_FILTER
        : type === 'component'
            ? RESOLVE_COMPONENT
            : RESOLVE_DIRECTIVE);
    for (let i = 0; i < assets.length; i++) {
        let id = assets[i];
        // potential component implicit self-reference inferred from SFC filename
        const maybeSelfReference = id.endsWith('__self');
        if (maybeSelfReference) {
            id = id.slice(0, -6);
        }
        push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`);
        if (i < assets.length - 1) {
            newline();
        }
    }
}
function genHoists(hoists, context) {
    if (!hoists.length) {
        return;
    }
    context.pure = true;
    const { push, newline, helper, scopeId, mode } = context;
    newline();
    for (let i = 0; i < hoists.length; i++) {
        const exp = hoists[i];
        if (exp) {
            push(`const _hoisted_${i + 1} = ${``}`);
            genNode(exp, context);
            newline();
        }
    }
    context.pure = false;
}
function isText$1(n) {
    return ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(n) ||
        n.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ ||
        n.type === 2 /* NodeTypes.TEXT */ ||
        n.type === 5 /* NodeTypes.INTERPOLATION */ ||
        n.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */);
}
function genNodeListAsArray(nodes, context) {
    const multilines = nodes.length > 3 ||
        ((( true)) && nodes.some(n => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(n) || !isText$1(n)));
    context.push(`[`);
    multilines && context.indent();
    genNodeList(nodes, context, multilines);
    multilines && context.deindent();
    context.push(`]`);
}
function genNodeList(nodes, context, multilines = false, comma = true) {
    const { push, newline } = context;
    for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node)) {
            push(node);
        }
        else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node)) {
            genNodeListAsArray(node, context);
        }
        else {
            genNode(node, context);
        }
        if (i < nodes.length - 1) {
            if (multilines) {
                comma && push(',');
                newline();
            }
            else {
                comma && push(', ');
            }
        }
    }
}
function genNode(node, context) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node)) {
        context.push(node);
        return;
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(node)) {
        context.push(context.helper(node));
        return;
    }
    switch (node.type) {
        case 1 /* NodeTypes.ELEMENT */:
        case 9 /* NodeTypes.IF */:
        case 11 /* NodeTypes.FOR */:
            ( true) &&
                assert(node.codegenNode != null, `Codegen node is missing for element/if/for node. ` +
                    `Apply appropriate transforms first.`);
            genNode(node.codegenNode, context);
            break;
        case 2 /* NodeTypes.TEXT */:
            genText(node, context);
            break;
        case 4 /* NodeTypes.SIMPLE_EXPRESSION */:
            genExpression(node, context);
            break;
        case 5 /* NodeTypes.INTERPOLATION */:
            genInterpolation(node, context);
            break;
        case 12 /* NodeTypes.TEXT_CALL */:
            genNode(node.codegenNode, context);
            break;
        case 8 /* NodeTypes.COMPOUND_EXPRESSION */:
            genCompoundExpression(node, context);
            break;
        case 3 /* NodeTypes.COMMENT */:
            genComment(node, context);
            break;
        case 13 /* NodeTypes.VNODE_CALL */:
            genVNodeCall(node, context);
            break;
        case 14 /* NodeTypes.JS_CALL_EXPRESSION */:
            genCallExpression(node, context);
            break;
        case 15 /* NodeTypes.JS_OBJECT_EXPRESSION */:
            genObjectExpression(node, context);
            break;
        case 17 /* NodeTypes.JS_ARRAY_EXPRESSION */:
            genArrayExpression(node, context);
            break;
        case 18 /* NodeTypes.JS_FUNCTION_EXPRESSION */:
            genFunctionExpression(node, context);
            break;
        case 19 /* NodeTypes.JS_CONDITIONAL_EXPRESSION */:
            genConditionalExpression(node, context);
            break;
        case 20 /* NodeTypes.JS_CACHE_EXPRESSION */:
            genCacheExpression(node, context);
            break;
        case 21 /* NodeTypes.JS_BLOCK_STATEMENT */:
            genNodeList(node.body, context, true, false);
            break;
        // SSR only types
        case 22 /* NodeTypes.JS_TEMPLATE_LITERAL */:
            break;
        case 23 /* NodeTypes.JS_IF_STATEMENT */:
            break;
        case 24 /* NodeTypes.JS_ASSIGNMENT_EXPRESSION */:
            break;
        case 25 /* NodeTypes.JS_SEQUENCE_EXPRESSION */:
            break;
        case 26 /* NodeTypes.JS_RETURN_STATEMENT */:
            break;
        /* istanbul ignore next */
        case 10 /* NodeTypes.IF_BRANCH */:
            // noop
            break;
        default:
            if ((true)) {
                assert(false, `unhandled codegen node type: ${node.type}`);
                // make sure we exhaust all possible types
                const exhaustiveCheck = node;
                return exhaustiveCheck;
            }
    }
}
function genText(node, context) {
    context.push(JSON.stringify(node.content), node);
}
function genExpression(node, context) {
    const { content, isStatic } = node;
    context.push(isStatic ? JSON.stringify(content) : content, node);
}
function genInterpolation(node, context) {
    const { push, helper, pure } = context;
    if (pure)
        push(PURE_ANNOTATION);
    push(`${helper(TO_DISPLAY_STRING)}(`);
    genNode(node.content, context);
    push(`)`);
}
function genCompoundExpression(node, context) {
    for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child)) {
            context.push(child);
        }
        else {
            genNode(child, context);
        }
    }
}
function genExpressionAsPropertyKey(node, context) {
    const { push } = context;
    if (node.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */) {
        push(`[`);
        genCompoundExpression(node, context);
        push(`]`);
    }
    else if (node.isStatic) {
        // only quote keys if necessary
        const text = isSimpleIdentifier(node.content)
            ? node.content
            : JSON.stringify(node.content);
        push(text, node);
    }
    else {
        push(`[${node.content}]`, node);
    }
}
function genComment(node, context) {
    const { push, helper, pure } = context;
    if (pure) {
        push(PURE_ANNOTATION);
    }
    push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);
}
function genVNodeCall(node, context) {
    const { push, helper, pure } = context;
    const { tag, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking, isComponent } = node;
    if (directives) {
        push(helper(WITH_DIRECTIVES) + `(`);
    }
    if (isBlock) {
        push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
    }
    if (pure) {
        push(PURE_ANNOTATION);
    }
    const callHelper = isBlock
        ? getVNodeBlockHelper(context.inSSR, isComponent)
        : getVNodeHelper(context.inSSR, isComponent);
    push(helper(callHelper) + `(`, node);
    genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context);
    push(`)`);
    if (isBlock) {
        push(`)`);
    }
    if (directives) {
        push(`, `);
        genNode(directives, context);
        push(`)`);
    }
}
function genNullableArgs(args) {
    let i = args.length;
    while (i--) {
        if (args[i] != null)
            break;
    }
    return args.slice(0, i + 1).map(arg => arg || `null`);
}
// JavaScript
function genCallExpression(node, context) {
    const { push, helper, pure } = context;
    const callee = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node.callee) ? node.callee : helper(node.callee);
    if (pure) {
        push(PURE_ANNOTATION);
    }
    push(callee + `(`, node);
    genNodeList(node.arguments, context);
    push(`)`);
}
function genObjectExpression(node, context) {
    const { push, indent, deindent, newline } = context;
    const { properties } = node;
    if (!properties.length) {
        push(`{}`, node);
        return;
    }
    const multilines = properties.length > 1 ||
        ((( true)) &&
            properties.some(p => p.value.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */));
    push(multilines ? `{` : `{ `);
    multilines && indent();
    for (let i = 0; i < properties.length; i++) {
        const { key, value } = properties[i];
        // key
        genExpressionAsPropertyKey(key, context);
        push(`: `);
        // value
        genNode(value, context);
        if (i < properties.length - 1) {
            // will only reach this if it's multilines
            push(`,`);
            newline();
        }
    }
    multilines && deindent();
    push(multilines ? `}` : ` }`);
}
function genArrayExpression(node, context) {
    genNodeListAsArray(node.elements, context);
}
function genFunctionExpression(node, context) {
    const { push, indent, deindent } = context;
    const { params, returns, body, newline, isSlot } = node;
    if (isSlot) {
        // wrap slot functions with owner context
        push(`_${helperNameMap[WITH_CTX]}(`);
    }
    push(`(`, node);
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(params)) {
        genNodeList(params, context);
    }
    else if (params) {
        genNode(params, context);
    }
    push(`) => `);
    if (newline || body) {
        push(`{`);
        indent();
    }
    if (returns) {
        if (newline) {
            push(`return `);
        }
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(returns)) {
            genNodeListAsArray(returns, context);
        }
        else {
            genNode(returns, context);
        }
    }
    else if (body) {
        genNode(body, context);
    }
    if (newline || body) {
        deindent();
        push(`}`);
    }
    if (isSlot) {
        if (node.isNonScopedSlot) {
            push(`, undefined, true`);
        }
        push(`)`);
    }
}
function genConditionalExpression(node, context) {
    const { test, consequent, alternate, newline: needNewline } = node;
    const { push, indent, deindent, newline } = context;
    if (test.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
        const needsParens = !isSimpleIdentifier(test.content);
        needsParens && push(`(`);
        genExpression(test, context);
        needsParens && push(`)`);
    }
    else {
        push(`(`);
        genNode(test, context);
        push(`)`);
    }
    needNewline && indent();
    context.indentLevel++;
    needNewline || push(` `);
    push(`? `);
    genNode(consequent, context);
    context.indentLevel--;
    needNewline && newline();
    needNewline || push(` `);
    push(`: `);
    const isNested = alternate.type === 19 /* NodeTypes.JS_CONDITIONAL_EXPRESSION */;
    if (!isNested) {
        context.indentLevel++;
    }
    genNode(alternate, context);
    if (!isNested) {
        context.indentLevel--;
    }
    needNewline && deindent(true /* without newline */);
}
function genCacheExpression(node, context) {
    const { push, helper, indent, deindent, newline } = context;
    push(`_cache[${node.index}] || (`);
    if (node.isVNode) {
        indent();
        push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
        newline();
    }
    push(`_cache[${node.index}] = `);
    genNode(node.value, context);
    if (node.isVNode) {
        push(`,`);
        newline();
        push(`${helper(SET_BLOCK_TRACKING)}(1),`);
        newline();
        push(`_cache[${node.index}]`);
        deindent();
    }
    push(`)`);
}

function walkIdentifiers(root, onIdentifier, includeAll = false, parentStack = [], knownIds = Object.create(null)) {
    {
        return;
    }
}
function isReferencedIdentifier(id, parent, parentStack) {
    {
        return false;
    }
}
function isInDestructureAssignment(parent, parentStack) {
    if (parent &&
        (parent.type === 'ObjectProperty' || parent.type === 'ArrayPattern')) {
        let i = parentStack.length;
        while (i--) {
            const p = parentStack[i];
            if (p.type === 'AssignmentExpression') {
                return true;
            }
            else if (p.type !== 'ObjectProperty' && !p.type.endsWith('Pattern')) {
                break;
            }
        }
    }
    return false;
}
function walkFunctionParams(node, onIdent) {
    for (const p of node.params) {
        for (const id of extractIdentifiers(p)) {
            onIdent(id);
        }
    }
}
function walkBlockDeclarations(block, onIdent) {
    for (const stmt of block.body) {
        if (stmt.type === 'VariableDeclaration') {
            if (stmt.declare)
                continue;
            for (const decl of stmt.declarations) {
                for (const id of extractIdentifiers(decl.id)) {
                    onIdent(id);
                }
            }
        }
        else if (stmt.type === 'FunctionDeclaration' ||
            stmt.type === 'ClassDeclaration') {
            if (stmt.declare || !stmt.id)
                continue;
            onIdent(stmt.id);
        }
    }
}
function extractIdentifiers(param, nodes = []) {
    switch (param.type) {
        case 'Identifier':
            nodes.push(param);
            break;
        case 'MemberExpression':
            let object = param;
            while (object.type === 'MemberExpression') {
                object = object.object;
            }
            nodes.push(object);
            break;
        case 'ObjectPattern':
            for (const prop of param.properties) {
                if (prop.type === 'RestElement') {
                    extractIdentifiers(prop.argument, nodes);
                }
                else {
                    extractIdentifiers(prop.value, nodes);
                }
            }
            break;
        case 'ArrayPattern':
            param.elements.forEach(element => {
                if (element)
                    extractIdentifiers(element, nodes);
            });
            break;
        case 'RestElement':
            extractIdentifiers(param.argument, nodes);
            break;
        case 'AssignmentPattern':
            extractIdentifiers(param.left, nodes);
            break;
    }
    return nodes;
}
const isFunctionType = (node) => {
    return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
};
const isStaticProperty = (node) => node &&
    (node.type === 'ObjectProperty' || node.type === 'ObjectMethod') &&
    !node.computed;
const isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;

// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed
const prohibitedKeywordRE = new RegExp('\\b' +
    ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
        'super,throw,while,yield,delete,export,import,return,switch,default,' +
        'extends,finally,continue,debugger,function,arguments,typeof,void')
        .split(',')
        .join('\\b|\\b') +
    '\\b');
// strip strings in expressions
const stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
/**
 * Validate a non-prefixed expression.
 * This is only called when using the in-browser runtime compiler since it
 * doesn't prefix expressions.
 */
function validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {
    const exp = node.content;
    // empty expressions are validated per-directive since some directives
    // do allow empty expressions.
    if (!exp.trim()) {
        return;
    }
    try {
        new Function(asRawStatements
            ? ` ${exp} `
            : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`);
    }
    catch (e) {
        let message = e.message;
        const keywordMatch = exp
            .replace(stripStringRE, '')
            .match(prohibitedKeywordRE);
        if (keywordMatch) {
            message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
        }
        context.onError(createCompilerError(45 /* ErrorCodes.X_INVALID_EXPRESSION */, node.loc, undefined, message));
    }
}

const transformExpression = (node, context) => {
    if (node.type === 5 /* NodeTypes.INTERPOLATION */) {
        node.content = processExpression(node.content, context);
    }
    else if (node.type === 1 /* NodeTypes.ELEMENT */) {
        // handle directives on element
        for (let i = 0; i < node.props.length; i++) {
            const dir = node.props[i];
            // do not process for v-on & v-for since they are special handled
            if (dir.type === 7 /* NodeTypes.DIRECTIVE */ && dir.name !== 'for') {
                const exp = dir.exp;
                const arg = dir.arg;
                // do not process exp if this is v-on:arg - we need special handling
                // for wrapping inline statements.
                if (exp &&
                    exp.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ &&
                    !(dir.name === 'on' && arg)) {
                    dir.exp = processExpression(exp, context, 
                    // slot args must be processed as function params
                    dir.name === 'slot');
                }
                if (arg && arg.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ && !arg.isStatic) {
                    dir.arg = processExpression(arg, context);
                }
            }
        }
    }
};
// Important: since this function uses Node.js only dependencies, it should
// always be used with a leading !true check so that it can be
// tree-shaken from the browser build.
function processExpression(node, context, 
// some expressions like v-slot props & v-for aliases should be parsed as
// function params
asParams = false, 
// v-on handler values may contain multiple statements
asRawStatements = false, localVars = Object.create(context.identifiers)) {
    {
        if ((true)) {
            // simple in-browser validation (same logic in 2.x)
            validateBrowserExpression(node, context, asParams, asRawStatements);
        }
        return node;
    }
}
function stringifyExpression(exp) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(exp)) {
        return exp;
    }
    else if (exp.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
        return exp.content;
    }
    else {
        return exp.children
            .map(stringifyExpression)
            .join('');
    }
}

const transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context) => {
    return processIf(node, dir, context, (ifNode, branch, isRoot) => {
        // #1587: We need to dynamically increment the key based on the current
        // node's sibling nodes, since chained v-if/else branches are
        // rendered at the same depth
        const siblings = context.parent.children;
        let i = siblings.indexOf(ifNode);
        let key = 0;
        while (i-- >= 0) {
            const sibling = siblings[i];
            if (sibling && sibling.type === 9 /* NodeTypes.IF */) {
                key += sibling.branches.length;
            }
        }
        // Exit callback. Complete the codegenNode when all children have been
        // transformed.
        return () => {
            if (isRoot) {
                ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);
            }
            else {
                // attach this branch's codegen node to the v-if root.
                const parentCondition = getParentCondition(ifNode.codegenNode);
                parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);
            }
        };
    });
});
// target-agnostic transform used for both Client and SSR
function processIf(node, dir, context, processCodegen) {
    if (dir.name !== 'else' &&
        (!dir.exp || !dir.exp.content.trim())) {
        const loc = dir.exp ? dir.exp.loc : node.loc;
        context.onError(createCompilerError(28 /* ErrorCodes.X_V_IF_NO_EXPRESSION */, dir.loc));
        dir.exp = createSimpleExpression(`true`, false, loc);
    }
    if ( true && dir.exp) {
        validateBrowserExpression(dir.exp, context);
    }
    if (dir.name === 'if') {
        const branch = createIfBranch(node, dir);
        const ifNode = {
            type: 9 /* NodeTypes.IF */,
            loc: node.loc,
            branches: [branch]
        };
        context.replaceNode(ifNode);
        if (processCodegen) {
            return processCodegen(ifNode, branch, true);
        }
    }
    else {
        // locate the adjacent v-if
        const siblings = context.parent.children;
        const comments = [];
        let i = siblings.indexOf(node);
        while (i-- >= -1) {
            const sibling = siblings[i];
            if (sibling && sibling.type === 3 /* NodeTypes.COMMENT */) {
                context.removeNode(sibling);
                ( true) && comments.unshift(sibling);
                continue;
            }
            if (sibling &&
                sibling.type === 2 /* NodeTypes.TEXT */ &&
                !sibling.content.trim().length) {
                context.removeNode(sibling);
                continue;
            }
            if (sibling && sibling.type === 9 /* NodeTypes.IF */) {
                // Check if v-else was followed by v-else-if
                if (dir.name === 'else-if' &&
                    sibling.branches[sibling.branches.length - 1].condition === undefined) {
                    context.onError(createCompilerError(30 /* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */, node.loc));
                }
                // move the node to the if node's branches
                context.removeNode();
                const branch = createIfBranch(node, dir);
                if (( true) &&
                    comments.length &&
                    // #3619 ignore comments if the v-if is direct child of <transition>
                    !(context.parent &&
                        context.parent.type === 1 /* NodeTypes.ELEMENT */ &&
                        isBuiltInType(context.parent.tag, 'transition'))) {
                    branch.children = [...comments, ...branch.children];
                }
                // check if user is forcing same key on different branches
                if (true) {
                    const key = branch.userKey;
                    if (key) {
                        sibling.branches.forEach(({ userKey }) => {
                            if (isSameKey(userKey, key)) {
                                context.onError(createCompilerError(29 /* ErrorCodes.X_V_IF_SAME_KEY */, branch.userKey.loc));
                            }
                        });
                    }
                }
                sibling.branches.push(branch);
                const onExit = processCodegen && processCodegen(sibling, branch, false);
                // since the branch was removed, it will not be traversed.
                // make sure to traverse here.
                traverseNode(branch, context);
                // call on exit
                if (onExit)
                    onExit();
                // make sure to reset currentNode after traversal to indicate this
                // node has been removed.
                context.currentNode = null;
            }
            else {
                context.onError(createCompilerError(30 /* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */, node.loc));
            }
            break;
        }
    }
}
function createIfBranch(node, dir) {
    const isTemplateIf = node.tagType === 3 /* ElementTypes.TEMPLATE */;
    return {
        type: 10 /* NodeTypes.IF_BRANCH */,
        loc: node.loc,
        condition: dir.name === 'else' ? undefined : dir.exp,
        children: isTemplateIf && !findDir(node, 'for') ? node.children : [node],
        userKey: findProp(node, `key`),
        isTemplateIf
    };
}
function createCodegenNodeForBranch(branch, keyIndex, context) {
    if (branch.condition) {
        return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context), 
        // make sure to pass in asBlock: true so that the comment node call
        // closes the current block.
        createCallExpression(context.helper(CREATE_COMMENT), [
            ( true) ? '"v-if"' : 0,
            'true'
        ]));
    }
    else {
        return createChildrenCodegenNode(branch, keyIndex, context);
    }
}
function createChildrenCodegenNode(branch, keyIndex, context) {
    const { helper } = context;
    const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, 2 /* ConstantTypes.CAN_HOIST */));
    const { children } = branch;
    const firstChild = children[0];
    const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1 /* NodeTypes.ELEMENT */;
    if (needFragmentWrapper) {
        if (children.length === 1 && firstChild.type === 11 /* NodeTypes.FOR */) {
            // optimize away nested fragments when child is a ForNode
            const vnodeCall = firstChild.codegenNode;
            injectProp(vnodeCall, keyProperty, context);
            return vnodeCall;
        }
        else {
            let patchFlag = 64 /* PatchFlags.STABLE_FRAGMENT */;
            let patchFlagText = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[64];
            // check if the fragment actually contains a single valid child with
            // the rest being comments
            if (( true) &&
                !branch.isTemplateIf &&
                children.filter(c => c.type !== 3 /* NodeTypes.COMMENT */).length === 1) {
                patchFlag |= 2048 /* PatchFlags.DEV_ROOT_FRAGMENT */;
                patchFlagText += `, ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[2048]}`;
            }
            return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, patchFlag + (( true) ? ` /* ${patchFlagText} */` : 0), undefined, undefined, true, false, false /* isComponent */, branch.loc);
        }
    }
    else {
        const ret = firstChild.codegenNode;
        const vnodeCall = getMemoedVNodeCall(ret);
        // Change createVNode to createBlock.
        if (vnodeCall.type === 13 /* NodeTypes.VNODE_CALL */) {
            makeBlock(vnodeCall, context);
        }
        // inject branch key
        injectProp(vnodeCall, keyProperty, context);
        return ret;
    }
}
function isSameKey(a, b) {
    if (!a || a.type !== b.type) {
        return false;
    }
    if (a.type === 6 /* NodeTypes.ATTRIBUTE */) {
        if (a.value.content !== b.value.content) {
            return false;
        }
    }
    else {
        // directive
        const exp = a.exp;
        const branchExp = b.exp;
        if (exp.type !== branchExp.type) {
            return false;
        }
        if (exp.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */ ||
            exp.isStatic !== branchExp.isStatic ||
            exp.content !== branchExp.content) {
            return false;
        }
    }
    return true;
}
function getParentCondition(node) {
    while (true) {
        if (node.type === 19 /* NodeTypes.JS_CONDITIONAL_EXPRESSION */) {
            if (node.alternate.type === 19 /* NodeTypes.JS_CONDITIONAL_EXPRESSION */) {
                node = node.alternate;
            }
            else {
                return node;
            }
        }
        else if (node.type === 20 /* NodeTypes.JS_CACHE_EXPRESSION */) {
            node = node.value;
        }
    }
}

const transformFor = createStructuralDirectiveTransform('for', (node, dir, context) => {
    const { helper, removeHelper } = context;
    return processFor(node, dir, context, forNode => {
        // create the loop render function expression now, and add the
        // iterator on exit after all children have been traversed
        const renderExp = createCallExpression(helper(RENDER_LIST), [
            forNode.source
        ]);
        const isTemplate = isTemplateNode(node);
        const memo = findDir(node, 'memo');
        const keyProp = findProp(node, `key`);
        const keyExp = keyProp &&
            (keyProp.type === 6 /* NodeTypes.ATTRIBUTE */
                ? createSimpleExpression(keyProp.value.content, true)
                : keyProp.exp);
        const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;
        const isStableFragment = forNode.source.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ &&
            forNode.source.constType > 0 /* ConstantTypes.NOT_CONSTANT */;
        const fragmentFlag = isStableFragment
            ? 64 /* PatchFlags.STABLE_FRAGMENT */
            : keyProp
                ? 128 /* PatchFlags.KEYED_FRAGMENT */
                : 256 /* PatchFlags.UNKEYED_FRAGMENT */;
        forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, renderExp, fragmentFlag +
            (( true) ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[fragmentFlag]} */` : 0), undefined, undefined, true /* isBlock */, !isStableFragment /* disableTracking */, false /* isComponent */, node.loc);
        return () => {
            // finish the codegen now that all children have been traversed
            let childBlock;
            const { children } = forNode;
            // check <template v-for> key placement
            if (( true) && isTemplate) {
                node.children.some(c => {
                    if (c.type === 1 /* NodeTypes.ELEMENT */) {
                        const key = findProp(c, 'key');
                        if (key) {
                            context.onError(createCompilerError(33 /* ErrorCodes.X_V_FOR_TEMPLATE_KEY_PLACEMENT */, key.loc));
                            return true;
                        }
                    }
                });
            }
            const needFragmentWrapper = children.length !== 1 || children[0].type !== 1 /* NodeTypes.ELEMENT */;
            const slotOutlet = isSlotOutlet(node)
                ? node
                : isTemplate &&
                    node.children.length === 1 &&
                    isSlotOutlet(node.children[0])
                    ? node.children[0] // api-extractor somehow fails to infer this
                    : null;
            if (slotOutlet) {
                // <slot v-for="..."> or <template v-for="..."><slot/></template>
                childBlock = slotOutlet.codegenNode;
                if (isTemplate && keyProperty) {
                    // <template v-for="..." :key="..."><slot/></template>
                    // we need to inject the key to the renderSlot() call.
                    // the props for renderSlot is passed as the 3rd argument.
                    injectProp(childBlock, keyProperty, context);
                }
            }
            else if (needFragmentWrapper) {
                // <template v-for="..."> with text or multi-elements
                // should generate a fragment block for each loop
                childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : undefined, node.children, 64 /* PatchFlags.STABLE_FRAGMENT */ +
                    (( true)
                        ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[64]} */`
                        : 0), undefined, undefined, true, undefined, false /* isComponent */);
            }
            else {
                // Normal element v-for. Directly use the child's codegenNode
                // but mark it as a block.
                childBlock = children[0]
                    .codegenNode;
                if (isTemplate && keyProperty) {
                    injectProp(childBlock, keyProperty, context);
                }
                if (childBlock.isBlock !== !isStableFragment) {
                    if (childBlock.isBlock) {
                        // switch from block to vnode
                        removeHelper(OPEN_BLOCK);
                        removeHelper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
                    }
                    else {
                        // switch from vnode to block
                        removeHelper(getVNodeHelper(context.inSSR, childBlock.isComponent));
                    }
                }
                childBlock.isBlock = !isStableFragment;
                if (childBlock.isBlock) {
                    helper(OPEN_BLOCK);
                    helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
                }
                else {
                    helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
                }
            }
            if (memo) {
                const loop = createFunctionExpression(createForLoopParams(forNode.parseResult, [
                    createSimpleExpression(`_cached`)
                ]));
                loop.body = createBlockStatement([
                    createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
                    createCompoundExpression([
                        `if (_cached`,
                        ...(keyExp ? [` && _cached.key === `, keyExp] : []),
                        ` && ${context.helperString(IS_MEMO_SAME)}(_cached, _memo)) return _cached`
                    ]),
                    createCompoundExpression([`const _item = `, childBlock]),
                    createSimpleExpression(`_item.memo = _memo`),
                    createSimpleExpression(`return _item`)
                ]);
                renderExp.arguments.push(loop, createSimpleExpression(`_cache`), createSimpleExpression(String(context.cached++)));
            }
            else {
                renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true /* force newline */));
            }
        };
    });
});
// target-agnostic transform used for both Client and SSR
function processFor(node, dir, context, processCodegen) {
    if (!dir.exp) {
        context.onError(createCompilerError(31 /* ErrorCodes.X_V_FOR_NO_EXPRESSION */, dir.loc));
        return;
    }
    const parseResult = parseForExpression(
    // can only be simple expression because vFor transform is applied
    // before expression transform.
    dir.exp, context);
    if (!parseResult) {
        context.onError(createCompilerError(32 /* ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION */, dir.loc));
        return;
    }
    const { addIdentifiers, removeIdentifiers, scopes } = context;
    const { source, value, key, index } = parseResult;
    const forNode = {
        type: 11 /* NodeTypes.FOR */,
        loc: dir.loc,
        source,
        valueAlias: value,
        keyAlias: key,
        objectIndexAlias: index,
        parseResult,
        children: isTemplateNode(node) ? node.children : [node]
    };
    context.replaceNode(forNode);
    // bookkeeping
    scopes.vFor++;
    const onExit = processCodegen && processCodegen(forNode);
    return () => {
        scopes.vFor--;
        if (onExit)
            onExit();
    };
}
const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
// This regex doesn't cover the case if key or index aliases have destructuring,
// but those do not make sense in the first place, so this works in practice.
const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
const stripParensRE = /^\(|\)$/g;
function parseForExpression(input, context) {
    const loc = input.loc;
    const exp = input.content;
    const inMatch = exp.match(forAliasRE);
    if (!inMatch)
        return;
    const [, LHS, RHS] = inMatch;
    const result = {
        source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),
        value: undefined,
        key: undefined,
        index: undefined
    };
    if (true) {
        validateBrowserExpression(result.source, context);
    }
    let valueContent = LHS.trim().replace(stripParensRE, '').trim();
    const trimmedOffset = LHS.indexOf(valueContent);
    const iteratorMatch = valueContent.match(forIteratorRE);
    if (iteratorMatch) {
        valueContent = valueContent.replace(forIteratorRE, '').trim();
        const keyContent = iteratorMatch[1].trim();
        let keyOffset;
        if (keyContent) {
            keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
            result.key = createAliasExpression(loc, keyContent, keyOffset);
            if (true) {
                validateBrowserExpression(result.key, context, true);
            }
        }
        if (iteratorMatch[2]) {
            const indexContent = iteratorMatch[2].trim();
            if (indexContent) {
                result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key
                    ? keyOffset + keyContent.length
                    : trimmedOffset + valueContent.length));
                if (true) {
                    validateBrowserExpression(result.index, context, true);
                }
            }
        }
    }
    if (valueContent) {
        result.value = createAliasExpression(loc, valueContent, trimmedOffset);
        if (true) {
            validateBrowserExpression(result.value, context, true);
        }
    }
    return result;
}
function createAliasExpression(range, content, offset) {
    return createSimpleExpression(content, false, getInnerRange(range, offset, content.length));
}
function createForLoopParams({ value, key, index }, memoArgs = []) {
    return createParamsList([value, key, index, ...memoArgs]);
}
function createParamsList(args) {
    let i = args.length;
    while (i--) {
        if (args[i])
            break;
    }
    return args
        .slice(0, i + 1)
        .map((arg, i) => arg || createSimpleExpression(`_`.repeat(i + 1), false));
}

const defaultFallback = createSimpleExpression(`undefined`, false);
// A NodeTransform that:
// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed
//    by transformExpression. This is only applied in non-browser builds with
//    { prefixIdentifiers: true }.
// 2. Track v-slot depths so that we know a slot is inside another slot.
//    Note the exit callback is executed before buildSlots() on the same node,
//    so only nested slots see positive numbers.
const trackSlotScopes = (node, context) => {
    if (node.type === 1 /* NodeTypes.ELEMENT */ &&
        (node.tagType === 1 /* ElementTypes.COMPONENT */ ||
            node.tagType === 3 /* ElementTypes.TEMPLATE */)) {
        // We are only checking non-empty v-slot here
        // since we only care about slots that introduce scope variables.
        const vSlot = findDir(node, 'slot');
        if (vSlot) {
            vSlot.exp;
            context.scopes.vSlot++;
            return () => {
                context.scopes.vSlot--;
            };
        }
    }
};
// A NodeTransform that tracks scope identifiers for scoped slots with v-for.
// This transform is only applied in non-browser builds with { prefixIdentifiers: true }
const trackVForSlotScopes = (node, context) => {
    let vFor;
    if (isTemplateNode(node) &&
        node.props.some(isVSlot) &&
        (vFor = findDir(node, 'for'))) {
        const result = (vFor.parseResult = parseForExpression(vFor.exp, context));
        if (result) {
            const { value, key, index } = result;
            const { addIdentifiers, removeIdentifiers } = context;
            value && addIdentifiers(value);
            key && addIdentifiers(key);
            index && addIdentifiers(index);
            return () => {
                value && removeIdentifiers(value);
                key && removeIdentifiers(key);
                index && removeIdentifiers(index);
            };
        }
    }
};
const buildClientSlotFn = (props, children, loc) => createFunctionExpression(props, children, false /* newline */, true /* isSlot */, children.length ? children[0].loc : loc);
// Instead of being a DirectiveTransform, v-slot processing is called during
// transformElement to build the slots object for a component.
function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
    context.helper(WITH_CTX);
    const { children, loc } = node;
    const slotsProperties = [];
    const dynamicSlots = [];
    // If the slot is inside a v-for or another v-slot, force it to be dynamic
    // since it likely uses a scope variable.
    let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
    // 1. Check for slot with slotProps on component itself.
    //    <Comp v-slot="{ prop }"/>
    const onComponentSlot = findDir(node, 'slot', true);
    if (onComponentSlot) {
        const { arg, exp } = onComponentSlot;
        if (arg && !isStaticExp(arg)) {
            hasDynamicSlots = true;
        }
        slotsProperties.push(createObjectProperty(arg || createSimpleExpression('default', true), buildSlotFn(exp, children, loc)));
    }
    // 2. Iterate through children and check for template slots
    //    <template v-slot:foo="{ prop }">
    let hasTemplateSlots = false;
    let hasNamedDefaultSlot = false;
    const implicitDefaultChildren = [];
    const seenSlotNames = new Set();
    let conditionalBranchIndex = 0;
    for (let i = 0; i < children.length; i++) {
        const slotElement = children[i];
        let slotDir;
        if (!isTemplateNode(slotElement) ||
            !(slotDir = findDir(slotElement, 'slot', true))) {
            // not a <template v-slot>, skip.
            if (slotElement.type !== 3 /* NodeTypes.COMMENT */) {
                implicitDefaultChildren.push(slotElement);
            }
            continue;
        }
        if (onComponentSlot) {
            // already has on-component slot - this is incorrect usage.
            context.onError(createCompilerError(37 /* ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE */, slotDir.loc));
            break;
        }
        hasTemplateSlots = true;
        const { children: slotChildren, loc: slotLoc } = slotElement;
        const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;
        // check if name is dynamic.
        let staticSlotName;
        if (isStaticExp(slotName)) {
            staticSlotName = slotName ? slotName.content : `default`;
        }
        else {
            hasDynamicSlots = true;
        }
        const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);
        // check if this slot is conditional (v-if/v-for)
        let vIf;
        let vElse;
        let vFor;
        if ((vIf = findDir(slotElement, 'if'))) {
            hasDynamicSlots = true;
            dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++), defaultFallback));
        }
        else if ((vElse = findDir(slotElement, /^else(-if)?$/, true /* allowEmpty */))) {
            // find adjacent v-if
            let j = i;
            let prev;
            while (j--) {
                prev = children[j];
                if (prev.type !== 3 /* NodeTypes.COMMENT */) {
                    break;
                }
            }
            if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {
                // remove node
                children.splice(i, 1);
                i--;
                // attach this slot to previous conditional
                let conditional = dynamicSlots[dynamicSlots.length - 1];
                while (conditional.alternate.type === 19 /* NodeTypes.JS_CONDITIONAL_EXPRESSION */) {
                    conditional = conditional.alternate;
                }
                conditional.alternate = vElse.exp
                    ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++), defaultFallback)
                    : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++);
            }
            else {
                context.onError(createCompilerError(30 /* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */, vElse.loc));
            }
        }
        else if ((vFor = findDir(slotElement, 'for'))) {
            hasDynamicSlots = true;
            const parseResult = vFor.parseResult ||
                parseForExpression(vFor.exp, context);
            if (parseResult) {
                // Render the dynamic slots as an array and add it to the createSlot()
                // args. The runtime knows how to handle it appropriately.
                dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [
                    parseResult.source,
                    createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true /* force newline */)
                ]));
            }
            else {
                context.onError(createCompilerError(32 /* ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION */, vFor.loc));
            }
        }
        else {
            // check duplicate static names
            if (staticSlotName) {
                if (seenSlotNames.has(staticSlotName)) {
                    context.onError(createCompilerError(38 /* ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES */, dirLoc));
                    continue;
                }
                seenSlotNames.add(staticSlotName);
                if (staticSlotName === 'default') {
                    hasNamedDefaultSlot = true;
                }
            }
            slotsProperties.push(createObjectProperty(slotName, slotFunction));
        }
    }
    if (!onComponentSlot) {
        const buildDefaultSlotProperty = (props, children) => {
            const fn = buildSlotFn(props, children, loc);
            if (context.compatConfig) {
                fn.isNonScopedSlot = true;
            }
            return createObjectProperty(`default`, fn);
        };
        if (!hasTemplateSlots) {
            // implicit default slot (on component)
            slotsProperties.push(buildDefaultSlotProperty(undefined, children));
        }
        else if (implicitDefaultChildren.length &&
            // #3766
            // with whitespace: 'preserve', whitespaces between slots will end up in
            // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
            implicitDefaultChildren.some(node => isNonWhitespaceContent(node))) {
            // implicit default slot (mixed with named slots)
            if (hasNamedDefaultSlot) {
                context.onError(createCompilerError(39 /* ErrorCodes.X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */, implicitDefaultChildren[0].loc));
            }
            else {
                slotsProperties.push(buildDefaultSlotProperty(undefined, implicitDefaultChildren));
            }
        }
    }
    const slotFlag = hasDynamicSlots
        ? 2 /* SlotFlags.DYNAMIC */
        : hasForwardedSlots(node.children)
            ? 3 /* SlotFlags.FORWARDED */
            : 1 /* SlotFlags.STABLE */;
    let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`, 
    // 2 = compiled but dynamic = can skip normalization, but must run diff
    // 1 = compiled and static = can skip normalization AND diff as optimized
    createSimpleExpression(slotFlag + (( true) ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.slotFlagsText[slotFlag]} */` : 0), false))), loc);
    if (dynamicSlots.length) {
        slots = createCallExpression(context.helper(CREATE_SLOTS), [
            slots,
            createArrayExpression(dynamicSlots)
        ]);
    }
    return {
        slots,
        hasDynamicSlots
    };
}
function buildDynamicSlot(name, fn, index) {
    const props = [
        createObjectProperty(`name`, name),
        createObjectProperty(`fn`, fn)
    ];
    if (index != null) {
        props.push(createObjectProperty(`key`, createSimpleExpression(String(index), true)));
    }
    return createObjectExpression(props);
}
function hasForwardedSlots(children) {
    for (let i = 0; i < children.length; i++) {
        const child = children[i];
        switch (child.type) {
            case 1 /* NodeTypes.ELEMENT */:
                if (child.tagType === 2 /* ElementTypes.SLOT */ ||
                    hasForwardedSlots(child.children)) {
                    return true;
                }
                break;
            case 9 /* NodeTypes.IF */:
                if (hasForwardedSlots(child.branches))
                    return true;
                break;
            case 10 /* NodeTypes.IF_BRANCH */:
            case 11 /* NodeTypes.FOR */:
                if (hasForwardedSlots(child.children))
                    return true;
                break;
        }
    }
    return false;
}
function isNonWhitespaceContent(node) {
    if (node.type !== 2 /* NodeTypes.TEXT */ && node.type !== 12 /* NodeTypes.TEXT_CALL */)
        return true;
    return node.type === 2 /* NodeTypes.TEXT */
        ? !!node.content.trim()
        : isNonWhitespaceContent(node.content);
}

// some directive transforms (e.g. v-model) may return a symbol for runtime
// import, which should be used instead of a resolveDirective call.
const directiveImportMap = new WeakMap();
// generate a JavaScript AST for this element's codegen
const transformElement = (node, context) => {
    // perform the work on exit, after all child expressions have been
    // processed and merged.
    return function postTransformElement() {
        node = context.currentNode;
        if (!(node.type === 1 /* NodeTypes.ELEMENT */ &&
            (node.tagType === 0 /* ElementTypes.ELEMENT */ ||
                node.tagType === 1 /* ElementTypes.COMPONENT */))) {
            return;
        }
        const { tag, props } = node;
        const isComponent = node.tagType === 1 /* ElementTypes.COMPONENT */;
        // The goal of the transform is to create a codegenNode implementing the
        // VNodeCall interface.
        let vnodeTag = isComponent
            ? resolveComponentType(node, context)
            : `"${tag}"`;
        const isDynamicComponent = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
        let vnodeProps;
        let vnodeChildren;
        let vnodePatchFlag;
        let patchFlag = 0;
        let vnodeDynamicProps;
        let dynamicPropNames;
        let vnodeDirectives;
        let shouldUseBlock = 
        // dynamic component may resolve to plain elements
        isDynamicComponent ||
            vnodeTag === TELEPORT ||
            vnodeTag === SUSPENSE ||
            (!isComponent &&
                // <svg> and <foreignObject> must be forced into blocks so that block
                // updates inside get proper isSVG flag at runtime. (#639, #643)
                // This is technically web-specific, but splitting the logic out of core
                // leads to too much unnecessary complexity.
                (tag === 'svg' || tag === 'foreignObject'));
        // props
        if (props.length > 0) {
            const propsBuildResult = buildProps(node, context, undefined, isComponent, isDynamicComponent);
            vnodeProps = propsBuildResult.props;
            patchFlag = propsBuildResult.patchFlag;
            dynamicPropNames = propsBuildResult.dynamicPropNames;
            const directives = propsBuildResult.directives;
            vnodeDirectives =
                directives && directives.length
                    ? createArrayExpression(directives.map(dir => buildDirectiveArgs(dir, context)))
                    : undefined;
            if (propsBuildResult.shouldUseBlock) {
                shouldUseBlock = true;
            }
        }
        // children
        if (node.children.length > 0) {
            if (vnodeTag === KEEP_ALIVE) {
                // Although a built-in component, we compile KeepAlive with raw children
                // instead of slot functions so that it can be used inside Transition
                // or other Transition-wrapping HOCs.
                // To ensure correct updates with block optimizations, we need to:
                // 1. Force keep-alive into a block. This avoids its children being
                //    collected by a parent block.
                shouldUseBlock = true;
                // 2. Force keep-alive to always be updated, since it uses raw children.
                patchFlag |= 1024 /* PatchFlags.DYNAMIC_SLOTS */;
                if (( true) && node.children.length > 1) {
                    context.onError(createCompilerError(46 /* ErrorCodes.X_KEEP_ALIVE_INVALID_CHILDREN */, {
                        start: node.children[0].loc.start,
                        end: node.children[node.children.length - 1].loc.end,
                        source: ''
                    }));
                }
            }
            const shouldBuildAsSlots = isComponent &&
                // Teleport is not a real component and has dedicated runtime handling
                vnodeTag !== TELEPORT &&
                // explained above.
                vnodeTag !== KEEP_ALIVE;
            if (shouldBuildAsSlots) {
                const { slots, hasDynamicSlots } = buildSlots(node, context);
                vnodeChildren = slots;
                if (hasDynamicSlots) {
                    patchFlag |= 1024 /* PatchFlags.DYNAMIC_SLOTS */;
                }
            }
            else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
                const child = node.children[0];
                const type = child.type;
                // check for dynamic text children
                const hasDynamicTextChild = type === 5 /* NodeTypes.INTERPOLATION */ ||
                    type === 8 /* NodeTypes.COMPOUND_EXPRESSION */;
                if (hasDynamicTextChild &&
                    getConstantType(child, context) === 0 /* ConstantTypes.NOT_CONSTANT */) {
                    patchFlag |= 1 /* PatchFlags.TEXT */;
                }
                // pass directly if the only child is a text node
                // (plain / interpolation / expression)
                if (hasDynamicTextChild || type === 2 /* NodeTypes.TEXT */) {
                    vnodeChildren = child;
                }
                else {
                    vnodeChildren = node.children;
                }
            }
            else {
                vnodeChildren = node.children;
            }
        }
        // patchFlag & dynamicPropNames
        if (patchFlag !== 0) {
            if ((true)) {
                if (patchFlag < 0) {
                    // special flags (negative and mutually exclusive)
                    vnodePatchFlag = patchFlag + ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[patchFlag]} */`;
                }
                else {
                    // bitwise flags
                    const flagNames = Object.keys(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames)
                        .map(Number)
                        .filter(n => n > 0 && patchFlag & n)
                        .map(n => _vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[n])
                        .join(`, `);
                    vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;
                }
            }
            else {}
            if (dynamicPropNames && dynamicPropNames.length) {
                vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
            }
        }
        node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false /* disableTracking */, isComponent, node.loc);
    };
};
function resolveComponentType(node, context, ssr = false) {
    let { tag } = node;
    // 1. dynamic component
    const isExplicitDynamic = isComponentTag(tag);
    const isProp = findProp(node, 'is');
    if (isProp) {
        if (isExplicitDynamic ||
            (isCompatEnabled("COMPILER_IS_ON_ELEMENT" /* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */, context))) {
            const exp = isProp.type === 6 /* NodeTypes.ATTRIBUTE */
                ? isProp.value && createSimpleExpression(isProp.value.content, true)
                : isProp.exp;
            if (exp) {
                return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
                    exp
                ]);
            }
        }
        else if (isProp.type === 6 /* NodeTypes.ATTRIBUTE */ &&
            isProp.value.content.startsWith('vue:')) {
            // <button is="vue:xxx">
            // if not <component>, only is value that starts with "vue:" will be
            // treated as component by the parse phase and reach here, unless it's
            // compat mode where all is values are considered components
            tag = isProp.value.content.slice(4);
        }
    }
    // 1.5 v-is (TODO: Deprecate)
    const isDir = !isExplicitDynamic && findDir(node, 'is');
    if (isDir && isDir.exp) {
        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
            isDir.exp
        ]);
    }
    // 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)
    const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
    if (builtIn) {
        // built-ins are simply fallthroughs / have special handling during ssr
        // so we don't need to import their runtime equivalents
        if (!ssr)
            context.helper(builtIn);
        return builtIn;
    }
    // 5. user component (resolve)
    context.helper(RESOLVE_COMPONENT);
    context.components.add(tag);
    return toValidAssetId(tag, `component`);
}
function buildProps(node, context, props = node.props, isComponent, isDynamicComponent, ssr = false) {
    const { tag, loc: elementLoc, children } = node;
    let properties = [];
    const mergeArgs = [];
    const runtimeDirectives = [];
    const hasChildren = children.length > 0;
    let shouldUseBlock = false;
    // patchFlag analysis
    let patchFlag = 0;
    let hasRef = false;
    let hasClassBinding = false;
    let hasStyleBinding = false;
    let hasHydrationEventBinding = false;
    let hasDynamicKeys = false;
    let hasVnodeHook = false;
    const dynamicPropNames = [];
    const pushMergeArg = (arg) => {
        if (properties.length) {
            mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
            properties = [];
        }
        if (arg)
            mergeArgs.push(arg);
    };
    const analyzePatchFlag = ({ key, value }) => {
        if (isStaticExp(key)) {
            const name = key.content;
            const isEventHandler = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isOn)(name);
            if (isEventHandler &&
                (!isComponent || isDynamicComponent) &&
                // omit the flag for click handlers because hydration gives click
                // dedicated fast path.
                name.toLowerCase() !== 'onclick' &&
                // omit v-model handlers
                name !== 'onUpdate:modelValue' &&
                // omit onVnodeXXX hooks
                !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isReservedProp)(name)) {
                hasHydrationEventBinding = true;
            }
            if (isEventHandler && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isReservedProp)(name)) {
                hasVnodeHook = true;
            }
            if (value.type === 20 /* NodeTypes.JS_CACHE_EXPRESSION */ ||
                ((value.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ ||
                    value.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */) &&
                    getConstantType(value, context) > 0)) {
                // skip if the prop is a cached handler or has constant value
                return;
            }
            if (name === 'ref') {
                hasRef = true;
            }
            else if (name === 'class') {
                hasClassBinding = true;
            }
            else if (name === 'style') {
                hasStyleBinding = true;
            }
            else if (name !== 'key' && !dynamicPropNames.includes(name)) {
                dynamicPropNames.push(name);
            }
            // treat the dynamic class and style binding of the component as dynamic props
            if (isComponent &&
                (name === 'class' || name === 'style') &&
                !dynamicPropNames.includes(name)) {
                dynamicPropNames.push(name);
            }
        }
        else {
            hasDynamicKeys = true;
        }
    };
    for (let i = 0; i < props.length; i++) {
        // static attribute
        const prop = props[i];
        if (prop.type === 6 /* NodeTypes.ATTRIBUTE */) {
            const { loc, name, value } = prop;
            let isStatic = true;
            if (name === 'ref') {
                hasRef = true;
                if (context.scopes.vFor > 0) {
                    properties.push(createObjectProperty(createSimpleExpression('ref_for', true), createSimpleExpression('true')));
                }
            }
            // skip is on <component>, or is="vue:xxx"
            if (name === 'is' &&
                (isComponentTag(tag) ||
                    (value && value.content.startsWith('vue:')) ||
                    (isCompatEnabled("COMPILER_IS_ON_ELEMENT" /* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */, context)))) {
                continue;
            }
            properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : '', isStatic, value ? value.loc : loc)));
        }
        else {
            // directives
            const { name, arg, exp, loc } = prop;
            const isVBind = name === 'bind';
            const isVOn = name === 'on';
            // skip v-slot - it is handled by its dedicated transform.
            if (name === 'slot') {
                if (!isComponent) {
                    context.onError(createCompilerError(40 /* ErrorCodes.X_V_SLOT_MISPLACED */, loc));
                }
                continue;
            }
            // skip v-once/v-memo - they are handled by dedicated transforms.
            if (name === 'once' || name === 'memo') {
                continue;
            }
            // skip v-is and :is on <component>
            if (name === 'is' ||
                (isVBind &&
                    isStaticArgOf(arg, 'is') &&
                    (isComponentTag(tag) ||
                        (isCompatEnabled("COMPILER_IS_ON_ELEMENT" /* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */, context))))) {
                continue;
            }
            // skip v-on in SSR compilation
            if (isVOn && ssr) {
                continue;
            }
            if (
            // #938: elements with dynamic keys should be forced into blocks
            (isVBind && isStaticArgOf(arg, 'key')) ||
                // inline before-update hooks need to force block so that it is invoked
                // before children
                (isVOn && hasChildren && isStaticArgOf(arg, 'vue:before-update'))) {
                shouldUseBlock = true;
            }
            if (isVBind && isStaticArgOf(arg, 'ref') && context.scopes.vFor > 0) {
                properties.push(createObjectProperty(createSimpleExpression('ref_for', true), createSimpleExpression('true')));
            }
            // special case for v-bind and v-on with no argument
            if (!arg && (isVBind || isVOn)) {
                hasDynamicKeys = true;
                if (exp) {
                    if (isVBind) {
                        // have to merge early for compat build check
                        pushMergeArg();
                        {
                            // 2.x v-bind object order compat
                            if ((true)) {
                                const hasOverridableKeys = mergeArgs.some(arg => {
                                    if (arg.type === 15 /* NodeTypes.JS_OBJECT_EXPRESSION */) {
                                        return arg.properties.some(({ key }) => {
                                            if (key.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */ ||
                                                !key.isStatic) {
                                                return true;
                                            }
                                            return (key.content !== 'class' &&
                                                key.content !== 'style' &&
                                                !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isOn)(key.content));
                                        });
                                    }
                                    else {
                                        // dynamic expression
                                        return true;
                                    }
                                });
                                if (hasOverridableKeys) {
                                    checkCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER" /* CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER */, context, loc);
                                }
                            }
                            if (isCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER" /* CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER */, context)) {
                                mergeArgs.unshift(exp);
                                continue;
                            }
                        }
                        mergeArgs.push(exp);
                    }
                    else {
                        // v-on="obj" -> toHandlers(obj)
                        pushMergeArg({
                            type: 14 /* NodeTypes.JS_CALL_EXPRESSION */,
                            loc,
                            callee: context.helper(TO_HANDLERS),
                            arguments: isComponent ? [exp] : [exp, `true`]
                        });
                    }
                }
                else {
                    context.onError(createCompilerError(isVBind
                        ? 34 /* ErrorCodes.X_V_BIND_NO_EXPRESSION */
                        : 35 /* ErrorCodes.X_V_ON_NO_EXPRESSION */, loc));
                }
                continue;
            }
            const directiveTransform = context.directiveTransforms[name];
            if (directiveTransform) {
                // has built-in directive transform.
                const { props, needRuntime } = directiveTransform(prop, node, context);
                !ssr && props.forEach(analyzePatchFlag);
                if (isVOn && arg && !isStaticExp(arg)) {
                    pushMergeArg(createObjectExpression(props, elementLoc));
                }
                else {
                    properties.push(...props);
                }
                if (needRuntime) {
                    runtimeDirectives.push(prop);
                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(needRuntime)) {
                        directiveImportMap.set(prop, needRuntime);
                    }
                }
            }
            else if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isBuiltInDirective)(name)) {
                // no built-in transform, this is a user custom directive.
                runtimeDirectives.push(prop);
                // custom dirs may use beforeUpdate so they need to force blocks
                // to ensure before-update gets called before children update
                if (hasChildren) {
                    shouldUseBlock = true;
                }
            }
        }
    }
    let propsExpression = undefined;
    // has v-bind="object" or v-on="object", wrap with mergeProps
    if (mergeArgs.length) {
        // close up any not-yet-merged props
        pushMergeArg();
        if (mergeArgs.length > 1) {
            propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);
        }
        else {
            // single v-bind with nothing else - no need for a mergeProps call
            propsExpression = mergeArgs[0];
        }
    }
    else if (properties.length) {
        propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
    }
    // patchFlag analysis
    if (hasDynamicKeys) {
        patchFlag |= 16 /* PatchFlags.FULL_PROPS */;
    }
    else {
        if (hasClassBinding && !isComponent) {
            patchFlag |= 2 /* PatchFlags.CLASS */;
        }
        if (hasStyleBinding && !isComponent) {
            patchFlag |= 4 /* PatchFlags.STYLE */;
        }
        if (dynamicPropNames.length) {
            patchFlag |= 8 /* PatchFlags.PROPS */;
        }
        if (hasHydrationEventBinding) {
            patchFlag |= 32 /* PatchFlags.HYDRATE_EVENTS */;
        }
    }
    if (!shouldUseBlock &&
        (patchFlag === 0 || patchFlag === 32 /* PatchFlags.HYDRATE_EVENTS */) &&
        (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
        patchFlag |= 512 /* PatchFlags.NEED_PATCH */;
    }
    // pre-normalize props, SSR is skipped for now
    if (!context.inSSR && propsExpression) {
        switch (propsExpression.type) {
            case 15 /* NodeTypes.JS_OBJECT_EXPRESSION */:
                // means that there is no v-bind,
                // but still need to deal with dynamic key binding
                let classKeyIndex = -1;
                let styleKeyIndex = -1;
                let hasDynamicKey = false;
                for (let i = 0; i < propsExpression.properties.length; i++) {
                    const key = propsExpression.properties[i].key;
                    if (isStaticExp(key)) {
                        if (key.content === 'class') {
                            classKeyIndex = i;
                        }
                        else if (key.content === 'style') {
                            styleKeyIndex = i;
                        }
                    }
                    else if (!key.isHandlerKey) {
                        hasDynamicKey = true;
                    }
                }
                const classProp = propsExpression.properties[classKeyIndex];
                const styleProp = propsExpression.properties[styleKeyIndex];
                // no dynamic key
                if (!hasDynamicKey) {
                    if (classProp && !isStaticExp(classProp.value)) {
                        classProp.value = createCallExpression(context.helper(NORMALIZE_CLASS), [classProp.value]);
                    }
                    if (styleProp &&
                        // the static style is compiled into an object,
                        // so use `hasStyleBinding` to ensure that it is a dynamic style binding
                        (hasStyleBinding ||
                            (styleProp.value.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ &&
                                styleProp.value.content.trim()[0] === `[`) ||
                            // v-bind:style and style both exist,
                            // v-bind:style with static literal object
                            styleProp.value.type === 17 /* NodeTypes.JS_ARRAY_EXPRESSION */)) {
                        styleProp.value = createCallExpression(context.helper(NORMALIZE_STYLE), [styleProp.value]);
                    }
                }
                else {
                    // dynamic key binding, wrap with `normalizeProps`
                    propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [propsExpression]);
                }
                break;
            case 14 /* NodeTypes.JS_CALL_EXPRESSION */:
                // mergeProps call, do nothing
                break;
            default:
                // single v-bind
                propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [
                    createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
                        propsExpression
                    ])
                ]);
                break;
        }
    }
    return {
        props: propsExpression,
        directives: runtimeDirectives,
        patchFlag,
        dynamicPropNames,
        shouldUseBlock
    };
}
// Dedupe props in an object literal.
// Literal duplicated attributes would have been warned during the parse phase,
// however, it's possible to encounter duplicated `onXXX` handlers with different
// modifiers. We also need to merge static and dynamic class / style attributes.
// - onXXX handlers / style: merge into array
// - class: merge into single expression with concatenation
function dedupeProperties(properties) {
    const knownProps = new Map();
    const deduped = [];
    for (let i = 0; i < properties.length; i++) {
        const prop = properties[i];
        // dynamic keys are always allowed
        if (prop.key.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */ || !prop.key.isStatic) {
            deduped.push(prop);
            continue;
        }
        const name = prop.key.content;
        const existing = knownProps.get(name);
        if (existing) {
            if (name === 'style' || name === 'class' || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isOn)(name)) {
                mergeAsArray(existing, prop);
            }
            // unexpected duplicate, should have emitted error during parse
        }
        else {
            knownProps.set(name, prop);
            deduped.push(prop);
        }
    }
    return deduped;
}
function mergeAsArray(existing, incoming) {
    if (existing.value.type === 17 /* NodeTypes.JS_ARRAY_EXPRESSION */) {
        existing.value.elements.push(incoming.value);
    }
    else {
        existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
    }
}
function buildDirectiveArgs(dir, context) {
    const dirArgs = [];
    const runtime = directiveImportMap.get(dir);
    if (runtime) {
        // built-in directive with runtime
        dirArgs.push(context.helperString(runtime));
    }
    else {
        {
            // inject statement for resolving directive
            context.helper(RESOLVE_DIRECTIVE);
            context.directives.add(dir.name);
            dirArgs.push(toValidAssetId(dir.name, `directive`));
        }
    }
    const { loc } = dir;
    if (dir.exp)
        dirArgs.push(dir.exp);
    if (dir.arg) {
        if (!dir.exp) {
            dirArgs.push(`void 0`);
        }
        dirArgs.push(dir.arg);
    }
    if (Object.keys(dir.modifiers).length) {
        if (!dir.arg) {
            if (!dir.exp) {
                dirArgs.push(`void 0`);
            }
            dirArgs.push(`void 0`);
        }
        const trueExpression = createSimpleExpression(`true`, false, loc);
        dirArgs.push(createObjectExpression(dir.modifiers.map(modifier => createObjectProperty(modifier, trueExpression)), loc));
    }
    return createArrayExpression(dirArgs, dir.loc);
}
function stringifyDynamicPropNames(props) {
    let propsNamesString = `[`;
    for (let i = 0, l = props.length; i < l; i++) {
        propsNamesString += JSON.stringify(props[i]);
        if (i < l - 1)
            propsNamesString += ', ';
    }
    return propsNamesString + `]`;
}
function isComponentTag(tag) {
    return tag === 'component' || tag === 'Component';
}

( true)
    ? Object.freeze({})
    : 0;
( true) ? Object.freeze([]) : 0;
const cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return ((str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    });
};
const camelizeRE = /-(\w)/g;
/**
 * @private
 */
const camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
});

const transformSlotOutlet = (node, context) => {
    if (isSlotOutlet(node)) {
        const { children, loc } = node;
        const { slotName, slotProps } = processSlotOutlet(node, context);
        const slotArgs = [
            context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
            slotName,
            '{}',
            'undefined',
            'true'
        ];
        let expectedLen = 2;
        if (slotProps) {
            slotArgs[2] = slotProps;
            expectedLen = 3;
        }
        if (children.length) {
            slotArgs[3] = createFunctionExpression([], children, false, false, loc);
            expectedLen = 4;
        }
        if (context.scopeId && !context.slotted) {
            expectedLen = 5;
        }
        slotArgs.splice(expectedLen); // remove unused arguments
        node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);
    }
};
function processSlotOutlet(node, context) {
    let slotName = `"default"`;
    let slotProps = undefined;
    const nonNameProps = [];
    for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 6 /* NodeTypes.ATTRIBUTE */) {
            if (p.value) {
                if (p.name === 'name') {
                    slotName = JSON.stringify(p.value.content);
                }
                else {
                    p.name = camelize(p.name);
                    nonNameProps.push(p);
                }
            }
        }
        else {
            if (p.name === 'bind' && isStaticArgOf(p.arg, 'name')) {
                if (p.exp)
                    slotName = p.exp;
            }
            else {
                if (p.name === 'bind' && p.arg && isStaticExp(p.arg)) {
                    p.arg.content = camelize(p.arg.content);
                }
                nonNameProps.push(p);
            }
        }
    }
    if (nonNameProps.length > 0) {
        const { props, directives } = buildProps(node, context, nonNameProps, false, false);
        slotProps = props;
        if (directives.length) {
            context.onError(createCompilerError(36 /* ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */, directives[0].loc));
        }
    }
    return {
        slotName,
        slotProps
    };
}

const fnExpRE = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
const transformOn = (dir, node, context, augmentor) => {
    const { loc, modifiers, arg } = dir;
    if (!dir.exp && !modifiers.length) {
        context.onError(createCompilerError(35 /* ErrorCodes.X_V_ON_NO_EXPRESSION */, loc));
    }
    let eventName;
    if (arg.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
        if (arg.isStatic) {
            let rawName = arg.content;
            // TODO deprecate @vnodeXXX usage
            if (rawName.startsWith('vue:')) {
                rawName = `vnode-${rawName.slice(4)}`;
            }
            const eventString = node.tagType !== 0 /* ElementTypes.ELEMENT */ ||
                rawName.startsWith('vnode') ||
                !/[A-Z]/.test(rawName)
                ? // for non-element and vnode lifecycle event listeners, auto convert
                    // it to camelCase. See issue #2249
                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(rawName))
                : // preserve case for plain element listeners that have uppercase
                    // letters, as these may be custom elements' custom events
                    `on:${rawName}`;
            eventName = createSimpleExpression(eventString, true, arg.loc);
        }
        else {
            // #2388
            eventName = createCompoundExpression([
                `${context.helperString(TO_HANDLER_KEY)}(`,
                arg,
                `)`
            ]);
        }
    }
    else {
        // already a compound expression.
        eventName = arg;
        eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
        eventName.children.push(`)`);
    }
    // handler processing
    let exp = dir.exp;
    if (exp && !exp.content.trim()) {
        exp = undefined;
    }
    let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
    if (exp) {
        const isMemberExp = isMemberExpression(exp.content);
        const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
        const hasMultipleStatements = exp.content.includes(`;`);
        if (true) {
            validateBrowserExpression(exp, context, false, hasMultipleStatements);
        }
        if (isInlineStatement || (shouldCache && isMemberExp)) {
            // wrap inline statement in a function expression
            exp = createCompoundExpression([
                `${isInlineStatement
                    ? `$event`
                    : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
                exp,
                hasMultipleStatements ? `}` : `)`
            ]);
        }
    }
    let ret = {
        props: [
            createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))
        ]
    };
    // apply extended compiler augmentor
    if (augmentor) {
        ret = augmentor(ret);
    }
    if (shouldCache) {
        // cache handlers so that it's always the same handler being passed down.
        // this avoids unnecessary re-renders when users use inline handlers on
        // components.
        ret.props[0].value = context.cache(ret.props[0].value);
    }
    // mark the key as handler for props normalization check
    ret.props.forEach(p => (p.key.isHandlerKey = true));
    return ret;
};

// v-bind without arg is handled directly in ./transformElements.ts due to it affecting
// codegen for the entire props object. This transform here is only for v-bind
// *with* args.
const transformBind = (dir, _node, context) => {
    const { exp, modifiers, loc } = dir;
    const arg = dir.arg;
    if (arg.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
        arg.children.unshift(`(`);
        arg.children.push(`) || ""`);
    }
    else if (!arg.isStatic) {
        arg.content = `${arg.content} || ""`;
    }
    // .sync is replaced by v-model:arg
    if (modifiers.includes('camel')) {
        if (arg.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
            if (arg.isStatic) {
                arg.content = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(arg.content);
            }
            else {
                arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
            }
        }
        else {
            arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
            arg.children.push(`)`);
        }
    }
    if (!context.inSSR) {
        if (modifiers.includes('prop')) {
            injectPrefix(arg, '.');
        }
        if (modifiers.includes('attr')) {
            injectPrefix(arg, '^');
        }
    }
    if (!exp ||
        (exp.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ && !exp.content.trim())) {
        context.onError(createCompilerError(34 /* ErrorCodes.X_V_BIND_NO_EXPRESSION */, loc));
        return {
            props: [createObjectProperty(arg, createSimpleExpression('', true, loc))]
        };
    }
    return {
        props: [createObjectProperty(arg, exp)]
    };
};
const injectPrefix = (arg, prefix) => {
    if (arg.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
        if (arg.isStatic) {
            arg.content = prefix + arg.content;
        }
        else {
            arg.content = `\`${prefix}\${${arg.content}}\``;
        }
    }
    else {
        arg.children.unshift(`'${prefix}' + (`);
        arg.children.push(`)`);
    }
};

// Merge adjacent text nodes and expressions into a single expression
// e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.
const transformText = (node, context) => {
    if (node.type === 0 /* NodeTypes.ROOT */ ||
        node.type === 1 /* NodeTypes.ELEMENT */ ||
        node.type === 11 /* NodeTypes.FOR */ ||
        node.type === 10 /* NodeTypes.IF_BRANCH */) {
        // perform the transform on node exit so that all expressions have already
        // been processed.
        return () => {
            const children = node.children;
            let currentContainer = undefined;
            let hasText = false;
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (isText(child)) {
                    hasText = true;
                    for (let j = i + 1; j < children.length; j++) {
                        const next = children[j];
                        if (isText(next)) {
                            if (!currentContainer) {
                                currentContainer = children[i] = createCompoundExpression([child], child.loc);
                            }
                            // merge adjacent text node into current
                            currentContainer.children.push(` + `, next);
                            children.splice(j, 1);
                            j--;
                        }
                        else {
                            currentContainer = undefined;
                            break;
                        }
                    }
                }
            }
            if (!hasText ||
                // if this is a plain element with a single text child, leave it
                // as-is since the runtime has dedicated fast path for this by directly
                // setting textContent of the element.
                // for component root it's always normalized anyway.
                (children.length === 1 &&
                    (node.type === 0 /* NodeTypes.ROOT */ ||
                        (node.type === 1 /* NodeTypes.ELEMENT */ &&
                            node.tagType === 0 /* ElementTypes.ELEMENT */ &&
                            // #3756
                            // custom directives can potentially add DOM elements arbitrarily,
                            // we need to avoid setting textContent of the element at runtime
                            // to avoid accidentally overwriting the DOM elements added
                            // by the user through custom directives.
                            !node.props.find(p => p.type === 7 /* NodeTypes.DIRECTIVE */ &&
                                !context.directiveTransforms[p.name]) &&
                            // in compat mode, <template> tags with no special directives
                            // will be rendered as a fragment so its children must be
                            // converted into vnodes.
                            !(node.tag === 'template'))))) {
                return;
            }
            // pre-convert text nodes into createTextVNode(text) calls to avoid
            // runtime normalization.
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (isText(child) || child.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */) {
                    const callArgs = [];
                    // createTextVNode defaults to single whitespace, so if it is a
                    // single space the code could be an empty call to save bytes.
                    if (child.type !== 2 /* NodeTypes.TEXT */ || child.content !== ' ') {
                        callArgs.push(child);
                    }
                    // mark dynamic text with flag so it gets patched inside a block
                    if (!context.ssr &&
                        getConstantType(child, context) === 0 /* ConstantTypes.NOT_CONSTANT */) {
                        callArgs.push(1 /* PatchFlags.TEXT */ +
                            (( true) ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[1]} */` : 0));
                    }
                    children[i] = {
                        type: 12 /* NodeTypes.TEXT_CALL */,
                        content: child,
                        loc: child.loc,
                        codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)
                    };
                }
            }
        };
    }
};

const seen = new WeakSet();
const transformOnce = (node, context) => {
    if (node.type === 1 /* NodeTypes.ELEMENT */ && findDir(node, 'once', true)) {
        if (seen.has(node) || context.inVOnce) {
            return;
        }
        seen.add(node);
        context.inVOnce = true;
        context.helper(SET_BLOCK_TRACKING);
        return () => {
            context.inVOnce = false;
            const cur = context.currentNode;
            if (cur.codegenNode) {
                cur.codegenNode = context.cache(cur.codegenNode, true /* isVNode */);
            }
        };
    }
};

const transformModel = (dir, node, context) => {
    const { exp, arg } = dir;
    if (!exp) {
        context.onError(createCompilerError(41 /* ErrorCodes.X_V_MODEL_NO_EXPRESSION */, dir.loc));
        return createTransformProps();
    }
    const rawExp = exp.loc.source;
    const expString = exp.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ ? exp.content : rawExp;
    // im SFC <script setup> inline mode, the exp may have been transformed into
    // _unref(exp)
    const bindingType = context.bindingMetadata[rawExp];
    // check props
    if (bindingType === "props" /* BindingTypes.PROPS */ ||
        bindingType === "props-aliased" /* BindingTypes.PROPS_ALIASED */) {
        context.onError(createCompilerError(44 /* ErrorCodes.X_V_MODEL_ON_PROPS */, exp.loc));
        return createTransformProps();
    }
    const maybeRef = !true  ;
    if (!expString.trim() ||
        (!isMemberExpression(expString) && !maybeRef)) {
        context.onError(createCompilerError(42 /* ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION */, exp.loc));
        return createTransformProps();
    }
    const propName = arg ? arg : createSimpleExpression('modelValue', true);
    const eventName = arg
        ? isStaticExp(arg)
            ? `onUpdate:${arg.content}`
            : createCompoundExpression(['"onUpdate:" + ', arg])
        : `onUpdate:modelValue`;
    let assignmentExp;
    const eventArg = context.isTS ? `($event: any)` : `$event`;
    {
        assignmentExp = createCompoundExpression([
            `${eventArg} => ((`,
            exp,
            `) = $event)`
        ]);
    }
    const props = [
        // modelValue: foo
        createObjectProperty(propName, dir.exp),
        // "onUpdate:modelValue": $event => (foo = $event)
        createObjectProperty(eventName, assignmentExp)
    ];
    // modelModifiers: { foo: true, "bar-baz": true }
    if (dir.modifiers.length && node.tagType === 1 /* ElementTypes.COMPONENT */) {
        const modifiers = dir.modifiers
            .map(m => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`)
            .join(`, `);
        const modifiersKey = arg
            ? isStaticExp(arg)
                ? `${arg.content}Modifiers`
                : createCompoundExpression([arg, ' + "Modifiers"'])
            : `modelModifiers`;
        props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, 2 /* ConstantTypes.CAN_HOIST */)));
    }
    return createTransformProps(props);
};
function createTransformProps(props = []) {
    return { props };
}

const validDivisionCharRE = /[\w).+\-_$\]]/;
const transformFilter = (node, context) => {
    if (!isCompatEnabled("COMPILER_FILTER" /* CompilerDeprecationTypes.COMPILER_FILTERS */, context)) {
        return;
    }
    if (node.type === 5 /* NodeTypes.INTERPOLATION */) {
        // filter rewrite is applied before expression transform so only
        // simple expressions are possible at this stage
        rewriteFilter(node.content, context);
    }
    if (node.type === 1 /* NodeTypes.ELEMENT */) {
        node.props.forEach((prop) => {
            if (prop.type === 7 /* NodeTypes.DIRECTIVE */ &&
                prop.name !== 'for' &&
                prop.exp) {
                rewriteFilter(prop.exp, context);
            }
        });
    }
};
function rewriteFilter(node, context) {
    if (node.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
        parseFilter(node, context);
    }
    else {
        for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            if (typeof child !== 'object')
                continue;
            if (child.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
                parseFilter(child, context);
            }
            else if (child.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */) {
                rewriteFilter(node, context);
            }
            else if (child.type === 5 /* NodeTypes.INTERPOLATION */) {
                rewriteFilter(child.content, context);
            }
        }
    }
}
function parseFilter(node, context) {
    const exp = node.content;
    let inSingle = false;
    let inDouble = false;
    let inTemplateString = false;
    let inRegex = false;
    let curly = 0;
    let square = 0;
    let paren = 0;
    let lastFilterIndex = 0;
    let c, prev, i, expression, filters = [];
    for (i = 0; i < exp.length; i++) {
        prev = c;
        c = exp.charCodeAt(i);
        if (inSingle) {
            if (c === 0x27 && prev !== 0x5c)
                inSingle = false;
        }
        else if (inDouble) {
            if (c === 0x22 && prev !== 0x5c)
                inDouble = false;
        }
        else if (inTemplateString) {
            if (c === 0x60 && prev !== 0x5c)
                inTemplateString = false;
        }
        else if (inRegex) {
            if (c === 0x2f && prev !== 0x5c)
                inRegex = false;
        }
        else if (c === 0x7c && // pipe
            exp.charCodeAt(i + 1) !== 0x7c &&
            exp.charCodeAt(i - 1) !== 0x7c &&
            !curly &&
            !square &&
            !paren) {
            if (expression === undefined) {
                // first filter, end of expression
                lastFilterIndex = i + 1;
                expression = exp.slice(0, i).trim();
            }
            else {
                pushFilter();
            }
        }
        else {
            switch (c) {
                case 0x22:
                    inDouble = true;
                    break; // "
                case 0x27:
                    inSingle = true;
                    break; // '
                case 0x60:
                    inTemplateString = true;
                    break; // `
                case 0x28:
                    paren++;
                    break; // (
                case 0x29:
                    paren--;
                    break; // )
                case 0x5b:
                    square++;
                    break; // [
                case 0x5d:
                    square--;
                    break; // ]
                case 0x7b:
                    curly++;
                    break; // {
                case 0x7d:
                    curly--;
                    break; // }
            }
            if (c === 0x2f) {
                // /
                let j = i - 1;
                let p;
                // find first non-whitespace prev char
                for (; j >= 0; j--) {
                    p = exp.charAt(j);
                    if (p !== ' ')
                        break;
                }
                if (!p || !validDivisionCharRE.test(p)) {
                    inRegex = true;
                }
            }
        }
    }
    if (expression === undefined) {
        expression = exp.slice(0, i).trim();
    }
    else if (lastFilterIndex !== 0) {
        pushFilter();
    }
    function pushFilter() {
        filters.push(exp.slice(lastFilterIndex, i).trim());
        lastFilterIndex = i + 1;
    }
    if (filters.length) {
        ( true) &&
            warnDeprecation("COMPILER_FILTER" /* CompilerDeprecationTypes.COMPILER_FILTERS */, context, node.loc);
        for (i = 0; i < filters.length; i++) {
            expression = wrapFilter(expression, filters[i], context);
        }
        node.content = expression;
    }
}
function wrapFilter(exp, filter, context) {
    context.helper(RESOLVE_FILTER);
    const i = filter.indexOf('(');
    if (i < 0) {
        context.filters.add(filter);
        return `${toValidAssetId(filter, 'filter')}(${exp})`;
    }
    else {
        const name = filter.slice(0, i);
        const args = filter.slice(i + 1);
        context.filters.add(name);
        return `${toValidAssetId(name, 'filter')}(${exp}${args !== ')' ? ',' + args : args}`;
    }
}

const seen$1 = new WeakSet();
const transformMemo = (node, context) => {
    if (node.type === 1 /* NodeTypes.ELEMENT */) {
        const dir = findDir(node, 'memo');
        if (!dir || seen$1.has(node)) {
            return;
        }
        seen$1.add(node);
        return () => {
            const codegenNode = node.codegenNode ||
                context.currentNode.codegenNode;
            if (codegenNode && codegenNode.type === 13 /* NodeTypes.VNODE_CALL */) {
                // non-component sub tree should be turned into a block
                if (node.tagType !== 1 /* ElementTypes.COMPONENT */) {
                    makeBlock(codegenNode, context);
                }
                node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
                    dir.exp,
                    createFunctionExpression(undefined, codegenNode),
                    `_cache`,
                    String(context.cached++)
                ]);
            }
        };
    }
};

function getBaseTransformPreset(prefixIdentifiers) {
    return [
        [
            transformOnce,
            transformIf,
            transformMemo,
            transformFor,
            ...([transformFilter] ),
            ...(( true)
                    ? [transformExpression]
                    : 0),
            transformSlotOutlet,
            transformElement,
            trackSlotScopes,
            transformText
        ],
        {
            on: transformOn,
            bind: transformBind,
            model: transformModel
        }
    ];
}
// we name it `baseCompile` so that higher order compilers like
// @vue/compiler-dom can export `compile` while re-exporting everything else.
function baseCompile(template, options = {}) {
    const onError = options.onError || defaultOnError;
    const isModuleMode = options.mode === 'module';
    /* istanbul ignore if */
    {
        if (options.prefixIdentifiers === true) {
            onError(createCompilerError(47 /* ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED */));
        }
        else if (isModuleMode) {
            onError(createCompilerError(48 /* ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED */));
        }
    }
    const prefixIdentifiers = !true ;
    if (options.cacheHandlers) {
        onError(createCompilerError(49 /* ErrorCodes.X_CACHE_HANDLER_NOT_SUPPORTED */));
    }
    if (options.scopeId && !isModuleMode) {
        onError(createCompilerError(50 /* ErrorCodes.X_SCOPE_ID_NOT_SUPPORTED */));
    }
    const ast = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(template) ? baseParse(template, options) : template;
    const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
    transform(ast, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, options, {
        prefixIdentifiers,
        nodeTransforms: [
            ...nodeTransforms,
            ...(options.nodeTransforms || []) // user transforms
        ],
        directiveTransforms: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, directiveTransforms, options.directiveTransforms || {} // user transforms
        )
    }));
    return generate(ast, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, options, {
        prefixIdentifiers
    }));
}

const noopDirectiveTransform = () => ({ props: [] });




/***/ }),

/***/ "./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BASE_TRANSITION": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.BASE_TRANSITION),
/* harmony export */   "CAMELIZE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CAMELIZE),
/* harmony export */   "CAPITALIZE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CAPITALIZE),
/* harmony export */   "CREATE_BLOCK": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_BLOCK),
/* harmony export */   "CREATE_COMMENT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_COMMENT),
/* harmony export */   "CREATE_ELEMENT_BLOCK": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_ELEMENT_BLOCK),
/* harmony export */   "CREATE_ELEMENT_VNODE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_ELEMENT_VNODE),
/* harmony export */   "CREATE_SLOTS": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_SLOTS),
/* harmony export */   "CREATE_STATIC": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_STATIC),
/* harmony export */   "CREATE_TEXT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_TEXT),
/* harmony export */   "CREATE_VNODE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_VNODE),
/* harmony export */   "DOMDirectiveTransforms": () => (/* binding */ DOMDirectiveTransforms),
/* harmony export */   "DOMNodeTransforms": () => (/* binding */ DOMNodeTransforms),
/* harmony export */   "FRAGMENT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.FRAGMENT),
/* harmony export */   "GUARD_REACTIVE_PROPS": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.GUARD_REACTIVE_PROPS),
/* harmony export */   "IS_MEMO_SAME": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.IS_MEMO_SAME),
/* harmony export */   "IS_REF": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.IS_REF),
/* harmony export */   "KEEP_ALIVE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.KEEP_ALIVE),
/* harmony export */   "MERGE_PROPS": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.MERGE_PROPS),
/* harmony export */   "NORMALIZE_CLASS": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.NORMALIZE_CLASS),
/* harmony export */   "NORMALIZE_PROPS": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.NORMALIZE_PROPS),
/* harmony export */   "NORMALIZE_STYLE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.NORMALIZE_STYLE),
/* harmony export */   "OPEN_BLOCK": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.OPEN_BLOCK),
/* harmony export */   "POP_SCOPE_ID": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.POP_SCOPE_ID),
/* harmony export */   "PUSH_SCOPE_ID": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.PUSH_SCOPE_ID),
/* harmony export */   "RENDER_LIST": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RENDER_LIST),
/* harmony export */   "RENDER_SLOT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RENDER_SLOT),
/* harmony export */   "RESOLVE_COMPONENT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_COMPONENT),
/* harmony export */   "RESOLVE_DIRECTIVE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_DIRECTIVE),
/* harmony export */   "RESOLVE_DYNAMIC_COMPONENT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_DYNAMIC_COMPONENT),
/* harmony export */   "RESOLVE_FILTER": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_FILTER),
/* harmony export */   "SET_BLOCK_TRACKING": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.SET_BLOCK_TRACKING),
/* harmony export */   "SUSPENSE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.SUSPENSE),
/* harmony export */   "TELEPORT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TELEPORT),
/* harmony export */   "TO_DISPLAY_STRING": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_DISPLAY_STRING),
/* harmony export */   "TO_HANDLERS": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_HANDLERS),
/* harmony export */   "TO_HANDLER_KEY": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_HANDLER_KEY),
/* harmony export */   "TRANSITION": () => (/* binding */ TRANSITION),
/* harmony export */   "TRANSITION_GROUP": () => (/* binding */ TRANSITION_GROUP),
/* harmony export */   "UNREF": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.UNREF),
/* harmony export */   "V_MODEL_CHECKBOX": () => (/* binding */ V_MODEL_CHECKBOX),
/* harmony export */   "V_MODEL_DYNAMIC": () => (/* binding */ V_MODEL_DYNAMIC),
/* harmony export */   "V_MODEL_RADIO": () => (/* binding */ V_MODEL_RADIO),
/* harmony export */   "V_MODEL_SELECT": () => (/* binding */ V_MODEL_SELECT),
/* harmony export */   "V_MODEL_TEXT": () => (/* binding */ V_MODEL_TEXT),
/* harmony export */   "V_ON_WITH_KEYS": () => (/* binding */ V_ON_WITH_KEYS),
/* harmony export */   "V_ON_WITH_MODIFIERS": () => (/* binding */ V_ON_WITH_MODIFIERS),
/* harmony export */   "V_SHOW": () => (/* binding */ V_SHOW),
/* harmony export */   "WITH_CTX": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_CTX),
/* harmony export */   "WITH_DIRECTIVES": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_DIRECTIVES),
/* harmony export */   "WITH_MEMO": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_MEMO),
/* harmony export */   "advancePositionWithClone": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.advancePositionWithClone),
/* harmony export */   "advancePositionWithMutation": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.advancePositionWithMutation),
/* harmony export */   "assert": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.assert),
/* harmony export */   "baseCompile": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseCompile),
/* harmony export */   "baseParse": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseParse),
/* harmony export */   "buildDirectiveArgs": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.buildDirectiveArgs),
/* harmony export */   "buildProps": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.buildProps),
/* harmony export */   "buildSlots": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.buildSlots),
/* harmony export */   "checkCompatEnabled": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.checkCompatEnabled),
/* harmony export */   "compile": () => (/* binding */ compile),
/* harmony export */   "createArrayExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createArrayExpression),
/* harmony export */   "createAssignmentExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createAssignmentExpression),
/* harmony export */   "createBlockStatement": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createBlockStatement),
/* harmony export */   "createCacheExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCacheExpression),
/* harmony export */   "createCallExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression),
/* harmony export */   "createCompilerError": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompilerError),
/* harmony export */   "createCompoundExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression),
/* harmony export */   "createConditionalExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createConditionalExpression),
/* harmony export */   "createDOMCompilerError": () => (/* binding */ createDOMCompilerError),
/* harmony export */   "createForLoopParams": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createForLoopParams),
/* harmony export */   "createFunctionExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createFunctionExpression),
/* harmony export */   "createIfStatement": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createIfStatement),
/* harmony export */   "createInterpolation": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createInterpolation),
/* harmony export */   "createObjectExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectExpression),
/* harmony export */   "createObjectProperty": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty),
/* harmony export */   "createReturnStatement": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createReturnStatement),
/* harmony export */   "createRoot": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createRoot),
/* harmony export */   "createSequenceExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSequenceExpression),
/* harmony export */   "createSimpleExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression),
/* harmony export */   "createStructuralDirectiveTransform": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createStructuralDirectiveTransform),
/* harmony export */   "createTemplateLiteral": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createTemplateLiteral),
/* harmony export */   "createTransformContext": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createTransformContext),
/* harmony export */   "createVNodeCall": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createVNodeCall),
/* harmony export */   "extractIdentifiers": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.extractIdentifiers),
/* harmony export */   "findDir": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findDir),
/* harmony export */   "findProp": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp),
/* harmony export */   "generate": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.generate),
/* harmony export */   "generateCodeFrame": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.generateCodeFrame),
/* harmony export */   "getBaseTransformPreset": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getBaseTransformPreset),
/* harmony export */   "getConstantType": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getConstantType),
/* harmony export */   "getInnerRange": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getInnerRange),
/* harmony export */   "getMemoedVNodeCall": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getMemoedVNodeCall),
/* harmony export */   "getVNodeBlockHelper": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getVNodeBlockHelper),
/* harmony export */   "getVNodeHelper": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getVNodeHelper),
/* harmony export */   "hasDynamicKeyVBind": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasDynamicKeyVBind),
/* harmony export */   "hasScopeRef": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasScopeRef),
/* harmony export */   "helperNameMap": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.helperNameMap),
/* harmony export */   "injectProp": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.injectProp),
/* harmony export */   "isBuiltInType": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isBuiltInType),
/* harmony export */   "isCoreComponent": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isCoreComponent),
/* harmony export */   "isFunctionType": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isFunctionType),
/* harmony export */   "isInDestructureAssignment": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isInDestructureAssignment),
/* harmony export */   "isMemberExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isMemberExpression),
/* harmony export */   "isMemberExpressionBrowser": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isMemberExpressionBrowser),
/* harmony export */   "isMemberExpressionNode": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isMemberExpressionNode),
/* harmony export */   "isReferencedIdentifier": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isReferencedIdentifier),
/* harmony export */   "isSimpleIdentifier": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isSimpleIdentifier),
/* harmony export */   "isSlotOutlet": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isSlotOutlet),
/* harmony export */   "isStaticArgOf": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticArgOf),
/* harmony export */   "isStaticExp": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp),
/* harmony export */   "isStaticProperty": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticProperty),
/* harmony export */   "isStaticPropertyKey": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticPropertyKey),
/* harmony export */   "isTemplateNode": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isTemplateNode),
/* harmony export */   "isText": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isText),
/* harmony export */   "isVSlot": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isVSlot),
/* harmony export */   "locStub": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.locStub),
/* harmony export */   "makeBlock": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.makeBlock),
/* harmony export */   "noopDirectiveTransform": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.noopDirectiveTransform),
/* harmony export */   "parse": () => (/* binding */ parse),
/* harmony export */   "parserOptions": () => (/* binding */ parserOptions),
/* harmony export */   "processExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processExpression),
/* harmony export */   "processFor": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processFor),
/* harmony export */   "processIf": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processIf),
/* harmony export */   "processSlotOutlet": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processSlotOutlet),
/* harmony export */   "registerRuntimeHelpers": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeHelpers),
/* harmony export */   "resolveComponentType": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.resolveComponentType),
/* harmony export */   "stringifyExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.stringifyExpression),
/* harmony export */   "toValidAssetId": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.toValidAssetId),
/* harmony export */   "trackSlotScopes": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.trackSlotScopes),
/* harmony export */   "trackVForSlotScopes": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.trackVForSlotScopes),
/* harmony export */   "transform": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transform),
/* harmony export */   "transformBind": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformBind),
/* harmony export */   "transformElement": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformElement),
/* harmony export */   "transformExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformExpression),
/* harmony export */   "transformModel": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformModel),
/* harmony export */   "transformOn": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformOn),
/* harmony export */   "transformStyle": () => (/* binding */ transformStyle),
/* harmony export */   "traverseNode": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.traverseNode),
/* harmony export */   "walkBlockDeclarations": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.walkBlockDeclarations),
/* harmony export */   "walkFunctionParams": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.walkFunctionParams),
/* harmony export */   "walkIdentifiers": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.walkIdentifiers),
/* harmony export */   "warnDeprecation": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.warnDeprecation)
/* harmony export */ });
/* harmony import */ var _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/compiler-core */ "./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");




const V_MODEL_RADIO = Symbol(( true) ? `vModelRadio` : 0);
const V_MODEL_CHECKBOX = Symbol(( true) ? `vModelCheckbox` : 0);
const V_MODEL_TEXT = Symbol(( true) ? `vModelText` : 0);
const V_MODEL_SELECT = Symbol(( true) ? `vModelSelect` : 0);
const V_MODEL_DYNAMIC = Symbol(( true) ? `vModelDynamic` : 0);
const V_ON_WITH_MODIFIERS = Symbol(( true) ? `vOnModifiersGuard` : 0);
const V_ON_WITH_KEYS = Symbol(( true) ? `vOnKeysGuard` : 0);
const V_SHOW = Symbol(( true) ? `vShow` : 0);
const TRANSITION = Symbol(( true) ? `Transition` : 0);
const TRANSITION_GROUP = Symbol(( true) ? `TransitionGroup` : 0);
(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeHelpers)({
    [V_MODEL_RADIO]: `vModelRadio`,
    [V_MODEL_CHECKBOX]: `vModelCheckbox`,
    [V_MODEL_TEXT]: `vModelText`,
    [V_MODEL_SELECT]: `vModelSelect`,
    [V_MODEL_DYNAMIC]: `vModelDynamic`,
    [V_ON_WITH_MODIFIERS]: `withModifiers`,
    [V_ON_WITH_KEYS]: `withKeys`,
    [V_SHOW]: `vShow`,
    [TRANSITION]: `Transition`,
    [TRANSITION_GROUP]: `TransitionGroup`
});

/* eslint-disable no-restricted-globals */
let decoder;
function decodeHtmlBrowser(raw, asAttr = false) {
    if (!decoder) {
        decoder = document.createElement('div');
    }
    if (asAttr) {
        decoder.innerHTML = `<div foo="${raw.replace(/"/g, '&quot;')}">`;
        return decoder.children[0].getAttribute('foo');
    }
    else {
        decoder.innerHTML = raw;
        return decoder.textContent;
    }
}

const isRawTextContainer = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('style,iframe,script,noscript', true);
const parserOptions = {
    isVoidTag: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isVoidTag,
    isNativeTag: tag => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isHTMLTag)(tag) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSVGTag)(tag),
    isPreTag: tag => tag === 'pre',
    decodeEntities: decodeHtmlBrowser ,
    isBuiltInComponent: (tag) => {
        if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isBuiltInType)(tag, `Transition`)) {
            return TRANSITION;
        }
        else if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isBuiltInType)(tag, `TransitionGroup`)) {
            return TRANSITION_GROUP;
        }
    },
    // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
    getNamespace(tag, parent) {
        let ns = parent ? parent.ns : 0 /* DOMNamespaces.HTML */;
        if (parent && ns === 2 /* DOMNamespaces.MATH_ML */) {
            if (parent.tag === 'annotation-xml') {
                if (tag === 'svg') {
                    return 1 /* DOMNamespaces.SVG */;
                }
                if (parent.props.some(a => a.type === 6 /* NodeTypes.ATTRIBUTE */ &&
                    a.name === 'encoding' &&
                    a.value != null &&
                    (a.value.content === 'text/html' ||
                        a.value.content === 'application/xhtml+xml'))) {
                    ns = 0 /* DOMNamespaces.HTML */;
                }
            }
            else if (/^m(?:[ions]|text)$/.test(parent.tag) &&
                tag !== 'mglyph' &&
                tag !== 'malignmark') {
                ns = 0 /* DOMNamespaces.HTML */;
            }
        }
        else if (parent && ns === 1 /* DOMNamespaces.SVG */) {
            if (parent.tag === 'foreignObject' ||
                parent.tag === 'desc' ||
                parent.tag === 'title') {
                ns = 0 /* DOMNamespaces.HTML */;
            }
        }
        if (ns === 0 /* DOMNamespaces.HTML */) {
            if (tag === 'svg') {
                return 1 /* DOMNamespaces.SVG */;
            }
            if (tag === 'math') {
                return 2 /* DOMNamespaces.MATH_ML */;
            }
        }
        return ns;
    },
    // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
    getTextMode({ tag, ns }) {
        if (ns === 0 /* DOMNamespaces.HTML */) {
            if (tag === 'textarea' || tag === 'title') {
                return 1 /* TextModes.RCDATA */;
            }
            if (isRawTextContainer(tag)) {
                return 2 /* TextModes.RAWTEXT */;
            }
        }
        return 0 /* TextModes.DATA */;
    }
};

// Parse inline CSS strings for static style attributes into an object.
// This is a NodeTransform since it works on the static `style` attribute and
// converts it into a dynamic equivalent:
// style="color: red" -> :style='{ "color": "red" }'
// It is then processed by `transformElement` and included in the generated
// props.
const transformStyle = node => {
    if (node.type === 1 /* NodeTypes.ELEMENT */) {
        node.props.forEach((p, i) => {
            if (p.type === 6 /* NodeTypes.ATTRIBUTE */ && p.name === 'style' && p.value) {
                // replace p with an expression node
                node.props[i] = {
                    type: 7 /* NodeTypes.DIRECTIVE */,
                    name: `bind`,
                    arg: (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(`style`, true, p.loc),
                    exp: parseInlineCSS(p.value.content, p.loc),
                    modifiers: [],
                    loc: p.loc
                };
            }
        });
    }
};
const parseInlineCSS = (cssText, loc) => {
    const normalized = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.parseStringStyle)(cssText);
    return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(JSON.stringify(normalized), false, loc, 3 /* ConstantTypes.CAN_STRINGIFY */);
};

function createDOMCompilerError(code, loc) {
    return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompilerError)(code, loc,  true ? DOMErrorMessages : 0);
}
const DOMErrorMessages = {
    [51 /* DOMErrorCodes.X_V_HTML_NO_EXPRESSION */]: `v-html is missing expression.`,
    [52 /* DOMErrorCodes.X_V_HTML_WITH_CHILDREN */]: `v-html will override element children.`,
    [53 /* DOMErrorCodes.X_V_TEXT_NO_EXPRESSION */]: `v-text is missing expression.`,
    [54 /* DOMErrorCodes.X_V_TEXT_WITH_CHILDREN */]: `v-text will override element children.`,
    [55 /* DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT */]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
    [56 /* DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT */]: `v-model argument is not supported on plain elements.`,
    [57 /* DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT */]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
    [58 /* DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE */]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
    [59 /* DOMErrorCodes.X_V_SHOW_NO_EXPRESSION */]: `v-show is missing expression.`,
    [60 /* DOMErrorCodes.X_TRANSITION_INVALID_CHILDREN */]: `<Transition> expects exactly one child element or component.`,
    [61 /* DOMErrorCodes.X_IGNORED_SIDE_EFFECT_TAG */]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
};

const transformVHtml = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
        context.onError(createDOMCompilerError(51 /* DOMErrorCodes.X_V_HTML_NO_EXPRESSION */, loc));
    }
    if (node.children.length) {
        context.onError(createDOMCompilerError(52 /* DOMErrorCodes.X_V_HTML_WITH_CHILDREN */, loc));
        node.children.length = 0;
    }
    return {
        props: [
            (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(`innerHTML`, true, loc), exp || (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)('', true))
        ]
    };
};

const transformVText = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
        context.onError(createDOMCompilerError(53 /* DOMErrorCodes.X_V_TEXT_NO_EXPRESSION */, loc));
    }
    if (node.children.length) {
        context.onError(createDOMCompilerError(54 /* DOMErrorCodes.X_V_TEXT_WITH_CHILDREN */, loc));
        node.children.length = 0;
    }
    return {
        props: [
            (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(`textContent`, true), exp
                ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getConstantType)(exp, context) > 0
                    ? exp
                    : (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(context.helperString(_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_DISPLAY_STRING), [exp], loc)
                : (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)('', true))
        ]
    };
};

const transformModel = (dir, node, context) => {
    const baseResult = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformModel)(dir, node, context);
    // base transform has errors OR component v-model (only need props)
    if (!baseResult.props.length || node.tagType === 1 /* ElementTypes.COMPONENT */) {
        return baseResult;
    }
    if (dir.arg) {
        context.onError(createDOMCompilerError(56 /* DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT */, dir.arg.loc));
    }
    function checkDuplicatedValue() {
        const value = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp)(node, 'value');
        if (value) {
            context.onError(createDOMCompilerError(58 /* DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE */, value.loc));
        }
    }
    const { tag } = node;
    const isCustomElement = context.isCustomElement(tag);
    if (tag === 'input' ||
        tag === 'textarea' ||
        tag === 'select' ||
        isCustomElement) {
        let directiveToUse = V_MODEL_TEXT;
        let isInvalidType = false;
        if (tag === 'input' || isCustomElement) {
            const type = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp)(node, `type`);
            if (type) {
                if (type.type === 7 /* NodeTypes.DIRECTIVE */) {
                    // :type="foo"
                    directiveToUse = V_MODEL_DYNAMIC;
                }
                else if (type.value) {
                    switch (type.value.content) {
                        case 'radio':
                            directiveToUse = V_MODEL_RADIO;
                            break;
                        case 'checkbox':
                            directiveToUse = V_MODEL_CHECKBOX;
                            break;
                        case 'file':
                            isInvalidType = true;
                            context.onError(createDOMCompilerError(57 /* DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT */, dir.loc));
                            break;
                        default:
                            // text type
                            ( true) && checkDuplicatedValue();
                            break;
                    }
                }
            }
            else if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasDynamicKeyVBind)(node)) {
                // element has bindings with dynamic keys, which can possibly contain
                // "type".
                directiveToUse = V_MODEL_DYNAMIC;
            }
            else {
                // text type
                ( true) && checkDuplicatedValue();
            }
        }
        else if (tag === 'select') {
            directiveToUse = V_MODEL_SELECT;
        }
        else {
            // textarea
            ( true) && checkDuplicatedValue();
        }
        // inject runtime directive
        // by returning the helper symbol via needRuntime
        // the import will replaced a resolveDirective call.
        if (!isInvalidType) {
            baseResult.needRuntime = context.helper(directiveToUse);
        }
    }
    else {
        context.onError(createDOMCompilerError(55 /* DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT */, dir.loc));
    }
    // native vmodel doesn't need the `modelValue` props since they are also
    // passed to the runtime as `binding.value`. removing it reduces code size.
    baseResult.props = baseResult.props.filter(p => !(p.key.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ &&
        p.key.content === 'modelValue'));
    return baseResult;
};

const isEventOptionModifier = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(`passive,once,capture`);
const isNonKeyModifier = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(
// event propagation management
`stop,prevent,self,` +
    // system modifiers + exact
    `ctrl,shift,alt,meta,exact,` +
    // mouse
    `middle`);
// left & right could be mouse or key modifiers based on event type
const maybeKeyModifier = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('left,right');
const isKeyboardEvent = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(`onkeyup,onkeydown,onkeypress`, true);
const resolveModifiers = (key, modifiers, context, loc) => {
    const keyModifiers = [];
    const nonKeyModifiers = [];
    const eventOptionModifiers = [];
    for (let i = 0; i < modifiers.length; i++) {
        const modifier = modifiers[i];
        if (modifier === 'native' &&
            (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.checkCompatEnabled)("COMPILER_V_ON_NATIVE" /* CompilerDeprecationTypes.COMPILER_V_ON_NATIVE */, context, loc)) {
            eventOptionModifiers.push(modifier);
        }
        else if (isEventOptionModifier(modifier)) {
            // eventOptionModifiers: modifiers for addEventListener() options,
            // e.g. .passive & .capture
            eventOptionModifiers.push(modifier);
        }
        else {
            // runtimeModifiers: modifiers that needs runtime guards
            if (maybeKeyModifier(modifier)) {
                if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key)) {
                    if (isKeyboardEvent(key.content)) {
                        keyModifiers.push(modifier);
                    }
                    else {
                        nonKeyModifiers.push(modifier);
                    }
                }
                else {
                    keyModifiers.push(modifier);
                    nonKeyModifiers.push(modifier);
                }
            }
            else {
                if (isNonKeyModifier(modifier)) {
                    nonKeyModifiers.push(modifier);
                }
                else {
                    keyModifiers.push(modifier);
                }
            }
        }
    }
    return {
        keyModifiers,
        nonKeyModifiers,
        eventOptionModifiers
    };
};
const transformClick = (key, event) => {
    const isStaticClick = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key) && key.content.toLowerCase() === 'onclick';
    return isStaticClick
        ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(event, true)
        : key.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */
            ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression)([
                `(`,
                key,
                `) === "onClick" ? "${event}" : (`,
                key,
                `)`
            ])
            : key;
};
const transformOn = (dir, node, context) => {
    return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformOn)(dir, node, context, baseResult => {
        const { modifiers } = dir;
        if (!modifiers.length)
            return baseResult;
        let { key, value: handlerExp } = baseResult.props[0];
        const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
        // normalize click.right and click.middle since they don't actually fire
        if (nonKeyModifiers.includes('right')) {
            key = transformClick(key, `onContextmenu`);
        }
        if (nonKeyModifiers.includes('middle')) {
            key = transformClick(key, `onMouseup`);
        }
        if (nonKeyModifiers.length) {
            handlerExp = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(context.helper(V_ON_WITH_MODIFIERS), [
                handlerExp,
                JSON.stringify(nonKeyModifiers)
            ]);
        }
        if (keyModifiers.length &&
            // if event name is dynamic, always wrap with keys guard
            (!(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key) || isKeyboardEvent(key.content))) {
            handlerExp = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(context.helper(V_ON_WITH_KEYS), [
                handlerExp,
                JSON.stringify(keyModifiers)
            ]);
        }
        if (eventOptionModifiers.length) {
            const modifierPostfix = eventOptionModifiers.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize).join('');
            key = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key)
                ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(`${key.content}${modifierPostfix}`, true)
                : (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression)([`(`, key, `) + "${modifierPostfix}"`]);
        }
        return {
            props: [(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)(key, handlerExp)]
        };
    });
};

const transformShow = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
        context.onError(createDOMCompilerError(59 /* DOMErrorCodes.X_V_SHOW_NO_EXPRESSION */, loc));
    }
    return {
        props: [],
        needRuntime: context.helper(V_SHOW)
    };
};

const transformTransition = (node, context) => {
    if (node.type === 1 /* NodeTypes.ELEMENT */ &&
        node.tagType === 1 /* ElementTypes.COMPONENT */) {
        const component = context.isBuiltInComponent(node.tag);
        if (component === TRANSITION) {
            return () => {
                if (!node.children.length) {
                    return;
                }
                // warn multiple transition children
                if (hasMultipleChildren(node)) {
                    context.onError(createDOMCompilerError(60 /* DOMErrorCodes.X_TRANSITION_INVALID_CHILDREN */, {
                        start: node.children[0].loc.start,
                        end: node.children[node.children.length - 1].loc.end,
                        source: ''
                    }));
                }
                // check if it's s single child w/ v-show
                // if yes, inject "persisted: true" to the transition props
                const child = node.children[0];
                if (child.type === 1 /* NodeTypes.ELEMENT */) {
                    for (const p of child.props) {
                        if (p.type === 7 /* NodeTypes.DIRECTIVE */ && p.name === 'show') {
                            node.props.push({
                                type: 6 /* NodeTypes.ATTRIBUTE */,
                                name: 'persisted',
                                value: undefined,
                                loc: node.loc
                            });
                        }
                    }
                }
            };
        }
    }
};
function hasMultipleChildren(node) {
    // #1352 filter out potential comment nodes.
    const children = (node.children = node.children.filter(c => c.type !== 3 /* NodeTypes.COMMENT */ &&
        !(c.type === 2 /* NodeTypes.TEXT */ && !c.content.trim())));
    const child = children[0];
    return (children.length !== 1 ||
        child.type === 11 /* NodeTypes.FOR */ ||
        (child.type === 9 /* NodeTypes.IF */ && child.branches.some(hasMultipleChildren)));
}

const ignoreSideEffectTags = (node, context) => {
    if (node.type === 1 /* NodeTypes.ELEMENT */ &&
        node.tagType === 0 /* ElementTypes.ELEMENT */ &&
        (node.tag === 'script' || node.tag === 'style')) {
        context.onError(createDOMCompilerError(61 /* DOMErrorCodes.X_IGNORED_SIDE_EFFECT_TAG */, node.loc));
        context.removeNode();
    }
};

const DOMNodeTransforms = [
    transformStyle,
    ...(( true) ? [transformTransition] : 0)
];
const DOMDirectiveTransforms = {
    cloak: _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.noopDirectiveTransform,
    html: transformVHtml,
    text: transformVText,
    model: transformModel,
    on: transformOn,
    show: transformShow
};
function compile(template, options = {}) {
    return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseCompile)(template, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, parserOptions, options, {
        nodeTransforms: [
            // ignore <script> and <tag>
            // this is not put inside DOMNodeTransforms because that list is used
            // by compiler-ssr to generate vnode fallback branches
            ignoreSideEffectTags,
            ...DOMNodeTransforms,
            ...(options.nodeTransforms || [])
        ],
        directiveTransforms: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, DOMDirectiveTransforms, options.directiveTransforms || {}),
        transformHoist: null 
    }));
}
function parse(template, options = {}) {
    return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseParse)(template, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, parserOptions, options));
}




/***/ }),

/***/ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EffectScope": () => (/* binding */ EffectScope),
/* harmony export */   "ITERATE_KEY": () => (/* binding */ ITERATE_KEY),
/* harmony export */   "ReactiveEffect": () => (/* binding */ ReactiveEffect),
/* harmony export */   "computed": () => (/* binding */ computed),
/* harmony export */   "customRef": () => (/* binding */ customRef),
/* harmony export */   "deferredComputed": () => (/* binding */ deferredComputed),
/* harmony export */   "effect": () => (/* binding */ effect),
/* harmony export */   "effectScope": () => (/* binding */ effectScope),
/* harmony export */   "enableTracking": () => (/* binding */ enableTracking),
/* harmony export */   "getCurrentScope": () => (/* binding */ getCurrentScope),
/* harmony export */   "isProxy": () => (/* binding */ isProxy),
/* harmony export */   "isReactive": () => (/* binding */ isReactive),
/* harmony export */   "isReadonly": () => (/* binding */ isReadonly),
/* harmony export */   "isRef": () => (/* binding */ isRef),
/* harmony export */   "isShallow": () => (/* binding */ isShallow),
/* harmony export */   "markRaw": () => (/* binding */ markRaw),
/* harmony export */   "onScopeDispose": () => (/* binding */ onScopeDispose),
/* harmony export */   "pauseTracking": () => (/* binding */ pauseTracking),
/* harmony export */   "proxyRefs": () => (/* binding */ proxyRefs),
/* harmony export */   "reactive": () => (/* binding */ reactive),
/* harmony export */   "readonly": () => (/* binding */ readonly),
/* harmony export */   "ref": () => (/* binding */ ref),
/* harmony export */   "resetTracking": () => (/* binding */ resetTracking),
/* harmony export */   "shallowReactive": () => (/* binding */ shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* binding */ shallowReadonly),
/* harmony export */   "shallowRef": () => (/* binding */ shallowRef),
/* harmony export */   "stop": () => (/* binding */ stop),
/* harmony export */   "toRaw": () => (/* binding */ toRaw),
/* harmony export */   "toRef": () => (/* binding */ toRef),
/* harmony export */   "toRefs": () => (/* binding */ toRefs),
/* harmony export */   "track": () => (/* binding */ track),
/* harmony export */   "trigger": () => (/* binding */ trigger),
/* harmony export */   "triggerRef": () => (/* binding */ triggerRef),
/* harmony export */   "unref": () => (/* binding */ unref)
/* harmony export */ });
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");


function warn(msg, ...args) {
    console.warn(`[Vue warn] ${msg}`, ...args);
}

let activeEffectScope;
class EffectScope {
    constructor(detached = false) {
        this.detached = detached;
        /**
         * @internal
         */
        this.active = true;
        /**
         * @internal
         */
        this.effects = [];
        /**
         * @internal
         */
        this.cleanups = [];
        this.parent = activeEffectScope;
        if (!detached && activeEffectScope) {
            this.index =
                (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
        }
    }
    run(fn) {
        if (this.active) {
            const currentEffectScope = activeEffectScope;
            try {
                activeEffectScope = this;
                return fn();
            }
            finally {
                activeEffectScope = currentEffectScope;
            }
        }
        else if ((true)) {
            warn(`cannot run an inactive effect scope.`);
        }
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    on() {
        activeEffectScope = this;
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    off() {
        activeEffectScope = this.parent;
    }
    stop(fromParent) {
        if (this.active) {
            let i, l;
            for (i = 0, l = this.effects.length; i < l; i++) {
                this.effects[i].stop();
            }
            for (i = 0, l = this.cleanups.length; i < l; i++) {
                this.cleanups[i]();
            }
            if (this.scopes) {
                for (i = 0, l = this.scopes.length; i < l; i++) {
                    this.scopes[i].stop(true);
                }
            }
            // nested scope, dereference from parent to avoid memory leaks
            if (!this.detached && this.parent && !fromParent) {
                // optimized O(1) removal
                const last = this.parent.scopes.pop();
                if (last && last !== this) {
                    this.parent.scopes[this.index] = last;
                    last.index = this.index;
                }
            }
            this.parent = undefined;
            this.active = false;
        }
    }
}
function effectScope(detached) {
    return new EffectScope(detached);
}
function recordEffectScope(effect, scope = activeEffectScope) {
    if (scope && scope.active) {
        scope.effects.push(effect);
    }
}
function getCurrentScope() {
    return activeEffectScope;
}
function onScopeDispose(fn) {
    if (activeEffectScope) {
        activeEffectScope.cleanups.push(fn);
    }
    else if ((true)) {
        warn(`onScopeDispose() is called when there is no active effect scope` +
            ` to be associated with.`);
    }
}

const createDep = (effects) => {
    const dep = new Set(effects);
    dep.w = 0;
    dep.n = 0;
    return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
    if (deps.length) {
        for (let i = 0; i < deps.length; i++) {
            deps[i].w |= trackOpBit; // set was tracked
        }
    }
};
const finalizeDepMarkers = (effect) => {
    const { deps } = effect;
    if (deps.length) {
        let ptr = 0;
        for (let i = 0; i < deps.length; i++) {
            const dep = deps[i];
            if (wasTracked(dep) && !newTracked(dep)) {
                dep.delete(effect);
            }
            else {
                deps[ptr++] = dep;
            }
            // clear bits
            dep.w &= ~trackOpBit;
            dep.n &= ~trackOpBit;
        }
        deps.length = ptr;
    }
};

const targetMap = new WeakMap();
// The number of effects currently being tracked recursively.
let effectTrackDepth = 0;
let trackOpBit = 1;
/**
 * The bitwise track markers support at most 30 levels of recursion.
 * This value is chosen to enable modern JS engines to use a SMI on all platforms.
 * When recursion depth is greater, fall back to using a full cleanup.
 */
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol(( true) ? 'iterate' : 0);
const MAP_KEY_ITERATE_KEY = Symbol(( true) ? 'Map key iterate' : 0);
class ReactiveEffect {
    constructor(fn, scheduler = null, scope) {
        this.fn = fn;
        this.scheduler = scheduler;
        this.active = true;
        this.deps = [];
        this.parent = undefined;
        recordEffectScope(this, scope);
    }
    run() {
        if (!this.active) {
            return this.fn();
        }
        let parent = activeEffect;
        let lastShouldTrack = shouldTrack;
        while (parent) {
            if (parent === this) {
                return;
            }
            parent = parent.parent;
        }
        try {
            this.parent = activeEffect;
            activeEffect = this;
            shouldTrack = true;
            trackOpBit = 1 << ++effectTrackDepth;
            if (effectTrackDepth <= maxMarkerBits) {
                initDepMarkers(this);
            }
            else {
                cleanupEffect(this);
            }
            return this.fn();
        }
        finally {
            if (effectTrackDepth <= maxMarkerBits) {
                finalizeDepMarkers(this);
            }
            trackOpBit = 1 << --effectTrackDepth;
            activeEffect = this.parent;
            shouldTrack = lastShouldTrack;
            this.parent = undefined;
            if (this.deferStop) {
                this.stop();
            }
        }
    }
    stop() {
        // stopped while running itself - defer the cleanup
        if (activeEffect === this) {
            this.deferStop = true;
        }
        else if (this.active) {
            cleanupEffect(this);
            if (this.onStop) {
                this.onStop();
            }
            this.active = false;
        }
    }
}
function cleanupEffect(effect) {
    const { deps } = effect;
    if (deps.length) {
        for (let i = 0; i < deps.length; i++) {
            deps[i].delete(effect);
        }
        deps.length = 0;
    }
}
function effect(fn, options) {
    if (fn.effect) {
        fn = fn.effect.fn;
    }
    const _effect = new ReactiveEffect(fn);
    if (options) {
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(_effect, options);
        if (options.scope)
            recordEffectScope(_effect, options.scope);
    }
    if (!options || !options.lazy) {
        _effect.run();
    }
    const runner = _effect.run.bind(_effect);
    runner.effect = _effect;
    return runner;
}
function stop(runner) {
    runner.effect.stop();
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
}
function enableTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = true;
}
function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === undefined ? true : last;
}
function track(target, type, key) {
    if (shouldTrack && activeEffect) {
        let depsMap = targetMap.get(target);
        if (!depsMap) {
            targetMap.set(target, (depsMap = new Map()));
        }
        let dep = depsMap.get(key);
        if (!dep) {
            depsMap.set(key, (dep = createDep()));
        }
        const eventInfo = ( true)
            ? { effect: activeEffect, target, type, key }
            : 0;
        trackEffects(dep, eventInfo);
    }
}
function trackEffects(dep, debuggerEventExtraInfo) {
    let shouldTrack = false;
    if (effectTrackDepth <= maxMarkerBits) {
        if (!newTracked(dep)) {
            dep.n |= trackOpBit; // set newly tracked
            shouldTrack = !wasTracked(dep);
        }
    }
    else {
        // Full cleanup mode.
        shouldTrack = !dep.has(activeEffect);
    }
    if (shouldTrack) {
        dep.add(activeEffect);
        activeEffect.deps.push(dep);
        if (( true) && activeEffect.onTrack) {
            activeEffect.onTrack(Object.assign({ effect: activeEffect }, debuggerEventExtraInfo));
        }
    }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
        // never been tracked
        return;
    }
    let deps = [];
    if (type === "clear" /* TriggerOpTypes.CLEAR */) {
        // collection being cleared
        // trigger all effects for target
        deps = [...depsMap.values()];
    }
    else if (key === 'length' && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
        const newLength = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toNumber)(newValue);
        depsMap.forEach((dep, key) => {
            if (key === 'length' || key >= newLength) {
                deps.push(dep);
            }
        });
    }
    else {
        // schedule runs for SET | ADD | DELETE
        if (key !== void 0) {
            deps.push(depsMap.get(key));
        }
        // also run for iteration key on ADD | DELETE | Map.SET
        switch (type) {
            case "add" /* TriggerOpTypes.ADD */:
                if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
                    deps.push(depsMap.get(ITERATE_KEY));
                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                    }
                }
                else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key)) {
                    // new index added to array -> length changes
                    deps.push(depsMap.get('length'));
                }
                break;
            case "delete" /* TriggerOpTypes.DELETE */:
                if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
                    deps.push(depsMap.get(ITERATE_KEY));
                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                    }
                }
                break;
            case "set" /* TriggerOpTypes.SET */:
                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
                    deps.push(depsMap.get(ITERATE_KEY));
                }
                break;
        }
    }
    const eventInfo = ( true)
        ? { target, type, key, newValue, oldValue, oldTarget }
        : 0;
    if (deps.length === 1) {
        if (deps[0]) {
            if ((true)) {
                triggerEffects(deps[0], eventInfo);
            }
            else {}
        }
    }
    else {
        const effects = [];
        for (const dep of deps) {
            if (dep) {
                effects.push(...dep);
            }
        }
        if ((true)) {
            triggerEffects(createDep(effects), eventInfo);
        }
        else {}
    }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
    // spread into array for stabilization
    const effects = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(dep) ? dep : [...dep];
    for (const effect of effects) {
        if (effect.computed) {
            triggerEffect(effect, debuggerEventExtraInfo);
        }
    }
    for (const effect of effects) {
        if (!effect.computed) {
            triggerEffect(effect, debuggerEventExtraInfo);
        }
    }
}
function triggerEffect(effect, debuggerEventExtraInfo) {
    if (effect !== activeEffect || effect.allowRecurse) {
        if (( true) && effect.onTrigger) {
            effect.onTrigger((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({ effect }, debuggerEventExtraInfo));
        }
        if (effect.scheduler) {
            effect.scheduler();
        }
        else {
            effect.run();
        }
    }
}

const isNonTrackableKeys = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.makeMap)(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
/*#__PURE__*/
Object.getOwnPropertyNames(Symbol)
    // ios10.x Object.getOwnPropertyNames(Symbol) can enumerate 'arguments' and 'caller'
    // but accessing them on Symbol leads to TypeError because Symbol is a strict mode
    // function
    .filter(key => key !== 'arguments' && key !== 'caller')
    .map(key => Symbol[key])
    .filter(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol));
const get = /*#__PURE__*/ createGetter();
const shallowGet = /*#__PURE__*/ createGetter(false, true);
const readonlyGet = /*#__PURE__*/ createGetter(true);
const shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);
const arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations();
function createArrayInstrumentations() {
    const instrumentations = {};
    ['includes', 'indexOf', 'lastIndexOf'].forEach(key => {
        instrumentations[key] = function (...args) {
            const arr = toRaw(this);
            for (let i = 0, l = this.length; i < l; i++) {
                track(arr, "get" /* TrackOpTypes.GET */, i + '');
            }
            // we run the method using the original args first (which may be reactive)
            const res = arr[key](...args);
            if (res === -1 || res === false) {
                // if that didn't work, run it again using raw values.
                return arr[key](...args.map(toRaw));
            }
            else {
                return res;
            }
        };
    });
    ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {
        instrumentations[key] = function (...args) {
            pauseTracking();
            const res = toRaw(this)[key].apply(this, args);
            resetTracking();
            return res;
        };
    });
    return instrumentations;
}
function createGetter(isReadonly = false, shallow = false) {
    return function get(target, key, receiver) {
        if (key === "__v_isReactive" /* ReactiveFlags.IS_REACTIVE */) {
            return !isReadonly;
        }
        else if (key === "__v_isReadonly" /* ReactiveFlags.IS_READONLY */) {
            return isReadonly;
        }
        else if (key === "__v_isShallow" /* ReactiveFlags.IS_SHALLOW */) {
            return shallow;
        }
        else if (key === "__v_raw" /* ReactiveFlags.RAW */ &&
            receiver ===
                (isReadonly
                    ? shallow
                        ? shallowReadonlyMap
                        : readonlyMap
                    : shallow
                        ? shallowReactiveMap
                        : reactiveMap).get(target)) {
            return target;
        }
        const targetIsArray = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target);
        if (!isReadonly && targetIsArray && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(arrayInstrumentations, key)) {
            return Reflect.get(arrayInstrumentations, key, receiver);
        }
        const res = Reflect.get(target, key, receiver);
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
            return res;
        }
        if (!isReadonly) {
            track(target, "get" /* TrackOpTypes.GET */, key);
        }
        if (shallow) {
            return res;
        }
        if (isRef(res)) {
            // ref unwrapping - skip unwrap for Array + integer key.
            return targetIsArray && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key) ? res : res.value;
        }
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(res)) {
            // Convert returned value into a proxy as well. we do the isObject check
            // here to avoid invalid value warning. Also need to lazy access readonly
            // and reactive here to avoid circular dependency.
            return isReadonly ? readonly(res) : reactive(res);
        }
        return res;
    };
}
const set = /*#__PURE__*/ createSetter();
const shallowSet = /*#__PURE__*/ createSetter(true);
function createSetter(shallow = false) {
    return function set(target, key, value, receiver) {
        let oldValue = target[key];
        if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
            return false;
        }
        if (!shallow) {
            if (!isShallow(value) && !isReadonly(value)) {
                oldValue = toRaw(oldValue);
                value = toRaw(value);
            }
            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) && isRef(oldValue) && !isRef(value)) {
                oldValue.value = value;
                return true;
            }
        }
        const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key)
            ? Number(key) < target.length
            : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);
        const result = Reflect.set(target, key, value, receiver);
        // don't trigger if target is something up in the prototype chain of original
        if (target === toRaw(receiver)) {
            if (!hadKey) {
                trigger(target, "add" /* TriggerOpTypes.ADD */, key, value);
            }
            else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {
                trigger(target, "set" /* TriggerOpTypes.SET */, key, value, oldValue);
            }
        }
        return result;
    };
}
function deleteProperty(target, key) {
    const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
        trigger(target, "delete" /* TriggerOpTypes.DELETE */, key, undefined, oldValue);
    }
    return result;
}
function has(target, key) {
    const result = Reflect.has(target, key);
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) || !builtInSymbols.has(key)) {
        track(target, "has" /* TrackOpTypes.HAS */, key);
    }
    return result;
}
function ownKeys(target) {
    track(target, "iterate" /* TrackOpTypes.ITERATE */, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) ? 'length' : ITERATE_KEY);
    return Reflect.ownKeys(target);
}
const mutableHandlers = {
    get,
    set,
    deleteProperty,
    has,
    ownKeys
};
const readonlyHandlers = {
    get: readonlyGet,
    set(target, key) {
        if ((true)) {
            warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
        }
        return true;
    },
    deleteProperty(target, key) {
        if ((true)) {
            warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
        }
        return true;
    }
};
const shallowReactiveHandlers = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, mutableHandlers, {
    get: shallowGet,
    set: shallowSet
});
// Props handlers are special in the sense that it should not unwrap top-level
// refs (in order to allow refs to be explicitly passed down), but should
// retain the reactivity of the normal readonly object.
const shallowReadonlyHandlers = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, readonlyHandlers, {
    get: shallowReadonlyGet
});

const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get$1(target, key, isReadonly = false, isShallow = false) {
    // #1772: readonly(reactive(Map)) should return readonly + reactive version
    // of the value
    target = target["__v_raw" /* ReactiveFlags.RAW */];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly) {
        if (key !== rawKey) {
            track(rawTarget, "get" /* TrackOpTypes.GET */, key);
        }
        track(rawTarget, "get" /* TrackOpTypes.GET */, rawKey);
    }
    const { has } = getProto(rawTarget);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    if (has.call(rawTarget, key)) {
        return wrap(target.get(key));
    }
    else if (has.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
    }
    else if (target !== rawTarget) {
        // #3602 readonly(reactive(Map))
        // ensure that the nested reactive `Map` can do tracking for itself
        target.get(key);
    }
}
function has$1(key, isReadonly = false) {
    const target = this["__v_raw" /* ReactiveFlags.RAW */];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly) {
        if (key !== rawKey) {
            track(rawTarget, "has" /* TrackOpTypes.HAS */, key);
        }
        track(rawTarget, "has" /* TrackOpTypes.HAS */, rawKey);
    }
    return key === rawKey
        ? target.has(key)
        : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly = false) {
    target = target["__v_raw" /* ReactiveFlags.RAW */];
    !isReadonly && track(toRaw(target), "iterate" /* TrackOpTypes.ITERATE */, ITERATE_KEY);
    return Reflect.get(target, 'size', target);
}
function add(value) {
    value = toRaw(value);
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
        target.add(value);
        trigger(target, "add" /* TriggerOpTypes.ADD */, value, value);
    }
    return this;
}
function set$1(key, value) {
    value = toRaw(value);
    const target = toRaw(this);
    const { has, get } = getProto(target);
    let hadKey = has.call(target, key);
    if (!hadKey) {
        key = toRaw(key);
        hadKey = has.call(target, key);
    }
    else if ((true)) {
        checkIdentityKeys(target, has, key);
    }
    const oldValue = get.call(target, key);
    target.set(key, value);
    if (!hadKey) {
        trigger(target, "add" /* TriggerOpTypes.ADD */, key, value);
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {
        trigger(target, "set" /* TriggerOpTypes.SET */, key, value, oldValue);
    }
    return this;
}
function deleteEntry(key) {
    const target = toRaw(this);
    const { has, get } = getProto(target);
    let hadKey = has.call(target, key);
    if (!hadKey) {
        key = toRaw(key);
        hadKey = has.call(target, key);
    }
    else if ((true)) {
        checkIdentityKeys(target, has, key);
    }
    const oldValue = get ? get.call(target, key) : undefined;
    // forward the operation before queueing reactions
    const result = target.delete(key);
    if (hadKey) {
        trigger(target, "delete" /* TriggerOpTypes.DELETE */, key, undefined, oldValue);
    }
    return result;
}
function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const oldTarget = ( true)
        ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)
            ? new Map(target)
            : new Set(target)
        : 0;
    // forward the operation before queueing reactions
    const result = target.clear();
    if (hadItems) {
        trigger(target, "clear" /* TriggerOpTypes.CLEAR */, undefined, undefined, oldTarget);
    }
    return result;
}
function createForEach(isReadonly, isShallow) {
    return function forEach(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw" /* ReactiveFlags.RAW */];
        const rawTarget = toRaw(target);
        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
        !isReadonly && track(rawTarget, "iterate" /* TrackOpTypes.ITERATE */, ITERATE_KEY);
        return target.forEach((value, key) => {
            // important: make sure the callback is
            // 1. invoked with the reactive map as `this` and 3rd arg
            // 2. the value received should be a corresponding reactive/readonly.
            return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
    };
}
function createIterableMethod(method, isReadonly, isShallow) {
    return function (...args) {
        const target = this["__v_raw" /* ReactiveFlags.RAW */];
        const rawTarget = toRaw(target);
        const targetIsMap = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(rawTarget);
        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);
        const isKeyOnly = method === 'keys' && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
        !isReadonly &&
            track(rawTarget, "iterate" /* TrackOpTypes.ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
        // return a wrapped iterator which returns observed versions of the
        // values emitted from the real iterator
        return {
            // iterator protocol
            next() {
                const { value, done } = innerIterator.next();
                return done
                    ? { value, done }
                    : {
                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
                        done
                    };
            },
            // iterable protocol
            [Symbol.iterator]() {
                return this;
            }
        };
    };
}
function createReadonlyMethod(type) {
    return function (...args) {
        if ((true)) {
            const key = args[0] ? `on key "${args[0]}" ` : ``;
            console.warn(`${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.capitalize)(type)} operation ${key}failed: target is readonly.`, toRaw(this));
        }
        return type === "delete" /* TriggerOpTypes.DELETE */ ? false : this;
    };
}
function createInstrumentations() {
    const mutableInstrumentations = {
        get(key) {
            return get$1(this, key);
        },
        get size() {
            return size(this);
        },
        has: has$1,
        add,
        set: set$1,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, false)
    };
    const shallowInstrumentations = {
        get(key) {
            return get$1(this, key, false, true);
        },
        get size() {
            return size(this);
        },
        has: has$1,
        add,
        set: set$1,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, true)
    };
    const readonlyInstrumentations = {
        get(key) {
            return get$1(this, key, true);
        },
        get size() {
            return size(this, true);
        },
        has(key) {
            return has$1.call(this, key, true);
        },
        add: createReadonlyMethod("add" /* TriggerOpTypes.ADD */),
        set: createReadonlyMethod("set" /* TriggerOpTypes.SET */),
        delete: createReadonlyMethod("delete" /* TriggerOpTypes.DELETE */),
        clear: createReadonlyMethod("clear" /* TriggerOpTypes.CLEAR */),
        forEach: createForEach(true, false)
    };
    const shallowReadonlyInstrumentations = {
        get(key) {
            return get$1(this, key, true, true);
        },
        get size() {
            return size(this, true);
        },
        has(key) {
            return has$1.call(this, key, true);
        },
        add: createReadonlyMethod("add" /* TriggerOpTypes.ADD */),
        set: createReadonlyMethod("set" /* TriggerOpTypes.SET */),
        delete: createReadonlyMethod("delete" /* TriggerOpTypes.DELETE */),
        clear: createReadonlyMethod("clear" /* TriggerOpTypes.CLEAR */),
        forEach: createForEach(true, true)
    };
    const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];
    iteratorMethods.forEach(method => {
        mutableInstrumentations[method] = createIterableMethod(method, false, false);
        readonlyInstrumentations[method] = createIterableMethod(method, true, false);
        shallowInstrumentations[method] = createIterableMethod(method, false, true);
        shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);
    });
    return [
        mutableInstrumentations,
        readonlyInstrumentations,
        shallowInstrumentations,
        shallowReadonlyInstrumentations
    ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* #__PURE__*/ createInstrumentations();
function createInstrumentationGetter(isReadonly, shallow) {
    const instrumentations = shallow
        ? isReadonly
            ? shallowReadonlyInstrumentations
            : shallowInstrumentations
        : isReadonly
            ? readonlyInstrumentations
            : mutableInstrumentations;
    return (target, key, receiver) => {
        if (key === "__v_isReactive" /* ReactiveFlags.IS_REACTIVE */) {
            return !isReadonly;
        }
        else if (key === "__v_isReadonly" /* ReactiveFlags.IS_READONLY */) {
            return isReadonly;
        }
        else if (key === "__v_raw" /* ReactiveFlags.RAW */) {
            return target;
        }
        return Reflect.get((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(instrumentations, key) && key in target
            ? instrumentations
            : target, key, receiver);
    };
}
const mutableCollectionHandlers = {
    get: /*#__PURE__*/ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
    get: /*#__PURE__*/ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
    get: /*#__PURE__*/ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
    get: /*#__PURE__*/ createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has, key) {
    const rawKey = toRaw(key);
    if (rawKey !== key && has.call(target, rawKey)) {
        const type = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(target);
        console.warn(`Reactive ${type} contains both the raw and reactive ` +
            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +
            `which can lead to inconsistencies. ` +
            `Avoid differentiating between the raw and reactive versions ` +
            `of an object and only use the reactive version if possible.`);
    }
}

const reactiveMap = new WeakMap();
const shallowReactiveMap = new WeakMap();
const readonlyMap = new WeakMap();
const shallowReadonlyMap = new WeakMap();
function targetTypeMap(rawType) {
    switch (rawType) {
        case 'Object':
        case 'Array':
            return 1 /* TargetType.COMMON */;
        case 'Map':
        case 'Set':
        case 'WeakMap':
        case 'WeakSet':
            return 2 /* TargetType.COLLECTION */;
        default:
            return 0 /* TargetType.INVALID */;
    }
}
function getTargetType(value) {
    return value["__v_skip" /* ReactiveFlags.SKIP */] || !Object.isExtensible(value)
        ? 0 /* TargetType.INVALID */
        : targetTypeMap((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(value));
}
function reactive(target) {
    // if trying to observe a readonly proxy, return the readonly version.
    if (isReadonly(target)) {
        return target;
    }
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
/**
 * Return a shallowly-reactive copy of the original object, where only the root
 * level properties are reactive. It also does not auto-unwrap refs (even at the
 * root level).
 */
function shallowReactive(target) {
    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
/**
 * Creates a readonly copy of the original object. Note the returned copy is not
 * made reactive, but `readonly` can be called on an already reactive object.
 */
function readonly(target) {
    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
/**
 * Returns a reactive-copy of the original object, where only the root level
 * properties are readonly, and does NOT unwrap refs nor recursively convert
 * returned properties.
 * This is used for creating the props proxy object for stateful components.
 */
function shallowReadonly(target) {
    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}
function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(target)) {
        if ((true)) {
            console.warn(`value cannot be made reactive: ${String(target)}`);
        }
        return target;
    }
    // target is already a Proxy, return it.
    // exception: calling readonly() on a reactive object
    if (target["__v_raw" /* ReactiveFlags.RAW */] &&
        !(isReadonly && target["__v_isReactive" /* ReactiveFlags.IS_REACTIVE */])) {
        return target;
    }
    // target already has corresponding Proxy
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
        return existingProxy;
    }
    // only specific value types can be observed.
    const targetType = getTargetType(target);
    if (targetType === 0 /* TargetType.INVALID */) {
        return target;
    }
    const proxy = new Proxy(target, targetType === 2 /* TargetType.COLLECTION */ ? collectionHandlers : baseHandlers);
    proxyMap.set(target, proxy);
    return proxy;
}
function isReactive(value) {
    if (isReadonly(value)) {
        return isReactive(value["__v_raw" /* ReactiveFlags.RAW */]);
    }
    return !!(value && value["__v_isReactive" /* ReactiveFlags.IS_REACTIVE */]);
}
function isReadonly(value) {
    return !!(value && value["__v_isReadonly" /* ReactiveFlags.IS_READONLY */]);
}
function isShallow(value) {
    return !!(value && value["__v_isShallow" /* ReactiveFlags.IS_SHALLOW */]);
}
function isProxy(value) {
    return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
    const raw = observed && observed["__v_raw" /* ReactiveFlags.RAW */];
    return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.def)(value, "__v_skip" /* ReactiveFlags.SKIP */, true);
    return value;
}
const toReactive = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? reactive(value) : value;
const toReadonly = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? readonly(value) : value;

function trackRefValue(ref) {
    if (shouldTrack && activeEffect) {
        ref = toRaw(ref);
        if ((true)) {
            trackEffects(ref.dep || (ref.dep = createDep()), {
                target: ref,
                type: "get" /* TrackOpTypes.GET */,
                key: 'value'
            });
        }
        else {}
    }
}
function triggerRefValue(ref, newVal) {
    ref = toRaw(ref);
    if (ref.dep) {
        if ((true)) {
            triggerEffects(ref.dep, {
                target: ref,
                type: "set" /* TriggerOpTypes.SET */,
                key: 'value',
                newValue: newVal
            });
        }
        else {}
    }
}
function isRef(r) {
    return !!(r && r.__v_isRef === true);
}
function ref(value) {
    return createRef(value, false);
}
function shallowRef(value) {
    return createRef(value, true);
}
function createRef(rawValue, shallow) {
    if (isRef(rawValue)) {
        return rawValue;
    }
    return new RefImpl(rawValue, shallow);
}
class RefImpl {
    constructor(value, __v_isShallow) {
        this.__v_isShallow = __v_isShallow;
        this.dep = undefined;
        this.__v_isRef = true;
        this._rawValue = __v_isShallow ? value : toRaw(value);
        this._value = __v_isShallow ? value : toReactive(value);
    }
    get value() {
        trackRefValue(this);
        return this._value;
    }
    set value(newVal) {
        const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
        newVal = useDirectValue ? newVal : toRaw(newVal);
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(newVal, this._rawValue)) {
            this._rawValue = newVal;
            this._value = useDirectValue ? newVal : toReactive(newVal);
            triggerRefValue(this, newVal);
        }
    }
}
function triggerRef(ref) {
    triggerRefValue(ref, ( true) ? ref.value : 0);
}
function unref(ref) {
    return isRef(ref) ? ref.value : ref;
}
const shallowUnwrapHandlers = {
    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
    set: (target, key, value, receiver) => {
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
            oldValue.value = value;
            return true;
        }
        else {
            return Reflect.set(target, key, value, receiver);
        }
    }
};
function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs)
        ? objectWithRefs
        : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
    constructor(factory) {
        this.dep = undefined;
        this.__v_isRef = true;
        const { get, set } = factory(() => trackRefValue(this), () => triggerRefValue(this));
        this._get = get;
        this._set = set;
    }
    get value() {
        return this._get();
    }
    set value(newVal) {
        this._set(newVal);
    }
}
function customRef(factory) {
    return new CustomRefImpl(factory);
}
function toRefs(object) {
    if (( true) && !isProxy(object)) {
        console.warn(`toRefs() expects a reactive object but received a plain one.`);
    }
    const ret = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(object) ? new Array(object.length) : {};
    for (const key in object) {
        ret[key] = toRef(object, key);
    }
    return ret;
}
class ObjectRefImpl {
    constructor(_object, _key, _defaultValue) {
        this._object = _object;
        this._key = _key;
        this._defaultValue = _defaultValue;
        this.__v_isRef = true;
    }
    get value() {
        const val = this._object[this._key];
        return val === undefined ? this._defaultValue : val;
    }
    set value(newVal) {
        this._object[this._key] = newVal;
    }
}
function toRef(object, key, defaultValue) {
    const val = object[key];
    return isRef(val)
        ? val
        : new ObjectRefImpl(object, key, defaultValue);
}

var _a;
class ComputedRefImpl {
    constructor(getter, _setter, isReadonly, isSSR) {
        this._setter = _setter;
        this.dep = undefined;
        this.__v_isRef = true;
        this[_a] = false;
        this._dirty = true;
        this.effect = new ReactiveEffect(getter, () => {
            if (!this._dirty) {
                this._dirty = true;
                triggerRefValue(this);
            }
        });
        this.effect.computed = this;
        this.effect.active = this._cacheable = !isSSR;
        this["__v_isReadonly" /* ReactiveFlags.IS_READONLY */] = isReadonly;
    }
    get value() {
        // the computed ref may get wrapped by other proxies e.g. readonly() #3376
        const self = toRaw(this);
        trackRefValue(self);
        if (self._dirty || !self._cacheable) {
            self._dirty = false;
            self._value = self.effect.run();
        }
        return self._value;
    }
    set value(newValue) {
        this._setter(newValue);
    }
}
_a = "__v_isReadonly" /* ReactiveFlags.IS_READONLY */;
function computed(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    const onlyGetter = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(getterOrOptions);
    if (onlyGetter) {
        getter = getterOrOptions;
        setter = ( true)
            ? () => {
                console.warn('Write operation failed: computed value is readonly');
            }
            : 0;
    }
    else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
    if (( true) && debugOptions && !isSSR) {
        cRef.effect.onTrack = debugOptions.onTrack;
        cRef.effect.onTrigger = debugOptions.onTrigger;
    }
    return cRef;
}

var _a$1;
const tick = /*#__PURE__*/ Promise.resolve();
const queue = [];
let queued = false;
const scheduler = (fn) => {
    queue.push(fn);
    if (!queued) {
        queued = true;
        tick.then(flush);
    }
};
const flush = () => {
    for (let i = 0; i < queue.length; i++) {
        queue[i]();
    }
    queue.length = 0;
    queued = false;
};
class DeferredComputedRefImpl {
    constructor(getter) {
        this.dep = undefined;
        this._dirty = true;
        this.__v_isRef = true;
        this[_a$1] = true;
        let compareTarget;
        let hasCompareTarget = false;
        let scheduled = false;
        this.effect = new ReactiveEffect(getter, (computedTrigger) => {
            if (this.dep) {
                if (computedTrigger) {
                    compareTarget = this._value;
                    hasCompareTarget = true;
                }
                else if (!scheduled) {
                    const valueToCompare = hasCompareTarget ? compareTarget : this._value;
                    scheduled = true;
                    hasCompareTarget = false;
                    scheduler(() => {
                        if (this.effect.active && this._get() !== valueToCompare) {
                            triggerRefValue(this);
                        }
                        scheduled = false;
                    });
                }
                // chained upstream computeds are notified synchronously to ensure
                // value invalidation in case of sync access; normal effects are
                // deferred to be triggered in scheduler.
                for (const e of this.dep) {
                    if (e.computed instanceof DeferredComputedRefImpl) {
                        e.scheduler(true /* computedTrigger */);
                    }
                }
            }
            this._dirty = true;
        });
        this.effect.computed = this;
    }
    _get() {
        if (this._dirty) {
            this._dirty = false;
            return (this._value = this.effect.run());
        }
        return this._value;
    }
    get value() {
        trackRefValue(this);
        // the computed ref may get wrapped by other proxies e.g. readonly() #3376
        return toRaw(this)._get();
    }
}
_a$1 = "__v_isReadonly" /* ReactiveFlags.IS_READONLY */;
function deferredComputed(getter) {
    return new DeferredComputedRefImpl(getter);
}




/***/ }),

/***/ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseTransition": () => (/* binding */ BaseTransition),
/* harmony export */   "Comment": () => (/* binding */ Comment),
/* harmony export */   "EffectScope": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.EffectScope),
/* harmony export */   "Fragment": () => (/* binding */ Fragment),
/* harmony export */   "KeepAlive": () => (/* binding */ KeepAlive),
/* harmony export */   "ReactiveEffect": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect),
/* harmony export */   "Static": () => (/* binding */ Static),
/* harmony export */   "Suspense": () => (/* binding */ Suspense),
/* harmony export */   "Teleport": () => (/* binding */ Teleport),
/* harmony export */   "Text": () => (/* binding */ Text),
/* harmony export */   "callWithAsyncErrorHandling": () => (/* binding */ callWithAsyncErrorHandling),
/* harmony export */   "callWithErrorHandling": () => (/* binding */ callWithErrorHandling),
/* harmony export */   "camelize": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize),
/* harmony export */   "capitalize": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize),
/* harmony export */   "cloneVNode": () => (/* binding */ cloneVNode),
/* harmony export */   "compatUtils": () => (/* binding */ compatUtils),
/* harmony export */   "computed": () => (/* binding */ computed),
/* harmony export */   "createBlock": () => (/* binding */ createBlock),
/* harmony export */   "createCommentVNode": () => (/* binding */ createCommentVNode),
/* harmony export */   "createElementBlock": () => (/* binding */ createElementBlock),
/* harmony export */   "createElementVNode": () => (/* binding */ createBaseVNode),
/* harmony export */   "createHydrationRenderer": () => (/* binding */ createHydrationRenderer),
/* harmony export */   "createPropsRestProxy": () => (/* binding */ createPropsRestProxy),
/* harmony export */   "createRenderer": () => (/* binding */ createRenderer),
/* harmony export */   "createSlots": () => (/* binding */ createSlots),
/* harmony export */   "createStaticVNode": () => (/* binding */ createStaticVNode),
/* harmony export */   "createTextVNode": () => (/* binding */ createTextVNode),
/* harmony export */   "createVNode": () => (/* binding */ createVNode),
/* harmony export */   "customRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   "defineAsyncComponent": () => (/* binding */ defineAsyncComponent),
/* harmony export */   "defineComponent": () => (/* binding */ defineComponent),
/* harmony export */   "defineEmits": () => (/* binding */ defineEmits),
/* harmony export */   "defineExpose": () => (/* binding */ defineExpose),
/* harmony export */   "defineProps": () => (/* binding */ defineProps),
/* harmony export */   "devtools": () => (/* binding */ devtools),
/* harmony export */   "effect": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effect),
/* harmony export */   "effectScope": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effectScope),
/* harmony export */   "getCurrentInstance": () => (/* binding */ getCurrentInstance),
/* harmony export */   "getCurrentScope": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope),
/* harmony export */   "getTransitionRawChildren": () => (/* binding */ getTransitionRawChildren),
/* harmony export */   "guardReactiveProps": () => (/* binding */ guardReactiveProps),
/* harmony export */   "h": () => (/* binding */ h),
/* harmony export */   "handleError": () => (/* binding */ handleError),
/* harmony export */   "initCustomFormatter": () => (/* binding */ initCustomFormatter),
/* harmony export */   "inject": () => (/* binding */ inject),
/* harmony export */   "isMemoSame": () => (/* binding */ isMemoSame),
/* harmony export */   "isProxy": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   "isReactive": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   "isReadonly": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   "isRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   "isRuntimeOnly": () => (/* binding */ isRuntimeOnly),
/* harmony export */   "isShallow": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow),
/* harmony export */   "isVNode": () => (/* binding */ isVNode),
/* harmony export */   "markRaw": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   "mergeDefaults": () => (/* binding */ mergeDefaults),
/* harmony export */   "mergeProps": () => (/* binding */ mergeProps),
/* harmony export */   "nextTick": () => (/* binding */ nextTick),
/* harmony export */   "normalizeClass": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass),
/* harmony export */   "normalizeProps": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeProps),
/* harmony export */   "normalizeStyle": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle),
/* harmony export */   "onActivated": () => (/* binding */ onActivated),
/* harmony export */   "onBeforeMount": () => (/* binding */ onBeforeMount),
/* harmony export */   "onBeforeUnmount": () => (/* binding */ onBeforeUnmount),
/* harmony export */   "onBeforeUpdate": () => (/* binding */ onBeforeUpdate),
/* harmony export */   "onDeactivated": () => (/* binding */ onDeactivated),
/* harmony export */   "onErrorCaptured": () => (/* binding */ onErrorCaptured),
/* harmony export */   "onMounted": () => (/* binding */ onMounted),
/* harmony export */   "onRenderTracked": () => (/* binding */ onRenderTracked),
/* harmony export */   "onRenderTriggered": () => (/* binding */ onRenderTriggered),
/* harmony export */   "onScopeDispose": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose),
/* harmony export */   "onServerPrefetch": () => (/* binding */ onServerPrefetch),
/* harmony export */   "onUnmounted": () => (/* binding */ onUnmounted),
/* harmony export */   "onUpdated": () => (/* binding */ onUpdated),
/* harmony export */   "openBlock": () => (/* binding */ openBlock),
/* harmony export */   "popScopeId": () => (/* binding */ popScopeId),
/* harmony export */   "provide": () => (/* binding */ provide),
/* harmony export */   "proxyRefs": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   "pushScopeId": () => (/* binding */ pushScopeId),
/* harmony export */   "queuePostFlushCb": () => (/* binding */ queuePostFlushCb),
/* harmony export */   "reactive": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   "readonly": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   "ref": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   "registerRuntimeCompiler": () => (/* binding */ registerRuntimeCompiler),
/* harmony export */   "renderList": () => (/* binding */ renderList),
/* harmony export */   "renderSlot": () => (/* binding */ renderSlot),
/* harmony export */   "resolveComponent": () => (/* binding */ resolveComponent),
/* harmony export */   "resolveDirective": () => (/* binding */ resolveDirective),
/* harmony export */   "resolveDynamicComponent": () => (/* binding */ resolveDynamicComponent),
/* harmony export */   "resolveFilter": () => (/* binding */ resolveFilter),
/* harmony export */   "resolveTransitionHooks": () => (/* binding */ resolveTransitionHooks),
/* harmony export */   "setBlockTracking": () => (/* binding */ setBlockTracking),
/* harmony export */   "setDevtoolsHook": () => (/* binding */ setDevtoolsHook),
/* harmony export */   "setTransitionHooks": () => (/* binding */ setTransitionHooks),
/* harmony export */   "shallowReactive": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   "shallowRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   "ssrContextKey": () => (/* binding */ ssrContextKey),
/* harmony export */   "ssrUtils": () => (/* binding */ ssrUtils),
/* harmony export */   "stop": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.stop),
/* harmony export */   "toDisplayString": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey),
/* harmony export */   "toHandlers": () => (/* binding */ toHandlers),
/* harmony export */   "toRaw": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   "toRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   "toRefs": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   "transformVNodeArgs": () => (/* binding */ transformVNodeArgs),
/* harmony export */   "triggerRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   "unref": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   "useAttrs": () => (/* binding */ useAttrs),
/* harmony export */   "useSSRContext": () => (/* binding */ useSSRContext),
/* harmony export */   "useSlots": () => (/* binding */ useSlots),
/* harmony export */   "useTransitionState": () => (/* binding */ useTransitionState),
/* harmony export */   "version": () => (/* binding */ version),
/* harmony export */   "warn": () => (/* binding */ warn),
/* harmony export */   "watch": () => (/* binding */ watch),
/* harmony export */   "watchEffect": () => (/* binding */ watchEffect),
/* harmony export */   "watchPostEffect": () => (/* binding */ watchPostEffect),
/* harmony export */   "watchSyncEffect": () => (/* binding */ watchSyncEffect),
/* harmony export */   "withAsyncContext": () => (/* binding */ withAsyncContext),
/* harmony export */   "withCtx": () => (/* binding */ withCtx),
/* harmony export */   "withDefaults": () => (/* binding */ withDefaults),
/* harmony export */   "withDirectives": () => (/* binding */ withDirectives),
/* harmony export */   "withMemo": () => (/* binding */ withMemo),
/* harmony export */   "withScopeId": () => (/* binding */ withScopeId)
/* harmony export */ });
/* harmony import */ var _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/reactivity */ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");





const stack = [];
function pushWarningContext(vnode) {
    stack.push(vnode);
}
function popWarningContext() {
    stack.pop();
}
function warn(msg, ...args) {
    if (false)
        {}
    // avoid props formatting or warn handler tracking deps that might be mutated
    // during patch, leading to infinite recursion.
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) {
        callWithErrorHandling(appWarnHandler, instance, 11 /* ErrorCodes.APP_WARN_HANDLER */, [
            msg + args.join(''),
            instance && instance.proxy,
            trace
                .map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`)
                .join('\n'),
            trace
        ]);
    }
    else {
        const warnArgs = [`[Vue warn]: ${msg}`, ...args];
        /* istanbul ignore if */
        if (trace.length &&
            // avoid spamming console during tests
            !false) {
            warnArgs.push(`\n`, ...formatTrace(trace));
        }
        console.warn(...warnArgs);
    }
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
}
function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) {
        return [];
    }
    // we can't just use the stack because it will be incomplete during updates
    // that did not start from the root. Re-construct the parent chain using
    // instance parent pointers.
    const normalizedStack = [];
    while (currentVNode) {
        const last = normalizedStack[0];
        if (last && last.vnode === currentVNode) {
            last.recurseCount++;
        }
        else {
            normalizedStack.push({
                vnode: currentVNode,
                recurseCount: 0
            });
        }
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
}
/* istanbul ignore next */
function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i) => {
        logs.push(...(i === 0 ? [] : [`\n`]), ...formatTraceEntry(entry));
    });
    return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
    const close = `>` + postfix;
    return vnode.props
        ? [open, ...formatProps(vnode.props), close]
        : [open + close];
}
/* istanbul ignore next */
function formatProps(props) {
    const res = [];
    const keys = Object.keys(props);
    keys.slice(0, 3).forEach(key => {
        res.push(...formatProp(key, props[key]));
    });
    if (keys.length > 3) {
        res.push(` ...`);
    }
    return res;
}
/* istanbul ignore next */
function formatProp(key, value, raw) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {
        value = JSON.stringify(value);
        return raw ? value : [`${key}=${value}`];
    }
    else if (typeof value === 'number' ||
        typeof value === 'boolean' ||
        value == null) {
        return raw ? value : [`${key}=${value}`];
    }
    else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(value)) {
        value = formatProp(key, (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(value.value), true);
        return raw ? value : [`${key}=Ref<`, value, `>`];
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
    }
    else {
        value = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(value);
        return raw ? value : [`${key}=`, value];
    }
}

const ErrorTypeStrings = {
    ["sp" /* LifecycleHooks.SERVER_PREFETCH */]: 'serverPrefetch hook',
    ["bc" /* LifecycleHooks.BEFORE_CREATE */]: 'beforeCreate hook',
    ["c" /* LifecycleHooks.CREATED */]: 'created hook',
    ["bm" /* LifecycleHooks.BEFORE_MOUNT */]: 'beforeMount hook',
    ["m" /* LifecycleHooks.MOUNTED */]: 'mounted hook',
    ["bu" /* LifecycleHooks.BEFORE_UPDATE */]: 'beforeUpdate hook',
    ["u" /* LifecycleHooks.UPDATED */]: 'updated',
    ["bum" /* LifecycleHooks.BEFORE_UNMOUNT */]: 'beforeUnmount hook',
    ["um" /* LifecycleHooks.UNMOUNTED */]: 'unmounted hook',
    ["a" /* LifecycleHooks.ACTIVATED */]: 'activated hook',
    ["da" /* LifecycleHooks.DEACTIVATED */]: 'deactivated hook',
    ["ec" /* LifecycleHooks.ERROR_CAPTURED */]: 'errorCaptured hook',
    ["rtc" /* LifecycleHooks.RENDER_TRACKED */]: 'renderTracked hook',
    ["rtg" /* LifecycleHooks.RENDER_TRIGGERED */]: 'renderTriggered hook',
    [0 /* ErrorCodes.SETUP_FUNCTION */]: 'setup function',
    [1 /* ErrorCodes.RENDER_FUNCTION */]: 'render function',
    [2 /* ErrorCodes.WATCH_GETTER */]: 'watcher getter',
    [3 /* ErrorCodes.WATCH_CALLBACK */]: 'watcher callback',
    [4 /* ErrorCodes.WATCH_CLEANUP */]: 'watcher cleanup function',
    [5 /* ErrorCodes.NATIVE_EVENT_HANDLER */]: 'native event handler',
    [6 /* ErrorCodes.COMPONENT_EVENT_HANDLER */]: 'component event handler',
    [7 /* ErrorCodes.VNODE_HOOK */]: 'vnode hook',
    [8 /* ErrorCodes.DIRECTIVE_HOOK */]: 'directive hook',
    [9 /* ErrorCodes.TRANSITION_HOOK */]: 'transition hook',
    [10 /* ErrorCodes.APP_ERROR_HANDLER */]: 'app errorHandler',
    [11 /* ErrorCodes.APP_WARN_HANDLER */]: 'app warnHandler',
    [12 /* ErrorCodes.FUNCTION_REF */]: 'ref function',
    [13 /* ErrorCodes.ASYNC_COMPONENT_LOADER */]: 'async component loader',
    [14 /* ErrorCodes.SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' +
        'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core'
};
function callWithErrorHandling(fn, instance, type, args) {
    let res;
    try {
        res = args ? fn(...args) : fn();
    }
    catch (err) {
        handleError(err, instance, type);
    }
    return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(fn)) {
        const res = callWithErrorHandling(fn, instance, type, args);
        if (res && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(res)) {
            res.catch(err => {
                handleError(err, instance, type);
            });
        }
        return res;
    }
    const values = [];
    for (let i = 0; i < fn.length; i++) {
        values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    }
    return values;
}
function handleError(err, instance, type, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    if (instance) {
        let cur = instance.parent;
        // the exposed instance is the render proxy to keep it consistent with 2.x
        const exposedInstance = instance.proxy;
        // in production the hook receives only the error code
        const errorInfo = ( true) ? ErrorTypeStrings[type] : 0;
        while (cur) {
            const errorCapturedHooks = cur.ec;
            if (errorCapturedHooks) {
                for (let i = 0; i < errorCapturedHooks.length; i++) {
                    if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
                        return;
                    }
                }
            }
            cur = cur.parent;
        }
        // app-level handling
        const appErrorHandler = instance.appContext.config.errorHandler;
        if (appErrorHandler) {
            callWithErrorHandling(appErrorHandler, null, 10 /* ErrorCodes.APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);
            return;
        }
    }
    logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
    if ((true)) {
        const info = ErrorTypeStrings[type];
        if (contextVNode) {
            pushWarningContext(contextVNode);
        }
        warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
        if (contextVNode) {
            popWarningContext();
        }
        // crash in dev by default so it's more noticeable
        if (throwInDev) {
            throw err;
        }
        else {
            console.error(err);
        }
    }
    else {}
}

let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /*#__PURE__*/ Promise.resolve();
let currentFlushPromise = null;
const RECURSION_LIMIT = 100;
function nextTick(fn) {
    const p = currentFlushPromise || resolvedPromise;
    return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
// #2768
// Use binary-search to find a suitable position in the queue,
// so that the queue maintains the increasing order of job's id,
// which can prevent the job from being skipped and also can avoid repeated patching.
function findInsertionIndex(id) {
    // the start index should be `flushIndex + 1`
    let start = flushIndex + 1;
    let end = queue.length;
    while (start < end) {
        const middle = (start + end) >>> 1;
        const middleJobId = getId(queue[middle]);
        middleJobId < id ? (start = middle + 1) : (end = middle);
    }
    return start;
}
function queueJob(job) {
    // the dedupe search uses the startIndex argument of Array.includes()
    // by default the search index includes the current job that is being run
    // so it cannot recursively trigger itself again.
    // if the job is a watch() callback, the search will start with a +1 index to
    // allow it recursively trigger itself - it is the user's responsibility to
    // ensure it doesn't end up in an infinite loop.
    if (!queue.length ||
        !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) {
        if (job.id == null) {
            queue.push(job);
        }
        else {
            queue.splice(findInsertionIndex(job.id), 0, job);
        }
        queueFlush();
    }
}
function queueFlush() {
    if (!isFlushing && !isFlushPending) {
        isFlushPending = true;
        currentFlushPromise = resolvedPromise.then(flushJobs);
    }
}
function invalidateJob(job) {
    const i = queue.indexOf(job);
    if (i > flushIndex) {
        queue.splice(i, 1);
    }
}
function queuePostFlushCb(cb) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(cb)) {
        if (!activePostFlushCbs ||
            !activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) {
            pendingPostFlushCbs.push(cb);
        }
    }
    else {
        // if cb is an array, it is a component lifecycle hook which can only be
        // triggered by a job, which is already deduped in the main queue, so
        // we can skip duplicate check here to improve perf
        pendingPostFlushCbs.push(...cb);
    }
    queueFlush();
}
function flushPreFlushCbs(seen, 
// if currently flushing, skip the current job itself
i = isFlushing ? flushIndex + 1 : 0) {
    if ((true)) {
        seen = seen || new Map();
    }
    for (; i < queue.length; i++) {
        const cb = queue[i];
        if (cb && cb.pre) {
            if (( true) && checkRecursiveUpdates(seen, cb)) {
                continue;
            }
            queue.splice(i, 1);
            i--;
            cb();
        }
    }
}
function flushPostFlushCbs(seen) {
    if (pendingPostFlushCbs.length) {
        const deduped = [...new Set(pendingPostFlushCbs)];
        pendingPostFlushCbs.length = 0;
        // #1947 already has active queue, nested flushPostFlushCbs call
        if (activePostFlushCbs) {
            activePostFlushCbs.push(...deduped);
            return;
        }
        activePostFlushCbs = deduped;
        if ((true)) {
            seen = seen || new Map();
        }
        activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
            if (( true) &&
                checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {
                continue;
            }
            activePostFlushCbs[postFlushIndex]();
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
    }
}
const getId = (job) => job.id == null ? Infinity : job.id;
const comparator = (a, b) => {
    const diff = getId(a) - getId(b);
    if (diff === 0) {
        if (a.pre && !b.pre)
            return -1;
        if (b.pre && !a.pre)
            return 1;
    }
    return diff;
};
function flushJobs(seen) {
    isFlushPending = false;
    isFlushing = true;
    if ((true)) {
        seen = seen || new Map();
    }
    // Sort queue before flush.
    // This ensures that:
    // 1. Components are updated from parent to child. (because parent is always
    //    created before the child so its render effect will have smaller
    //    priority number)
    // 2. If a component is unmounted during a parent component's update,
    //    its update can be skipped.
    queue.sort(comparator);
    // conditional usage of checkRecursiveUpdate must be determined out of
    // try ... catch block since Rollup by default de-optimizes treeshaking
    // inside try-catch. This can leave all warning code unshaked. Although
    // they would get eventually shaken by a minifier like terser, some minifiers
    // would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)
    const check = ( true)
        ? (job) => checkRecursiveUpdates(seen, job)
        : 0;
    try {
        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
            const job = queue[flushIndex];
            if (job && job.active !== false) {
                if (( true) && check(job)) {
                    continue;
                }
                // console.log(`running:`, job.id)
                callWithErrorHandling(job, null, 14 /* ErrorCodes.SCHEDULER */);
            }
        }
    }
    finally {
        flushIndex = 0;
        queue.length = 0;
        flushPostFlushCbs(seen);
        isFlushing = false;
        currentFlushPromise = null;
        // some postFlushCb queued jobs!
        // keep flushing until it drains.
        if (queue.length || pendingPostFlushCbs.length) {
            flushJobs(seen);
        }
    }
}
function checkRecursiveUpdates(seen, fn) {
    if (!seen.has(fn)) {
        seen.set(fn, 1);
    }
    else {
        const count = seen.get(fn);
        if (count > RECURSION_LIMIT) {
            const instance = fn.ownerInstance;
            const componentName = instance && getComponentName(instance.type);
            warn(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. ` +
                `This means you have a reactive effect that is mutating its own ` +
                `dependencies and thus recursively triggering itself. Possible sources ` +
                `include component template, render function, updated hook or ` +
                `watcher source function.`);
            return true;
        }
        else {
            seen.set(fn, count + 1);
        }
    }
}

/* eslint-disable no-restricted-globals */
let isHmrUpdating = false;
const hmrDirtyComponents = new Set();
// Expose the HMR runtime on the global object
// This makes it entirely tree-shakable without polluting the exports and makes
// it easier to be used in toolings like vue-loader
// Note: for a component to be eligible for HMR it also needs the __hmrId option
// to be set so that its instances can be registered / removed.
if ((true)) {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_HMR_RUNTIME__ = {
        createRecord: tryWrap(createRecord),
        rerender: tryWrap(rerender),
        reload: tryWrap(reload)
    };
}
const map = new Map();
function registerHMR(instance) {
    const id = instance.type.__hmrId;
    let record = map.get(id);
    if (!record) {
        createRecord(id, instance.type);
        record = map.get(id);
    }
    record.instances.add(instance);
}
function unregisterHMR(instance) {
    map.get(instance.type.__hmrId).instances.delete(instance);
}
function createRecord(id, initialDef) {
    if (map.has(id)) {
        return false;
    }
    map.set(id, {
        initialDef: normalizeClassComponent(initialDef),
        instances: new Set()
    });
    return true;
}
function normalizeClassComponent(component) {
    return isClassComponent(component) ? component.__vccOpts : component;
}
function rerender(id, newRender) {
    const record = map.get(id);
    if (!record) {
        return;
    }
    // update initial record (for not-yet-rendered component)
    record.initialDef.render = newRender;
    [...record.instances].forEach(instance => {
        if (newRender) {
            instance.render = newRender;
            normalizeClassComponent(instance.type).render = newRender;
        }
        instance.renderCache = [];
        // this flag forces child components with slot content to update
        isHmrUpdating = true;
        instance.update();
        isHmrUpdating = false;
    });
}
function reload(id, newComp) {
    const record = map.get(id);
    if (!record)
        return;
    newComp = normalizeClassComponent(newComp);
    // update initial def (for not-yet-rendered components)
    updateComponentDef(record.initialDef, newComp);
    // create a snapshot which avoids the set being mutated during updates
    const instances = [...record.instances];
    for (const instance of instances) {
        const oldComp = normalizeClassComponent(instance.type);
        if (!hmrDirtyComponents.has(oldComp)) {
            // 1. Update existing comp definition to match new one
            if (oldComp !== record.initialDef) {
                updateComponentDef(oldComp, newComp);
            }
            // 2. mark definition dirty. This forces the renderer to replace the
            // component on patch.
            hmrDirtyComponents.add(oldComp);
        }
        // 3. invalidate options resolution cache
        instance.appContext.optionsCache.delete(instance.type);
        // 4. actually update
        if (instance.ceReload) {
            // custom element
            hmrDirtyComponents.add(oldComp);
            instance.ceReload(newComp.styles);
            hmrDirtyComponents.delete(oldComp);
        }
        else if (instance.parent) {
            // 4. Force the parent instance to re-render. This will cause all updated
            // components to be unmounted and re-mounted. Queue the update so that we
            // don't end up forcing the same parent to re-render multiple times.
            queueJob(instance.parent.update);
        }
        else if (instance.appContext.reload) {
            // root instance mounted via createApp() has a reload method
            instance.appContext.reload();
        }
        else if (typeof window !== 'undefined') {
            // root instance inside tree created via raw render(). Force reload.
            window.location.reload();
        }
        else {
            console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');
        }
    }
    // 5. make sure to cleanup dirty hmr components after update
    queuePostFlushCb(() => {
        for (const instance of instances) {
            hmrDirtyComponents.delete(normalizeClassComponent(instance.type));
        }
    });
}
function updateComponentDef(oldComp, newComp) {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(oldComp, newComp);
    for (const key in oldComp) {
        if (key !== '__file' && !(key in newComp)) {
            delete oldComp[key];
        }
    }
}
function tryWrap(fn) {
    return (id, arg) => {
        try {
            return fn(id, arg);
        }
        catch (e) {
            console.error(e);
            console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` +
                `Full reload required.`);
        }
    };
}

let devtools;
let buffer = [];
let devtoolsNotInstalled = false;
function emit(event, ...args) {
    if (devtools) {
        devtools.emit(event, ...args);
    }
    else if (!devtoolsNotInstalled) {
        buffer.push({ event, args });
    }
}
function setDevtoolsHook(hook, target) {
    var _a, _b;
    devtools = hook;
    if (devtools) {
        devtools.enabled = true;
        buffer.forEach(({ event, args }) => devtools.emit(event, ...args));
        buffer = [];
    }
    else if (
    // handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    typeof window !== 'undefined' &&
        // some envs mock window but not fully
        window.HTMLElement &&
        // also exclude jsdom
        !((_b = (_a = window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === null || _b === void 0 ? void 0 : _b.includes('jsdom'))) {
        const replay = (target.__VUE_DEVTOOLS_HOOK_REPLAY__ =
            target.__VUE_DEVTOOLS_HOOK_REPLAY__ || []);
        replay.push((newHook) => {
            setDevtoolsHook(newHook, target);
        });
        // clear buffer after 3s - the user probably doesn't have devtools installed
        // at all, and keeping the buffer will cause memory leaks (#4738)
        setTimeout(() => {
            if (!devtools) {
                target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
                devtoolsNotInstalled = true;
                buffer = [];
            }
        }, 3000);
    }
    else {
        // non-browser env, assume not installed
        devtoolsNotInstalled = true;
        buffer = [];
    }
}
function devtoolsInitApp(app, version) {
    emit("app:init" /* DevtoolsHooks.APP_INIT */, app, version, {
        Fragment,
        Text,
        Comment,
        Static
    });
}
function devtoolsUnmountApp(app) {
    emit("app:unmount" /* DevtoolsHooks.APP_UNMOUNT */, app);
}
const devtoolsComponentAdded = /*#__PURE__*/ createDevtoolsComponentHook("component:added" /* DevtoolsHooks.COMPONENT_ADDED */);
const devtoolsComponentUpdated = 
/*#__PURE__*/ createDevtoolsComponentHook("component:updated" /* DevtoolsHooks.COMPONENT_UPDATED */);
const _devtoolsComponentRemoved = /*#__PURE__*/ createDevtoolsComponentHook("component:removed" /* DevtoolsHooks.COMPONENT_REMOVED */);
const devtoolsComponentRemoved = (component) => {
    if (devtools &&
        typeof devtools.cleanupBuffer === 'function' &&
        // remove the component if it wasn't buffered
        !devtools.cleanupBuffer(component)) {
        _devtoolsComponentRemoved(component);
    }
};
function createDevtoolsComponentHook(hook) {
    return (component) => {
        emit(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : undefined, component);
    };
}
const devtoolsPerfStart = /*#__PURE__*/ createDevtoolsPerformanceHook("perf:start" /* DevtoolsHooks.PERFORMANCE_START */);
const devtoolsPerfEnd = /*#__PURE__*/ createDevtoolsPerformanceHook("perf:end" /* DevtoolsHooks.PERFORMANCE_END */);
function createDevtoolsPerformanceHook(hook) {
    return (component, type, time) => {
        emit(hook, component.appContext.app, component.uid, component, type, time);
    };
}
function devtoolsComponentEmit(component, event, params) {
    emit("component:emit" /* DevtoolsHooks.COMPONENT_EMIT */, component.appContext.app, component, event, params);
}

function emit$1(instance, event, ...rawArgs) {
    if (instance.isUnmounted)
        return;
    const props = instance.vnode.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    if ((true)) {
        const { emitsOptions, propsOptions: [propsOptions] } = instance;
        if (emitsOptions) {
            if (!(event in emitsOptions) &&
                !(false )) {
                if (!propsOptions || !((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event) in propsOptions)) {
                    warn(`Component emitted event "${event}" but it is neither declared in ` +
                        `the emits option nor as an "${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event)}" prop.`);
                }
            }
            else {
                const validator = emitsOptions[event];
                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(validator)) {
                    const isValid = validator(...rawArgs);
                    if (!isValid) {
                        warn(`Invalid event arguments: event validation failed for event "${event}".`);
                    }
                }
            }
        }
    }
    let args = rawArgs;
    const isModelListener = event.startsWith('update:');
    // for v-model update:xxx events, apply modifiers on args
    const modelArg = isModelListener && event.slice(7);
    if (modelArg && modelArg in props) {
        const modifiersKey = `${modelArg === 'modelValue' ? 'model' : modelArg}Modifiers`;
        const { number, trim } = props[modifiersKey] || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        if (trim) {
            args = rawArgs.map(a => ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(a) ? a.trim() : a));
        }
        if (number) {
            args = rawArgs.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber);
        }
    }
    if (true) {
        devtoolsComponentEmit(instance, event, args);
    }
    if ((true)) {
        const lowerCaseEvent = event.toLowerCase();
        if (lowerCaseEvent !== event && props[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(lowerCaseEvent)]) {
            warn(`Event "${lowerCaseEvent}" is emitted in component ` +
                `${formatComponentName(instance, instance.type)} but the handler is registered for "${event}". ` +
                `Note that HTML attributes are case-insensitive and you cannot use ` +
                `v-on to listen to camelCase events when using in-DOM templates. ` +
                `You should probably use "${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event)}" instead of "${event}".`);
        }
    }
    let handlerName;
    let handler = props[(handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event))] ||
        // also try camelCase event handler (#2249)
        props[(handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(event)))];
    // for v-model update:xxx events, also trigger kebab-case equivalent
    // for props passed via kebab-case
    if (!handler && isModelListener) {
        handler = props[(handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event)))];
    }
    if (handler) {
        callWithAsyncErrorHandling(handler, instance, 6 /* ErrorCodes.COMPONENT_EVENT_HANDLER */, args);
    }
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
        if (!instance.emitted) {
            instance.emitted = {};
        }
        else if (instance.emitted[handlerName]) {
            return;
        }
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(onceHandler, instance, 6 /* ErrorCodes.COMPONENT_EVENT_HANDLER */, args);
    }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.emitsCache;
    const cached = cache.get(comp);
    if (cached !== undefined) {
        return cached;
    }
    const raw = comp.emits;
    let normalized = {};
    // apply mixin/extends props
    let hasExtends = false;
    if (__VUE_OPTIONS_API__ && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
        const extendEmits = (raw) => {
            const normalizedFromExtend = normalizeEmitsOptions(raw, appContext, true);
            if (normalizedFromExtend) {
                hasExtends = true;
                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, normalizedFromExtend);
            }
        };
        if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendEmits);
        }
        if (comp.extends) {
            extendEmits(comp.extends);
        }
        if (comp.mixins) {
            comp.mixins.forEach(extendEmits);
        }
    }
    if (!raw && !hasExtends) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp)) {
            cache.set(comp, null);
        }
        return null;
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
        raw.forEach(key => (normalized[key] = null));
    }
    else {
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, raw);
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp)) {
        cache.set(comp, normalized);
    }
    return normalized;
}
// Check if an incoming prop key is a declared emit event listener.
// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are
// both considered matched listeners.
function isEmitListener(options, key) {
    if (!options || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
        return false;
    }
    key = key.slice(2).replace(/Once$/, '');
    return ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, key[0].toLowerCase() + key.slice(1)) ||
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)) ||
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, key));
}

/**
 * mark the current rendering instance for asset resolution (e.g.
 * resolveComponent, resolveDirective) during render
 */
let currentRenderingInstance = null;
let currentScopeId = null;
/**
 * Note: rendering calls maybe nested. The function returns the parent rendering
 * instance if present, which should be restored after the render is done:
 *
 * ```js
 * const prev = setCurrentRenderingInstance(i)
 * // ...render
 * setCurrentRenderingInstance(prev)
 * ```
 */
function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = (instance && instance.type.__scopeId) || null;
    return prev;
}
/**
 * Set scope id when creating hoisted vnodes.
 * @private compiler helper
 */
function pushScopeId(id) {
    currentScopeId = id;
}
/**
 * Technically we no longer need this after 3.0.8 but we need to keep the same
 * API for backwards compat w/ code generated by compilers.
 * @private
 */
function popScopeId() {
    currentScopeId = null;
}
/**
 * Only for backwards compat
 * @private
 */
const withScopeId = (_id) => withCtx;
/**
 * Wrap a slot function to memoize current rendering instance
 * @private compiler helper
 */
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot // false only
) {
    if (!ctx)
        return fn;
    // already normalized
    if (fn._n) {
        return fn;
    }
    const renderFnWithContext = (...args) => {
        // If a user calls a compiled slot inside a template expression (#1745), it
        // can mess up block tracking, so by default we disable block tracking and
        // force bail out when invoking a compiled slot (indicated by the ._d flag).
        // This isn't necessary if rendering a compiled `<slot>`, so we flip the
        // ._d flag off when invoking the wrapped fn inside `renderSlot`.
        if (renderFnWithContext._d) {
            setBlockTracking(-1);
        }
        const prevInstance = setCurrentRenderingInstance(ctx);
        let res;
        try {
            res = fn(...args);
        }
        finally {
            setCurrentRenderingInstance(prevInstance);
            if (renderFnWithContext._d) {
                setBlockTracking(1);
            }
        }
        if (true) {
            devtoolsComponentUpdated(ctx);
        }
        return res;
    };
    // mark normalized to avoid duplicated wrapping
    renderFnWithContext._n = true;
    // mark this as compiled by default
    // this is used in vnode.ts -> normalizeChildren() to set the slot
    // rendering flag.
    renderFnWithContext._c = true;
    // disable block tracking by default
    renderFnWithContext._d = true;
    return renderFnWithContext;
}

/**
 * dev only flag to track whether $attrs was used during render.
 * If $attrs was used during render then the warning for failed attrs
 * fallthrough can be suppressed.
 */
let accessedAttrs = false;
function markAttrsAccessed() {
    accessedAttrs = true;
}
function renderComponentRoot(instance) {
    const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render, renderCache, data, setupState, ctx, inheritAttrs } = instance;
    let result;
    let fallthroughAttrs;
    const prev = setCurrentRenderingInstance(instance);
    if ((true)) {
        accessedAttrs = false;
    }
    try {
        if (vnode.shapeFlag & 4 /* ShapeFlags.STATEFUL_COMPONENT */) {
            // withProxy is a proxy with a different `has` trap only for
            // runtime-compiled render functions using `with` block.
            const proxyToUse = withProxy || proxy;
            result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
            fallthroughAttrs = attrs;
        }
        else {
            // functional
            const render = Component;
            // in dev, mark attrs accessed if optional props (attrs === props)
            if (( true) && attrs === props) {
                markAttrsAccessed();
            }
            result = normalizeVNode(render.length > 1
                ? render(props, ( true)
                    ? {
                        get attrs() {
                            markAttrsAccessed();
                            return attrs;
                        },
                        slots,
                        emit
                    }
                    : 0)
                : render(props, null /* we know it doesn't need it */));
            fallthroughAttrs = Component.props
                ? attrs
                : getFunctionalFallthrough(attrs);
        }
    }
    catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1 /* ErrorCodes.RENDER_FUNCTION */);
        result = createVNode(Comment);
    }
    // attr merging
    // in dev mode, comments are preserved, and it's possible for a template
    // to have comments along side the root element which makes it a fragment
    let root = result;
    let setRoot = undefined;
    if (( true) &&
        result.patchFlag > 0 &&
        result.patchFlag & 2048 /* PatchFlags.DEV_ROOT_FRAGMENT */) {
        [root, setRoot] = getChildRoot(result);
    }
    if (fallthroughAttrs && inheritAttrs !== false) {
        const keys = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root;
        if (keys.length) {
            if (shapeFlag & (1 /* ShapeFlags.ELEMENT */ | 6 /* ShapeFlags.COMPONENT */)) {
                if (propsOptions && keys.some(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)) {
                    // If a v-model listener (onUpdate:xxx) has a corresponding declared
                    // prop, it indicates this component expects to handle v-model and
                    // it should not fallthrough.
                    // related: #1543, #1643, #1989
                    fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
                }
                root = cloneVNode(root, fallthroughAttrs);
            }
            else if (( true) && !accessedAttrs && root.type !== Comment) {
                const allAttrs = Object.keys(attrs);
                const eventAttrs = [];
                const extraAttrs = [];
                for (let i = 0, l = allAttrs.length; i < l; i++) {
                    const key = allAttrs[i];
                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
                        // ignore v-model handlers when they fail to fallthrough
                        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key)) {
                            // remove `on`, lowercase first letter to reflect event casing
                            // accurately
                            eventAttrs.push(key[2].toLowerCase() + key.slice(3));
                        }
                    }
                    else {
                        extraAttrs.push(key);
                    }
                }
                if (extraAttrs.length) {
                    warn(`Extraneous non-props attributes (` +
                        `${extraAttrs.join(', ')}) ` +
                        `were passed to component but could not be automatically inherited ` +
                        `because component renders fragment or text root nodes.`);
                }
                if (eventAttrs.length) {
                    warn(`Extraneous non-emits event listeners (` +
                        `${eventAttrs.join(', ')}) ` +
                        `were passed to component but could not be automatically inherited ` +
                        `because component renders fragment or text root nodes. ` +
                        `If the listener is intended to be a component custom event listener only, ` +
                        `declare it using the "emits" option.`);
                }
            }
        }
    }
    // inherit directives
    if (vnode.dirs) {
        if (( true) && !isElementRoot(root)) {
            warn(`Runtime directive used on component with non-element root node. ` +
                `The directives will not function as intended.`);
        }
        // clone before mutating since the root may be a hoisted vnode
        root = cloneVNode(root);
        root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    // inherit transition data
    if (vnode.transition) {
        if (( true) && !isElementRoot(root)) {
            warn(`Component inside <Transition> renders non-element root node ` +
                `that cannot be animated.`);
        }
        root.transition = vnode.transition;
    }
    if (( true) && setRoot) {
        setRoot(root);
    }
    else {
        result = root;
    }
    setCurrentRenderingInstance(prev);
    return result;
}
/**
 * dev only
 * In dev mode, template root level comments are rendered, which turns the
 * template into a fragment root, but we need to locate the single element
 * root for attrs and scope id processing.
 */
const getChildRoot = (vnode) => {
    const rawChildren = vnode.children;
    const dynamicChildren = vnode.dynamicChildren;
    const childRoot = filterSingleRoot(rawChildren);
    if (!childRoot) {
        return [vnode, undefined];
    }
    const index = rawChildren.indexOf(childRoot);
    const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
    const setRoot = (updatedRoot) => {
        rawChildren[index] = updatedRoot;
        if (dynamicChildren) {
            if (dynamicIndex > -1) {
                dynamicChildren[dynamicIndex] = updatedRoot;
            }
            else if (updatedRoot.patchFlag > 0) {
                vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
            }
        }
    };
    return [normalizeVNode(childRoot), setRoot];
};
function filterSingleRoot(children) {
    let singleRoot;
    for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isVNode(child)) {
            // ignore user comment
            if (child.type !== Comment || child.children === 'v-if') {
                if (singleRoot) {
                    // has more than 1 non-comment child, return now
                    return;
                }
                else {
                    singleRoot = child;
                }
            }
        }
        else {
            return;
        }
    }
    return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
    let res;
    for (const key in attrs) {
        if (key === 'class' || key === 'style' || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
            (res || (res = {}))[key] = attrs[key];
        }
    }
    return res;
};
const filterModelListeners = (attrs, props) => {
    const res = {};
    for (const key in attrs) {
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key) || !(key.slice(9) in props)) {
            res[key] = attrs[key];
        }
    }
    return res;
};
const isElementRoot = (vnode) => {
    return (vnode.shapeFlag & (6 /* ShapeFlags.COMPONENT */ | 1 /* ShapeFlags.ELEMENT */) ||
        vnode.type === Comment // potential v-if branch switch
    );
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component.emitsOptions;
    // Parent component's render function was hot-updated. Since this may have
    // caused the child component's slots content to have changed, we need to
    // force the child to update as well.
    if (( true) && (prevChildren || nextChildren) && isHmrUpdating) {
        return true;
    }
    // force child update for runtime directive or transition on component vnode.
    if (nextVNode.dirs || nextVNode.transition) {
        return true;
    }
    if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024 /* PatchFlags.DYNAMIC_SLOTS */) {
            // slot content that references values that might have changed,
            // e.g. in a v-for
            return true;
        }
        if (patchFlag & 16 /* PatchFlags.FULL_PROPS */) {
            if (!prevProps) {
                return !!nextProps;
            }
            // presence of this flag indicates props are always non-null
            return hasPropsChanged(prevProps, nextProps, emits);
        }
        else if (patchFlag & 8 /* PatchFlags.PROPS */) {
            const dynamicProps = nextVNode.dynamicProps;
            for (let i = 0; i < dynamicProps.length; i++) {
                const key = dynamicProps[i];
                if (nextProps[key] !== prevProps[key] &&
                    !isEmitListener(emits, key)) {
                    return true;
                }
            }
        }
    }
    else {
        // this path is only taken by manually written render functions
        // so presence of any children leads to a forced update
        if (prevChildren || nextChildren) {
            if (!nextChildren || !nextChildren.$stable) {
                return true;
            }
        }
        if (prevProps === nextProps) {
            return false;
        }
        if (!prevProps) {
            return !!nextProps;
        }
        if (!nextProps) {
            return true;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
        return true;
    }
    for (let i = 0; i < nextKeys.length; i++) {
        const key = nextKeys[i];
        if (nextProps[key] !== prevProps[key] &&
            !isEmitListener(emitsOptions, key)) {
            return true;
        }
    }
    return false;
}
function updateHOCHostEl({ vnode, parent }, el // HostNode
) {
    while (parent && parent.subTree === vnode) {
        (vnode = parent.vnode).el = el;
        parent = parent.parent;
    }
}

const isSuspense = (type) => type.__isSuspense;
// Suspense exposes a component-like API, and is treated like a component
// in the compiler, but internally it's a special built-in type that hooks
// directly into the renderer.
const SuspenseImpl = {
    name: 'Suspense',
    // In order to make Suspense tree-shakable, we need to avoid importing it
    // directly in the renderer. The renderer checks for the __isSuspense flag
    // on a vnode's type and calls the `process` method, passing in renderer
    // internals.
    __isSuspense: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, 
    // platform-specific impl passed from renderer
    rendererInternals) {
        if (n1 == null) {
            mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);
        }
        else {
            patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);
        }
    },
    hydrate: hydrateSuspense,
    create: createSuspenseBoundary,
    normalize: normalizeSuspenseChildren
};
// Force-casted public typing for h and TSX props inference
const Suspense = (SuspenseImpl
    );
function triggerEvent(vnode, name) {
    const eventListener = vnode.props && vnode.props[name];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(eventListener)) {
        eventListener();
    }
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
    const { p: patch, o: { createElement } } = rendererInternals;
    const hiddenContainer = createElement('div');
    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals));
    // start mounting the content subtree in an off-dom container
    patch(null, (suspense.pendingBranch = vnode.ssContent), hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);
    // now check if we have encountered any async deps
    if (suspense.deps > 0) {
        // has async
        // invoke @fallback event
        triggerEvent(vnode, 'onPending');
        triggerEvent(vnode, 'onFallback');
        // mount the fallback tree
        patch(null, vnode.ssFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
        isSVG, slotScopeIds);
        setActiveBranch(suspense, vnode.ssFallback);
    }
    else {
        // Suspense has no async deps. Just resolve.
        suspense.resolve();
    }
}
function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
    const suspense = (n2.suspense = n1.suspense);
    suspense.vnode = n2;
    n2.el = n1.el;
    const newBranch = n2.ssContent;
    const newFallback = n2.ssFallback;
    const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
    if (pendingBranch) {
        suspense.pendingBranch = newBranch;
        if (isSameVNodeType(newBranch, pendingBranch)) {
            // same root type but content may have changed.
            patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
            if (suspense.deps <= 0) {
                suspense.resolve();
            }
            else if (isInFallback) {
                patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                isSVG, slotScopeIds, optimized);
                setActiveBranch(suspense, newFallback);
            }
        }
        else {
            // toggled before pending tree is resolved
            suspense.pendingId++;
            if (isHydrating) {
                // if toggled before hydration is finished, the current DOM tree is
                // no longer valid. set it as the active branch so it will be unmounted
                // when resolved
                suspense.isHydrating = false;
                suspense.activeBranch = pendingBranch;
            }
            else {
                unmount(pendingBranch, parentComponent, suspense);
            }
            // increment pending ID. this is used to invalidate async callbacks
            // reset suspense state
            suspense.deps = 0;
            // discard effects from pending branch
            suspense.effects.length = 0;
            // discard previous container
            suspense.hiddenContainer = createElement('div');
            if (isInFallback) {
                // already in fallback state
                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                if (suspense.deps <= 0) {
                    suspense.resolve();
                }
                else {
                    patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                    isSVG, slotScopeIds, optimized);
                    setActiveBranch(suspense, newFallback);
                }
            }
            else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
                // toggled "back" to current active branch
                patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                // force resolve
                suspense.resolve(true);
            }
            else {
                // switched to a 3rd branch
                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                if (suspense.deps <= 0) {
                    suspense.resolve();
                }
            }
        }
    }
    else {
        if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
            // root did not change, just normal patch
            patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
            setActiveBranch(suspense, newBranch);
        }
        else {
            // root node toggled
            // invoke @pending event
            triggerEvent(n2, 'onPending');
            // mount pending branch in off-dom container
            suspense.pendingBranch = newBranch;
            suspense.pendingId++;
            patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
            if (suspense.deps <= 0) {
                // incoming branch has no async deps, resolve now.
                suspense.resolve();
            }
            else {
                const { timeout, pendingId } = suspense;
                if (timeout > 0) {
                    setTimeout(() => {
                        if (suspense.pendingId === pendingId) {
                            suspense.fallback(newFallback);
                        }
                    }, timeout);
                }
                else if (timeout === 0) {
                    suspense.fallback(newFallback);
                }
            }
        }
    }
}
let hasWarned = false;
function createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
    /* istanbul ignore if */
    if ( true && !hasWarned) {
        hasWarned = true;
        // @ts-ignore `console.info` cannot be null error
        console[console.info ? 'info' : 'log'](`<Suspense> is an experimental feature and its API will likely change.`);
    }
    const { p: patch, m: move, um: unmount, n: next, o: { parentNode, remove } } = rendererInternals;
    const timeout = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(vnode.props && vnode.props.timeout);
    const suspense = {
        vnode,
        parent,
        parentComponent,
        isSVG,
        container,
        hiddenContainer,
        anchor,
        deps: 0,
        pendingId: 0,
        timeout: typeof timeout === 'number' ? timeout : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: true,
        isHydrating,
        isUnmounted: false,
        effects: [],
        resolve(resume = false) {
            if ((true)) {
                if (!resume && !suspense.pendingBranch) {
                    throw new Error(`suspense.resolve() is called without a pending branch.`);
                }
                if (suspense.isUnmounted) {
                    throw new Error(`suspense.resolve() is called on an already unmounted suspense boundary.`);
                }
            }
            const { vnode, activeBranch, pendingBranch, pendingId, effects, parentComponent, container } = suspense;
            if (suspense.isHydrating) {
                suspense.isHydrating = false;
            }
            else if (!resume) {
                const delayEnter = activeBranch &&
                    pendingBranch.transition &&
                    pendingBranch.transition.mode === 'out-in';
                if (delayEnter) {
                    activeBranch.transition.afterLeave = () => {
                        if (pendingId === suspense.pendingId) {
                            move(pendingBranch, container, anchor, 0 /* MoveType.ENTER */);
                        }
                    };
                }
                // this is initial anchor on mount
                let { anchor } = suspense;
                // unmount current active tree
                if (activeBranch) {
                    // if the fallback tree was mounted, it may have been moved
                    // as part of a parent suspense. get the latest anchor for insertion
                    anchor = next(activeBranch);
                    unmount(activeBranch, parentComponent, suspense, true);
                }
                if (!delayEnter) {
                    // move content from off-dom container to actual container
                    move(pendingBranch, container, anchor, 0 /* MoveType.ENTER */);
                }
            }
            setActiveBranch(suspense, pendingBranch);
            suspense.pendingBranch = null;
            suspense.isInFallback = false;
            // flush buffered effects
            // check if there is a pending parent suspense
            let parent = suspense.parent;
            let hasUnresolvedAncestor = false;
            while (parent) {
                if (parent.pendingBranch) {
                    // found a pending parent suspense, merge buffered post jobs
                    // into that parent
                    parent.effects.push(...effects);
                    hasUnresolvedAncestor = true;
                    break;
                }
                parent = parent.parent;
            }
            // no pending parent suspense, flush all jobs
            if (!hasUnresolvedAncestor) {
                queuePostFlushCb(effects);
            }
            suspense.effects = [];
            // invoke @resolve event
            triggerEvent(vnode, 'onResolve');
        },
        fallback(fallbackVNode) {
            if (!suspense.pendingBranch) {
                return;
            }
            const { vnode, activeBranch, parentComponent, container, isSVG } = suspense;
            // invoke @fallback event
            triggerEvent(vnode, 'onFallback');
            const anchor = next(activeBranch);
            const mountFallback = () => {
                if (!suspense.isInFallback) {
                    return;
                }
                // mount the fallback tree
                patch(null, fallbackVNode, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                isSVG, slotScopeIds, optimized);
                setActiveBranch(suspense, fallbackVNode);
            };
            const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === 'out-in';
            if (delayEnter) {
                activeBranch.transition.afterLeave = mountFallback;
            }
            suspense.isInFallback = true;
            // unmount current active branch
            unmount(activeBranch, parentComponent, null, // no suspense so unmount hooks fire now
            true // shouldRemove
            );
            if (!delayEnter) {
                mountFallback();
            }
        },
        move(container, anchor, type) {
            suspense.activeBranch &&
                move(suspense.activeBranch, container, anchor, type);
            suspense.container = container;
        },
        next() {
            return suspense.activeBranch && next(suspense.activeBranch);
        },
        registerDep(instance, setupRenderEffect) {
            const isInPendingSuspense = !!suspense.pendingBranch;
            if (isInPendingSuspense) {
                suspense.deps++;
            }
            const hydratedEl = instance.vnode.el;
            instance
                .asyncDep.catch(err => {
                handleError(err, instance, 0 /* ErrorCodes.SETUP_FUNCTION */);
            })
                .then(asyncSetupResult => {
                // retry when the setup() promise resolves.
                // component may have been unmounted before resolve.
                if (instance.isUnmounted ||
                    suspense.isUnmounted ||
                    suspense.pendingId !== instance.suspenseId) {
                    return;
                }
                // retry from this component
                instance.asyncResolved = true;
                const { vnode } = instance;
                if ((true)) {
                    pushWarningContext(vnode);
                }
                handleSetupResult(instance, asyncSetupResult, false);
                if (hydratedEl) {
                    // vnode may have been replaced if an update happened before the
                    // async dep is resolved.
                    vnode.el = hydratedEl;
                }
                const placeholder = !hydratedEl && instance.subTree.el;
                setupRenderEffect(instance, vnode, 
                // component may have been moved before resolve.
                // if this is not a hydration, instance.subTree will be the comment
                // placeholder.
                parentNode(hydratedEl || instance.subTree.el), 
                // anchor will not be used if this is hydration, so only need to
                // consider the comment placeholder case.
                hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);
                if (placeholder) {
                    remove(placeholder);
                }
                updateHOCHostEl(instance, vnode.el);
                if ((true)) {
                    popWarningContext();
                }
                // only decrease deps count if suspense is not already resolved
                if (isInPendingSuspense && --suspense.deps === 0) {
                    suspense.resolve();
                }
            });
        },
        unmount(parentSuspense, doRemove) {
            suspense.isUnmounted = true;
            if (suspense.activeBranch) {
                unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);
            }
            if (suspense.pendingBranch) {
                unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);
            }
        }
    };
    return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
    /* eslint-disable no-restricted-globals */
    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement('div'), null, isSVG, slotScopeIds, optimized, rendererInternals, true /* hydrating */));
    // there are two possible scenarios for server-rendered suspense:
    // - success: ssr content should be fully resolved
    // - failure: ssr content should be the fallback branch.
    // however, on the client we don't really know if it has failed or not
    // attempt to hydrate the DOM assuming it has succeeded, but we still
    // need to construct a suspense boundary first
    const result = hydrateNode(node, (suspense.pendingBranch = vnode.ssContent), parentComponent, suspense, slotScopeIds, optimized);
    if (suspense.deps === 0) {
        suspense.resolve();
    }
    return result;
    /* eslint-enable no-restricted-globals */
}
function normalizeSuspenseChildren(vnode) {
    const { shapeFlag, children } = vnode;
    const isSlotChildren = shapeFlag & 32 /* ShapeFlags.SLOTS_CHILDREN */;
    vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
    vnode.ssFallback = isSlotChildren
        ? normalizeSuspenseSlot(children.fallback)
        : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
    let block;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) {
        const trackBlock = isBlockTreeEnabled && s._c;
        if (trackBlock) {
            // disableTracking: false
            // allow block tracking for compiled slots
            // (see ./componentRenderContext.ts)
            s._d = false;
            openBlock();
        }
        s = s();
        if (trackBlock) {
            s._d = true;
            block = currentBlock;
            closeBlock();
        }
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(s)) {
        const singleChild = filterSingleRoot(s);
        if (( true) && !singleChild) {
            warn(`<Suspense> slots expect a single root node.`);
        }
        s = singleChild;
    }
    s = normalizeVNode(s);
    if (block && !s.dynamicChildren) {
        s.dynamicChildren = block.filter(c => c !== s);
    }
    return s;
}
function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn)) {
            suspense.effects.push(...fn);
        }
        else {
            suspense.effects.push(fn);
        }
    }
    else {
        queuePostFlushCb(fn);
    }
}
function setActiveBranch(suspense, branch) {
    suspense.activeBranch = branch;
    const { vnode, parentComponent } = suspense;
    const el = (vnode.el = branch.el);
    // in case suspense is the root node of a component,
    // recursively update the HOC el
    if (parentComponent && parentComponent.subTree === vnode) {
        parentComponent.vnode.el = el;
        updateHOCHostEl(parentComponent, el);
    }
}

function provide(key, value) {
    if (!currentInstance) {
        if ((true)) {
            warn(`provide() can only be used inside setup().`);
        }
    }
    else {
        let provides = currentInstance.provides;
        // by default an instance inherits its parent's provides object
        // but when it needs to provide values of its own, it creates its
        // own provides object using parent provides object as prototype.
        // this way in `inject` we can simply look up injections from direct
        // parent and let the prototype chain do the work.
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) {
            provides = currentInstance.provides = Object.create(parentProvides);
        }
        // TS doesn't allow symbol as index type
        provides[key] = value;
    }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
    // fallback to `currentRenderingInstance` so that this can be called in
    // a functional component
    const instance = currentInstance || currentRenderingInstance;
    if (instance) {
        // #2400
        // to support `app.use` plugins,
        // fallback to appContext's `provides` if the instance is at root
        const provides = instance.parent == null
            ? instance.vnode.appContext && instance.vnode.appContext.provides
            : instance.parent.provides;
        if (provides && key in provides) {
            // TS doesn't allow symbol as index type
            return provides[key];
        }
        else if (arguments.length > 1) {
            return treatDefaultAsFactory && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(defaultValue)
                ? defaultValue.call(instance.proxy)
                : defaultValue;
        }
        else if ((true)) {
            warn(`injection "${String(key)}" not found.`);
        }
    }
    else if ((true)) {
        warn(`inject() can only be used inside setup() or functional components.`);
    }
}

// Simple effect.
function watchEffect(effect, options) {
    return doWatch(effect, null, options);
}
function watchPostEffect(effect, options) {
    return doWatch(effect, null, (( true)
        ? Object.assign(Object.assign({}, options), { flush: 'post' }) : 0));
}
function watchSyncEffect(effect, options) {
    return doWatch(effect, null, (( true)
        ? Object.assign(Object.assign({}, options), { flush: 'sync' }) : 0));
}
// initial value for watchers to trigger on undefined initial values
const INITIAL_WATCHER_VALUE = {};
// implementation
function watch(source, cb, options) {
    if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(cb)) {
        warn(`\`watch(fn, options?)\` signature has been moved to a separate API. ` +
            `Use \`watchEffect(fn, options?)\` instead. \`watch\` now only ` +
            `supports \`watch(source, cb, options?) signature.`);
    }
    return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
    if (( true) && !cb) {
        if (immediate !== undefined) {
            warn(`watch() "immediate" option is only respected when using the ` +
                `watch(source, callback, options?) signature.`);
        }
        if (deep !== undefined) {
            warn(`watch() "deep" option is only respected when using the ` +
                `watch(source, callback, options?) signature.`);
        }
    }
    const warnInvalidSource = (s) => {
        warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` +
            `a reactive object, or an array of these types.`);
    };
    const instance = currentInstance;
    let getter;
    let forceTrigger = false;
    let isMultiSource = false;
    if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(source)) {
        getter = () => source.value;
        forceTrigger = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow)(source);
    }
    else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(source)) {
        getter = () => source;
        deep = true;
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(source)) {
        isMultiSource = true;
        forceTrigger = source.some(s => (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(s) || (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow)(s));
        getter = () => source.map(s => {
            if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(s)) {
                return s.value;
            }
            else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(s)) {
                return traverse(s);
            }
            else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) {
                return callWithErrorHandling(s, instance, 2 /* ErrorCodes.WATCH_GETTER */);
            }
            else {
                ( true) && warnInvalidSource(s);
            }
        });
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source)) {
        if (cb) {
            // getter with cb
            getter = () => callWithErrorHandling(source, instance, 2 /* ErrorCodes.WATCH_GETTER */);
        }
        else {
            // no cb -> simple effect
            getter = () => {
                if (instance && instance.isUnmounted) {
                    return;
                }
                if (cleanup) {
                    cleanup();
                }
                return callWithAsyncErrorHandling(source, instance, 3 /* ErrorCodes.WATCH_CALLBACK */, [onCleanup]);
            };
        }
    }
    else {
        getter = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
        ( true) && warnInvalidSource(source);
    }
    if (cb && deep) {
        const baseGetter = getter;
        getter = () => traverse(baseGetter());
    }
    let cleanup;
    let onCleanup = (fn) => {
        cleanup = effect.onStop = () => {
            callWithErrorHandling(fn, instance, 4 /* ErrorCodes.WATCH_CLEANUP */);
        };
    };
    // in SSR there is no need to setup an actual effect, and it should be noop
    // unless it's eager or sync flush
    let ssrCleanup;
    if (isInSSRComponentSetup) {
        // we will also not call the invalidate callback (+ runner is not set up)
        onCleanup = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
        if (!cb) {
            getter();
        }
        else if (immediate) {
            callWithAsyncErrorHandling(cb, instance, 3 /* ErrorCodes.WATCH_CALLBACK */, [
                getter(),
                isMultiSource ? [] : undefined,
                onCleanup
            ]);
        }
        if (flush === 'sync') {
            const ctx = useSSRContext();
            ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
        }
        else {
            return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
        }
    }
    let oldValue = isMultiSource
        ? new Array(source.length).fill(INITIAL_WATCHER_VALUE)
        : INITIAL_WATCHER_VALUE;
    const job = () => {
        if (!effect.active) {
            return;
        }
        if (cb) {
            // watch(source, cb)
            const newValue = effect.run();
            if (deep ||
                forceTrigger ||
                (isMultiSource
                    ? newValue.some((v, i) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(v, oldValue[i]))
                    : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(newValue, oldValue)) ||
                (false  )) {
                // cleanup before running cb again
                if (cleanup) {
                    cleanup();
                }
                callWithAsyncErrorHandling(cb, instance, 3 /* ErrorCodes.WATCH_CALLBACK */, [
                    newValue,
                    // pass undefined as the old value when it's changed for the first time
                    oldValue === INITIAL_WATCHER_VALUE
                        ? undefined
                        : (isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE)
                            ? []
                            : oldValue,
                    onCleanup
                ]);
                oldValue = newValue;
            }
        }
        else {
            // watchEffect
            effect.run();
        }
    };
    // important: mark the job as a watcher callback so that scheduler knows
    // it is allowed to self-trigger (#1727)
    job.allowRecurse = !!cb;
    let scheduler;
    if (flush === 'sync') {
        scheduler = job; // the scheduler function gets called directly
    }
    else if (flush === 'post') {
        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
    }
    else {
        // default: 'pre'
        job.pre = true;
        if (instance)
            job.id = instance.uid;
        scheduler = () => queueJob(job);
    }
    const effect = new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect(getter, scheduler);
    if ((true)) {
        effect.onTrack = onTrack;
        effect.onTrigger = onTrigger;
    }
    // initial run
    if (cb) {
        if (immediate) {
            job();
        }
        else {
            oldValue = effect.run();
        }
    }
    else if (flush === 'post') {
        queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
    }
    else {
        effect.run();
    }
    const unwatch = () => {
        effect.stop();
        if (instance && instance.scope) {
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(instance.scope.effects, effect);
        }
    };
    if (ssrCleanup)
        ssrCleanup.push(unwatch);
    return unwatch;
}
// this.$watch
function instanceWatch(source, value, options) {
    const publicThis = this.proxy;
    const getter = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(source)
        ? source.includes('.')
            ? createPathGetter(publicThis, source)
            : () => publicThis[source]
        : source.bind(publicThis, publicThis);
    let cb;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
        cb = value;
    }
    else {
        cb = value.handler;
        options = value;
    }
    const cur = currentInstance;
    setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options);
    if (cur) {
        setCurrentInstance(cur);
    }
    else {
        unsetCurrentInstance();
    }
    return res;
}
function createPathGetter(ctx, path) {
    const segments = path.split('.');
    return () => {
        let cur = ctx;
        for (let i = 0; i < segments.length && cur; i++) {
            cur = cur[segments[i]];
        }
        return cur;
    };
}
function traverse(value, seen) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(value) || value["__v_skip" /* ReactiveFlags.SKIP */]) {
        return value;
    }
    seen = seen || new Set();
    if (seen.has(value)) {
        return value;
    }
    seen.add(value);
    if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(value)) {
        traverse(value.value, seen);
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
        for (let i = 0; i < value.length; i++) {
            traverse(value[i], seen);
        }
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isMap)(value)) {
        value.forEach((v) => {
            traverse(v, seen);
        });
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(value)) {
        for (const key in value) {
            traverse(value[key], seen);
        }
    }
    return value;
}

function useTransitionState() {
    const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: new Map()
    };
    onMounted(() => {
        state.isMounted = true;
    });
    onBeforeUnmount(() => {
        state.isUnmounting = true;
    });
    return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionImpl = {
    name: `BaseTransition`,
    props: {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        // enter
        onBeforeEnter: TransitionHookValidator,
        onEnter: TransitionHookValidator,
        onAfterEnter: TransitionHookValidator,
        onEnterCancelled: TransitionHookValidator,
        // leave
        onBeforeLeave: TransitionHookValidator,
        onLeave: TransitionHookValidator,
        onAfterLeave: TransitionHookValidator,
        onLeaveCancelled: TransitionHookValidator,
        // appear
        onBeforeAppear: TransitionHookValidator,
        onAppear: TransitionHookValidator,
        onAfterAppear: TransitionHookValidator,
        onAppearCancelled: TransitionHookValidator
    },
    setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevTransitionKey;
        return () => {
            const children = slots.default && getTransitionRawChildren(slots.default(), true);
            if (!children || !children.length) {
                return;
            }
            let child = children[0];
            if (children.length > 1) {
                let hasFound = false;
                // locate first non-comment child
                for (const c of children) {
                    if (c.type !== Comment) {
                        if (( true) && hasFound) {
                            // warn more than one non-comment child
                            warn('<transition> can only be used on a single element or component. ' +
                                'Use <transition-group> for lists.');
                            break;
                        }
                        child = c;
                        hasFound = true;
                        if (false)
                            {}
                    }
                }
            }
            // there's no need to track reactivity for these props so use the raw
            // props for a bit better perf
            const rawProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
            const { mode } = rawProps;
            // check mode
            if (( true) &&
                mode &&
                mode !== 'in-out' &&
                mode !== 'out-in' &&
                mode !== 'default') {
                warn(`invalid <transition> mode: ${mode}`);
            }
            if (state.isLeaving) {
                return emptyPlaceholder(child);
            }
            // in the case of <transition><keep-alive/></transition>, we need to
            // compare the type of the kept-alive children.
            const innerChild = getKeepAliveChild(child);
            if (!innerChild) {
                return emptyPlaceholder(child);
            }
            const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
            setTransitionHooks(innerChild, enterHooks);
            const oldChild = instance.subTree;
            const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
            let transitionKeyChanged = false;
            const { getTransitionKey } = innerChild.type;
            if (getTransitionKey) {
                const key = getTransitionKey();
                if (prevTransitionKey === undefined) {
                    prevTransitionKey = key;
                }
                else if (key !== prevTransitionKey) {
                    prevTransitionKey = key;
                    transitionKeyChanged = true;
                }
            }
            // handle mode
            if (oldInnerChild &&
                oldInnerChild.type !== Comment &&
                (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
                const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
                // update old tree's hooks in case of dynamic transition
                setTransitionHooks(oldInnerChild, leavingHooks);
                // switching between different views
                if (mode === 'out-in') {
                    state.isLeaving = true;
                    // return placeholder node and queue update when leave finishes
                    leavingHooks.afterLeave = () => {
                        state.isLeaving = false;
                        // #6835
                        // it also needs to be updated when active is undefined
                        if (instance.update.active !== false) {
                            instance.update();
                        }
                    };
                    return emptyPlaceholder(child);
                }
                else if (mode === 'in-out' && innerChild.type !== Comment) {
                    leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                        const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
                        leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                        // early removal callback
                        el._leaveCb = () => {
                            earlyRemove();
                            el._leaveCb = undefined;
                            delete enterHooks.delayedLeave;
                        };
                        enterHooks.delayedLeave = delayedLeave;
                    };
                }
            }
            return child;
        };
    }
};
// export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
        leavingVNodesCache = Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
}
// The transition hooks are attached to the vnode as vnode.transition
// and will be called at appropriate timing in the renderer.
function resolveTransitionHooks(vnode, props, state, instance) {
    const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
    const key = String(vnode.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
    const callHook = (hook, args) => {
        hook &&
            callWithAsyncErrorHandling(hook, instance, 9 /* ErrorCodes.TRANSITION_HOOK */, args);
    };
    const callAsyncHook = (hook, args) => {
        const done = args[1];
        callHook(hook, args);
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {
            if (hook.every(hook => hook.length <= 1))
                done();
        }
        else if (hook.length <= 1) {
            done();
        }
    };
    const hooks = {
        mode,
        persisted,
        beforeEnter(el) {
            let hook = onBeforeEnter;
            if (!state.isMounted) {
                if (appear) {
                    hook = onBeforeAppear || onBeforeEnter;
                }
                else {
                    return;
                }
            }
            // for same element (v-show)
            if (el._leaveCb) {
                el._leaveCb(true /* cancelled */);
            }
            // for toggled element with same key (v-if)
            const leavingVNode = leavingVNodesCache[key];
            if (leavingVNode &&
                isSameVNodeType(vnode, leavingVNode) &&
                leavingVNode.el._leaveCb) {
                // force early removal (not cancelled)
                leavingVNode.el._leaveCb();
            }
            callHook(hook, [el]);
        },
        enter(el) {
            let hook = onEnter;
            let afterHook = onAfterEnter;
            let cancelHook = onEnterCancelled;
            if (!state.isMounted) {
                if (appear) {
                    hook = onAppear || onEnter;
                    afterHook = onAfterAppear || onAfterEnter;
                    cancelHook = onAppearCancelled || onEnterCancelled;
                }
                else {
                    return;
                }
            }
            let called = false;
            const done = (el._enterCb = (cancelled) => {
                if (called)
                    return;
                called = true;
                if (cancelled) {
                    callHook(cancelHook, [el]);
                }
                else {
                    callHook(afterHook, [el]);
                }
                if (hooks.delayedLeave) {
                    hooks.delayedLeave();
                }
                el._enterCb = undefined;
            });
            if (hook) {
                callAsyncHook(hook, [el, done]);
            }
            else {
                done();
            }
        },
        leave(el, remove) {
            const key = String(vnode.key);
            if (el._enterCb) {
                el._enterCb(true /* cancelled */);
            }
            if (state.isUnmounting) {
                return remove();
            }
            callHook(onBeforeLeave, [el]);
            let called = false;
            const done = (el._leaveCb = (cancelled) => {
                if (called)
                    return;
                called = true;
                remove();
                if (cancelled) {
                    callHook(onLeaveCancelled, [el]);
                }
                else {
                    callHook(onAfterLeave, [el]);
                }
                el._leaveCb = undefined;
                if (leavingVNodesCache[key] === vnode) {
                    delete leavingVNodesCache[key];
                }
            });
            leavingVNodesCache[key] = vnode;
            if (onLeave) {
                callAsyncHook(onLeave, [el, done]);
            }
            else {
                done();
            }
        },
        clone(vnode) {
            return resolveTransitionHooks(vnode, props, state, instance);
        }
    };
    return hooks;
}
// the placeholder really only handles one special case: KeepAlive
// in the case of a KeepAlive in a leave phase we need to return a KeepAlive
// placeholder with empty content to avoid the KeepAlive instance from being
// unmounted.
function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
    }
}
function getKeepAliveChild(vnode) {
    return isKeepAlive(vnode)
        ? vnode.children
            ? vnode.children[0]
            : undefined
        : vnode;
}
function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 /* ShapeFlags.COMPONENT */ && vnode.component) {
        setTransitionHooks(vnode.component.subTree, hooks);
    }
    else if (vnode.shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {
        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    }
    else {
        vnode.transition = hooks;
    }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
    let ret = [];
    let keyedFragmentCount = 0;
    for (let i = 0; i < children.length; i++) {
        let child = children[i];
        // #5360 inherit parent key in case of <template v-for>
        const key = parentKey == null
            ? child.key
            : String(parentKey) + String(child.key != null ? child.key : i);
        // handle fragment children case, e.g. v-for
        if (child.type === Fragment) {
            if (child.patchFlag & 128 /* PatchFlags.KEYED_FRAGMENT */)
                keyedFragmentCount++;
            ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
        }
        // comment placeholders should be skipped, e.g. v-if
        else if (keepComment || child.type !== Comment) {
            ret.push(key != null ? cloneVNode(child, { key }) : child);
        }
    }
    // #1126 if a transition children list contains multiple sub fragments, these
    // fragments will be merged into a flat children array. Since each v-for
    // fragment may contain different static bindings inside, we need to de-op
    // these children to force full diffs to ensure correct behavior.
    if (keyedFragmentCount > 1) {
        for (let i = 0; i < ret.length; i++) {
            ret[i].patchFlag = -2 /* PatchFlags.BAIL */;
        }
    }
    return ret;
}

// implementation, close to no-op
function defineComponent(options) {
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options) ? { setup: options, name: options.name } : options;
}

const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
function defineAsyncComponent(source) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source)) {
        source = { loader: source };
    }
    const { loader, loadingComponent, errorComponent, delay = 200, timeout, // undefined = never times out
    suspensible = true, onError: userOnError } = source;
    let pendingRequest = null;
    let resolvedComp;
    let retries = 0;
    const retry = () => {
        retries++;
        pendingRequest = null;
        return load();
    };
    const load = () => {
        let thisRequest;
        return (pendingRequest ||
            (thisRequest = pendingRequest =
                loader()
                    .catch(err => {
                    err = err instanceof Error ? err : new Error(String(err));
                    if (userOnError) {
                        return new Promise((resolve, reject) => {
                            const userRetry = () => resolve(retry());
                            const userFail = () => reject(err);
                            userOnError(err, userRetry, userFail, retries + 1);
                        });
                    }
                    else {
                        throw err;
                    }
                })
                    .then((comp) => {
                    if (thisRequest !== pendingRequest && pendingRequest) {
                        return pendingRequest;
                    }
                    if (( true) && !comp) {
                        warn(`Async component loader resolved to undefined. ` +
                            `If you are using retry(), make sure to return its return value.`);
                    }
                    // interop module default
                    if (comp &&
                        (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {
                        comp = comp.default;
                    }
                    if (( true) && comp && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
                        throw new Error(`Invalid async component load result: ${comp}`);
                    }
                    resolvedComp = comp;
                    return comp;
                })));
    };
    return defineComponent({
        name: 'AsyncComponentWrapper',
        __asyncLoader: load,
        get __asyncResolved() {
            return resolvedComp;
        },
        setup() {
            const instance = currentInstance;
            // already resolved
            if (resolvedComp) {
                return () => createInnerComp(resolvedComp, instance);
            }
            const onError = (err) => {
                pendingRequest = null;
                handleError(err, instance, 13 /* ErrorCodes.ASYNC_COMPONENT_LOADER */, !errorComponent /* do not throw in dev if user provided error component */);
            };
            // suspense-controlled or SSR.
            if ((suspensible && instance.suspense) ||
                (isInSSRComponentSetup)) {
                return load()
                    .then(comp => {
                    return () => createInnerComp(comp, instance);
                })
                    .catch(err => {
                    onError(err);
                    return () => errorComponent
                        ? createVNode(errorComponent, {
                            error: err
                        })
                        : null;
                });
            }
            const loaded = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(false);
            const error = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)();
            const delayed = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(!!delay);
            if (delay) {
                setTimeout(() => {
                    delayed.value = false;
                }, delay);
            }
            if (timeout != null) {
                setTimeout(() => {
                    if (!loaded.value && !error.value) {
                        const err = new Error(`Async component timed out after ${timeout}ms.`);
                        onError(err);
                        error.value = err;
                    }
                }, timeout);
            }
            load()
                .then(() => {
                loaded.value = true;
                if (instance.parent && isKeepAlive(instance.parent.vnode)) {
                    // parent is keep-alive, force update so the loaded component's
                    // name is taken into account
                    queueJob(instance.parent.update);
                }
            })
                .catch(err => {
                onError(err);
                error.value = err;
            });
            return () => {
                if (loaded.value && resolvedComp) {
                    return createInnerComp(resolvedComp, instance);
                }
                else if (error.value && errorComponent) {
                    return createVNode(errorComponent, {
                        error: error.value
                    });
                }
                else if (loadingComponent && !delayed.value) {
                    return createVNode(loadingComponent);
                }
            };
        }
    });
}
function createInnerComp(comp, parent) {
    const { ref, props, children, ce } = parent.vnode;
    const vnode = createVNode(comp, props, children);
    // ensure inner component inherits the async wrapper's ref owner
    vnode.ref = ref;
    // pass the custom element callback on to the inner comp
    // and remove it from the async wrapper
    vnode.ce = ce;
    delete parent.vnode.ce;
    return vnode;
}

const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
    name: `KeepAlive`,
    // Marker for special handling inside the renderer. We are not using a ===
    // check directly on KeepAlive in the renderer, because importing it directly
    // would prevent it from being tree-shaken.
    __isKeepAlive: true,
    props: {
        include: [String, RegExp, Array],
        exclude: [String, RegExp, Array],
        max: [String, Number]
    },
    setup(props, { slots }) {
        const instance = getCurrentInstance();
        // KeepAlive communicates with the instantiated renderer via the
        // ctx where the renderer passes in its internals,
        // and the KeepAlive instance exposes activate/deactivate implementations.
        // The whole point of this is to avoid importing KeepAlive directly in the
        // renderer to facilitate tree-shaking.
        const sharedContext = instance.ctx;
        // if the internal renderer is not registered, it indicates that this is server-side rendering,
        // for KeepAlive, we just need to render its children
        if (!sharedContext.renderer) {
            return () => {
                const children = slots.default && slots.default();
                return children && children.length === 1 ? children[0] : children;
            };
        }
        const cache = new Map();
        const keys = new Set();
        let current = null;
        if (true) {
            instance.__v_cache = cache;
        }
        const parentSuspense = instance.suspense;
        const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;
        const storageContainer = createElement('div');
        sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
            const instance = vnode.component;
            move(vnode, container, anchor, 0 /* MoveType.ENTER */, parentSuspense);
            // in case props have changed
            patch(instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, vnode.slotScopeIds, optimized);
            queuePostRenderEffect(() => {
                instance.isDeactivated = false;
                if (instance.a) {
                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.a);
                }
                const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
                if (vnodeHook) {
                    invokeVNodeHook(vnodeHook, instance.parent, vnode);
                }
            }, parentSuspense);
            if (true) {
                // Update components tree
                devtoolsComponentAdded(instance);
            }
        };
        sharedContext.deactivate = (vnode) => {
            const instance = vnode.component;
            move(vnode, storageContainer, null, 1 /* MoveType.LEAVE */, parentSuspense);
            queuePostRenderEffect(() => {
                if (instance.da) {
                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.da);
                }
                const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
                if (vnodeHook) {
                    invokeVNodeHook(vnodeHook, instance.parent, vnode);
                }
                instance.isDeactivated = true;
            }, parentSuspense);
            if (true) {
                // Update components tree
                devtoolsComponentAdded(instance);
            }
        };
        function unmount(vnode) {
            // reset the shapeFlag so it can be properly unmounted
            resetShapeFlag(vnode);
            _unmount(vnode, instance, parentSuspense, true);
        }
        function pruneCache(filter) {
            cache.forEach((vnode, key) => {
                const name = getComponentName(vnode.type);
                if (name && (!filter || !filter(name))) {
                    pruneCacheEntry(key);
                }
            });
        }
        function pruneCacheEntry(key) {
            const cached = cache.get(key);
            if (!current || cached.type !== current.type) {
                unmount(cached);
            }
            else if (current) {
                // current active instance should no longer be kept-alive.
                // we can't unmount it now but it might be later, so reset its flag now.
                resetShapeFlag(current);
            }
            cache.delete(key);
            keys.delete(key);
        }
        // prune cache on include/exclude prop change
        watch(() => [props.include, props.exclude], ([include, exclude]) => {
            include && pruneCache(name => matches(include, name));
            exclude && pruneCache(name => !matches(exclude, name));
        }, 
        // prune post-render after `current` has been updated
        { flush: 'post', deep: true });
        // cache sub tree after render
        let pendingCacheKey = null;
        const cacheSubtree = () => {
            // fix #1621, the pendingCacheKey could be 0
            if (pendingCacheKey != null) {
                cache.set(pendingCacheKey, getInnerChild(instance.subTree));
            }
        };
        onMounted(cacheSubtree);
        onUpdated(cacheSubtree);
        onBeforeUnmount(() => {
            cache.forEach(cached => {
                const { subTree, suspense } = instance;
                const vnode = getInnerChild(subTree);
                if (cached.type === vnode.type) {
                    // current instance will be unmounted as part of keep-alive's unmount
                    resetShapeFlag(vnode);
                    // but invoke its deactivated hook here
                    const da = vnode.component.da;
                    da && queuePostRenderEffect(da, suspense);
                    return;
                }
                unmount(cached);
            });
        });
        return () => {
            pendingCacheKey = null;
            if (!slots.default) {
                return null;
            }
            const children = slots.default();
            const rawVNode = children[0];
            if (children.length > 1) {
                if ((true)) {
                    warn(`KeepAlive should contain exactly one component child.`);
                }
                current = null;
                return children;
            }
            else if (!isVNode(rawVNode) ||
                (!(rawVNode.shapeFlag & 4 /* ShapeFlags.STATEFUL_COMPONENT */) &&
                    !(rawVNode.shapeFlag & 128 /* ShapeFlags.SUSPENSE */))) {
                current = null;
                return rawVNode;
            }
            let vnode = getInnerChild(rawVNode);
            const comp = vnode.type;
            // for async components, name check should be based in its loaded
            // inner component if available
            const name = getComponentName(isAsyncWrapper(vnode)
                ? vnode.type.__asyncResolved || {}
                : comp);
            const { include, exclude, max } = props;
            if ((include && (!name || !matches(include, name))) ||
                (exclude && name && matches(exclude, name))) {
                current = vnode;
                return rawVNode;
            }
            const key = vnode.key == null ? comp : vnode.key;
            const cachedVNode = cache.get(key);
            // clone vnode if it's reused because we are going to mutate it
            if (vnode.el) {
                vnode = cloneVNode(vnode);
                if (rawVNode.shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {
                    rawVNode.ssContent = vnode;
                }
            }
            // #1513 it's possible for the returned vnode to be cloned due to attr
            // fallthrough or scopeId, so the vnode here may not be the final vnode
            // that is mounted. Instead of caching it directly, we store the pending
            // key and cache `instance.subTree` (the normalized vnode) in
            // beforeMount/beforeUpdate hooks.
            pendingCacheKey = key;
            if (cachedVNode) {
                // copy over mounted state
                vnode.el = cachedVNode.el;
                vnode.component = cachedVNode.component;
                if (vnode.transition) {
                    // recursively update transition hooks on subTree
                    setTransitionHooks(vnode, vnode.transition);
                }
                // avoid vnode being mounted as fresh
                vnode.shapeFlag |= 512 /* ShapeFlags.COMPONENT_KEPT_ALIVE */;
                // make this key the freshest
                keys.delete(key);
                keys.add(key);
            }
            else {
                keys.add(key);
                // prune oldest entry
                if (max && keys.size > parseInt(max, 10)) {
                    pruneCacheEntry(keys.values().next().value);
                }
            }
            // avoid vnode being unmounted
            vnode.shapeFlag |= 256 /* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */;
            current = vnode;
            return isSuspense(rawVNode.type) ? rawVNode : vnode;
        };
    }
};
// export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(pattern)) {
        return pattern.some((p) => matches(p, name));
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(pattern)) {
        return pattern.split(',').includes(name);
    }
    else if (pattern.test) {
        return pattern.test(name);
    }
    /* istanbul ignore next */
    return false;
}
function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a" /* LifecycleHooks.ACTIVATED */, target);
}
function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da" /* LifecycleHooks.DEACTIVATED */, target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
    // cache the deactivate branch check wrapper for injected hooks so the same
    // hook can be properly deduped by the scheduler. "__wdc" stands for "with
    // deactivation check".
    const wrappedHook = hook.__wdc ||
        (hook.__wdc = () => {
            // only fire the hook if the target instance is NOT in a deactivated branch.
            let current = target;
            while (current) {
                if (current.isDeactivated) {
                    return;
                }
                current = current.parent;
            }
            return hook();
        });
    injectHook(type, wrappedHook, target);
    // In addition to registering it on the target instance, we walk up the parent
    // chain and register it on all ancestor instances that are keep-alive roots.
    // This avoids the need to walk the entire component tree when invoking these
    // hooks, and more importantly, avoids the need to track child components in
    // arrays.
    if (target) {
        let current = target.parent;
        while (current && current.parent) {
            if (isKeepAlive(current.parent.vnode)) {
                injectToKeepAliveRoot(wrappedHook, type, target, current);
            }
            current = current.parent;
        }
    }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
    // injectHook wraps the original for error handling, so make sure to remove
    // the wrapped version.
    const injected = injectHook(type, hook, keepAliveRoot, true /* prepend */);
    onUnmounted(() => {
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(keepAliveRoot[type], injected);
    }, target);
}
function resetShapeFlag(vnode) {
    // bitwise operations to remove keep alive flags
    vnode.shapeFlag &= ~256 /* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */;
    vnode.shapeFlag &= ~512 /* ShapeFlags.COMPONENT_KEPT_ALIVE */;
}
function getInnerChild(vnode) {
    return vnode.shapeFlag & 128 /* ShapeFlags.SUSPENSE */ ? vnode.ssContent : vnode;
}

function injectHook(type, hook, target = currentInstance, prepend = false) {
    if (target) {
        const hooks = target[type] || (target[type] = []);
        // cache the error handling wrapper for injected hooks so the same hook
        // can be properly deduped by the scheduler. "__weh" stands for "with error
        // handling".
        const wrappedHook = hook.__weh ||
            (hook.__weh = (...args) => {
                if (target.isUnmounted) {
                    return;
                }
                // disable tracking inside all lifecycle hooks
                // since they can potentially be called inside effects.
                (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
                // Set currentInstance during hook invocation.
                // This assumes the hook does not synchronously trigger other hooks, which
                // can only be false when the user does something really funky.
                setCurrentInstance(target);
                const res = callWithAsyncErrorHandling(hook, target, type, args);
                unsetCurrentInstance();
                (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
                return res;
            });
        if (prepend) {
            hooks.unshift(wrappedHook);
        }
        else {
            hooks.push(wrappedHook);
        }
        return wrappedHook;
    }
    else if ((true)) {
        const apiName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(ErrorTypeStrings[type].replace(/ hook$/, ''));
        warn(`${apiName} is called when there is no active component instance to be ` +
            `associated with. ` +
            `Lifecycle injection APIs can only be used during execution of setup().` +
            (` If you are using async setup(), make sure to register lifecycle ` +
                    `hooks before the first await statement.`
                ));
    }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => 
// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
(!isInSSRComponentSetup || lifecycle === "sp" /* LifecycleHooks.SERVER_PREFETCH */) &&
    injectHook(lifecycle, (...args) => hook(...args), target);
const onBeforeMount = createHook("bm" /* LifecycleHooks.BEFORE_MOUNT */);
const onMounted = createHook("m" /* LifecycleHooks.MOUNTED */);
const onBeforeUpdate = createHook("bu" /* LifecycleHooks.BEFORE_UPDATE */);
const onUpdated = createHook("u" /* LifecycleHooks.UPDATED */);
const onBeforeUnmount = createHook("bum" /* LifecycleHooks.BEFORE_UNMOUNT */);
const onUnmounted = createHook("um" /* LifecycleHooks.UNMOUNTED */);
const onServerPrefetch = createHook("sp" /* LifecycleHooks.SERVER_PREFETCH */);
const onRenderTriggered = createHook("rtg" /* LifecycleHooks.RENDER_TRIGGERED */);
const onRenderTracked = createHook("rtc" /* LifecycleHooks.RENDER_TRACKED */);
function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec" /* LifecycleHooks.ERROR_CAPTURED */, hook, target);
}

/**
Runtime helper for applying directives to a vnode. Example usage:

const comp = resolveComponent('comp')
const foo = resolveDirective('foo')
const bar = resolveDirective('bar')

return withDirectives(h(comp), [
  [foo, this.x],
  [bar, this.y]
])
*/
function validateDirectiveName(name) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isBuiltInDirective)(name)) {
        warn('Do not use built-in directive ids as custom directive id: ' + name);
    }
}
/**
 * Adds directives to a VNode.
 */
function withDirectives(vnode, directives) {
    const internalInstance = currentRenderingInstance;
    if (internalInstance === null) {
        ( true) && warn(`withDirectives can only be used inside render functions.`);
        return vnode;
    }
    const instance = getExposeProxy(internalInstance) ||
        internalInstance.proxy;
    const bindings = vnode.dirs || (vnode.dirs = []);
    for (let i = 0; i < directives.length; i++) {
        let [dir, value, arg, modifiers = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ] = directives[i];
        if (dir) {
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dir)) {
                dir = {
                    mounted: dir,
                    updated: dir
                };
            }
            if (dir.deep) {
                traverse(value);
            }
            bindings.push({
                dir,
                instance,
                value,
                oldValue: void 0,
                arg,
                modifiers
            });
        }
    }
    return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i = 0; i < bindings.length; i++) {
        const binding = bindings[i];
        if (oldBindings) {
            binding.oldValue = oldBindings[i].value;
        }
        let hook = binding.dir[name];
        if (hook) {
            // disable tracking inside all lifecycle hooks
            // since they can potentially be called inside effects.
            (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
            callWithAsyncErrorHandling(hook, instance, 8 /* ErrorCodes.DIRECTIVE_HOOK */, [
                vnode.el,
                binding,
                vnode,
                prevVNode
            ]);
            (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
        }
    }
}

const COMPONENTS = 'components';
const DIRECTIVES = 'directives';
/**
 * @private
 */
function resolveComponent(name, maybeSelfReference) {
    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol();
/**
 * @private
 */
function resolveDynamicComponent(component) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(component)) {
        return resolveAsset(COMPONENTS, component, false) || component;
    }
    else {
        // invalid types will fallthrough to createVNode and raise warning
        return (component || NULL_DYNAMIC_COMPONENT);
    }
}
/**
 * @private
 */
function resolveDirective(name) {
    return resolveAsset(DIRECTIVES, name);
}
// implementation
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
        const Component = instance.type;
        // explicit self name has highest priority
        if (type === COMPONENTS) {
            const selfName = getComponentName(Component, false /* do not include inferred name to avoid breaking existing code */);
            if (selfName &&
                (selfName === name ||
                    selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name) ||
                    selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)))) {
                return Component;
            }
        }
        const res = 
        // local registration
        // check instance[type] first which is resolved for options API
        resolve(instance[type] || Component[type], name) ||
            // global registration
            resolve(instance.appContext[type], name);
        if (!res && maybeSelfReference) {
            // fallback to implicit self-reference
            return Component;
        }
        if (( true) && warnMissing && !res) {
            const extra = type === COMPONENTS
                ? `\nIf this is a native custom element, make sure to exclude it from ` +
                    `component resolution via compilerOptions.isCustomElement.`
                : ``;
            warn(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
        }
        return res;
    }
    else if ((true)) {
        warn(`resolve${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(type.slice(0, -1))} ` +
            `can only be used in render() or setup().`);
    }
}
function resolve(registry, name) {
    return (registry &&
        (registry[name] ||
            registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)] ||
            registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name))]));
}

/**
 * Actual implementation
 */
function renderList(source, renderItem, cache, index) {
    let ret;
    const cached = (cache && cache[index]);
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(source) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(source)) {
        ret = new Array(source.length);
        for (let i = 0, l = source.length; i < l; i++) {
            ret[i] = renderItem(source[i], i, undefined, cached && cached[i]);
        }
    }
    else if (typeof source === 'number') {
        if (( true) && !Number.isInteger(source)) {
            warn(`The v-for range expect an integer value but got ${source}.`);
        }
        ret = new Array(source);
        for (let i = 0; i < source; i++) {
            ret[i] = renderItem(i + 1, i, undefined, cached && cached[i]);
        }
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(source)) {
        if (source[Symbol.iterator]) {
            ret = Array.from(source, (item, i) => renderItem(item, i, undefined, cached && cached[i]));
        }
        else {
            const keys = Object.keys(source);
            ret = new Array(keys.length);
            for (let i = 0, l = keys.length; i < l; i++) {
                const key = keys[i];
                ret[i] = renderItem(source[key], key, i, cached && cached[i]);
            }
        }
    }
    else {
        ret = [];
    }
    if (cache) {
        cache[index] = ret;
    }
    return ret;
}

/**
 * Compiler runtime helper for creating dynamic slots object
 * @private
 */
function createSlots(slots, dynamicSlots) {
    for (let i = 0; i < dynamicSlots.length; i++) {
        const slot = dynamicSlots[i];
        // array of dynamic slot generated by <template v-for="..." #[...]>
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(slot)) {
            for (let j = 0; j < slot.length; j++) {
                slots[slot[j].name] = slot[j].fn;
            }
        }
        else if (slot) {
            // conditional single slot generated by <template v-if="..." #foo>
            slots[slot.name] = slot.key
                ? (...args) => {
                    const res = slot.fn(...args);
                    // attach branch key so each conditional branch is considered a
                    // different fragment
                    if (res)
                        res.key = slot.key;
                    return res;
                }
                : slot.fn;
        }
    }
    return slots;
}

/**
 * Compiler runtime helper for rendering `<slot/>`
 * @private
 */
function renderSlot(slots, name, props = {}, 
// this is not a user-facing function, so the fallback is always generated by
// the compiler and guaranteed to be a function returning an array
fallback, noSlotted) {
    if (currentRenderingInstance.isCE ||
        (currentRenderingInstance.parent &&
            isAsyncWrapper(currentRenderingInstance.parent) &&
            currentRenderingInstance.parent.isCE)) {
        if (name !== 'default')
            props.name = name;
        return createVNode('slot', props, fallback && fallback());
    }
    let slot = slots[name];
    if (( true) && slot && slot.length > 1) {
        warn(`SSR-optimized slot function detected in a non-SSR-optimized render ` +
            `function. You need to mark this component with $dynamic-slots in the ` +
            `parent template.`);
        slot = () => [];
    }
    // a compiled slot disables block tracking by default to avoid manual
    // invocation interfering with template-based block tracking, but in
    // `renderSlot` we can be sure that it's template-based so we can force
    // enable it.
    if (slot && slot._c) {
        slot._d = false;
    }
    openBlock();
    const validSlotContent = slot && ensureValidVNode(slot(props));
    const rendered = createBlock(Fragment, {
        key: props.key ||
            // slot content array of a dynamic conditional slot may have a branch
            // key attached in the `createSlots` helper, respect that
            (validSlotContent && validSlotContent.key) ||
            `_${name}`
    }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 /* SlotFlags.STABLE */
        ? 64 /* PatchFlags.STABLE_FRAGMENT */
        : -2 /* PatchFlags.BAIL */);
    if (!noSlotted && rendered.scopeId) {
        rendered.slotScopeIds = [rendered.scopeId + '-s'];
    }
    if (slot && slot._c) {
        slot._d = true;
    }
    return rendered;
}
function ensureValidVNode(vnodes) {
    return vnodes.some(child => {
        if (!isVNode(child))
            return true;
        if (child.type === Comment)
            return false;
        if (child.type === Fragment &&
            !ensureValidVNode(child.children))
            return false;
        return true;
    })
        ? vnodes
        : null;
}

/**
 * For prefixing keys in v-on="obj" with "on"
 * @private
 */
function toHandlers(obj, preserveCaseIfNecessary) {
    const ret = {};
    if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {
        warn(`v-on with no argument expects an object value.`);
        return ret;
    }
    for (const key in obj) {
        ret[preserveCaseIfNecessary && /[A-Z]/.test(key)
            ? `on:${key}`
            : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(key)] = obj[key];
    }
    return ret;
}

/**
 * #2437 In Vue 3, functional components do not have a public instance proxy but
 * they exist in the internal parent chain. For code that relies on traversing
 * public $parent chains, skip functional ones and go to the parent instead.
 */
const getPublicInstance = (i) => {
    if (!i)
        return null;
    if (isStatefulComponent(i))
        return getExposeProxy(i) || i.proxy;
    return getPublicInstance(i.parent);
};
const publicPropertiesMap = 
// Move PURE marker to new line to workaround compiler discarding it
// due to type annotation
/*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Object.create(null), {
    $: i => i,
    $el: i => i.vnode.el,
    $data: i => i.data,
    $props: i => (( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.props) : 0),
    $attrs: i => (( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.attrs) : 0),
    $slots: i => (( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.slots) : 0),
    $refs: i => (( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.refs) : 0),
    $parent: i => getPublicInstance(i.parent),
    $root: i => getPublicInstance(i.root),
    $emit: i => i.emit,
    $options: i => (__VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type),
    $forceUpdate: i => i.f || (i.f = () => queueJob(i.update)),
    $nextTick: i => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: i => (__VUE_OPTIONS_API__ ? instanceWatch.bind(i) : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP)
});
const isReservedPrefix = (key) => key === '_' || key === '$';
const hasSetupBinding = (state, key) => state !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && !state.__isScriptSetup && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(state, key);
const PublicInstanceProxyHandlers = {
    get({ _: instance }, key) {
        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
        // for internal formatters to know that this is a Vue instance
        if (( true) && key === '__isVue') {
            return true;
        }
        // data / props / ctx
        // This getter gets called for every property access on the render context
        // during render and is a major hotspot. The most expensive part of this
        // is the multiple hasOwn() calls. It's much faster to do a simple property
        // access on a plain object, so we use an accessCache object (with null
        // prototype) to memoize what access type a key corresponds to.
        let normalizedProps;
        if (key[0] !== '$') {
            const n = accessCache[key];
            if (n !== undefined) {
                switch (n) {
                    case 1 /* AccessTypes.SETUP */:
                        return setupState[key];
                    case 2 /* AccessTypes.DATA */:
                        return data[key];
                    case 4 /* AccessTypes.CONTEXT */:
                        return ctx[key];
                    case 3 /* AccessTypes.PROPS */:
                        return props[key];
                    // default: just fallthrough
                }
            }
            else if (hasSetupBinding(setupState, key)) {
                accessCache[key] = 1 /* AccessTypes.SETUP */;
                return setupState[key];
            }
            else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
                accessCache[key] = 2 /* AccessTypes.DATA */;
                return data[key];
            }
            else if (
            // only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) &&
                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(normalizedProps, key)) {
                accessCache[key] = 3 /* AccessTypes.PROPS */;
                return props[key];
            }
            else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)) {
                accessCache[key] = 4 /* AccessTypes.CONTEXT */;
                return ctx[key];
            }
            else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) {
                accessCache[key] = 0 /* AccessTypes.OTHER */;
            }
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        // public $xxx properties
        if (publicGetter) {
            if (key === '$attrs') {
                (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(instance, "get" /* TrackOpTypes.GET */, key);
                ( true) && markAttrsAccessed();
            }
            return publicGetter(instance);
        }
        else if (
        // css module (injected by vue-loader)
        (cssModule = type.__cssModules) &&
            (cssModule = cssModule[key])) {
            return cssModule;
        }
        else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)) {
            // user may set custom properties to `this` that start with `$`
            accessCache[key] = 4 /* AccessTypes.CONTEXT */;
            return ctx[key];
        }
        else if (
        // global properties
        ((globalProperties = appContext.config.globalProperties),
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(globalProperties, key))) {
            {
                return globalProperties[key];
            }
        }
        else if (( true) &&
            currentRenderingInstance &&
            (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(key) ||
                // #1091 avoid internal isRef/isVNode checks on component instance leading
                // to infinite warning loop
                key.indexOf('__v') !== 0)) {
            if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && isReservedPrefix(key[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
                warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved ` +
                    `character ("$" or "_") and is not proxied on the render context.`);
            }
            else if (instance === currentRenderingInstance) {
                warn(`Property ${JSON.stringify(key)} was accessed during render ` +
                    `but is not defined on instance.`);
            }
        }
    },
    set({ _: instance }, key, value) {
        const { data, setupState, ctx } = instance;
        if (hasSetupBinding(setupState, key)) {
            setupState[key] = value;
            return true;
        }
        else if (( true) &&
            setupState.__isScriptSetup &&
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) {
            warn(`Cannot mutate <script setup> binding "${key}" from Options API.`);
            return false;
        }
        else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
            data[key] = value;
            return true;
        }
        else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(instance.props, key)) {
            ( true) && warn(`Attempting to mutate prop "${key}". Props are readonly.`);
            return false;
        }
        if (key[0] === '$' && key.slice(1) in instance) {
            ( true) &&
                warn(`Attempting to mutate public property "${key}". ` +
                    `Properties starting with $ are reserved and readonly.`);
            return false;
        }
        else {
            if (( true) && key in instance.appContext.config.globalProperties) {
                Object.defineProperty(ctx, key, {
                    enumerable: true,
                    configurable: true,
                    value
                });
            }
            else {
                ctx[key] = value;
            }
        }
        return true;
    },
    has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
        let normalizedProps;
        return (!!accessCache[key] ||
            (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) ||
            hasSetupBinding(setupState, key) ||
            ((normalizedProps = propsOptions[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(normalizedProps, key)) ||
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key) ||
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(publicPropertiesMap, key) ||
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(appContext.config.globalProperties, key));
    },
    defineProperty(target, key, descriptor) {
        if (descriptor.get != null) {
            // invalidate key cache of a getter based property #5417
            target._.accessCache[key] = 0;
        }
        else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(descriptor, 'value')) {
            this.set(target, key, descriptor.value, null);
        }
        return Reflect.defineProperty(target, key, descriptor);
    }
};
if (true) {
    PublicInstanceProxyHandlers.ownKeys = (target) => {
        warn(`Avoid app logic that relies on enumerating keys on a component instance. ` +
            `The keys will be empty in production mode to avoid performance overhead.`);
        return Reflect.ownKeys(target);
    };
}
const RuntimeCompiledPublicInstanceProxyHandlers = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, PublicInstanceProxyHandlers, {
    get(target, key) {
        // fast path for unscopables when using `with` block
        if (key === Symbol.unscopables) {
            return;
        }
        return PublicInstanceProxyHandlers.get(target, key, target);
    },
    has(_, key) {
        const has = key[0] !== '_' && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isGloballyWhitelisted)(key);
        if (( true) && !has && PublicInstanceProxyHandlers.has(_, key)) {
            warn(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);
        }
        return has;
    }
});
// dev only
// In dev mode, the proxy target exposes the same properties as seen on `this`
// for easier console inspection. In prod mode it will be an empty object so
// these properties definitions can be skipped.
function createDevRenderContext(instance) {
    const target = {};
    // expose internal instance for proxy handlers
    Object.defineProperty(target, `_`, {
        configurable: true,
        enumerable: false,
        get: () => instance
    });
    // expose public properties
    Object.keys(publicPropertiesMap).forEach(key => {
        Object.defineProperty(target, key, {
            configurable: true,
            enumerable: false,
            get: () => publicPropertiesMap[key](instance),
            // intercepted by the proxy so no need for implementation,
            // but needed to prevent set errors
            set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
        });
    });
    return target;
}
// dev only
function exposePropsOnRenderContext(instance) {
    const { ctx, propsOptions: [propsOptions] } = instance;
    if (propsOptions) {
        Object.keys(propsOptions).forEach(key => {
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: () => instance.props[key],
                set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
            });
        });
    }
}
// dev only
function exposeSetupStateOnRenderContext(instance) {
    const { ctx, setupState } = instance;
    Object.keys((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(setupState)).forEach(key => {
        if (!setupState.__isScriptSetup) {
            if (isReservedPrefix(key[0])) {
                warn(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" ` +
                    `which are reserved prefixes for Vue internals.`);
                return;
            }
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: () => setupState[key],
                set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
            });
        }
    });
}

function createDuplicateChecker() {
    const cache = Object.create(null);
    return (type, key) => {
        if (cache[key]) {
            warn(`${type} property "${key}" is already defined in ${cache[key]}.`);
        }
        else {
            cache[key] = type;
        }
    };
}
let shouldCacheAccess = true;
function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    // do not cache property access on public proxy during state initialization
    shouldCacheAccess = false;
    // call beforeCreate first before accessing other options since
    // the hook may mutate resolved options (#2791)
    if (options.beforeCreate) {
        callHook(options.beforeCreate, instance, "bc" /* LifecycleHooks.BEFORE_CREATE */);
    }
    const { 
    // state
    data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, 
    // lifecycle
    created, beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeDestroy, beforeUnmount, destroyed, unmounted, render, renderTracked, renderTriggered, errorCaptured, serverPrefetch, 
    // public API
    expose, inheritAttrs, 
    // assets
    components, directives, filters } = options;
    const checkDuplicateProperties = ( true) ? createDuplicateChecker() : 0;
    if ((true)) {
        const [propsOptions] = instance.propsOptions;
        if (propsOptions) {
            for (const key in propsOptions) {
                checkDuplicateProperties("Props" /* OptionTypes.PROPS */, key);
            }
        }
    }
    // options initialization order (to be consistent with Vue 2):
    // - props (already done outside of this function)
    // - inject
    // - methods
    // - data (deferred since it relies on `this` access)
    // - computed
    // - watch (deferred since it relies on `this` access)
    if (injectOptions) {
        resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
    }
    if (methods) {
        for (const key in methods) {
            const methodHandler = methods[key];
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(methodHandler)) {
                // In dev mode, we use the `createRenderContext` function to define
                // methods to the proxy target, and those are read-only but
                // reconfigurable, so it needs to be redefined here
                if ((true)) {
                    Object.defineProperty(ctx, key, {
                        value: methodHandler.bind(publicThis),
                        configurable: true,
                        enumerable: true,
                        writable: true
                    });
                }
                else {}
                if ((true)) {
                    checkDuplicateProperties("Methods" /* OptionTypes.METHODS */, key);
                }
            }
            else if ((true)) {
                warn(`Method "${key}" has type "${typeof methodHandler}" in the component definition. ` +
                    `Did you reference the function correctly?`);
            }
        }
    }
    if (dataOptions) {
        if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dataOptions)) {
            warn(`The data option must be a function. ` +
                `Plain object usage is no longer supported.`);
        }
        const data = dataOptions.call(publicThis, publicThis);
        if (( true) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(data)) {
            warn(`data() returned a Promise - note data() cannot be async; If you ` +
                `intend to perform data fetching before component renders, use ` +
                `async setup() + <Suspense>.`);
        }
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(data)) {
            ( true) && warn(`data() should return an object.`);
        }
        else {
            instance.data = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive)(data);
            if ((true)) {
                for (const key in data) {
                    checkDuplicateProperties("Data" /* OptionTypes.DATA */, key);
                    // expose data on ctx during dev
                    if (!isReservedPrefix(key[0])) {
                        Object.defineProperty(ctx, key, {
                            configurable: true,
                            enumerable: true,
                            get: () => data[key],
                            set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
                        });
                    }
                }
            }
        }
    }
    // state initialization complete at this point - start caching access
    shouldCacheAccess = true;
    if (computedOptions) {
        for (const key in computedOptions) {
            const opt = computedOptions[key];
            const get = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt)
                ? opt.bind(publicThis, publicThis)
                : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt.get)
                    ? opt.get.bind(publicThis, publicThis)
                    : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
            if (( true) && get === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {
                warn(`Computed property "${key}" has no getter.`);
            }
            const set = !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt.set)
                ? opt.set.bind(publicThis)
                : ( true)
                    ? () => {
                        warn(`Write operation failed: computed property "${key}" is readonly.`);
                    }
                    : 0;
            const c = computed({
                get,
                set
            });
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: () => c.value,
                set: v => (c.value = v)
            });
            if ((true)) {
                checkDuplicateProperties("Computed" /* OptionTypes.COMPUTED */, key);
            }
        }
    }
    if (watchOptions) {
        for (const key in watchOptions) {
            createWatcher(watchOptions[key], ctx, publicThis, key);
        }
    }
    if (provideOptions) {
        const provides = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(provideOptions)
            ? provideOptions.call(publicThis)
            : provideOptions;
        Reflect.ownKeys(provides).forEach(key => {
            provide(key, provides[key]);
        });
    }
    if (created) {
        callHook(created, instance, "c" /* LifecycleHooks.CREATED */);
    }
    function registerLifecycleHook(register, hook) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {
            hook.forEach(_hook => register(_hook.bind(publicThis)));
        }
        else if (hook) {
            register(hook.bind(publicThis));
        }
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(expose)) {
        if (expose.length) {
            const exposed = instance.exposed || (instance.exposed = {});
            expose.forEach(key => {
                Object.defineProperty(exposed, key, {
                    get: () => publicThis[key],
                    set: val => (publicThis[key] = val)
                });
            });
        }
        else if (!instance.exposed) {
            instance.exposed = {};
        }
    }
    // options that are handled when creating the instance but also need to be
    // applied from mixins
    if (render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {
        instance.render = render;
    }
    if (inheritAttrs != null) {
        instance.inheritAttrs = inheritAttrs;
    }
    // asset options.
    if (components)
        instance.components = components;
    if (directives)
        instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP, unwrapRef = false) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(injectOptions)) {
        injectOptions = normalizeInject(injectOptions);
    }
    for (const key in injectOptions) {
        const opt = injectOptions[key];
        let injected;
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opt)) {
            if ('default' in opt) {
                injected = inject(opt.from || key, opt.default, true /* treat default function as factory */);
            }
            else {
                injected = inject(opt.from || key);
            }
        }
        else {
            injected = inject(opt);
        }
        if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(injected)) {
            // TODO remove the check in 3.3
            if (unwrapRef) {
                Object.defineProperty(ctx, key, {
                    enumerable: true,
                    configurable: true,
                    get: () => injected.value,
                    set: v => (injected.value = v)
                });
            }
            else {
                if ((true)) {
                    warn(`injected property "${key}" is a ref and will be auto-unwrapped ` +
                        `and no longer needs \`.value\` in the next minor release. ` +
                        `To opt-in to the new behavior now, ` +
                        `set \`app.config.unwrapInjectedRef = true\` (this config is ` +
                        `temporary and will not be needed in the future.)`);
                }
                ctx[key] = injected;
            }
        }
        else {
            ctx[key] = injected;
        }
        if ((true)) {
            checkDuplicateProperties("Inject" /* OptionTypes.INJECT */, key);
        }
    }
}
function callHook(hook, instance, type) {
    callWithAsyncErrorHandling((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)
        ? hook.map(h => h.bind(instance.proxy))
        : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key) {
    const getter = key.includes('.')
        ? createPathGetter(publicThis, key)
        : () => publicThis[key];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw)) {
        const handler = ctx[raw];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(handler)) {
            watch(getter, handler);
        }
        else if ((true)) {
            warn(`Invalid watch handler specified by key "${raw}"`, handler);
        }
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw)) {
        watch(getter, raw.bind(publicThis));
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
            raw.forEach(r => createWatcher(r, ctx, publicThis, key));
        }
        else {
            const handler = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw.handler)
                ? raw.handler.bind(publicThis)
                : ctx[raw.handler];
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(handler)) {
                watch(getter, handler, raw);
            }
            else if ((true)) {
                warn(`Invalid watch handler specified by key "${raw.handler}"`, handler);
            }
        }
    }
    else if ((true)) {
        warn(`Invalid watch option: "${key}"`, raw);
    }
}
/**
 * Resolve merged options and cache it on the component.
 * This is done only once per-component since the merging does not involve
 * instances.
 */
function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins, extends: extendsOptions } = base;
    const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
    const cached = cache.get(base);
    let resolved;
    if (cached) {
        resolved = cached;
    }
    else if (!globalMixins.length && !mixins && !extendsOptions) {
        {
            resolved = base;
        }
    }
    else {
        resolved = {};
        if (globalMixins.length) {
            globalMixins.forEach(m => mergeOptions(resolved, m, optionMergeStrategies, true));
        }
        mergeOptions(resolved, base, optionMergeStrategies);
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(base)) {
        cache.set(base, resolved);
    }
    return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) {
        mergeOptions(to, extendsOptions, strats, true);
    }
    if (mixins) {
        mixins.forEach((m) => mergeOptions(to, m, strats, true));
    }
    for (const key in from) {
        if (asMixin && key === 'expose') {
            ( true) &&
                warn(`"expose" option is ignored when declared in mixins or extends. ` +
                    `It should only be declared in the base component itself.`);
        }
        else {
            const strat = internalOptionMergeStrats[key] || (strats && strats[key]);
            to[key] = strat ? strat(to[key], from[key]) : from[key];
        }
    }
    return to;
}
const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeObjectOptions,
    emits: mergeObjectOptions,
    // objects
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    // lifecycle
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    // assets
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    // watch
    watch: mergeWatchOptions,
    // provide / inject
    provide: mergeDataFn,
    inject: mergeInject
};
function mergeDataFn(to, from) {
    if (!from) {
        return to;
    }
    if (!to) {
        return from;
    }
    return function mergedDataFn() {
        return ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend))((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(to) ? to.call(this, this) : to, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(from) ? from.call(this, this) : from);
    };
}
function mergeInject(to, from) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
        const res = {};
        for (let i = 0; i < raw.length; i++) {
            res[raw[i]] = raw[i];
        }
        return res;
    }
    return raw;
}
function mergeAsArray(to, from) {
    return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
    return to ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Object.create(null), to), from) : from;
}
function mergeWatchOptions(to, from) {
    if (!to)
        return from;
    if (!from)
        return to;
    const merged = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Object.create(null), to);
    for (const key in from) {
        merged[key] = mergeAsArray(to[key], from[key]);
    }
    return merged;
}

function initProps(instance, rawProps, isStateful, // result of bitwise flag comparison
isSSR = false) {
    const props = {};
    const attrs = {};
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(attrs, InternalObjectKey, 1);
    instance.propsDefaults = Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    // ensure all declared prop keys are present
    for (const key in instance.propsOptions[0]) {
        if (!(key in props)) {
            props[key] = undefined;
        }
    }
    // validation
    if ((true)) {
        validateProps(rawProps || {}, props, instance);
    }
    if (isStateful) {
        // stateful
        instance.props = isSSR ? props : (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive)(props);
    }
    else {
        if (!instance.type.props) {
            // functional w/ optional props, props === attrs
            instance.props = attrs;
        }
        else {
            // functional w/ declared props
            instance.props = props;
        }
    }
    instance.attrs = attrs;
}
function isInHmrContext(instance) {
    while (instance) {
        if (instance.type.__hmrId)
            return true;
        instance = instance.parent;
    }
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const { props, attrs, vnode: { patchFlag } } = instance;
    const rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !(( true) && isInHmrContext(instance)) &&
        (optimized || patchFlag > 0) &&
        !(patchFlag & 16 /* PatchFlags.FULL_PROPS */)) {
        if (patchFlag & 8 /* PatchFlags.PROPS */) {
            // Compiler-generated props & no keys change, just set the updated
            // the props.
            const propsToUpdate = instance.vnode.dynamicProps;
            for (let i = 0; i < propsToUpdate.length; i++) {
                let key = propsToUpdate[i];
                // skip if the prop key is a declared emit event listener
                if (isEmitListener(instance.emitsOptions, key)) {
                    continue;
                }
                // PROPS flag guarantees rawProps to be non-null
                const value = rawProps[key];
                if (options) {
                    // attr / props separation was done on init and will be consistent
                    // in this code path, so just check if attrs have it.
                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(attrs, key)) {
                        if (value !== attrs[key]) {
                            attrs[key] = value;
                            hasAttrsChanged = true;
                        }
                    }
                    else {
                        const camelizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);
                        props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false /* isAbsent */);
                    }
                }
                else {
                    if (value !== attrs[key]) {
                        attrs[key] = value;
                        hasAttrsChanged = true;
                    }
                }
            }
        }
    }
    else {
        // full props update.
        if (setFullProps(instance, rawProps, props, attrs)) {
            hasAttrsChanged = true;
        }
        // in case of dynamic props, check if we need to delete keys from
        // the props object
        let kebabKey;
        for (const key in rawCurrentProps) {
            if (!rawProps ||
                // for camelCase
                (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) &&
                    // it's possible the original props was passed in as kebab-case
                    // and converted to camelCase (#955)
                    ((kebabKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)) === key || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, kebabKey)))) {
                if (options) {
                    if (rawPrevProps &&
                        // for camelCase
                        (rawPrevProps[key] !== undefined ||
                            // for kebab-case
                            rawPrevProps[kebabKey] !== undefined)) {
                        props[key] = resolvePropValue(options, rawCurrentProps, key, undefined, instance, true /* isAbsent */);
                    }
                }
                else {
                    delete props[key];
                }
            }
        }
        // in the case of functional component w/o props declaration, props and
        // attrs point to the same object so it should already have been updated.
        if (attrs !== rawCurrentProps) {
            for (const key in attrs) {
                if (!rawProps ||
                    (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) &&
                        (!false ))) {
                    delete attrs[key];
                    hasAttrsChanged = true;
                }
            }
        }
    }
    // trigger updates for $attrs in case it's used in component slots
    if (hasAttrsChanged) {
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.trigger)(instance, "set" /* TriggerOpTypes.SET */, '$attrs');
    }
    if ((true)) {
        validateProps(rawProps || {}, props, instance);
    }
}
function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) {
        for (let key in rawProps) {
            // key, ref are reserved and never passed down
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {
                continue;
            }
            const value = rawProps[key];
            // prop option names are camelized during normalization, so to support
            // kebab -> camel conversion here we need to camelize the key.
            let camelKey;
            if (options && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, (camelKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key)))) {
                if (!needCastKeys || !needCastKeys.includes(camelKey)) {
                    props[camelKey] = value;
                }
                else {
                    (rawCastValues || (rawCastValues = {}))[camelKey] = value;
                }
            }
            else if (!isEmitListener(instance.emitsOptions, key)) {
                if (!(key in attrs) || value !== attrs[key]) {
                    attrs[key] = value;
                    hasAttrsChanged = true;
                }
            }
        }
    }
    if (needCastKeys) {
        const rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
        const castValues = rawCastValues || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        for (let i = 0; i < needCastKeys.length; i++) {
            const key = needCastKeys[i];
            props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(castValues, key));
        }
    }
    return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
    const opt = options[key];
    if (opt != null) {
        const hasDefault = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(opt, 'default');
        // default values
        if (hasDefault && value === undefined) {
            const defaultValue = opt.default;
            if (opt.type !== Function && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(defaultValue)) {
                const { propsDefaults } = instance;
                if (key in propsDefaults) {
                    value = propsDefaults[key];
                }
                else {
                    setCurrentInstance(instance);
                    value = propsDefaults[key] = defaultValue.call(null, props);
                    unsetCurrentInstance();
                }
            }
            else {
                value = defaultValue;
            }
        }
        // boolean casting
        if (opt[0 /* BooleanFlags.shouldCast */]) {
            if (isAbsent && !hasDefault) {
                value = false;
            }
            else if (opt[1 /* BooleanFlags.shouldCastTrue */] &&
                (value === '' || value === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key))) {
                value = true;
            }
        }
    }
    return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.propsCache;
    const cached = cache.get(comp);
    if (cached) {
        return cached;
    }
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    // apply mixin/extends props
    let hasExtends = false;
    if (__VUE_OPTIONS_API__ && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
        const extendProps = (raw) => {
            hasExtends = true;
            const [props, keys] = normalizePropsOptions(raw, appContext, true);
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, props);
            if (keys)
                needCastKeys.push(...keys);
        };
        if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendProps);
        }
        if (comp.extends) {
            extendProps(comp.extends);
        }
        if (comp.mixins) {
            comp.mixins.forEach(extendProps);
        }
    }
    if (!raw && !hasExtends) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp)) {
            cache.set(comp, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR);
        }
        return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
        for (let i = 0; i < raw.length; i++) {
            if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw[i])) {
                warn(`props must be strings when using array syntax.`, raw[i]);
            }
            const normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(raw[i]);
            if (validatePropName(normalizedKey)) {
                normalized[normalizedKey] = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
            }
        }
    }
    else if (raw) {
        if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)) {
            warn(`invalid props options`, raw);
        }
        for (const key in raw) {
            const normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);
            if (validatePropName(normalizedKey)) {
                const opt = raw[key];
                const prop = (normalized[normalizedKey] =
                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opt) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) ? { type: opt } : Object.assign({}, opt));
                if (prop) {
                    const booleanIndex = getTypeIndex(Boolean, prop.type);
                    const stringIndex = getTypeIndex(String, prop.type);
                    prop[0 /* BooleanFlags.shouldCast */] = booleanIndex > -1;
                    prop[1 /* BooleanFlags.shouldCastTrue */] =
                        stringIndex < 0 || booleanIndex < stringIndex;
                    // if the prop needs boolean casting or default value
                    if (booleanIndex > -1 || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(prop, 'default')) {
                        needCastKeys.push(normalizedKey);
                    }
                }
            }
        }
    }
    const res = [normalized, needCastKeys];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp)) {
        cache.set(comp, res);
    }
    return res;
}
function validatePropName(key) {
    if (key[0] !== '$') {
        return true;
    }
    else if ((true)) {
        warn(`Invalid prop name: "${key}" is a reserved property.`);
    }
    return false;
}
// use function string name to check type constructors
// so that it works across vms / iframes.
function getType(ctor) {
    const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
    return match ? match[1] : ctor === null ? 'null' : '';
}
function isSameType(a, b) {
    return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(expectedTypes)) {
        return expectedTypes.findIndex(t => isSameType(t, type));
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(expectedTypes)) {
        return isSameType(expectedTypes, type) ? 0 : -1;
    }
    return -1;
}
/**
 * dev only
 */
function validateProps(rawProps, props, instance) {
    const resolvedValues = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
    const options = instance.propsOptions[0];
    for (const key in options) {
        let opt = options[key];
        if (opt == null)
            continue;
        validateProp(key, resolvedValues[key], opt, !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)));
    }
}
/**
 * dev only
 */
function validateProp(name, value, prop, isAbsent) {
    const { type, required, validator } = prop;
    // required!
    if (required && isAbsent) {
        warn('Missing required prop: "' + name + '"');
        return;
    }
    // missing but optional
    if (value == null && !prop.required) {
        return;
    }
    // type check
    if (type != null && type !== true) {
        let isValid = false;
        const types = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(type) ? type : [type];
        const expectedTypes = [];
        // value is valid as long as one of the specified types match
        for (let i = 0; i < types.length && !isValid; i++) {
            const { valid, expectedType } = assertType(value, types[i]);
            expectedTypes.push(expectedType || '');
            isValid = valid;
        }
        if (!isValid) {
            warn(getInvalidTypeMessage(name, value, expectedTypes));
            return;
        }
    }
    // custom validator
    if (validator && !validator(value)) {
        warn('Invalid prop: custom validator check failed for prop "' + name + '".');
    }
}
const isSimpleType = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('String,Number,Boolean,Function,Symbol,BigInt');
/**
 * dev only
 */
function assertType(value, type) {
    let valid;
    const expectedType = getType(type);
    if (isSimpleType(expectedType)) {
        const t = typeof value;
        valid = t === expectedType.toLowerCase();
        // for primitive wrapper objects
        if (!valid && t === 'object') {
            valid = value instanceof type;
        }
    }
    else if (expectedType === 'Object') {
        valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(value);
    }
    else if (expectedType === 'Array') {
        valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value);
    }
    else if (expectedType === 'null') {
        valid = value === null;
    }
    else {
        valid = value instanceof type;
    }
    return {
        valid,
        expectedType
    };
}
/**
 * dev only
 */
function getInvalidTypeMessage(name, value, expectedTypes) {
    let message = `Invalid prop: type check failed for prop "${name}".` +
        ` Expected ${expectedTypes.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize).join(' | ')}`;
    const expectedType = expectedTypes[0];
    const receivedType = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toRawType)(value);
    const expectedValue = styleValue(value, expectedType);
    const receivedValue = styleValue(value, receivedType);
    // check if we need to specify expected value
    if (expectedTypes.length === 1 &&
        isExplicable(expectedType) &&
        !isBoolean(expectedType, receivedType)) {
        message += ` with value ${expectedValue}`;
    }
    message += `, got ${receivedType} `;
    // check if we need to specify received value
    if (isExplicable(receivedType)) {
        message += `with value ${receivedValue}.`;
    }
    return message;
}
/**
 * dev only
 */
function styleValue(value, type) {
    if (type === 'String') {
        return `"${value}"`;
    }
    else if (type === 'Number') {
        return `${Number(value)}`;
    }
    else {
        return `${value}`;
    }
}
/**
 * dev only
 */
function isExplicable(type) {
    const explicitTypes = ['string', 'number', 'boolean'];
    return explicitTypes.some(elem => type.toLowerCase() === elem);
}
/**
 * dev only
 */
function isBoolean(...args) {
    return args.some(elem => elem.toLowerCase() === 'boolean');
}

const isInternalKey = (key) => key[0] === '_' || key === '$stable';
const normalizeSlotValue = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)
    ? value.map(normalizeVNode)
    : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
    if (rawSlot._n) {
        // already normalized - #5353
        return rawSlot;
    }
    const normalized = withCtx((...args) => {
        if (( true) && currentInstance) {
            warn(`Slot "${key}" invoked outside of the render function: ` +
                `this will not track dependencies used in the slot. ` +
                `Invoke the slot function inside the render function instead.`);
        }
        return normalizeSlotValue(rawSlot(...args));
    }, ctx);
    normalized._c = false;
    return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
    const ctx = rawSlots._ctx;
    for (const key in rawSlots) {
        if (isInternalKey(key))
            continue;
        const value = rawSlots[key];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
            slots[key] = normalizeSlot(key, value, ctx);
        }
        else if (value != null) {
            if (true) {
                warn(`Non-function value encountered for slot "${key}". ` +
                    `Prefer function slots for better performance.`);
            }
            const normalized = normalizeSlotValue(value);
            slots[key] = () => normalized;
        }
    }
};
const normalizeVNodeSlots = (instance, children) => {
    if (( true) &&
        !isKeepAlive(instance.vnode) &&
        !(false )) {
        warn(`Non-function value encountered for default slot. ` +
            `Prefer function slots for better performance.`);
    }
    const normalized = normalizeSlotValue(children);
    instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
    if (instance.vnode.shapeFlag & 32 /* ShapeFlags.SLOTS_CHILDREN */) {
        const type = children._;
        if (type) {
            // users can get the shallow readonly version of the slots object through `this.$slots`,
            // we should avoid the proxy object polluting the slots of the internal instance
            instance.slots = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(children);
            // make compiler marker non-enumerable
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(children, '_', type);
        }
        else {
            normalizeObjectSlots(children, (instance.slots = {}));
        }
    }
    else {
        instance.slots = {};
        if (children) {
            normalizeVNodeSlots(instance, children);
        }
    }
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    if (vnode.shapeFlag & 32 /* ShapeFlags.SLOTS_CHILDREN */) {
        const type = children._;
        if (type) {
            // compiled slots.
            if (( true) && isHmrUpdating) {
                // Parent was HMR updated so slot content may have changed.
                // force update slots and mark instance for hmr as well
                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(slots, children);
            }
            else if (optimized && type === 1 /* SlotFlags.STABLE */) {
                // compiled AND stable.
                // no need to update, and skip stale slots removal.
                needDeletionCheck = false;
            }
            else {
                // compiled but dynamic (v-if/v-for on slots) - update slots, but skip
                // normalization.
                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(slots, children);
                // #2893
                // when rendering the optimized slots by manually written render function,
                // we need to delete the `slots._` flag if necessary to make subsequent updates reliable,
                // i.e. let the `renderSlot` create the bailed Fragment
                if (!optimized && type === 1 /* SlotFlags.STABLE */) {
                    delete slots._;
                }
            }
        }
        else {
            needDeletionCheck = !children.$stable;
            normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
    }
    else if (children) {
        // non slot object children (direct value) passed to a component
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = { default: 1 };
    }
    // delete stale slots
    if (needDeletionCheck) {
        for (const key in slots) {
            if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
                delete slots[key];
            }
        }
    }
};

function createAppContext() {
    return {
        app: null,
        config: {
            isNativeTag: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO,
            performance: false,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: undefined,
            warnHandler: undefined,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap(),
        propsCache: new WeakMap(),
        emitsCache: new WeakMap()
    };
}
let uid = 0;
function createAppAPI(render, hydrate) {
    return function createApp(rootComponent, rootProps = null) {
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(rootComponent)) {
            rootComponent = Object.assign({}, rootComponent);
        }
        if (rootProps != null && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(rootProps)) {
            ( true) && warn(`root props passed to app.mount() must be an object.`);
            rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = new Set();
        let isMounted = false;
        const app = (context.app = {
            _uid: uid++,
            _component: rootComponent,
            _props: rootProps,
            _container: null,
            _context: context,
            _instance: null,
            version,
            get config() {
                return context.config;
            },
            set config(v) {
                if ((true)) {
                    warn(`app.config cannot be replaced. Modify individual options instead.`);
                }
            },
            use(plugin, ...options) {
                if (installedPlugins.has(plugin)) {
                    ( true) && warn(`Plugin has already been applied to target app.`);
                }
                else if (plugin && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(plugin.install)) {
                    installedPlugins.add(plugin);
                    plugin.install(app, ...options);
                }
                else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(plugin)) {
                    installedPlugins.add(plugin);
                    plugin(app, ...options);
                }
                else if ((true)) {
                    warn(`A plugin must either be a function or an object with an "install" ` +
                        `function.`);
                }
                return app;
            },
            mixin(mixin) {
                if (__VUE_OPTIONS_API__) {
                    if (!context.mixins.includes(mixin)) {
                        context.mixins.push(mixin);
                    }
                    else if ((true)) {
                        warn('Mixin has already been applied to target app' +
                            (mixin.name ? `: ${mixin.name}` : ''));
                    }
                }
                else if ((true)) {
                    warn('Mixins are only available in builds supporting Options API');
                }
                return app;
            },
            component(name, component) {
                if ((true)) {
                    validateComponentName(name, context.config);
                }
                if (!component) {
                    return context.components[name];
                }
                if (( true) && context.components[name]) {
                    warn(`Component "${name}" has already been registered in target app.`);
                }
                context.components[name] = component;
                return app;
            },
            directive(name, directive) {
                if ((true)) {
                    validateDirectiveName(name);
                }
                if (!directive) {
                    return context.directives[name];
                }
                if (( true) && context.directives[name]) {
                    warn(`Directive "${name}" has already been registered in target app.`);
                }
                context.directives[name] = directive;
                return app;
            },
            mount(rootContainer, isHydrate, isSVG) {
                if (!isMounted) {
                    // #5571
                    if (( true) && rootContainer.__vue_app__) {
                        warn(`There is already an app instance mounted on the host container.\n` +
                            ` If you want to mount another app on the same host container,` +
                            ` you need to unmount the previous app by calling \`app.unmount()\` first.`);
                    }
                    const vnode = createVNode(rootComponent, rootProps);
                    // store app context on the root VNode.
                    // this will be set on the root instance on initial mount.
                    vnode.appContext = context;
                    // HMR root reload
                    if ((true)) {
                        context.reload = () => {
                            render(cloneVNode(vnode), rootContainer, isSVG);
                        };
                    }
                    if (isHydrate && hydrate) {
                        hydrate(vnode, rootContainer);
                    }
                    else {
                        render(vnode, rootContainer, isSVG);
                    }
                    isMounted = true;
                    app._container = rootContainer;
                    rootContainer.__vue_app__ = app;
                    if (true) {
                        app._instance = vnode.component;
                        devtoolsInitApp(app, version);
                    }
                    return getExposeProxy(vnode.component) || vnode.component.proxy;
                }
                else if ((true)) {
                    warn(`App has already been mounted.\n` +
                        `If you want to remount the same app, move your app creation logic ` +
                        `into a factory function and create fresh app instances for each ` +
                        `mount - e.g. \`const createMyApp = () => createApp(App)\``);
                }
            },
            unmount() {
                if (isMounted) {
                    render(null, app._container);
                    if (true) {
                        app._instance = null;
                        devtoolsUnmountApp(app);
                    }
                    delete app._container.__vue_app__;
                }
                else if ((true)) {
                    warn(`Cannot unmount an app that is not mounted.`);
                }
            },
            provide(key, value) {
                if (( true) && key in context.provides) {
                    warn(`App already provides property with key "${String(key)}". ` +
                        `It will be overwritten with the new value.`);
                }
                context.provides[key] = value;
                return app;
            }
        });
        return app;
    };
}

/**
 * Function for handling a template ref
 */
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(rawRef)) {
        rawRef.forEach((r, i) => setRef(r, oldRawRef && ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
        return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) {
        // when mounting async components, nothing needs to be done,
        // because the template ref is forwarded to inner component
        return;
    }
    const refValue = vnode.shapeFlag & 4 /* ShapeFlags.STATEFUL_COMPONENT */
        ? getExposeProxy(vnode.component) || vnode.component.proxy
        : vnode.el;
    const value = isUnmount ? null : refValue;
    const { i: owner, r: ref } = rawRef;
    if (( true) && !owner) {
        warn(`Missing ref owner context. ref cannot be used on hoisted vnodes. ` +
            `A vnode with ref must be created inside the render function.`);
        return;
    }
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ ? (owner.refs = {}) : owner.refs;
    const setupState = owner.setupState;
    // dynamic ref changed. unset old ref
    if (oldRef != null && oldRef !== ref) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(oldRef)) {
            refs[oldRef] = null;
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, oldRef)) {
                setupState[oldRef] = null;
            }
        }
        else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(oldRef)) {
            oldRef.value = null;
        }
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref)) {
        callWithErrorHandling(ref, owner, 12 /* ErrorCodes.FUNCTION_REF */, [value, refs]);
    }
    else {
        const _isString = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref);
        const _isRef = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref);
        if (_isString || _isRef) {
            const doSet = () => {
                if (rawRef.f) {
                    const existing = _isString
                        ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, ref)
                            ? setupState[ref]
                            : refs[ref]
                        : ref.value;
                    if (isUnmount) {
                        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(existing) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(existing, refValue);
                    }
                    else {
                        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(existing)) {
                            if (_isString) {
                                refs[ref] = [refValue];
                                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, ref)) {
                                    setupState[ref] = refs[ref];
                                }
                            }
                            else {
                                ref.value = [refValue];
                                if (rawRef.k)
                                    refs[rawRef.k] = ref.value;
                            }
                        }
                        else if (!existing.includes(refValue)) {
                            existing.push(refValue);
                        }
                    }
                }
                else if (_isString) {
                    refs[ref] = value;
                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, ref)) {
                        setupState[ref] = value;
                    }
                }
                else if (_isRef) {
                    ref.value = value;
                    if (rawRef.k)
                        refs[rawRef.k] = value;
                }
                else if ((true)) {
                    warn('Invalid template ref type:', ref, `(${typeof ref})`);
                }
            };
            if (value) {
                doSet.id = -1;
                queuePostRenderEffect(doSet, parentSuspense);
            }
            else {
                doSet();
            }
        }
        else if ((true)) {
            warn('Invalid template ref type:', ref, `(${typeof ref})`);
        }
    }
}

let hasMismatch = false;
const isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== 'foreignObject';
const isComment = (node) => node.nodeType === 8 /* DOMNodeTypes.COMMENT */;
// Note: hydration is DOM-specific
// But we have to place it in core due to tight coupling with core - splitting
// it out creates a ton of unnecessary complexity.
// Hydration also depends on some renderer internal logic which needs to be
// passed in via arguments.
function createHydrationFunctions(rendererInternals) {
    const { mt: mountComponent, p: patch, o: { patchProp, createText, nextSibling, parentNode, remove, insert, createComment } } = rendererInternals;
    const hydrate = (vnode, container) => {
        if (!container.hasChildNodes()) {
            ( true) &&
                warn(`Attempting to hydrate existing markup but container is empty. ` +
                    `Performing full mount instead.`);
            patch(null, vnode, container);
            flushPostFlushCbs();
            container._vnode = vnode;
            return;
        }
        hasMismatch = false;
        hydrateNode(container.firstChild, vnode, null, null, null);
        flushPostFlushCbs();
        container._vnode = vnode;
        if (hasMismatch && !false) {
            // this error should show up in production
            console.error(`Hydration completed but contains mismatches.`);
        }
    };
    const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
        const isFragmentStart = isComment(node) && node.data === '[';
        const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
        const { type, ref, shapeFlag, patchFlag } = vnode;
        let domType = node.nodeType;
        vnode.el = node;
        if (patchFlag === -2 /* PatchFlags.BAIL */) {
            optimized = false;
            vnode.dynamicChildren = null;
        }
        let nextNode = null;
        switch (type) {
            case Text:
                if (domType !== 3 /* DOMNodeTypes.TEXT */) {
                    // #5728 empty text node inside a slot can cause hydration failure
                    // because the server rendered HTML won't contain a text node
                    if (vnode.children === '') {
                        insert((vnode.el = createText('')), parentNode(node), node);
                        nextNode = node;
                    }
                    else {
                        nextNode = onMismatch();
                    }
                }
                else {
                    if (node.data !== vnode.children) {
                        hasMismatch = true;
                        ( true) &&
                            warn(`Hydration text mismatch:` +
                                `\n- Client: ${JSON.stringify(node.data)}` +
                                `\n- Server: ${JSON.stringify(vnode.children)}`);
                        node.data = vnode.children;
                    }
                    nextNode = nextSibling(node);
                }
                break;
            case Comment:
                if (domType !== 8 /* DOMNodeTypes.COMMENT */ || isFragmentStart) {
                    nextNode = onMismatch();
                }
                else {
                    nextNode = nextSibling(node);
                }
                break;
            case Static:
                if (isFragmentStart) {
                    // entire template is static but SSRed as a fragment
                    node = nextSibling(node);
                    domType = node.nodeType;
                }
                if (domType === 1 /* DOMNodeTypes.ELEMENT */ || domType === 3 /* DOMNodeTypes.TEXT */) {
                    // determine anchor, adopt content
                    nextNode = node;
                    // if the static vnode has its content stripped during build,
                    // adopt it from the server-rendered HTML.
                    const needToAdoptContent = !vnode.children.length;
                    for (let i = 0; i < vnode.staticCount; i++) {
                        if (needToAdoptContent)
                            vnode.children +=
                                nextNode.nodeType === 1 /* DOMNodeTypes.ELEMENT */
                                    ? nextNode.outerHTML
                                    : nextNode.data;
                        if (i === vnode.staticCount - 1) {
                            vnode.anchor = nextNode;
                        }
                        nextNode = nextSibling(nextNode);
                    }
                    return isFragmentStart ? nextSibling(nextNode) : nextNode;
                }
                else {
                    onMismatch();
                }
                break;
            case Fragment:
                if (!isFragmentStart) {
                    nextNode = onMismatch();
                }
                else {
                    nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                }
                break;
            default:
                if (shapeFlag & 1 /* ShapeFlags.ELEMENT */) {
                    if (domType !== 1 /* DOMNodeTypes.ELEMENT */ ||
                        vnode.type.toLowerCase() !==
                            node.tagName.toLowerCase()) {
                        nextNode = onMismatch();
                    }
                    else {
                        nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                    }
                }
                else if (shapeFlag & 6 /* ShapeFlags.COMPONENT */) {
                    // when setting up the render effect, if the initial vnode already
                    // has .el set, the component will perform hydration instead of mount
                    // on its sub-tree.
                    vnode.slotScopeIds = slotScopeIds;
                    const container = parentNode(node);
                    mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);
                    // component may be async, so in the case of fragments we cannot rely
                    // on component's rendered output to determine the end of the fragment
                    // instead, we do a lookahead to find the end anchor node.
                    nextNode = isFragmentStart
                        ? locateClosingAsyncAnchor(node)
                        : nextSibling(node);
                    // #4293 teleport as component root
                    if (nextNode &&
                        isComment(nextNode) &&
                        nextNode.data === 'teleport end') {
                        nextNode = nextSibling(nextNode);
                    }
                    // #3787
                    // if component is async, it may get moved / unmounted before its
                    // inner component is loaded, so we need to give it a placeholder
                    // vnode that matches its adopted DOM.
                    if (isAsyncWrapper(vnode)) {
                        let subTree;
                        if (isFragmentStart) {
                            subTree = createVNode(Fragment);
                            subTree.anchor = nextNode
                                ? nextNode.previousSibling
                                : container.lastChild;
                        }
                        else {
                            subTree =
                                node.nodeType === 3 ? createTextVNode('') : createVNode('div');
                        }
                        subTree.el = node;
                        vnode.component.subTree = subTree;
                    }
                }
                else if (shapeFlag & 64 /* ShapeFlags.TELEPORT */) {
                    if (domType !== 8 /* DOMNodeTypes.COMMENT */) {
                        nextNode = onMismatch();
                    }
                    else {
                        nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
                    }
                }
                else if (shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {
                    nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);
                }
                else if ((true)) {
                    warn('Invalid HostVNode type:', type, `(${typeof type})`);
                }
        }
        if (ref != null) {
            setRef(ref, null, parentSuspense, vnode);
        }
        return nextNode;
    };
    const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
        optimized = optimized || !!vnode.dynamicChildren;
        const { type, props, patchFlag, shapeFlag, dirs } = vnode;
        // #4006 for form elements with non-string v-model value bindings
        // e.g. <option :value="obj">, <input type="checkbox" :true-value="1">
        const forcePatchValue = (type === 'input' && dirs) || type === 'option';
        // skip props & children if this is hoisted static nodes
        // #5405 in dev, always hydrate children for HMR
        if (true /* PatchFlags.HOISTED */) {
            if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'created');
            }
            // props
            if (props) {
                if (forcePatchValue ||
                    !optimized ||
                    patchFlag & (16 /* PatchFlags.FULL_PROPS */ | 32 /* PatchFlags.HYDRATE_EVENTS */)) {
                    for (const key in props) {
                        if ((forcePatchValue && key.endsWith('value')) ||
                            ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key))) {
                            patchProp(el, key, null, props[key], false, undefined, parentComponent);
                        }
                    }
                }
                else if (props.onClick) {
                    // Fast path for click listeners (which is most often) to avoid
                    // iterating through props.
                    patchProp(el, 'onClick', null, props.onClick, false, undefined, parentComponent);
                }
            }
            // vnode / directive hooks
            let vnodeHooks;
            if ((vnodeHooks = props && props.onVnodeBeforeMount)) {
                invokeVNodeHook(vnodeHooks, parentComponent, vnode);
            }
            if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
            }
            if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {
                queueEffectWithSuspense(() => {
                    vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
                    dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
                }, parentSuspense);
            }
            // children
            if (shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */ &&
                // skip if element has innerHTML / textContent
                !(props && (props.innerHTML || props.textContent))) {
                let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);
                let hasWarned = false;
                while (next) {
                    hasMismatch = true;
                    if (( true) && !hasWarned) {
                        warn(`Hydration children mismatch in <${vnode.type}>: ` +
                            `server rendered element contains more child nodes than client vdom.`);
                        hasWarned = true;
                    }
                    // The SSRed DOM contains more nodes than it should. Remove them.
                    const cur = next;
                    next = next.nextSibling;
                    remove(cur);
                }
            }
            else if (shapeFlag & 8 /* ShapeFlags.TEXT_CHILDREN */) {
                if (el.textContent !== vnode.children) {
                    hasMismatch = true;
                    ( true) &&
                        warn(`Hydration text content mismatch in <${vnode.type}>:\n` +
                            `- Client: ${el.textContent}\n` +
                            `- Server: ${vnode.children}`);
                    el.textContent = vnode.children;
                }
            }
        }
        return el.nextSibling;
    };
    const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
        optimized = optimized || !!parentVNode.dynamicChildren;
        const children = parentVNode.children;
        const l = children.length;
        let hasWarned = false;
        for (let i = 0; i < l; i++) {
            const vnode = optimized
                ? children[i]
                : (children[i] = normalizeVNode(children[i]));
            if (node) {
                node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
            }
            else if (vnode.type === Text && !vnode.children) {
                continue;
            }
            else {
                hasMismatch = true;
                if (( true) && !hasWarned) {
                    warn(`Hydration children mismatch in <${container.tagName.toLowerCase()}>: ` +
                        `server rendered element contains fewer child nodes than client vdom.`);
                    hasWarned = true;
                }
                // the SSRed DOM didn't contain enough nodes. Mount the missing ones.
                patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
            }
        }
        return node;
    };
    const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
        const { slotScopeIds: fragmentSlotScopeIds } = vnode;
        if (fragmentSlotScopeIds) {
            slotScopeIds = slotScopeIds
                ? slotScopeIds.concat(fragmentSlotScopeIds)
                : fragmentSlotScopeIds;
        }
        const container = parentNode(node);
        const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);
        if (next && isComment(next) && next.data === ']') {
            return nextSibling((vnode.anchor = next));
        }
        else {
            // fragment didn't hydrate successfully, since we didn't get a end anchor
            // back. This should have led to node/children mismatch warnings.
            hasMismatch = true;
            // since the anchor is missing, we need to create one and insert it
            insert((vnode.anchor = createComment(`]`)), container, next);
            return next;
        }
    };
    const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
        hasMismatch = true;
        ( true) &&
            warn(`Hydration node mismatch:\n- Client vnode:`, vnode.type, `\n- Server rendered DOM:`, node, node.nodeType === 3 /* DOMNodeTypes.TEXT */
                ? `(text)`
                : isComment(node) && node.data === '['
                    ? `(start of fragment)`
                    : ``);
        vnode.el = null;
        if (isFragment) {
            // remove excessive fragment nodes
            const end = locateClosingAsyncAnchor(node);
            while (true) {
                const next = nextSibling(node);
                if (next && next !== end) {
                    remove(next);
                }
                else {
                    break;
                }
            }
        }
        const next = nextSibling(node);
        const container = parentNode(node);
        remove(node);
        patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
        return next;
    };
    const locateClosingAsyncAnchor = (node) => {
        let match = 0;
        while (node) {
            node = nextSibling(node);
            if (node && isComment(node)) {
                if (node.data === '[')
                    match++;
                if (node.data === ']') {
                    if (match === 0) {
                        return nextSibling(node);
                    }
                    else {
                        match--;
                    }
                }
            }
        }
        return node;
    };
    return [hydrate, hydrateNode];
}

/* eslint-disable no-restricted-globals */
let supported;
let perf;
function startMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
        perf.mark(`vue-${type}-${instance.uid}`);
    }
    if (true) {
        devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());
    }
}
function endMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
        const startTag = `vue-${type}-${instance.uid}`;
        const endTag = startTag + `:end`;
        perf.mark(endTag);
        perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);
        perf.clearMarks(startTag);
        perf.clearMarks(endTag);
    }
    if (true) {
        devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());
    }
}
function isSupported() {
    if (supported !== undefined) {
        return supported;
    }
    if (typeof window !== 'undefined' && window.performance) {
        supported = true;
        perf = window.performance;
    }
    else {
        supported = false;
    }
    return supported;
}

/**
 * This is only called in esm-bundler builds.
 * It is called when a renderer is created, in `baseCreateRenderer` so that
 * importing runtime-core is side-effects free.
 *
 * istanbul-ignore-next
 */
function initFeatureFlags() {
    const needWarn = [];
    if (typeof __VUE_OPTIONS_API__ !== 'boolean') {
        ( true) && needWarn.push(`__VUE_OPTIONS_API__`);
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_OPTIONS_API__ = true;
    }
    if (typeof __VUE_PROD_DEVTOOLS__ !== 'boolean') {
        ( true) && needWarn.push(`__VUE_PROD_DEVTOOLS__`);
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_PROD_DEVTOOLS__ = false;
    }
    if (( true) && needWarn.length) {
        const multi = needWarn.length > 1;
        console.warn(`Feature flag${multi ? `s` : ``} ${needWarn.join(', ')} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, ` +
            `which expects these compile-time feature flags to be globally injected ` +
            `via the bundler config in order to get better tree-shaking in the ` +
            `production bundle.\n\n` +
            `For more details, see https://link.vuejs.org/feature-flags.`);
    }
}

const queuePostRenderEffect = queueEffectWithSuspense
    ;
/**
 * The createRenderer function accepts two generic arguments:
 * HostNode and HostElement, corresponding to Node and Element types in the
 * host environment. For example, for runtime-dom, HostNode would be the DOM
 * `Node` interface and HostElement would be the DOM `Element` interface.
 *
 * Custom renderers can pass in the platform specific types like this:
 *
 * ``` js
 * const { render, createApp } = createRenderer<Node, Element>({
 *   patchProp,
 *   ...nodeOps
 * })
 * ```
 */
function createRenderer(options) {
    return baseCreateRenderer(options);
}
// Separate API for creating hydration-enabled renderer.
// Hydration logic is only used when calling this function, making it
// tree-shakable.
function createHydrationRenderer(options) {
    return baseCreateRenderer(options, createHydrationFunctions);
}
// implementation
function baseCreateRenderer(options, createHydrationFns) {
    // compile-time feature flags check
    {
        initFeatureFlags();
    }
    const target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)();
    target.__VUE__ = true;
    if (true) {
        setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
    }
    const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP, insertStaticContent: hostInsertStaticContent } = options;
    // Note: functions inside this closure should use `const xxx = () => {}`
    // style in order to prevent being inlined by minifiers.
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = ( true) && isHmrUpdating ? false : !!n2.dynamicChildren) => {
        if (n1 === n2) {
            return;
        }
        // patching & not same type, unmount old tree
        if (n1 && !isSameVNodeType(n1, n2)) {
            anchor = getNextHostNode(n1);
            unmount(n1, parentComponent, parentSuspense, true);
            n1 = null;
        }
        if (n2.patchFlag === -2 /* PatchFlags.BAIL */) {
            optimized = false;
            n2.dynamicChildren = null;
        }
        const { type, ref, shapeFlag } = n2;
        switch (type) {
            case Text:
                processText(n1, n2, container, anchor);
                break;
            case Comment:
                processCommentNode(n1, n2, container, anchor);
                break;
            case Static:
                if (n1 == null) {
                    mountStaticNode(n2, container, anchor, isSVG);
                }
                else if ((true)) {
                    patchStaticNode(n1, n2, container, isSVG);
                }
                break;
            case Fragment:
                processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                break;
            default:
                if (shapeFlag & 1 /* ShapeFlags.ELEMENT */) {
                    processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
                else if (shapeFlag & 6 /* ShapeFlags.COMPONENT */) {
                    processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
                else if (shapeFlag & 64 /* ShapeFlags.TELEPORT */) {
                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
                }
                else if (shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {
                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
                }
                else if ((true)) {
                    warn('Invalid VNode type:', type, `(${typeof type})`);
                }
        }
        // set ref
        if (ref != null && parentComponent) {
            setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
        }
    };
    const processText = (n1, n2, container, anchor) => {
        if (n1 == null) {
            hostInsert((n2.el = hostCreateText(n2.children)), container, anchor);
        }
        else {
            const el = (n2.el = n1.el);
            if (n2.children !== n1.children) {
                hostSetText(el, n2.children);
            }
        }
    };
    const processCommentNode = (n1, n2, container, anchor) => {
        if (n1 == null) {
            hostInsert((n2.el = hostCreateComment(n2.children || '')), container, anchor);
        }
        else {
            // there's no support for dynamic comments
            n2.el = n1.el;
        }
    };
    const mountStaticNode = (n2, container, anchor, isSVG) => {
        [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
    };
    /**
     * Dev / HMR only
     */
    const patchStaticNode = (n1, n2, container, isSVG) => {
        // static nodes are only patched during dev for HMR
        if (n2.children !== n1.children) {
            const anchor = hostNextSibling(n1.anchor);
            // remove existing
            removeStaticNode(n1);
            [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
        }
        else {
            n2.el = n1.el;
            n2.anchor = n1.anchor;
        }
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
        let next;
        while (el && el !== anchor) {
            next = hostNextSibling(el);
            hostInsert(el, container, nextSibling);
            el = next;
        }
        hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor }) => {
        let next;
        while (el && el !== anchor) {
            next = hostNextSibling(el);
            hostRemove(el);
            el = next;
        }
        hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        isSVG = isSVG || n2.type === 'svg';
        if (n1 == null) {
            mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
        else {
            patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        let el;
        let vnodeHook;
        const { type, props, shapeFlag, transition, dirs } = vnode;
        el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
        // mount children first, since some props may rely on child content
        // being already rendered, e.g. `<select value>`
        if (shapeFlag & 8 /* ShapeFlags.TEXT_CHILDREN */) {
            hostSetElementText(el, vnode.children);
        }
        else if (shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {
            mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== 'foreignObject', slotScopeIds, optimized);
        }
        if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, 'created');
        }
        // props
        if (props) {
            for (const key in props) {
                if (key !== 'value' && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {
                    hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                }
            }
            /**
             * Special case for setting value on DOM elements:
             * - it can be order-sensitive (e.g. should be set *after* min/max, #2325, #4024)
             * - it needs to be forced (#1471)
             * #2353 proposes adding another renderer option to configure this, but
             * the properties affects are so finite it is worth special casing it
             * here to reduce the complexity. (Special casing it also should not
             * affect non-DOM renderers)
             */
            if ('value' in props) {
                hostPatchProp(el, 'value', null, props.value);
            }
            if ((vnodeHook = props.onVnodeBeforeMount)) {
                invokeVNodeHook(vnodeHook, parentComponent, vnode);
            }
        }
        // scopeId
        setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        if (true) {
            Object.defineProperty(el, '__vnode', {
                value: vnode,
                enumerable: false
            });
            Object.defineProperty(el, '__vueParentComponent', {
                value: parentComponent,
                enumerable: false
            });
        }
        if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
        }
        // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved
        // #1689 For inside suspense + suspense resolved case, just call it
        const needCallTransitionHooks = (!parentSuspense || (parentSuspense && !parentSuspense.pendingBranch)) &&
            transition &&
            !transition.persisted;
        if (needCallTransitionHooks) {
            transition.beforeEnter(el);
        }
        hostInsert(el, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) ||
            needCallTransitionHooks ||
            dirs) {
            queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                needCallTransitionHooks && transition.enter(el);
                dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
            }, parentSuspense);
        }
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
        if (scopeId) {
            hostSetScopeId(el, scopeId);
        }
        if (slotScopeIds) {
            for (let i = 0; i < slotScopeIds.length; i++) {
                hostSetScopeId(el, slotScopeIds[i]);
            }
        }
        if (parentComponent) {
            let subTree = parentComponent.subTree;
            if (( true) &&
                subTree.patchFlag > 0 &&
                subTree.patchFlag & 2048 /* PatchFlags.DEV_ROOT_FRAGMENT */) {
                subTree =
                    filterSingleRoot(subTree.children) || subTree;
            }
            if (vnode === subTree) {
                const parentVNode = parentComponent.vnode;
                setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
            }
        }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
        for (let i = start; i < children.length; i++) {
            const child = (children[i] = optimized
                ? cloneIfMounted(children[i])
                : normalizeVNode(children[i]));
            patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        const el = (n2.el = n1.el);
        let { patchFlag, dynamicChildren, dirs } = n2;
        // #1426 take the old vnode's patch flag into account since user may clone a
        // compiler-generated vnode, which de-opts to FULL_PROPS
        patchFlag |= n1.patchFlag & 16 /* PatchFlags.FULL_PROPS */;
        const oldProps = n1.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        const newProps = n2.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        let vnodeHook;
        // disable recurse in beforeUpdate hooks
        parentComponent && toggleRecurse(parentComponent, false);
        if ((vnodeHook = newProps.onVnodeBeforeUpdate)) {
            invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        }
        if (dirs) {
            invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate');
        }
        parentComponent && toggleRecurse(parentComponent, true);
        if (( true) && isHmrUpdating) {
            // HMR updated, force full diff
            patchFlag = 0;
            optimized = false;
            dynamicChildren = null;
        }
        const areChildrenSVG = isSVG && n2.type !== 'foreignObject';
        if (dynamicChildren) {
            patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
            if (( true) && parentComponent && parentComponent.type.__hmrId) {
                traverseStaticChildren(n1, n2);
            }
        }
        else if (!optimized) {
            // full diff
            patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
        }
        if (patchFlag > 0) {
            // the presence of a patchFlag means this element's render code was
            // generated by the compiler and can take the fast path.
            // in this path old node and new node are guaranteed to have the same shape
            // (i.e. at the exact same position in the source template)
            if (patchFlag & 16 /* PatchFlags.FULL_PROPS */) {
                // element props contain dynamic keys, full diff needed
                patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
            }
            else {
                // class
                // this flag is matched when the element has dynamic class bindings.
                if (patchFlag & 2 /* PatchFlags.CLASS */) {
                    if (oldProps.class !== newProps.class) {
                        hostPatchProp(el, 'class', null, newProps.class, isSVG);
                    }
                }
                // style
                // this flag is matched when the element has dynamic style bindings
                if (patchFlag & 4 /* PatchFlags.STYLE */) {
                    hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG);
                }
                // props
                // This flag is matched when the element has dynamic prop/attr bindings
                // other than class and style. The keys of dynamic prop/attrs are saved for
                // faster iteration.
                // Note dynamic keys like :[foo]="bar" will cause this optimization to
                // bail out and go through a full diff because we need to unset the old key
                if (patchFlag & 8 /* PatchFlags.PROPS */) {
                    // if the flag is present then dynamicProps must be non-null
                    const propsToUpdate = n2.dynamicProps;
                    for (let i = 0; i < propsToUpdate.length; i++) {
                        const key = propsToUpdate[i];
                        const prev = oldProps[key];
                        const next = newProps[key];
                        // #1471 force patch value
                        if (next !== prev || key === 'value') {
                            hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
                        }
                    }
                }
            }
            // text
            // This flag is matched when the element has only dynamic text children.
            if (patchFlag & 1 /* PatchFlags.TEXT */) {
                if (n1.children !== n2.children) {
                    hostSetElementText(el, n2.children);
                }
            }
        }
        else if (!optimized && dynamicChildren == null) {
            // unoptimized, full diff
            patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
        }
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
            queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
                dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated');
            }, parentSuspense);
        }
    };
    // The fast path for blocks.
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
        for (let i = 0; i < newChildren.length; i++) {
            const oldVNode = oldChildren[i];
            const newVNode = newChildren[i];
            // Determine the container (parent element) for the patch.
            const container = 
            // oldVNode may be an errored async setup() component inside Suspense
            // which will not have a mounted element
            oldVNode.el &&
                // - In the case of a Fragment, we need to provide the actual parent
                // of the Fragment itself so it can move its children.
                (oldVNode.type === Fragment ||
                    // - In the case of different nodes, there is going to be a replacement
                    // which also requires the correct parent container
                    !isSameVNodeType(oldVNode, newVNode) ||
                    // - In the case of a component, it could contain anything.
                    oldVNode.shapeFlag & (6 /* ShapeFlags.COMPONENT */ | 64 /* ShapeFlags.TELEPORT */))
                ? hostParentNode(oldVNode.el)
                : // In other cases, the parent container is not actually used so we
                    // just pass the block element here to avoid a DOM parentNode call.
                    fallbackContainer;
            patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
        }
    };
    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
        if (oldProps !== newProps) {
            if (oldProps !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
                for (const key in oldProps) {
                    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key) && !(key in newProps)) {
                        hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                    }
                }
            }
            for (const key in newProps) {
                // empty string is not valid prop
                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key))
                    continue;
                const next = newProps[key];
                const prev = oldProps[key];
                // defer patching value
                if (next !== prev && key !== 'value') {
                    hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                }
            }
            if ('value' in newProps) {
                hostPatchProp(el, 'value', oldProps.value, newProps.value);
            }
        }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(''));
        const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(''));
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (( true) &&
            // #5523 dev root fragment may inherit directives
            (isHmrUpdating || patchFlag & 2048 /* PatchFlags.DEV_ROOT_FRAGMENT */)) {
            // HMR updated / Dev root fragment (w/ comments), force full diff
            patchFlag = 0;
            optimized = false;
            dynamicChildren = null;
        }
        // check if this is a slot fragment with :slotted scope ids
        if (fragmentSlotScopeIds) {
            slotScopeIds = slotScopeIds
                ? slotScopeIds.concat(fragmentSlotScopeIds)
                : fragmentSlotScopeIds;
        }
        if (n1 == null) {
            hostInsert(fragmentStartAnchor, container, anchor);
            hostInsert(fragmentEndAnchor, container, anchor);
            // a fragment can only have array children
            // since they are either generated by the compiler, or implicitly created
            // from arrays.
            mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
        else {
            if (patchFlag > 0 &&
                patchFlag & 64 /* PatchFlags.STABLE_FRAGMENT */ &&
                dynamicChildren &&
                // #2715 the previous fragment could've been a BAILed one as a result
                // of renderSlot() with no valid children
                n1.dynamicChildren) {
                // a stable fragment (template root or <template v-for>) doesn't need to
                // patch children order, but it may contain dynamicChildren.
                patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
                if (( true) && parentComponent && parentComponent.type.__hmrId) {
                    traverseStaticChildren(n1, n2);
                }
                else if (
                // #2080 if the stable fragment has a key, it's a <template v-for> that may
                //  get moved around. Make sure all root level vnodes inherit el.
                // #2134 or if it's a component root, it may also get moved around
                // as the component is being moved.
                n2.key != null ||
                    (parentComponent && n2 === parentComponent.subTree)) {
                    traverseStaticChildren(n1, n2, true /* shallow */);
                }
            }
            else {
                // keyed / unkeyed, or manual fragments.
                // for keyed & unkeyed, since they are compiler generated from v-for,
                // each child is guaranteed to be a block so the fragment will never
                // have dynamicChildren.
                patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            }
        }
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        n2.slotScopeIds = slotScopeIds;
        if (n1 == null) {
            if (n2.shapeFlag & 512 /* ShapeFlags.COMPONENT_KEPT_ALIVE */) {
                parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
            }
            else {
                mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
            }
        }
        else {
            updateComponent(n1, n2, optimized);
        }
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
        const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense));
        if (( true) && instance.type.__hmrId) {
            registerHMR(instance);
        }
        if ((true)) {
            pushWarningContext(initialVNode);
            startMeasure(instance, `mount`);
        }
        // inject renderer internals for keepAlive
        if (isKeepAlive(initialVNode)) {
            instance.ctx.renderer = internals;
        }
        // resolve props and slots for setup context
        {
            if ((true)) {
                startMeasure(instance, `init`);
            }
            setupComponent(instance);
            if ((true)) {
                endMeasure(instance, `init`);
            }
        }
        // setup() is async. This component relies on async logic to be resolved
        // before proceeding
        if (instance.asyncDep) {
            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
            // Give it a placeholder if this is not hydration
            // TODO handle self-defined fallback
            if (!initialVNode.el) {
                const placeholder = (instance.subTree = createVNode(Comment));
                processCommentNode(null, placeholder, container, anchor);
            }
            return;
        }
        setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
        if ((true)) {
            popWarningContext();
            endMeasure(instance, `mount`);
        }
    };
    const updateComponent = (n1, n2, optimized) => {
        const instance = (n2.component = n1.component);
        if (shouldUpdateComponent(n1, n2, optimized)) {
            if (instance.asyncDep &&
                !instance.asyncResolved) {
                // async & still pending - just update props and slots
                // since the component's reactive effect for render isn't set-up yet
                if ((true)) {
                    pushWarningContext(n2);
                }
                updateComponentPreRender(instance, n2, optimized);
                if ((true)) {
                    popWarningContext();
                }
                return;
            }
            else {
                // normal update
                instance.next = n2;
                // in case the child component is also queued, remove it to avoid
                // double updating the same child component in the same flush.
                invalidateJob(instance.update);
                // instance.update is the reactive effect.
                instance.update();
            }
        }
        else {
            // no update needed. just copy over properties
            n2.el = n1.el;
            instance.vnode = n2;
        }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
        const componentUpdateFn = () => {
            if (!instance.isMounted) {
                let vnodeHook;
                const { el, props } = initialVNode;
                const { bm, m, parent } = instance;
                const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
                toggleRecurse(instance, false);
                // beforeMount hook
                if (bm) {
                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bm);
                }
                // onVnodeBeforeMount
                if (!isAsyncWrapperVNode &&
                    (vnodeHook = props && props.onVnodeBeforeMount)) {
                    invokeVNodeHook(vnodeHook, parent, initialVNode);
                }
                toggleRecurse(instance, true);
                if (el && hydrateNode) {
                    // vnode has adopted host node - perform hydration instead of mount.
                    const hydrateSubTree = () => {
                        if ((true)) {
                            startMeasure(instance, `render`);
                        }
                        instance.subTree = renderComponentRoot(instance);
                        if ((true)) {
                            endMeasure(instance, `render`);
                        }
                        if ((true)) {
                            startMeasure(instance, `hydrate`);
                        }
                        hydrateNode(el, instance.subTree, instance, parentSuspense, null);
                        if ((true)) {
                            endMeasure(instance, `hydrate`);
                        }
                    };
                    if (isAsyncWrapperVNode) {
                        initialVNode.type.__asyncLoader().then(
                        // note: we are moving the render call into an async callback,
                        // which means it won't track dependencies - but it's ok because
                        // a server-rendered async wrapper is already in resolved state
                        // and it will never need to change.
                        () => !instance.isUnmounted && hydrateSubTree());
                    }
                    else {
                        hydrateSubTree();
                    }
                }
                else {
                    if ((true)) {
                        startMeasure(instance, `render`);
                    }
                    const subTree = (instance.subTree = renderComponentRoot(instance));
                    if ((true)) {
                        endMeasure(instance, `render`);
                    }
                    if ((true)) {
                        startMeasure(instance, `patch`);
                    }
                    patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
                    if ((true)) {
                        endMeasure(instance, `patch`);
                    }
                    initialVNode.el = subTree.el;
                }
                // mounted hook
                if (m) {
                    queuePostRenderEffect(m, parentSuspense);
                }
                // onVnodeMounted
                if (!isAsyncWrapperVNode &&
                    (vnodeHook = props && props.onVnodeMounted)) {
                    const scopedInitialVNode = initialVNode;
                    queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
                }
                // activated hook for keep-alive roots.
                // #1742 activated hook must be accessed after first render
                // since the hook may be injected by a child keep-alive
                if (initialVNode.shapeFlag & 256 /* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */ ||
                    (parent &&
                        isAsyncWrapper(parent.vnode) &&
                        parent.vnode.shapeFlag & 256 /* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */)) {
                    instance.a && queuePostRenderEffect(instance.a, parentSuspense);
                }
                instance.isMounted = true;
                if (true) {
                    devtoolsComponentAdded(instance);
                }
                // #2458: deference mount-only object parameters to prevent memleaks
                initialVNode = container = anchor = null;
            }
            else {
                // updateComponent
                // This is triggered by mutation of component's own state (next: null)
                // OR parent calling processComponent (next: VNode)
                let { next, bu, u, parent, vnode } = instance;
                let originNext = next;
                let vnodeHook;
                if ((true)) {
                    pushWarningContext(next || instance.vnode);
                }
                // Disallow component effect recursion during pre-lifecycle hooks.
                toggleRecurse(instance, false);
                if (next) {
                    next.el = vnode.el;
                    updateComponentPreRender(instance, next, optimized);
                }
                else {
                    next = vnode;
                }
                // beforeUpdate hook
                if (bu) {
                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bu);
                }
                // onVnodeBeforeUpdate
                if ((vnodeHook = next.props && next.props.onVnodeBeforeUpdate)) {
                    invokeVNodeHook(vnodeHook, parent, next, vnode);
                }
                toggleRecurse(instance, true);
                // render
                if ((true)) {
                    startMeasure(instance, `render`);
                }
                const nextTree = renderComponentRoot(instance);
                if ((true)) {
                    endMeasure(instance, `render`);
                }
                const prevTree = instance.subTree;
                instance.subTree = nextTree;
                if ((true)) {
                    startMeasure(instance, `patch`);
                }
                patch(prevTree, nextTree, 
                // parent may have changed if it's in a teleport
                hostParentNode(prevTree.el), 
                // anchor may have changed if it's in a fragment
                getNextHostNode(prevTree), instance, parentSuspense, isSVG);
                if ((true)) {
                    endMeasure(instance, `patch`);
                }
                next.el = nextTree.el;
                if (originNext === null) {
                    // self-triggered update. In case of HOC, update parent component
                    // vnode el. HOC is indicated by parent instance's subTree pointing
                    // to child component's vnode
                    updateHOCHostEl(instance, nextTree.el);
                }
                // updated hook
                if (u) {
                    queuePostRenderEffect(u, parentSuspense);
                }
                // onVnodeUpdated
                if ((vnodeHook = next.props && next.props.onVnodeUpdated)) {
                    queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
                }
                if (true) {
                    devtoolsComponentUpdated(instance);
                }
                if ((true)) {
                    popWarningContext();
                }
            }
        };
        // create reactive effect for rendering
        const effect = (instance.effect = new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect(componentUpdateFn, () => queueJob(update), instance.scope // track it in component's effect scope
        ));
        const update = (instance.update = () => effect.run());
        update.id = instance.uid;
        // allowRecurse
        // #1801, #2043 component render effects should allow recursive updates
        toggleRecurse(instance, true);
        if ((true)) {
            effect.onTrack = instance.rtc
                ? e => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.rtc, e)
                : void 0;
            effect.onTrigger = instance.rtg
                ? e => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.rtg, e)
                : void 0;
            update.ownerInstance = instance;
        }
        update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
        // props update may have triggered pre-flush watchers.
        // flush them before the render update.
        flushPreFlushCbs();
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        // fast path
        if (patchFlag > 0) {
            if (patchFlag & 128 /* PatchFlags.KEYED_FRAGMENT */) {
                // this could be either fully-keyed or mixed (some keyed some not)
                // presence of patchFlag means children are guaranteed to be arrays
                patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                return;
            }
            else if (patchFlag & 256 /* PatchFlags.UNKEYED_FRAGMENT */) {
                // unkeyed
                patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                return;
            }
        }
        // children has 3 possibilities: text, array or no children.
        if (shapeFlag & 8 /* ShapeFlags.TEXT_CHILDREN */) {
            // text children fast path
            if (prevShapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {
                unmountChildren(c1, parentComponent, parentSuspense);
            }
            if (c2 !== c1) {
                hostSetElementText(container, c2);
            }
        }
        else {
            if (prevShapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {
                // prev children was array
                if (shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {
                    // two arrays, cannot assume anything, do full diff
                    patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
                else {
                    // no new children, just unmount old
                    unmountChildren(c1, parentComponent, parentSuspense, true);
                }
            }
            else {
                // prev children was text OR null
                // new children is array OR null
                if (prevShapeFlag & 8 /* ShapeFlags.TEXT_CHILDREN */) {
                    hostSetElementText(container, '');
                }
                // mount new if array
                if (shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {
                    mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
            }
        }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        c1 = c1 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
        c2 = c2 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i;
        for (i = 0; i < commonLength; i++) {
            const nextChild = (c2[i] = optimized
                ? cloneIfMounted(c2[i])
                : normalizeVNode(c2[i]));
            patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
        if (oldLength > newLength) {
            // remove old
            unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
        }
        else {
            // mount new
            mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
        }
    };
    // can be all-keyed or mixed
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        let i = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1; // prev ending index
        let e2 = l2 - 1; // next ending index
        // 1. sync from start
        // (a b) c
        // (a b) d e
        while (i <= e1 && i <= e2) {
            const n1 = c1[i];
            const n2 = (c2[i] = optimized
                ? cloneIfMounted(c2[i])
                : normalizeVNode(c2[i]));
            if (isSameVNodeType(n1, n2)) {
                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            }
            else {
                break;
            }
            i++;
        }
        // 2. sync from end
        // a (b c)
        // d e (b c)
        while (i <= e1 && i <= e2) {
            const n1 = c1[e1];
            const n2 = (c2[e2] = optimized
                ? cloneIfMounted(c2[e2])
                : normalizeVNode(c2[e2]));
            if (isSameVNodeType(n1, n2)) {
                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            }
            else {
                break;
            }
            e1--;
            e2--;
        }
        // 3. common sequence + mount
        // (a b)
        // (a b) c
        // i = 2, e1 = 1, e2 = 2
        // (a b)
        // c (a b)
        // i = 0, e1 = -1, e2 = 0
        if (i > e1) {
            if (i <= e2) {
                const nextPos = e2 + 1;
                const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
                while (i <= e2) {
                    patch(null, (c2[i] = optimized
                        ? cloneIfMounted(c2[i])
                        : normalizeVNode(c2[i])), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                    i++;
                }
            }
        }
        // 4. common sequence + unmount
        // (a b) c
        // (a b)
        // i = 2, e1 = 2, e2 = 1
        // a (b c)
        // (b c)
        // i = 0, e1 = 0, e2 = -1
        else if (i > e2) {
            while (i <= e1) {
                unmount(c1[i], parentComponent, parentSuspense, true);
                i++;
            }
        }
        // 5. unknown sequence
        // [i ... e1 + 1]: a b [c d e] f g
        // [i ... e2 + 1]: a b [e d c h] f g
        // i = 2, e1 = 4, e2 = 5
        else {
            const s1 = i; // prev starting index
            const s2 = i; // next starting index
            // 5.1 build key:index map for newChildren
            const keyToNewIndexMap = new Map();
            for (i = s2; i <= e2; i++) {
                const nextChild = (c2[i] = optimized
                    ? cloneIfMounted(c2[i])
                    : normalizeVNode(c2[i]));
                if (nextChild.key != null) {
                    if (( true) && keyToNewIndexMap.has(nextChild.key)) {
                        warn(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);
                    }
                    keyToNewIndexMap.set(nextChild.key, i);
                }
            }
            // 5.2 loop through old children left to be patched and try to patch
            // matching nodes & remove nodes that are no longer present
            let j;
            let patched = 0;
            const toBePatched = e2 - s2 + 1;
            let moved = false;
            // used to track whether any node has moved
            let maxNewIndexSoFar = 0;
            // works as Map<newIndex, oldIndex>
            // Note that oldIndex is offset by +1
            // and oldIndex = 0 is a special value indicating the new node has
            // no corresponding old node.
            // used for determining longest stable subsequence
            const newIndexToOldIndexMap = new Array(toBePatched);
            for (i = 0; i < toBePatched; i++)
                newIndexToOldIndexMap[i] = 0;
            for (i = s1; i <= e1; i++) {
                const prevChild = c1[i];
                if (patched >= toBePatched) {
                    // all new children have been patched so this can only be a removal
                    unmount(prevChild, parentComponent, parentSuspense, true);
                    continue;
                }
                let newIndex;
                if (prevChild.key != null) {
                    newIndex = keyToNewIndexMap.get(prevChild.key);
                }
                else {
                    // key-less node, try to locate a key-less node of the same type
                    for (j = s2; j <= e2; j++) {
                        if (newIndexToOldIndexMap[j - s2] === 0 &&
                            isSameVNodeType(prevChild, c2[j])) {
                            newIndex = j;
                            break;
                        }
                    }
                }
                if (newIndex === undefined) {
                    unmount(prevChild, parentComponent, parentSuspense, true);
                }
                else {
                    newIndexToOldIndexMap[newIndex - s2] = i + 1;
                    if (newIndex >= maxNewIndexSoFar) {
                        maxNewIndexSoFar = newIndex;
                    }
                    else {
                        moved = true;
                    }
                    patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                    patched++;
                }
            }
            // 5.3 move and mount
            // generate longest stable subsequence only when nodes have moved
            const increasingNewIndexSequence = moved
                ? getSequence(newIndexToOldIndexMap)
                : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
            j = increasingNewIndexSequence.length - 1;
            // looping backwards so that we can use last patched node as anchor
            for (i = toBePatched - 1; i >= 0; i--) {
                const nextIndex = s2 + i;
                const nextChild = c2[nextIndex];
                const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
                if (newIndexToOldIndexMap[i] === 0) {
                    // mount new
                    patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
                else if (moved) {
                    // move if:
                    // There is no stable subsequence (e.g. a reverse)
                    // OR current node is not among the stable sequence
                    if (j < 0 || i !== increasingNewIndexSequence[j]) {
                        move(nextChild, container, anchor, 2 /* MoveType.REORDER */);
                    }
                    else {
                        j--;
                    }
                }
            }
        }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
        const { el, type, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6 /* ShapeFlags.COMPONENT */) {
            move(vnode.component.subTree, container, anchor, moveType);
            return;
        }
        if (shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {
            vnode.suspense.move(container, anchor, moveType);
            return;
        }
        if (shapeFlag & 64 /* ShapeFlags.TELEPORT */) {
            type.move(vnode, container, anchor, internals);
            return;
        }
        if (type === Fragment) {
            hostInsert(el, container, anchor);
            for (let i = 0; i < children.length; i++) {
                move(children[i], container, anchor, moveType);
            }
            hostInsert(vnode.anchor, container, anchor);
            return;
        }
        if (type === Static) {
            moveStaticNode(vnode, container, anchor);
            return;
        }
        // single nodes
        const needTransition = moveType !== 2 /* MoveType.REORDER */ &&
            shapeFlag & 1 /* ShapeFlags.ELEMENT */ &&
            transition;
        if (needTransition) {
            if (moveType === 0 /* MoveType.ENTER */) {
                transition.beforeEnter(el);
                hostInsert(el, container, anchor);
                queuePostRenderEffect(() => transition.enter(el), parentSuspense);
            }
            else {
                const { leave, delayLeave, afterLeave } = transition;
                const remove = () => hostInsert(el, container, anchor);
                const performLeave = () => {
                    leave(el, () => {
                        remove();
                        afterLeave && afterLeave();
                    });
                };
                if (delayLeave) {
                    delayLeave(el, remove, performLeave);
                }
                else {
                    performLeave();
                }
            }
        }
        else {
            hostInsert(el, container, anchor);
        }
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
        const { type, props, ref, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
        // unset ref
        if (ref != null) {
            setRef(ref, null, parentSuspense, vnode, true);
        }
        if (shapeFlag & 256 /* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */) {
            parentComponent.ctx.deactivate(vnode);
            return;
        }
        const shouldInvokeDirs = shapeFlag & 1 /* ShapeFlags.ELEMENT */ && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook &&
            (vnodeHook = props && props.onVnodeBeforeUnmount)) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        if (shapeFlag & 6 /* ShapeFlags.COMPONENT */) {
            unmountComponent(vnode.component, parentSuspense, doRemove);
        }
        else {
            if (shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {
                vnode.suspense.unmount(parentSuspense, doRemove);
                return;
            }
            if (shouldInvokeDirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'beforeUnmount');
            }
            if (shapeFlag & 64 /* ShapeFlags.TELEPORT */) {
                vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
            }
            else if (dynamicChildren &&
                // #1153: fast path should not be taken for non-stable (v-for) fragments
                (type !== Fragment ||
                    (patchFlag > 0 && patchFlag & 64 /* PatchFlags.STABLE_FRAGMENT */))) {
                // fast path for block nodes: only need to unmount dynamic children.
                unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
            }
            else if ((type === Fragment &&
                patchFlag &
                    (128 /* PatchFlags.KEYED_FRAGMENT */ | 256 /* PatchFlags.UNKEYED_FRAGMENT */)) ||
                (!optimized && shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */)) {
                unmountChildren(children, parentComponent, parentSuspense);
            }
            if (doRemove) {
                remove(vnode);
            }
        }
        if ((shouldInvokeVnodeHook &&
            (vnodeHook = props && props.onVnodeUnmounted)) ||
            shouldInvokeDirs) {
            queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                shouldInvokeDirs &&
                    invokeDirectiveHook(vnode, null, parentComponent, 'unmounted');
            }, parentSuspense);
        }
    };
    const remove = vnode => {
        const { type, el, anchor, transition } = vnode;
        if (type === Fragment) {
            if (( true) &&
                vnode.patchFlag > 0 &&
                vnode.patchFlag & 2048 /* PatchFlags.DEV_ROOT_FRAGMENT */ &&
                transition &&
                !transition.persisted) {
                vnode.children.forEach(child => {
                    if (child.type === Comment) {
                        hostRemove(child.el);
                    }
                    else {
                        remove(child);
                    }
                });
            }
            else {
                removeFragment(el, anchor);
            }
            return;
        }
        if (type === Static) {
            removeStaticNode(vnode);
            return;
        }
        const performRemove = () => {
            hostRemove(el);
            if (transition && !transition.persisted && transition.afterLeave) {
                transition.afterLeave();
            }
        };
        if (vnode.shapeFlag & 1 /* ShapeFlags.ELEMENT */ &&
            transition &&
            !transition.persisted) {
            const { leave, delayLeave } = transition;
            const performLeave = () => leave(el, performRemove);
            if (delayLeave) {
                delayLeave(vnode.el, performRemove, performLeave);
            }
            else {
                performLeave();
            }
        }
        else {
            performRemove();
        }
    };
    const removeFragment = (cur, end) => {
        // For fragments, directly remove all contained DOM nodes.
        // (fragment child nodes cannot have transition)
        let next;
        while (cur !== end) {
            next = hostNextSibling(cur);
            hostRemove(cur);
            cur = next;
        }
        hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
        if (( true) && instance.type.__hmrId) {
            unregisterHMR(instance);
        }
        const { bum, scope, update, subTree, um } = instance;
        // beforeUnmount hook
        if (bum) {
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bum);
        }
        // stop effects in component scope
        scope.stop();
        // update may be null if a component is unmounted before its async
        // setup has resolved.
        if (update) {
            // so that scheduler will no longer invoke it
            update.active = false;
            unmount(subTree, instance, parentSuspense, doRemove);
        }
        // unmounted hook
        if (um) {
            queuePostRenderEffect(um, parentSuspense);
        }
        queuePostRenderEffect(() => {
            instance.isUnmounted = true;
        }, parentSuspense);
        // A component with async dep inside a pending suspense is unmounted before
        // its async dep resolves. This should remove the dep from the suspense, and
        // cause the suspense to resolve immediately if that was the last dep.
        if (parentSuspense &&
            parentSuspense.pendingBranch &&
            !parentSuspense.isUnmounted &&
            instance.asyncDep &&
            !instance.asyncResolved &&
            instance.suspenseId === parentSuspense.pendingId) {
            parentSuspense.deps--;
            if (parentSuspense.deps === 0) {
                parentSuspense.resolve();
            }
        }
        if (true) {
            devtoolsComponentRemoved(instance);
        }
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
        for (let i = start; i < children.length; i++) {
            unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
        }
    };
    const getNextHostNode = vnode => {
        if (vnode.shapeFlag & 6 /* ShapeFlags.COMPONENT */) {
            return getNextHostNode(vnode.component.subTree);
        }
        if (vnode.shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {
            return vnode.suspense.next();
        }
        return hostNextSibling((vnode.anchor || vnode.el));
    };
    const render = (vnode, container, isSVG) => {
        if (vnode == null) {
            if (container._vnode) {
                unmount(container._vnode, null, null, true);
            }
        }
        else {
            patch(container._vnode || null, vnode, container, null, null, null, isSVG);
        }
        flushPreFlushCbs();
        flushPostFlushCbs();
        container._vnode = vnode;
    };
    const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
    };
    let hydrate;
    let hydrateNode;
    if (createHydrationFns) {
        [hydrate, hydrateNode] = createHydrationFns(internals);
    }
    return {
        render,
        hydrate,
        createApp: createAppAPI(render, hydrate)
    };
}
function toggleRecurse({ effect, update }, allowed) {
    effect.allowRecurse = update.allowRecurse = allowed;
}
/**
 * #1156
 * When a component is HMR-enabled, we need to make sure that all static nodes
 * inside a block also inherit the DOM element from the previous tree so that
 * HMR updates (which are full updates) can retrieve the element for patching.
 *
 * #2080
 * Inside keyed `template` fragment static children, if a fragment is moved,
 * the children will always be moved. Therefore, in order to ensure correct move
 * position, el should be inherited from previous nodes.
 */
function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch1) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch2)) {
        for (let i = 0; i < ch1.length; i++) {
            // this is only called in the optimized path so array children are
            // guaranteed to be vnodes
            const c1 = ch1[i];
            let c2 = ch2[i];
            if (c2.shapeFlag & 1 /* ShapeFlags.ELEMENT */ && !c2.dynamicChildren) {
                if (c2.patchFlag <= 0 || c2.patchFlag === 32 /* PatchFlags.HYDRATE_EVENTS */) {
                    c2 = ch2[i] = cloneIfMounted(ch2[i]);
                    c2.el = c1.el;
                }
                if (!shallow)
                    traverseStaticChildren(c1, c2);
            }
            // #6852 also inherit for text nodes
            if (c2.type === Text) {
                c2.el = c1.el;
            }
            // also inherit for comment nodes, but not placeholders (e.g. v-if which
            // would have received .el during block patch)
            if (( true) && c2.type === Comment && !c2.el) {
                c2.el = c1.el;
            }
        }
    }
}
// https://en.wikipedia.org/wiki/Longest_increasing_subsequence
function getSequence(arr) {
    const p = arr.slice();
    const result = [0];
    let i, j, u, v, c;
    const len = arr.length;
    for (i = 0; i < len; i++) {
        const arrI = arr[i];
        if (arrI !== 0) {
            j = result[result.length - 1];
            if (arr[j] < arrI) {
                p[i] = j;
                result.push(i);
                continue;
            }
            u = 0;
            v = result.length - 1;
            while (u < v) {
                c = (u + v) >> 1;
                if (arr[result[c]] < arrI) {
                    u = c + 1;
                }
                else {
                    v = c;
                }
            }
            if (arrI < arr[result[u]]) {
                if (u > 0) {
                    p[i] = result[u - 1];
                }
                result[u] = i;
            }
        }
    }
    u = result.length;
    v = result[u - 1];
    while (u-- > 0) {
        result[u] = v;
        v = p[v];
    }
    return result;
}

const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === '');
const isTargetSVG = (target) => typeof SVGElement !== 'undefined' && target instanceof SVGElement;
const resolveTarget = (props, select) => {
    const targetSelector = props && props.to;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(targetSelector)) {
        if (!select) {
            ( true) &&
                warn(`Current renderer does not support string target for Teleports. ` +
                    `(missing querySelector renderer option)`);
            return null;
        }
        else {
            const target = select(targetSelector);
            if (!target) {
                ( true) &&
                    warn(`Failed to locate Teleport target with selector "${targetSelector}". ` +
                        `Note the target element must exist before the component is mounted - ` +
                        `i.e. the target cannot be rendered by the component itself, and ` +
                        `ideally should be outside of the entire Vue component tree.`);
            }
            return target;
        }
    }
    else {
        if (( true) && !targetSelector && !isTeleportDisabled(props)) {
            warn(`Invalid Teleport target: ${targetSelector}`);
        }
        return targetSelector;
    }
};
const TeleportImpl = {
    __isTeleport: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
        const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
        const disabled = isTeleportDisabled(n2.props);
        let { shapeFlag, children, dynamicChildren } = n2;
        // #3302
        // HMR updated, force full diff
        if (( true) && isHmrUpdating) {
            optimized = false;
            dynamicChildren = null;
        }
        if (n1 == null) {
            // insert anchors in the main view
            const placeholder = (n2.el = ( true)
                ? createComment('teleport start')
                : 0);
            const mainAnchor = (n2.anchor = ( true)
                ? createComment('teleport end')
                : 0);
            insert(placeholder, container, anchor);
            insert(mainAnchor, container, anchor);
            const target = (n2.target = resolveTarget(n2.props, querySelector));
            const targetAnchor = (n2.targetAnchor = createText(''));
            if (target) {
                insert(targetAnchor, target);
                // #2652 we could be teleporting from a non-SVG tree into an SVG tree
                isSVG = isSVG || isTargetSVG(target);
            }
            else if (( true) && !disabled) {
                warn('Invalid Teleport target on mount:', target, `(${typeof target})`);
            }
            const mount = (container, anchor) => {
                // Teleport *always* has Array children. This is enforced in both the
                // compiler and vnode children normalization.
                if (shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {
                    mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
            };
            if (disabled) {
                mount(container, mainAnchor);
            }
            else if (target) {
                mount(target, targetAnchor);
            }
        }
        else {
            // update content
            n2.el = n1.el;
            const mainAnchor = (n2.anchor = n1.anchor);
            const target = (n2.target = n1.target);
            const targetAnchor = (n2.targetAnchor = n1.targetAnchor);
            const wasDisabled = isTeleportDisabled(n1.props);
            const currentContainer = wasDisabled ? container : target;
            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
            isSVG = isSVG || isTargetSVG(target);
            if (dynamicChildren) {
                // fast path when the teleport happens to be a block root
                patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
                // even in block tree mode we need to make sure all root-level nodes
                // in the teleport inherit previous DOM references so that they can
                // be moved in future patches.
                traverseStaticChildren(n1, n2, true);
            }
            else if (!optimized) {
                patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
            }
            if (disabled) {
                if (!wasDisabled) {
                    // enabled -> disabled
                    // move into main container
                    moveTeleport(n2, container, mainAnchor, internals, 1 /* TeleportMoveTypes.TOGGLE */);
                }
            }
            else {
                // target changed
                if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                    const nextTarget = (n2.target = resolveTarget(n2.props, querySelector));
                    if (nextTarget) {
                        moveTeleport(n2, nextTarget, null, internals, 0 /* TeleportMoveTypes.TARGET_CHANGE */);
                    }
                    else if ((true)) {
                        warn('Invalid Teleport target on update:', target, `(${typeof target})`);
                    }
                }
                else if (wasDisabled) {
                    // disabled -> enabled
                    // move into teleport target
                    moveTeleport(n2, target, targetAnchor, internals, 1 /* TeleportMoveTypes.TOGGLE */);
                }
            }
        }
        updateCssVars(n2);
    },
    remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
        const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
        if (target) {
            hostRemove(targetAnchor);
        }
        // an unmounted teleport should always remove its children if not disabled
        if (doRemove || !isTeleportDisabled(props)) {
            hostRemove(anchor);
            if (shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {
                for (let i = 0; i < children.length; i++) {
                    const child = children[i];
                    unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
                }
            }
        }
    },
    move: moveTeleport,
    hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2 /* TeleportMoveTypes.REORDER */) {
    // move target anchor if this is a target change.
    if (moveType === 0 /* TeleportMoveTypes.TARGET_CHANGE */) {
        insert(vnode.targetAnchor, container, parentAnchor);
    }
    const { el, anchor, shapeFlag, children, props } = vnode;
    const isReorder = moveType === 2 /* TeleportMoveTypes.REORDER */;
    // move main view anchor if this is a re-order.
    if (isReorder) {
        insert(el, container, parentAnchor);
    }
    // if this is a re-order and teleport is enabled (content is in target)
    // do not move children. So the opposite is: only move children if this
    // is not a reorder, or the teleport is disabled
    if (!isReorder || isTeleportDisabled(props)) {
        // Teleport has either Array children or no children.
        if (shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {
            for (let i = 0; i < children.length; i++) {
                move(children[i], container, parentAnchor, 2 /* MoveType.REORDER */);
            }
        }
    }
    // move main view anchor if this is a re-order.
    if (isReorder) {
        insert(anchor, container, parentAnchor);
    }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
    const target = (vnode.target = resolveTarget(vnode.props, querySelector));
    if (target) {
        // if multiple teleports rendered to the same target element, we need to
        // pick up from where the last teleport finished instead of the first node
        const targetNode = target._lpa || target.firstChild;
        if (vnode.shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {
            if (isTeleportDisabled(vnode.props)) {
                vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
                vnode.targetAnchor = targetNode;
            }
            else {
                vnode.anchor = nextSibling(node);
                // lookahead until we find the target anchor
                // we cannot rely on return value of hydrateChildren() because there
                // could be nested teleports
                let targetAnchor = targetNode;
                while (targetAnchor) {
                    targetAnchor = nextSibling(targetAnchor);
                    if (targetAnchor &&
                        targetAnchor.nodeType === 8 &&
                        targetAnchor.data === 'teleport anchor') {
                        vnode.targetAnchor = targetAnchor;
                        target._lpa =
                            vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                        break;
                    }
                }
                hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
            }
        }
        updateCssVars(vnode);
    }
    return vnode.anchor && nextSibling(vnode.anchor);
}
// Force-casted public typing for h and TSX props inference
const Teleport = TeleportImpl;
function updateCssVars(vnode) {
    // presence of .ut method indicates owner component uses css vars.
    // code path here can assume browser environment.
    const ctx = vnode.ctx;
    if (ctx && ctx.ut) {
        let node = vnode.children[0].el;
        while (node !== vnode.targetAnchor) {
            if (node.nodeType === 1)
                node.setAttribute('data-v-owner', ctx.uid);
            node = node.nextSibling;
        }
        ctx.ut();
    }
}

const Fragment = Symbol(( true) ? 'Fragment' : 0);
const Text = Symbol(( true) ? 'Text' : 0);
const Comment = Symbol(( true) ? 'Comment' : 0);
const Static = Symbol(( true) ? 'Static' : 0);
// Since v-if and v-for are the two possible ways node structure can dynamically
// change, once we consider v-if branches and each v-for fragment a block, we
// can divide a template into nested blocks, and within each block the node
// structure would be stable. This allows us to skip most children diffing
// and only worry about the dynamic nodes (indicated by patch flags).
const blockStack = [];
let currentBlock = null;
/**
 * Open a block.
 * This must be called before `createBlock`. It cannot be part of `createBlock`
 * because the children of the block are evaluated before `createBlock` itself
 * is called. The generated code typically looks like this:
 *
 * ```js
 * function render() {
 *   return (openBlock(),createBlock('div', null, [...]))
 * }
 * ```
 * disableTracking is true when creating a v-for fragment block, since a v-for
 * fragment always diffs its children.
 *
 * @private
 */
function openBlock(disableTracking = false) {
    blockStack.push((currentBlock = disableTracking ? null : []));
}
function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
}
// Whether we should be tracking dynamic child nodes inside a block.
// Only tracks when this value is > 0
// We are not using a simple boolean because this value may need to be
// incremented/decremented by nested usage of v-once (see below)
let isBlockTreeEnabled = 1;
/**
 * Block tracking sometimes needs to be disabled, for example during the
 * creation of a tree that needs to be cached by v-once. The compiler generates
 * code like this:
 *
 * ``` js
 * _cache[1] || (
 *   setBlockTracking(-1),
 *   _cache[1] = createVNode(...),
 *   setBlockTracking(1),
 *   _cache[1]
 * )
 * ```
 *
 * @private
 */
function setBlockTracking(value) {
    isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
    // save current block children on the block vnode
    vnode.dynamicChildren =
        isBlockTreeEnabled > 0 ? currentBlock || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR : null;
    // close block
    closeBlock();
    // a block is always going to be patched, so track it as a child of its
    // parent block
    if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(vnode);
    }
    return vnode;
}
/**
 * @private
 */
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true /* isBlock */));
}
/**
 * Create a block root vnode. Takes the same exact arguments as `createVNode`.
 * A block root keeps track of dynamic nodes within the block in the
 * `dynamicChildren` array.
 *
 * @private
 */
function createBlock(type, props, children, patchFlag, dynamicProps) {
    return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true /* isBlock: prevent a block from tracking itself */));
}
function isVNode(value) {
    return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
    if (( true) &&
        n2.shapeFlag & 6 /* ShapeFlags.COMPONENT */ &&
        hmrDirtyComponents.has(n2.type)) {
        // #7042, ensure the vnode being unmounted during HMR
        // bitwise operations to remove keep alive flags
        n1.shapeFlag &= ~256 /* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */;
        n2.shapeFlag &= ~512 /* ShapeFlags.COMPONENT_KEPT_ALIVE */;
        // HMR only: if the component has been hot-updated, force a reload.
        return false;
    }
    return n1.type === n2.type && n1.key === n2.key;
}
let vnodeArgsTransformer;
/**
 * Internal API for registering an arguments transform for createVNode
 * used for creating stubs in the test-utils
 * It is *internal* but needs to be exposed for test-utils to pick up proper
 * typings
 */
function transformVNodeArgs(transformer) {
    vnodeArgsTransformer = transformer;
}
const createVNodeWithArgsTransform = (...args) => {
    return _createVNode(...(vnodeArgsTransformer
        ? vnodeArgsTransformer(args, currentRenderingInstance)
        : args));
};
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({ ref, ref_key, ref_for }) => {
    return (ref != null
        ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref) || (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref)
            ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for }
            : ref
        : null);
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1 /* ShapeFlags.ELEMENT */, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null,
        ctx: currentRenderingInstance
    };
    if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children);
        // normalize suspense children
        if (shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {
            type.normalize(vnode);
        }
    }
    else if (children) {
        // compiled element vnode - if children is passed, only possible types are
        // string or Array.
        vnode.shapeFlag |= (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(children)
            ? 8 /* ShapeFlags.TEXT_CHILDREN */
            : 16 /* ShapeFlags.ARRAY_CHILDREN */;
    }
    // validate key
    if (( true) && vnode.key !== vnode.key) {
        warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
    }
    // track vnode for block tree
    if (isBlockTreeEnabled > 0 &&
        // avoid a block node from tracking itself
        !isBlockNode &&
        // has current parent block
        currentBlock &&
        // presence of a patch flag indicates this node needs patching on updates.
        // component nodes also should always be patched, because even if the
        // component doesn't need to update, it needs to persist the instance on to
        // the next vnode so that it can be properly unmounted later.
        (vnode.patchFlag > 0 || shapeFlag & 6 /* ShapeFlags.COMPONENT */) &&
        // the EVENTS flag is only for hydration and if it is the only flag, the
        // vnode should not be considered dynamic due to handler caching.
        vnode.patchFlag !== 32 /* PatchFlags.HYDRATE_EVENTS */) {
        currentBlock.push(vnode);
    }
    return vnode;
}
const createVNode = (( true) ? createVNodeWithArgsTransform : 0);
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
        if (( true) && !type) {
            warn(`Invalid vnode type when creating vnode: ${type}.`);
        }
        type = Comment;
    }
    if (isVNode(type)) {
        // createVNode receiving an existing vnode. This happens in cases like
        // <component :is="vnode"/>
        // #2078 make sure to merge refs during the clone instead of overwriting it
        const cloned = cloneVNode(type, props, true /* mergeRef: true */);
        if (children) {
            normalizeChildren(cloned, children);
        }
        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
            if (cloned.shapeFlag & 6 /* ShapeFlags.COMPONENT */) {
                currentBlock[currentBlock.indexOf(type)] = cloned;
            }
            else {
                currentBlock.push(cloned);
            }
        }
        cloned.patchFlag |= -2 /* PatchFlags.BAIL */;
        return cloned;
    }
    // class component normalization.
    if (isClassComponent(type)) {
        type = type.__vccOpts;
    }
    // class & style normalization.
    if (props) {
        // for reactive or proxy objects, we need to clone it to enable mutation.
        props = guardReactiveProps(props);
        let { class: klass, style } = props;
        if (klass && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(klass)) {
            props.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(klass);
        }
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(style)) {
            // reactive state objects need to be cloned since they are likely to be
            // mutated
            if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(style) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(style)) {
                style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, style);
            }
            props.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)(style);
        }
    }
    // encode the vnode type information into a bitmap
    const shapeFlag = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(type)
        ? 1 /* ShapeFlags.ELEMENT */
        : isSuspense(type)
            ? 128 /* ShapeFlags.SUSPENSE */
            : isTeleport(type)
                ? 64 /* ShapeFlags.TELEPORT */
                : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(type)
                    ? 4 /* ShapeFlags.STATEFUL_COMPONENT */
                    : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(type)
                        ? 2 /* ShapeFlags.FUNCTIONAL_COMPONENT */
                        : 0;
    if (( true) && shapeFlag & 4 /* ShapeFlags.STATEFUL_COMPONENT */ && (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(type)) {
        type = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(type);
        warn(`Vue received a Component which was made a reactive object. This can ` +
            `lead to unnecessary performance overhead, and should be avoided by ` +
            `marking the component with \`markRaw\` or using \`shallowRef\` ` +
            `instead of \`ref\`.`, `\nComponent that was made reactive: `, type);
    }
    return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
    if (!props)
        return null;
    return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(props) || InternalObjectKey in props
        ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, props)
        : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
    // This is intentionally NOT using spread or extend to avoid the runtime
    // key enumeration cost.
    const { props, ref, patchFlag, children } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref
            ? // #2078 in the case of <component :is="vnode" ref="extra"/>
                // if the vnode itself already has a ref, cloneVNode will need to merge
                // the refs so the single vnode can be set on multiple refs
                mergeRef && ref
                    ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ref)
                        ? ref.concat(normalizeRef(extraProps))
                        : [ref, normalizeRef(extraProps)]
                    : normalizeRef(extraProps)
            : ref,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children: ( true) && patchFlag === -1 /* PatchFlags.HOISTED */ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children)
            ? children.map(deepCloneVNode)
            : children,
        target: vnode.target,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: preserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== Fragment
            ? patchFlag === -1 // hoisted node
                ? 16 /* PatchFlags.FULL_PROPS */
                : patchFlag | 16 /* PatchFlags.FULL_PROPS */
            : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition: vnode.transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor,
        ctx: vnode.ctx
    };
    return cloned;
}
/**
 * Dev only, for HMR of hoisted vnodes reused in v-for
 * https://github.com/vitejs/vite/issues/2022
 */
function deepCloneVNode(vnode) {
    const cloned = cloneVNode(vnode);
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(vnode.children)) {
        cloned.children = vnode.children.map(deepCloneVNode);
    }
    return cloned;
}
/**
 * @private
 */
function createTextVNode(text = ' ', flag = 0) {
    return createVNode(Text, null, text, flag);
}
/**
 * @private
 */
function createStaticVNode(content, numberOfNodes) {
    // A static vnode can contain multiple stringified elements, and the number
    // of elements is necessary for hydration.
    const vnode = createVNode(Static, null, content);
    vnode.staticCount = numberOfNodes;
    return vnode;
}
/**
 * @private
 */
function createCommentVNode(text = '', 
// when used as the v-else branch, the comment node must be created as a
// block to ensure correct updates.
asBlock = false) {
    return asBlock
        ? (openBlock(), createBlock(Comment, null, text))
        : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
    if (child == null || typeof child === 'boolean') {
        // empty placeholder
        return createVNode(Comment);
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(child)) {
        // fragment
        return createVNode(Fragment, null, 
        // #3666, avoid reference pollution when reusing vnode
        child.slice());
    }
    else if (typeof child === 'object') {
        // already vnode, this should be the most common since compiled templates
        // always produce all-vnode children arrays
        return cloneIfMounted(child);
    }
    else {
        // strings and numbers
        return createVNode(Text, null, String(child));
    }
}
// optimized normalization for template-compiled render fns
function cloneIfMounted(child) {
    return (child.el === null && child.patchFlag !== -1 /* PatchFlags.HOISTED */) ||
        child.memo
        ? child
        : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
    let type = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
        children = null;
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children)) {
        type = 16 /* ShapeFlags.ARRAY_CHILDREN */;
    }
    else if (typeof children === 'object') {
        if (shapeFlag & (1 /* ShapeFlags.ELEMENT */ | 64 /* ShapeFlags.TELEPORT */)) {
            // Normalize slot to plain children for plain element and Teleport
            const slot = children.default;
            if (slot) {
                // _c marker is added by withCtx() indicating this is a compiled slot
                slot._c && (slot._d = false);
                normalizeChildren(vnode, slot());
                slot._c && (slot._d = true);
            }
            return;
        }
        else {
            type = 32 /* ShapeFlags.SLOTS_CHILDREN */;
            const slotFlag = children._;
            if (!slotFlag && !(InternalObjectKey in children)) {
                children._ctx = currentRenderingInstance;
            }
            else if (slotFlag === 3 /* SlotFlags.FORWARDED */ && currentRenderingInstance) {
                // a child component receives forwarded slots from the parent.
                // its slot type is determined by its parent's slot type.
                if (currentRenderingInstance.slots._ === 1 /* SlotFlags.STABLE */) {
                    children._ = 1 /* SlotFlags.STABLE */;
                }
                else {
                    children._ = 2 /* SlotFlags.DYNAMIC */;
                    vnode.patchFlag |= 1024 /* PatchFlags.DYNAMIC_SLOTS */;
                }
            }
        }
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(children)) {
        children = { default: children, _ctx: currentRenderingInstance };
        type = 32 /* ShapeFlags.SLOTS_CHILDREN */;
    }
    else {
        children = String(children);
        // force teleport children to array so it can be moved around
        if (shapeFlag & 64 /* ShapeFlags.TELEPORT */) {
            type = 16 /* ShapeFlags.ARRAY_CHILDREN */;
            children = [createTextVNode(children)];
        }
        else {
            type = 8 /* ShapeFlags.TEXT_CHILDREN */;
        }
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
}
function mergeProps(...args) {
    const ret = {};
    for (let i = 0; i < args.length; i++) {
        const toMerge = args[i];
        for (const key in toMerge) {
            if (key === 'class') {
                if (ret.class !== toMerge.class) {
                    ret.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)([ret.class, toMerge.class]);
                }
            }
            else if (key === 'style') {
                ret.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)([ret.style, toMerge.style]);
            }
            else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
                const existing = ret[key];
                const incoming = toMerge[key];
                if (incoming &&
                    existing !== incoming &&
                    !((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(existing) && existing.includes(incoming))) {
                    ret[key] = existing
                        ? [].concat(existing, incoming)
                        : incoming;
                }
            }
            else if (key !== '') {
                ret[key] = toMerge[key];
            }
        }
    }
    return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7 /* ErrorCodes.VNODE_HOOK */, [
        vnode,
        prevVNode
    ]);
}

const emptyAppContext = createAppContext();
let uid$1 = 0;
function createComponentInstance(vnode, parent, suspense) {
    const type = vnode.type;
    // inherit parent app context - or - if root, adopt from root vnode
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
        uid: uid$1++,
        vnode,
        type,
        parent,
        appContext,
        root: null,
        next: null,
        subTree: null,
        effect: null,
        update: null,
        scope: new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.EffectScope(true /* detached */),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        accessCache: null,
        renderCache: [],
        // local resolved assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type, appContext),
        emitsOptions: normalizeEmitsOptions(type, appContext),
        // emit
        emit: null,
        emitted: null,
        // props default value
        propsDefaults: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        // inheritAttrs
        inheritAttrs: type.inheritAttrs,
        // state
        ctx: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        data: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        props: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        attrs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        slots: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        refs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        setupState: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        setupContext: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
    };
    if ((true)) {
        instance.ctx = createDevRenderContext(instance);
    }
    else {}
    instance.root = parent ? parent.root : instance;
    instance.emit = emit$1.bind(null, instance);
    // apply custom element special handling
    if (vnode.ce) {
        vnode.ce(instance);
    }
    return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
const setCurrentInstance = (instance) => {
    currentInstance = instance;
    instance.scope.on();
};
const unsetCurrentInstance = () => {
    currentInstance && currentInstance.scope.off();
    currentInstance = null;
};
const isBuiltInTag = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('slot,component');
function validateComponentName(name, config) {
    const appIsNativeTag = config.isNativeTag || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO;
    if (isBuiltInTag(name) || appIsNativeTag(name)) {
        warn('Do not use built-in or reserved HTML elements as component id: ' + name);
    }
}
function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4 /* ShapeFlags.STATEFUL_COMPONENT */;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
    isInSSRComponentSetup = isSSR;
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children);
    const setupResult = isStateful
        ? setupStatefulComponent(instance, isSSR)
        : undefined;
    isInSSRComponentSetup = false;
    return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
    var _a;
    const Component = instance.type;
    if ((true)) {
        if (Component.name) {
            validateComponentName(Component.name, instance.appContext.config);
        }
        if (Component.components) {
            const names = Object.keys(Component.components);
            for (let i = 0; i < names.length; i++) {
                validateComponentName(names[i], instance.appContext.config);
            }
        }
        if (Component.directives) {
            const names = Object.keys(Component.directives);
            for (let i = 0; i < names.length; i++) {
                validateDirectiveName(names[i]);
            }
        }
        if (Component.compilerOptions && isRuntimeOnly()) {
            warn(`"compilerOptions" is only supported when using a build of Vue that ` +
                `includes the runtime compiler. Since you are using a runtime-only ` +
                `build, the options should be passed via your build tool config instead.`);
        }
    }
    // 0. create render proxy property access cache
    instance.accessCache = Object.create(null);
    // 1. create public instance / render proxy
    // also mark it raw so it's never observed
    instance.proxy = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw)(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
    if ((true)) {
        exposePropsOnRenderContext(instance);
    }
    // 2. call setup()
    const { setup } = Component;
    if (setup) {
        const setupContext = (instance.setupContext =
            setup.length > 1 ? createSetupContext(instance) : null);
        setCurrentInstance(instance);
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
        const setupResult = callWithErrorHandling(setup, instance, 0 /* ErrorCodes.SETUP_FUNCTION */, [( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(instance.props) : 0, setupContext]);
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
        unsetCurrentInstance();
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(setupResult)) {
            setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
            if (isSSR) {
                // return the promise so server-renderer can wait on it
                return setupResult
                    .then((resolvedResult) => {
                    handleSetupResult(instance, resolvedResult, isSSR);
                })
                    .catch(e => {
                    handleError(e, instance, 0 /* ErrorCodes.SETUP_FUNCTION */);
                });
            }
            else {
                // async setup returned Promise.
                // bail here and wait for re-entry.
                instance.asyncDep = setupResult;
                if (( true) && !instance.suspense) {
                    const name = (_a = Component.name) !== null && _a !== void 0 ? _a : 'Anonymous';
                    warn(`Component <${name}>: setup function returned a promise, but no ` +
                        `<Suspense> boundary was found in the parent component tree. ` +
                        `A component with async setup() must be nested in a <Suspense> ` +
                        `in order to be rendered.`);
                }
            }
        }
        else {
            handleSetupResult(instance, setupResult, isSSR);
        }
    }
    else {
        finishComponentSetup(instance, isSSR);
    }
}
function handleSetupResult(instance, setupResult, isSSR) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(setupResult)) {
        // setup returned an inline render function
        if (instance.type.__ssrInlineRender) {
            // when the function's name is `ssrRender` (compiled by SFC inline mode),
            // set it as ssrRender instead.
            instance.ssrRender = setupResult;
        }
        else {
            instance.render = setupResult;
        }
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(setupResult)) {
        if (( true) && isVNode(setupResult)) {
            warn(`setup() should not return VNodes directly - ` +
                `return a render function instead.`);
        }
        // setup returned bindings.
        // assuming a render function compiled from template is present.
        if (true) {
            instance.devtoolsRawSetupState = setupResult;
        }
        instance.setupState = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)(setupResult);
        if ((true)) {
            exposeSetupStateOnRenderContext(instance);
        }
    }
    else if (( true) && setupResult !== undefined) {
        warn(`setup() should return an object. Received: ${setupResult === null ? 'null' : typeof setupResult}`);
    }
    finishComponentSetup(instance, isSSR);
}
let compile;
let installWithProxy;
/**
 * For runtime-dom to register the compiler.
 * Note the exported method uses any to avoid d.ts relying on the compiler types.
 */
function registerRuntimeCompiler(_compile) {
    compile = _compile;
    installWithProxy = i => {
        if (i.render._rc) {
            i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
        }
    };
}
// dev only
const isRuntimeOnly = () => !compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component = instance.type;
    // template / render function normalization
    // could be already set when returned from setup()
    if (!instance.render) {
        // only do on-the-fly compile if not in SSR - SSR on-the-fly compilation
        // is done by server-renderer
        if (!isSSR && compile && !Component.render) {
            const template = Component.template ||
                resolveMergedOptions(instance).template;
            if (template) {
                if ((true)) {
                    startMeasure(instance, `compile`);
                }
                const { isCustomElement, compilerOptions } = instance.appContext.config;
                const { delimiters, compilerOptions: componentCompilerOptions } = Component;
                const finalCompilerOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({
                    isCustomElement,
                    delimiters
                }, compilerOptions), componentCompilerOptions);
                Component.render = compile(template, finalCompilerOptions);
                if ((true)) {
                    endMeasure(instance, `compile`);
                }
            }
        }
        instance.render = (Component.render || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP);
        // for runtime-compiled render functions using `with` blocks, the render
        // proxy used needs a different `has` handler which is more performant and
        // also only allows a whitelist of globals to fallthrough.
        if (installWithProxy) {
            installWithProxy(instance);
        }
    }
    // support for 2.x options
    if (__VUE_OPTIONS_API__ && !(false )) {
        setCurrentInstance(instance);
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
        applyOptions(instance);
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
        unsetCurrentInstance();
    }
    // warn missing template/render
    // the runtime compilation of template in SSR is done by server-render
    if (( true) && !Component.render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP && !isSSR) {
        /* istanbul ignore if */
        if (!compile && Component.template) {
            warn(`Component provided template option but ` +
                `runtime compilation is not supported in this build of Vue.` +
                (` Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
                    ) /* should not happen */);
        }
        else {
            warn(`Component is missing template or render function.`);
        }
    }
}
function createAttrsProxy(instance) {
    return new Proxy(instance.attrs, ( true)
        ? {
            get(target, key) {
                markAttrsAccessed();
                (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(instance, "get" /* TrackOpTypes.GET */, '$attrs');
                return target[key];
            },
            set() {
                warn(`setupContext.attrs is readonly.`);
                return false;
            },
            deleteProperty() {
                warn(`setupContext.attrs is readonly.`);
                return false;
            }
        }
        : 0);
}
function createSetupContext(instance) {
    const expose = exposed => {
        if (( true) && instance.exposed) {
            warn(`expose() should be called only once per setup().`);
        }
        instance.exposed = exposed || {};
    };
    let attrs;
    if ((true)) {
        // We use getters in dev in case libs like test-utils overwrite instance
        // properties (overwrites should not be done in prod)
        return Object.freeze({
            get attrs() {
                return attrs || (attrs = createAttrsProxy(instance));
            },
            get slots() {
                return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(instance.slots);
            },
            get emit() {
                return (event, ...args) => instance.emit(event, ...args);
            },
            expose
        });
    }
    else {}
}
function getExposeProxy(instance) {
    if (instance.exposed) {
        return (instance.exposeProxy ||
            (instance.exposeProxy = new Proxy((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw)(instance.exposed)), {
                get(target, key) {
                    if (key in target) {
                        return target[key];
                    }
                    else if (key in publicPropertiesMap) {
                        return publicPropertiesMap[key](instance);
                    }
                },
                has(target, key) {
                    return key in target || key in publicPropertiesMap;
                }
            })));
    }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');
function getComponentName(Component, includeInferred = true) {
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(Component)
        ? Component.displayName || Component.name
        : Component.name || (includeInferred && Component.__name);
}
/* istanbul ignore next */
function formatComponentName(instance, Component, isRoot = false) {
    let name = getComponentName(Component);
    if (!name && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
        if (match) {
            name = match[1];
        }
    }
    if (!name && instance && instance.parent) {
        // try to infer the name based on reverse resolution
        const inferFromRegistry = (registry) => {
            for (const key in registry) {
                if (registry[key] === Component) {
                    return key;
                }
            }
        };
        name =
            inferFromRegistry(instance.components ||
                instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value) && '__vccOpts' in value;
}

const computed = ((getterOrOptions, debugOptions) => {
    // @ts-ignore
    return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.computed)(getterOrOptions, debugOptions, isInSSRComponentSetup);
});

// dev only
const warnRuntimeUsage = (method) => warn(`${method}() is a compiler-hint helper that is only usable inside ` +
    `<script setup> of a single file component. Its arguments should be ` +
    `compiled away and passing it at runtime has no effect.`);
// implementation
function defineProps() {
    if ((true)) {
        warnRuntimeUsage(`defineProps`);
    }
    return null;
}
// implementation
function defineEmits() {
    if ((true)) {
        warnRuntimeUsage(`defineEmits`);
    }
    return null;
}
/**
 * Vue `<script setup>` compiler macro for declaring a component's exposed
 * instance properties when it is accessed by a parent component via template
 * refs.
 *
 * `<script setup>` components are closed by default - i.e. variables inside
 * the `<script setup>` scope is not exposed to parent unless explicitly exposed
 * via `defineExpose`.
 *
 * This is only usable inside `<script setup>`, is compiled away in the
 * output and should **not** be actually called at runtime.
 */
function defineExpose(exposed) {
    if ((true)) {
        warnRuntimeUsage(`defineExpose`);
    }
}
/**
 * Vue `<script setup>` compiler macro for providing props default values when
 * using type-based `defineProps` declaration.
 *
 * Example usage:
 * ```ts
 * withDefaults(defineProps<{
 *   size?: number
 *   labels?: string[]
 * }>(), {
 *   size: 3,
 *   labels: () => ['default label']
 * })
 * ```
 *
 * This is only usable inside `<script setup>`, is compiled away in the output
 * and should **not** be actually called at runtime.
 */
function withDefaults(props, defaults) {
    if ((true)) {
        warnRuntimeUsage(`withDefaults`);
    }
    return null;
}
function useSlots() {
    return getContext().slots;
}
function useAttrs() {
    return getContext().attrs;
}
function getContext() {
    const i = getCurrentInstance();
    if (( true) && !i) {
        warn(`useContext() called without active instance.`);
    }
    return i.setupContext || (i.setupContext = createSetupContext(i));
}
/**
 * Runtime helper for merging default declarations. Imported by compiled code
 * only.
 * @internal
 */
function mergeDefaults(raw, defaults) {
    const props = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)
        ? raw.reduce((normalized, p) => ((normalized[p] = {}), normalized), {})
        : raw;
    for (const key in defaults) {
        const opt = props[key];
        if (opt) {
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opt) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt)) {
                props[key] = { type: opt, default: defaults[key] };
            }
            else {
                opt.default = defaults[key];
            }
        }
        else if (opt === null) {
            props[key] = { default: defaults[key] };
        }
        else if ((true)) {
            warn(`props default key "${key}" has no corresponding declaration.`);
        }
    }
    return props;
}
/**
 * Used to create a proxy for the rest element when destructuring props with
 * defineProps().
 * @internal
 */
function createPropsRestProxy(props, excludedKeys) {
    const ret = {};
    for (const key in props) {
        if (!excludedKeys.includes(key)) {
            Object.defineProperty(ret, key, {
                enumerable: true,
                get: () => props[key]
            });
        }
    }
    return ret;
}
/**
 * `<script setup>` helper for persisting the current instance context over
 * async/await flows.
 *
 * `@vue/compiler-sfc` converts the following:
 *
 * ```ts
 * const x = await foo()
 * ```
 *
 * into:
 *
 * ```ts
 * let __temp, __restore
 * const x = (([__temp, __restore] = withAsyncContext(() => foo())),__temp=await __temp,__restore(),__temp)
 * ```
 * @internal
 */
function withAsyncContext(getAwaitable) {
    const ctx = getCurrentInstance();
    if (( true) && !ctx) {
        warn(`withAsyncContext called without active current instance. ` +
            `This is likely a bug.`);
    }
    let awaitable = getAwaitable();
    unsetCurrentInstance();
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(awaitable)) {
        awaitable = awaitable.catch(e => {
            setCurrentInstance(ctx);
            throw e;
        });
    }
    return [awaitable, () => setCurrentInstance(ctx)];
}

// Actual implementation
function h(type, propsOrChildren, children) {
    const l = arguments.length;
    if (l === 2) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(propsOrChildren) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(propsOrChildren)) {
            // single vnode without props
            if (isVNode(propsOrChildren)) {
                return createVNode(type, null, [propsOrChildren]);
            }
            // props without children
            return createVNode(type, propsOrChildren);
        }
        else {
            // omit props
            return createVNode(type, null, propsOrChildren);
        }
    }
    else {
        if (l > 3) {
            children = Array.prototype.slice.call(arguments, 2);
        }
        else if (l === 3 && isVNode(children)) {
            children = [children];
        }
        return createVNode(type, propsOrChildren, children);
    }
}

const ssrContextKey = Symbol(( true) ? `ssrContext` : 0);
const useSSRContext = () => {
    {
        const ctx = inject(ssrContextKey);
        if (!ctx) {
            ( true) &&
                warn(`Server rendering context not provided. Make sure to only call ` +
                    `useSSRContext() conditionally in the server build.`);
        }
        return ctx;
    }
};

function isShallow(value) {
    return !!(value && value["__v_isShallow" /* ReactiveFlags.IS_SHALLOW */]);
}

function initCustomFormatter() {
    /* eslint-disable no-restricted-globals */
    if ( false || typeof window === 'undefined') {
        return;
    }
    const vueStyle = { style: 'color:#3ba776' };
    const numberStyle = { style: 'color:#0b1bc9' };
    const stringStyle = { style: 'color:#b62e24' };
    const keywordStyle = { style: 'color:#9d288c' };
    // custom formatter for Chrome
    // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html
    const formatter = {
        header(obj) {
            // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup
            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {
                return null;
            }
            if (obj.__isVue) {
                return ['div', vueStyle, `VueInstance`];
            }
            else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(obj)) {
                return [
                    'div',
                    {},
                    ['span', vueStyle, genRefFlag(obj)],
                    '<',
                    formatValue(obj.value),
                    `>`
                ];
            }
            else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(obj)) {
                return [
                    'div',
                    {},
                    ['span', vueStyle, isShallow(obj) ? 'ShallowReactive' : 'Reactive'],
                    '<',
                    formatValue(obj),
                    `>${(0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(obj) ? ` (readonly)` : ``}`
                ];
            }
            else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(obj)) {
                return [
                    'div',
                    {},
                    ['span', vueStyle, isShallow(obj) ? 'ShallowReadonly' : 'Readonly'],
                    '<',
                    formatValue(obj),
                    '>'
                ];
            }
            return null;
        },
        hasBody(obj) {
            return obj && obj.__isVue;
        },
        body(obj) {
            if (obj && obj.__isVue) {
                return [
                    'div',
                    {},
                    ...formatInstance(obj.$)
                ];
            }
        }
    };
    function formatInstance(instance) {
        const blocks = [];
        if (instance.type.props && instance.props) {
            blocks.push(createInstanceBlock('props', (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(instance.props)));
        }
        if (instance.setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
            blocks.push(createInstanceBlock('setup', instance.setupState));
        }
        if (instance.data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
            blocks.push(createInstanceBlock('data', (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(instance.data)));
        }
        const computed = extractKeys(instance, 'computed');
        if (computed) {
            blocks.push(createInstanceBlock('computed', computed));
        }
        const injected = extractKeys(instance, 'inject');
        if (injected) {
            blocks.push(createInstanceBlock('injected', injected));
        }
        blocks.push([
            'div',
            {},
            [
                'span',
                {
                    style: keywordStyle.style + ';opacity:0.66'
                },
                '$ (internal): '
            ],
            ['object', { object: instance }]
        ]);
        return blocks;
    }
    function createInstanceBlock(type, target) {
        target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, target);
        if (!Object.keys(target).length) {
            return ['span', {}];
        }
        return [
            'div',
            { style: 'line-height:1.25em;margin-bottom:0.6em' },
            [
                'div',
                {
                    style: 'color:#476582'
                },
                type
            ],
            [
                'div',
                {
                    style: 'padding-left:1.25em'
                },
                ...Object.keys(target).map(key => {
                    return [
                        'div',
                        {},
                        ['span', keywordStyle, key + ': '],
                        formatValue(target[key], false)
                    ];
                })
            ]
        ];
    }
    function formatValue(v, asRaw = true) {
        if (typeof v === 'number') {
            return ['span', numberStyle, v];
        }
        else if (typeof v === 'string') {
            return ['span', stringStyle, JSON.stringify(v)];
        }
        else if (typeof v === 'boolean') {
            return ['span', keywordStyle, v];
        }
        else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(v)) {
            return ['object', { object: asRaw ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(v) : v }];
        }
        else {
            return ['span', stringStyle, String(v)];
        }
    }
    function extractKeys(instance, type) {
        const Comp = instance.type;
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(Comp)) {
            return;
        }
        const extracted = {};
        for (const key in instance.ctx) {
            if (isKeyOfType(Comp, key, type)) {
                extracted[key] = instance.ctx[key];
            }
        }
        return extracted;
    }
    function isKeyOfType(Comp, key, type) {
        const opts = Comp[type];
        if (((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opts) && opts.includes(key)) ||
            ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opts) && key in opts)) {
            return true;
        }
        if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
            return true;
        }
        if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {
            return true;
        }
    }
    function genRefFlag(v) {
        if (isShallow(v)) {
            return `ShallowRef`;
        }
        if (v.effect) {
            return `ComputedRef`;
        }
        return `Ref`;
    }
    if (window.devtoolsFormatters) {
        window.devtoolsFormatters.push(formatter);
    }
    else {
        window.devtoolsFormatters = [formatter];
    }
}

function withMemo(memo, render, cache, index) {
    const cached = cache[index];
    if (cached && isMemoSame(cached, memo)) {
        return cached;
    }
    const ret = render();
    // shallow clone
    ret.memo = memo.slice();
    return (cache[index] = ret);
}
function isMemoSame(cached, memo) {
    const prev = cached.memo;
    if (prev.length != memo.length) {
        return false;
    }
    for (let i = 0; i < prev.length; i++) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(prev[i], memo[i])) {
            return false;
        }
    }
    // make sure to let parent block track it when returning cached
    if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(cached);
    }
    return true;
}

// Core API ------------------------------------------------------------------
const version = "3.2.45";
const _ssrUtils = {
    createComponentInstance,
    setupComponent,
    renderComponentRoot,
    setCurrentRenderingInstance,
    isVNode,
    normalizeVNode
};
/**
 * SSR utils for \@vue/server-renderer. Only exposed in ssr-possible builds.
 * @internal
 */
const ssrUtils = (_ssrUtils );
/**
 * @internal only exposed in compat builds
 */
const resolveFilter = null;
/**
 * @internal only exposed in compat builds.
 */
const compatUtils = (null);




/***/ }),

/***/ "./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseTransition": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition),
/* harmony export */   "Comment": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Comment),
/* harmony export */   "EffectScope": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.EffectScope),
/* harmony export */   "Fragment": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment),
/* harmony export */   "KeepAlive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.KeepAlive),
/* harmony export */   "ReactiveEffect": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect),
/* harmony export */   "Static": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Static),
/* harmony export */   "Suspense": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Suspense),
/* harmony export */   "Teleport": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Teleport),
/* harmony export */   "Text": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Text),
/* harmony export */   "Transition": () => (/* binding */ Transition),
/* harmony export */   "TransitionGroup": () => (/* binding */ TransitionGroup),
/* harmony export */   "VueElement": () => (/* binding */ VueElement),
/* harmony export */   "callWithAsyncErrorHandling": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling),
/* harmony export */   "callWithErrorHandling": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling),
/* harmony export */   "camelize": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.camelize),
/* harmony export */   "capitalize": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.capitalize),
/* harmony export */   "cloneVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.cloneVNode),
/* harmony export */   "compatUtils": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.compatUtils),
/* harmony export */   "computed": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.computed),
/* harmony export */   "createApp": () => (/* binding */ createApp),
/* harmony export */   "createBlock": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createBlock),
/* harmony export */   "createCommentVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode),
/* harmony export */   "createElementBlock": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createElementBlock),
/* harmony export */   "createElementVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createElementVNode),
/* harmony export */   "createHydrationRenderer": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer),
/* harmony export */   "createPropsRestProxy": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createPropsRestProxy),
/* harmony export */   "createRenderer": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createRenderer),
/* harmony export */   "createSSRApp": () => (/* binding */ createSSRApp),
/* harmony export */   "createSlots": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createSlots),
/* harmony export */   "createStaticVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode),
/* harmony export */   "createTextVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createTextVNode),
/* harmony export */   "createVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode),
/* harmony export */   "customRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   "defineAsyncComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent),
/* harmony export */   "defineComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineComponent),
/* harmony export */   "defineCustomElement": () => (/* binding */ defineCustomElement),
/* harmony export */   "defineEmits": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineEmits),
/* harmony export */   "defineExpose": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineExpose),
/* harmony export */   "defineProps": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineProps),
/* harmony export */   "defineSSRCustomElement": () => (/* binding */ defineSSRCustomElement),
/* harmony export */   "devtools": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.devtools),
/* harmony export */   "effect": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.effect),
/* harmony export */   "effectScope": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.effectScope),
/* harmony export */   "getCurrentInstance": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance),
/* harmony export */   "getCurrentScope": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope),
/* harmony export */   "getTransitionRawChildren": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren),
/* harmony export */   "guardReactiveProps": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.guardReactiveProps),
/* harmony export */   "h": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h),
/* harmony export */   "handleError": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.handleError),
/* harmony export */   "hydrate": () => (/* binding */ hydrate),
/* harmony export */   "initCustomFormatter": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter),
/* harmony export */   "initDirectivesForSSR": () => (/* binding */ initDirectivesForSSR),
/* harmony export */   "inject": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.inject),
/* harmony export */   "isMemoSame": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isMemoSame),
/* harmony export */   "isProxy": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   "isReactive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   "isReadonly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   "isRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   "isRuntimeOnly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly),
/* harmony export */   "isShallow": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isShallow),
/* harmony export */   "isVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isVNode),
/* harmony export */   "markRaw": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   "mergeDefaults": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.mergeDefaults),
/* harmony export */   "mergeProps": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.mergeProps),
/* harmony export */   "nextTick": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nextTick),
/* harmony export */   "normalizeClass": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.normalizeClass),
/* harmony export */   "normalizeProps": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.normalizeProps),
/* harmony export */   "normalizeStyle": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle),
/* harmony export */   "onActivated": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onActivated),
/* harmony export */   "onBeforeMount": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount),
/* harmony export */   "onBeforeUnmount": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount),
/* harmony export */   "onBeforeUpdate": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate),
/* harmony export */   "onDeactivated": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onDeactivated),
/* harmony export */   "onErrorCaptured": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured),
/* harmony export */   "onMounted": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onMounted),
/* harmony export */   "onRenderTracked": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked),
/* harmony export */   "onRenderTriggered": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered),
/* harmony export */   "onScopeDispose": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose),
/* harmony export */   "onServerPrefetch": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch),
/* harmony export */   "onUnmounted": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUnmounted),
/* harmony export */   "onUpdated": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated),
/* harmony export */   "openBlock": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.openBlock),
/* harmony export */   "popScopeId": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.popScopeId),
/* harmony export */   "provide": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.provide),
/* harmony export */   "proxyRefs": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   "pushScopeId": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.pushScopeId),
/* harmony export */   "queuePostFlushCb": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb),
/* harmony export */   "reactive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   "readonly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   "ref": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   "registerRuntimeCompiler": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler),
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "renderList": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.renderList),
/* harmony export */   "renderSlot": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.renderSlot),
/* harmony export */   "resolveComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveComponent),
/* harmony export */   "resolveDirective": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveDirective),
/* harmony export */   "resolveDynamicComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent),
/* harmony export */   "resolveFilter": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveFilter),
/* harmony export */   "resolveTransitionHooks": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks),
/* harmony export */   "setBlockTracking": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking),
/* harmony export */   "setDevtoolsHook": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook),
/* harmony export */   "setTransitionHooks": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks),
/* harmony export */   "shallowReactive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   "shallowRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   "ssrContextKey": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey),
/* harmony export */   "ssrUtils": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ssrUtils),
/* harmony export */   "stop": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.stop),
/* harmony export */   "toDisplayString": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey),
/* harmony export */   "toHandlers": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toHandlers),
/* harmony export */   "toRaw": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   "toRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   "toRefs": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   "transformVNodeArgs": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs),
/* harmony export */   "triggerRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   "unref": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   "useAttrs": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useAttrs),
/* harmony export */   "useCssModule": () => (/* binding */ useCssModule),
/* harmony export */   "useCssVars": () => (/* binding */ useCssVars),
/* harmony export */   "useSSRContext": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useSSRContext),
/* harmony export */   "useSlots": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useSlots),
/* harmony export */   "useTransitionState": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTransitionState),
/* harmony export */   "vModelCheckbox": () => (/* binding */ vModelCheckbox),
/* harmony export */   "vModelDynamic": () => (/* binding */ vModelDynamic),
/* harmony export */   "vModelRadio": () => (/* binding */ vModelRadio),
/* harmony export */   "vModelSelect": () => (/* binding */ vModelSelect),
/* harmony export */   "vModelText": () => (/* binding */ vModelText),
/* harmony export */   "vShow": () => (/* binding */ vShow),
/* harmony export */   "version": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.version),
/* harmony export */   "warn": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn),
/* harmony export */   "watch": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watch),
/* harmony export */   "watchEffect": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchEffect),
/* harmony export */   "watchPostEffect": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect),
/* harmony export */   "watchSyncEffect": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchSyncEffect),
/* harmony export */   "withAsyncContext": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withAsyncContext),
/* harmony export */   "withCtx": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withCtx),
/* harmony export */   "withDefaults": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withDefaults),
/* harmony export */   "withDirectives": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withDirectives),
/* harmony export */   "withKeys": () => (/* binding */ withKeys),
/* harmony export */   "withMemo": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withMemo),
/* harmony export */   "withModifiers": () => (/* binding */ withModifiers),
/* harmony export */   "withScopeId": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withScopeId)
/* harmony export */ });
/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-core */ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vue/runtime-core */ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js");




const svgNS = 'http://www.w3.org/2000/svg';
const doc = (typeof document !== 'undefined' ? document : null);
const templateContainer = doc && /*#__PURE__*/ doc.createElement('template');
const nodeOps = {
    insert: (child, parent, anchor) => {
        parent.insertBefore(child, anchor || null);
    },
    remove: child => {
        const parent = child.parentNode;
        if (parent) {
            parent.removeChild(child);
        }
    },
    createElement: (tag, isSVG, is, props) => {
        const el = isSVG
            ? doc.createElementNS(svgNS, tag)
            : doc.createElement(tag, is ? { is } : undefined);
        if (tag === 'select' && props && props.multiple != null) {
            el.setAttribute('multiple', props.multiple);
        }
        return el;
    },
    createText: text => doc.createTextNode(text),
    createComment: text => doc.createComment(text),
    setText: (node, text) => {
        node.nodeValue = text;
    },
    setElementText: (el, text) => {
        el.textContent = text;
    },
    parentNode: node => node.parentNode,
    nextSibling: node => node.nextSibling,
    querySelector: selector => doc.querySelector(selector),
    setScopeId(el, id) {
        el.setAttribute(id, '');
    },
    // __UNSAFE__
    // Reason: innerHTML.
    // Static content here can only come from compiled templates.
    // As long as the user only uses trusted templates, this is safe.
    insertStaticContent(content, parent, anchor, isSVG, start, end) {
        // <parent> before | first ... last | anchor </parent>
        const before = anchor ? anchor.previousSibling : parent.lastChild;
        // #5308 can only take cached path if:
        // - has a single root node
        // - nextSibling info is still available
        if (start && (start === end || start.nextSibling)) {
            // cached
            while (true) {
                parent.insertBefore(start.cloneNode(true), anchor);
                if (start === end || !(start = start.nextSibling))
                    break;
            }
        }
        else {
            // fresh insert
            templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
            const template = templateContainer.content;
            if (isSVG) {
                // remove outer svg wrapper
                const wrapper = template.firstChild;
                while (wrapper.firstChild) {
                    template.appendChild(wrapper.firstChild);
                }
                template.removeChild(wrapper);
            }
            parent.insertBefore(template, anchor);
        }
        return [
            // first
            before ? before.nextSibling : parent.firstChild,
            // last
            anchor ? anchor.previousSibling : parent.lastChild
        ];
    }
};

// compiler should normalize class + :class bindings on the same element
// into a single binding ['staticClass', dynamic]
function patchClass(el, value, isSVG) {
    // directly setting className should be faster than setAttribute in theory
    // if this is an element during a transition, take the temporary transition
    // classes into account.
    const transitionClasses = el._vtc;
    if (transitionClasses) {
        value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(' ');
    }
    if (value == null) {
        el.removeAttribute('class');
    }
    else if (isSVG) {
        el.setAttribute('class', value);
    }
    else {
        el.className = value;
    }
}

function patchStyle(el, prev, next) {
    const style = el.style;
    const isCssString = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(next);
    if (next && !isCssString) {
        for (const key in next) {
            setStyle(style, key, next[key]);
        }
        if (prev && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(prev)) {
            for (const key in prev) {
                if (next[key] == null) {
                    setStyle(style, key, '');
                }
            }
        }
    }
    else {
        const currentDisplay = style.display;
        if (isCssString) {
            if (prev !== next) {
                style.cssText = next;
            }
        }
        else if (prev) {
            el.removeAttribute('style');
        }
        // indicates that the `display` of the element is controlled by `v-show`,
        // so we always keep the current `display` value regardless of the `style`
        // value, thus handing over control to `v-show`.
        if ('_vod' in el) {
            style.display = currentDisplay;
        }
    }
}
const semicolonRE = /[^\\];\s*$/;
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(val)) {
        val.forEach(v => setStyle(style, name, v));
    }
    else {
        if (val == null)
            val = '';
        if ((true)) {
            if (semicolonRE.test(val)) {
                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Unexpected semicolon at the end of '${name}' style value: '${val}'`);
            }
        }
        if (name.startsWith('--')) {
            // custom property definition
            style.setProperty(name, val);
        }
        else {
            const prefixed = autoPrefix(style, name);
            if (importantRE.test(val)) {
                // !important
                style.setProperty((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(prefixed), val.replace(importantRE, ''), 'important');
            }
            else {
                style[prefixed] = val;
            }
        }
    }
}
const prefixes = ['Webkit', 'Moz', 'ms'];
const prefixCache = {};
function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) {
        return cached;
    }
    let name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(rawName);
    if (name !== 'filter' && name in style) {
        return (prefixCache[rawName] = name);
    }
    name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(name);
    for (let i = 0; i < prefixes.length; i++) {
        const prefixed = prefixes[i] + name;
        if (prefixed in style) {
            return (prefixCache[rawName] = prefixed);
        }
    }
    return rawName;
}

const xlinkNS = 'http://www.w3.org/1999/xlink';
function patchAttr(el, key, value, isSVG, instance) {
    if (isSVG && key.startsWith('xlink:')) {
        if (value == null) {
            el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        }
        else {
            el.setAttributeNS(xlinkNS, key, value);
        }
    }
    else {
        // note we are only checking boolean attributes that don't have a
        // corresponding dom prop of the same name here.
        const isBoolean = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSpecialBooleanAttr)(key);
        if (value == null || (isBoolean && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.includeBooleanAttr)(value))) {
            el.removeAttribute(key);
        }
        else {
            el.setAttribute(key, isBoolean ? '' : value);
        }
    }
}

// __UNSAFE__
// functions. The user is responsible for using them with only trusted content.
function patchDOMProp(el, key, value, 
// the following args are passed only due to potential innerHTML/textContent
// overriding existing VNodes, in which case the old tree must be properly
// unmounted.
prevChildren, parentComponent, parentSuspense, unmountChildren) {
    if (key === 'innerHTML' || key === 'textContent') {
        if (prevChildren) {
            unmountChildren(prevChildren, parentComponent, parentSuspense);
        }
        el[key] = value == null ? '' : value;
        return;
    }
    if (key === 'value' &&
        el.tagName !== 'PROGRESS' &&
        // custom elements may use _value internally
        !el.tagName.includes('-')) {
        // store value as _value as well since
        // non-string values will be stringified.
        el._value = value;
        const newValue = value == null ? '' : value;
        if (el.value !== newValue ||
            // #4956: always set for OPTION elements because its value falls back to
            // textContent if no value attribute is present. And setting .value for
            // OPTION has no side effect
            el.tagName === 'OPTION') {
            el.value = newValue;
        }
        if (value == null) {
            el.removeAttribute(key);
        }
        return;
    }
    let needRemove = false;
    if (value === '' || value == null) {
        const type = typeof el[key];
        if (type === 'boolean') {
            // e.g. <select multiple> compiles to { multiple: '' }
            value = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.includeBooleanAttr)(value);
        }
        else if (value == null && type === 'string') {
            // e.g. <div :id="null">
            value = '';
            needRemove = true;
        }
        else if (type === 'number') {
            // e.g. <img :width="null">
            value = 0;
            needRemove = true;
        }
    }
    // some properties perform value validation and throw,
    // some properties has getter, no setter, will error in 'use strict'
    // eg. <select :type="null"></select> <select :willValidate="null"></select>
    try {
        el[key] = value;
    }
    catch (e) {
        // do not warn if value is auto-coerced from nullish values
        if (( true) && !needRemove) {
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Failed setting prop "${key}" on <${el.tagName.toLowerCase()}>: ` +
                `value ${value} is invalid.`, e);
        }
    }
    needRemove && el.removeAttribute(key);
}

function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    // vei = vue event invokers
    const invokers = el._vei || (el._vei = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) {
        // patch
        existingInvoker.value = nextValue;
    }
    else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
            // add
            const invoker = (invokers[rawName] = createInvoker(nextValue, instance));
            addEventListener(el, name, invoker, options);
        }
        else if (existingInvoker) {
            // remove
            removeEventListener(el, name, existingInvoker, options);
            invokers[rawName] = undefined;
        }
    }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
        options = {};
        let m;
        while ((m = name.match(optionsModifierRE))) {
            name = name.slice(0, name.length - m[0].length);
            options[m[0].toLowerCase()] = true;
        }
    }
    const event = name[2] === ':' ? name.slice(3) : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(name.slice(2));
    return [event, options];
}
// To avoid the overhead of repeatedly calling Date.now(), we cache
// and use the same timestamp for all event listeners attached in the same tick.
let cachedNow = 0;
const p = /*#__PURE__*/ Promise.resolve();
const getNow = () => cachedNow || (p.then(() => (cachedNow = 0)), (cachedNow = Date.now()));
function createInvoker(initialValue, instance) {
    const invoker = (e) => {
        // async edge case vuejs/vue#6566
        // inner click event triggers patch, event handler
        // attached to outer element during patch, and triggered again. This
        // happens because browsers fire microtask ticks between event propagation.
        // this no longer happens for templates in Vue 3, but could still be
        // theoretically possible for hand-written render functions.
        // the solution: we save the timestamp when a handler is attached,
        // and also attach the timestamp to any event that was handled by vue
        // for the first time (to avoid inconsistent event timestamp implementations
        // or events fired from iframes, e.g. #2513)
        // The handler would only fire if the event passed to it was fired
        // AFTER it was attached.
        if (!e._vts) {
            e._vts = Date.now();
        }
        else if (e._vts <= invoker.attached) {
            return;
        }
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling)(patchStopImmediatePropagation(e, invoker.value), instance, 5 /* ErrorCodes.NATIVE_EVENT_HANDLER */, [e]);
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
}
function patchStopImmediatePropagation(e, value) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = () => {
            originalStop.call(e);
            e._stopped = true;
        };
        return value.map(fn => (e) => !e._stopped && fn && fn(e));
    }
    else {
        return value;
    }
}

const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
    if (key === 'class') {
        patchClass(el, nextValue, isSVG);
    }
    else if (key === 'style') {
        patchStyle(el, prevValue, nextValue);
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
        // ignore v-model listeners
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key)) {
            patchEvent(el, key, prevValue, nextValue, parentComponent);
        }
    }
    else if (key[0] === '.'
        ? ((key = key.slice(1)), true)
        : key[0] === '^'
            ? ((key = key.slice(1)), false)
            : shouldSetAsProp(el, key, nextValue, isSVG)) {
        patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
    }
    else {
        // special case for <input v-model type="checkbox"> with
        // :true-value & :false-value
        // store value as dom properties since non-string values will be
        // stringified.
        if (key === 'true-value') {
            el._trueValue = nextValue;
        }
        else if (key === 'false-value') {
            el._falseValue = nextValue;
        }
        patchAttr(el, key, nextValue, isSVG);
    }
};
function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
        // most keys must be set as attribute on svg elements to work
        // ...except innerHTML & textContent
        if (key === 'innerHTML' || key === 'textContent') {
            return true;
        }
        // or native onclick with function values
        if (key in el && nativeOnRE.test(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
            return true;
        }
        return false;
    }
    // these are enumerated attrs, however their corresponding DOM properties
    // are actually booleans - this leads to setting it with a string "false"
    // value leading it to be coerced to `true`, so we need to always treat
    // them as attributes.
    // Note that `contentEditable` doesn't have this problem: its DOM
    // property is also enumerated string values.
    if (key === 'spellcheck' || key === 'draggable' || key === 'translate') {
        return false;
    }
    // #1787, #2840 form property on form elements is readonly and must be set as
    // attribute.
    if (key === 'form') {
        return false;
    }
    // #1526 <input list> must be set as attribute
    if (key === 'list' && el.tagName === 'INPUT') {
        return false;
    }
    // #2766 <textarea type> must be set as attribute
    if (key === 'type' && el.tagName === 'TEXTAREA') {
        return false;
    }
    // native onclick with string value, must be set as attribute
    if (nativeOnRE.test(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {
        return false;
    }
    return key in el;
}

function defineCustomElement(options, hydrate) {
    const Comp = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineComponent)(options);
    class VueCustomElement extends VueElement {
        constructor(initialProps) {
            super(Comp, initialProps, hydrate);
        }
    }
    VueCustomElement.def = Comp;
    return VueCustomElement;
}
const defineSSRCustomElement = ((options) => {
    // @ts-ignore
    return defineCustomElement(options, hydrate);
});
const BaseClass = (typeof HTMLElement !== 'undefined' ? HTMLElement : class {
});
class VueElement extends BaseClass {
    constructor(_def, _props = {}, hydrate) {
        super();
        this._def = _def;
        this._props = _props;
        /**
         * @internal
         */
        this._instance = null;
        this._connected = false;
        this._resolved = false;
        this._numberProps = null;
        if (this.shadowRoot && hydrate) {
            hydrate(this._createVNode(), this.shadowRoot);
        }
        else {
            if (( true) && this.shadowRoot) {
                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Custom element has pre-rendered declarative shadow root but is not ` +
                    `defined as hydratable. Use \`defineSSRCustomElement\`.`);
            }
            this.attachShadow({ mode: 'open' });
            if (!this._def.__asyncLoader) {
                // for sync component defs we can immediately resolve props
                this._resolveProps(this._def);
            }
        }
    }
    connectedCallback() {
        this._connected = true;
        if (!this._instance) {
            if (this._resolved) {
                this._update();
            }
            else {
                this._resolveDef();
            }
        }
    }
    disconnectedCallback() {
        this._connected = false;
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => {
            if (!this._connected) {
                render(null, this.shadowRoot);
                this._instance = null;
            }
        });
    }
    /**
     * resolve inner component definition (handle possible async component)
     */
    _resolveDef() {
        this._resolved = true;
        // set initial attrs
        for (let i = 0; i < this.attributes.length; i++) {
            this._setAttr(this.attributes[i].name);
        }
        // watch future attr changes
        new MutationObserver(mutations => {
            for (const m of mutations) {
                this._setAttr(m.attributeName);
            }
        }).observe(this, { attributes: true });
        const resolve = (def, isAsync = false) => {
            const { props, styles } = def;
            // cast Number-type props set before resolve
            let numberProps;
            if (props && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(props)) {
                for (const key in props) {
                    const opt = props[key];
                    if (opt === Number || (opt && opt.type === Number)) {
                        if (key in this._props) {
                            this._props[key] = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(this._props[key]);
                        }
                        (numberProps || (numberProps = Object.create(null)))[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key)] = true;
                    }
                }
            }
            this._numberProps = numberProps;
            if (isAsync) {
                // defining getter/setters on prototype
                // for sync defs, this already happened in the constructor
                this._resolveProps(def);
            }
            // apply CSS
            this._applyStyles(styles);
            // initial render
            this._update();
        };
        const asyncDef = this._def.__asyncLoader;
        if (asyncDef) {
            asyncDef().then(def => resolve(def, true));
        }
        else {
            resolve(this._def);
        }
    }
    _resolveProps(def) {
        const { props } = def;
        const declaredPropKeys = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(props) ? props : Object.keys(props || {});
        // check if there are props set pre-upgrade or connect
        for (const key of Object.keys(this)) {
            if (key[0] !== '_' && declaredPropKeys.includes(key)) {
                this._setProp(key, this[key], true, false);
            }
        }
        // defining getter/setters on prototype
        for (const key of declaredPropKeys.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)) {
            Object.defineProperty(this, key, {
                get() {
                    return this._getProp(key);
                },
                set(val) {
                    this._setProp(key, val);
                }
            });
        }
    }
    _setAttr(key) {
        let value = this.getAttribute(key);
        const camelKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);
        if (this._numberProps && this._numberProps[camelKey]) {
            value = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(value);
        }
        this._setProp(camelKey, value, false);
    }
    /**
     * @internal
     */
    _getProp(key) {
        return this._props[key];
    }
    /**
     * @internal
     */
    _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
        if (val !== this._props[key]) {
            this._props[key] = val;
            if (shouldUpdate && this._instance) {
                this._update();
            }
            // reflect
            if (shouldReflect) {
                if (val === true) {
                    this.setAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key), '');
                }
                else if (typeof val === 'string' || typeof val === 'number') {
                    this.setAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key), val + '');
                }
                else if (!val) {
                    this.removeAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key));
                }
            }
        }
    }
    _update() {
        render(this._createVNode(), this.shadowRoot);
    }
    _createVNode() {
        const vnode = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode)(this._def, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, this._props));
        if (!this._instance) {
            vnode.ce = instance => {
                this._instance = instance;
                instance.isCE = true;
                // HMR
                if ((true)) {
                    instance.ceReload = newStyles => {
                        // always reset styles
                        if (this._styles) {
                            this._styles.forEach(s => this.shadowRoot.removeChild(s));
                            this._styles.length = 0;
                        }
                        this._applyStyles(newStyles);
                        this._instance = null;
                        this._update();
                    };
                }
                const dispatch = (event, args) => {
                    this.dispatchEvent(new CustomEvent(event, {
                        detail: args
                    }));
                };
                // intercept emit
                instance.emit = (event, ...args) => {
                    // dispatch both the raw and hyphenated versions of an event
                    // to match Vue behavior
                    dispatch(event, args);
                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event) !== event) {
                        dispatch((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event), args);
                    }
                };
                // locate nearest Vue custom element parent for provide/inject
                let parent = this;
                while ((parent =
                    parent && (parent.parentNode || parent.host))) {
                    if (parent instanceof VueElement) {
                        instance.parent = parent._instance;
                        instance.provides = parent._instance.provides;
                        break;
                    }
                }
            };
        }
        return vnode;
    }
    _applyStyles(styles) {
        if (styles) {
            styles.forEach(css => {
                const s = document.createElement('style');
                s.textContent = css;
                this.shadowRoot.appendChild(s);
                // record for HMR
                if ((true)) {
                    (this._styles || (this._styles = [])).push(s);
                }
            });
        }
    }
}

function useCssModule(name = '$style') {
    /* istanbul ignore else */
    {
        const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
        if (!instance) {
            ( true) && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`useCssModule must be called inside setup()`);
            return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        }
        const modules = instance.type.__cssModules;
        if (!modules) {
            ( true) && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Current instance does not have CSS modules injected.`);
            return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        }
        const mod = modules[name];
        if (!mod) {
            ( true) &&
                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Current instance does not have CSS module named "${name}".`);
            return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        }
        return mod;
    }
}

/**
 * Runtime helper for SFC's CSS variable injection feature.
 * @private
 */
function useCssVars(getter) {
    const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
    /* istanbul ignore next */
    if (!instance) {
        ( true) &&
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`useCssVars is called without current active component instance.`);
        return;
    }
    const updateTeleports = (instance.ut = (vars = getter(instance.proxy)) => {
        Array.from(document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)).forEach(node => setVarsOnNode(node, vars));
    });
    const setVars = () => {
        const vars = getter(instance.proxy);
        setVarsOnVNode(instance.subTree, vars);
        updateTeleports(vars);
    };
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect)(setVars);
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
        const ob = new MutationObserver(setVars);
        ob.observe(instance.subTree.el.parentNode, { childList: true });
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => ob.disconnect());
    });
}
function setVarsOnVNode(vnode, vars) {
    if (vnode.shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {
        const suspense = vnode.suspense;
        vnode = suspense.activeBranch;
        if (suspense.pendingBranch && !suspense.isHydrating) {
            suspense.effects.push(() => {
                setVarsOnVNode(suspense.activeBranch, vars);
            });
        }
    }
    // drill down HOCs until it's a non-component vnode
    while (vnode.component) {
        vnode = vnode.component.subTree;
    }
    if (vnode.shapeFlag & 1 /* ShapeFlags.ELEMENT */ && vnode.el) {
        setVarsOnNode(vnode.el, vars);
    }
    else if (vnode.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment) {
        vnode.children.forEach(c => setVarsOnVNode(c, vars));
    }
    else if (vnode.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Static) {
        let { el, anchor } = vnode;
        while (el) {
            setVarsOnNode(el, vars);
            if (el === anchor)
                break;
            el = el.nextSibling;
        }
    }
}
function setVarsOnNode(el, vars) {
    if (el.nodeType === 1) {
        const style = el.style;
        for (const key in vars) {
            style.setProperty(`--${key}`, vars[key]);
        }
    }
}

const TRANSITION = 'transition';
const ANIMATION = 'animation';
// DOM Transition is a higher-order-component based on the platform-agnostic
// base Transition component, with DOM-specific logic.
const Transition = (props, { slots }) => (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h)(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition, resolveTransitionProps(props), slots);
Transition.displayName = 'Transition';
const DOMTransitionPropsValidators = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: true
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
};
const TransitionPropsValidators = (Transition.props =
    /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition.props, DOMTransitionPropsValidators));
/**
 * #3227 Incoming hooks may be merged into arrays when wrapping Transition
 * with custom HOCs.
 */
const callHook = (hook, args = []) => {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {
        hook.forEach(h => h(...args));
    }
    else if (hook) {
        hook(...args);
    }
};
/**
 * Check if a hook expects a callback (2nd arg), which means the user
 * intends to explicitly control the end of the transition.
 */
const hasExplicitCallback = (hook) => {
    return hook
        ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)
            ? hook.some(h => h.length > 1)
            : hook.length > 1
        : false;
};
function resolveTransitionProps(rawProps) {
    const baseProps = {};
    for (const key in rawProps) {
        if (!(key in DOMTransitionPropsValidators)) {
            baseProps[key] = rawProps[key];
        }
    }
    if (rawProps.css === false) {
        return baseProps;
    }
    const { name = 'v', type, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;
    const durations = normalizeDuration(duration);
    const enterDuration = durations && durations[0];
    const leaveDuration = durations && durations[1];
    const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
    const finishEnter = (el, isAppear, done) => {
        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
    };
    const finishLeave = (el, done) => {
        el._isLeaving = false;
        removeTransitionClass(el, leaveFromClass);
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
        done && done();
    };
    const makeEnterHook = (isAppear) => {
        return (el, done) => {
            const hook = isAppear ? onAppear : onEnter;
            const resolve = () => finishEnter(el, isAppear, done);
            callHook(hook, [el, resolve]);
            nextFrame(() => {
                removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
                addTransitionClass(el, isAppear ? appearToClass : enterToClass);
                if (!hasExplicitCallback(hook)) {
                    whenTransitionEnds(el, type, enterDuration, resolve);
                }
            });
        };
    };
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(baseProps, {
        onBeforeEnter(el) {
            callHook(onBeforeEnter, [el]);
            addTransitionClass(el, enterFromClass);
            addTransitionClass(el, enterActiveClass);
        },
        onBeforeAppear(el) {
            callHook(onBeforeAppear, [el]);
            addTransitionClass(el, appearFromClass);
            addTransitionClass(el, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave(el, done) {
            el._isLeaving = true;
            const resolve = () => finishLeave(el, done);
            addTransitionClass(el, leaveFromClass);
            // force reflow so *-leave-from classes immediately take effect (#2593)
            forceReflow();
            addTransitionClass(el, leaveActiveClass);
            nextFrame(() => {
                if (!el._isLeaving) {
                    // cancelled
                    return;
                }
                removeTransitionClass(el, leaveFromClass);
                addTransitionClass(el, leaveToClass);
                if (!hasExplicitCallback(onLeave)) {
                    whenTransitionEnds(el, type, leaveDuration, resolve);
                }
            });
            callHook(onLeave, [el, resolve]);
        },
        onEnterCancelled(el) {
            finishEnter(el, false);
            callHook(onEnterCancelled, [el]);
        },
        onAppearCancelled(el) {
            finishEnter(el, true);
            callHook(onAppearCancelled, [el]);
        },
        onLeaveCancelled(el) {
            finishLeave(el);
            callHook(onLeaveCancelled, [el]);
        }
    });
}
function normalizeDuration(duration) {
    if (duration == null) {
        return null;
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(duration)) {
        return [NumberOf(duration.enter), NumberOf(duration.leave)];
    }
    else {
        const n = NumberOf(duration);
        return [n, n];
    }
}
function NumberOf(val) {
    const res = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(val);
    if ((true))
        validateDuration(res);
    return res;
}
function validateDuration(val) {
    if (typeof val !== 'number') {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<transition> explicit duration is not a valid number - ` +
            `got ${JSON.stringify(val)}.`);
    }
    else if (isNaN(val)) {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<transition> explicit duration is NaN - ` +
            'the duration expression might be incorrect.');
    }
}
function addTransitionClass(el, cls) {
    cls.split(/\s+/).forEach(c => c && el.classList.add(c));
    (el._vtc ||
        (el._vtc = new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
    cls.split(/\s+/).forEach(c => c && el.classList.remove(c));
    const { _vtc } = el;
    if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) {
            el._vtc = undefined;
        }
    }
}
function nextFrame(cb) {
    requestAnimationFrame(() => {
        requestAnimationFrame(cb);
    });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
    const id = (el._endId = ++endId);
    const resolveIfNotStale = () => {
        if (id === el._endId) {
            resolve();
        }
    };
    if (explicitTimeout) {
        return setTimeout(resolveIfNotStale, explicitTimeout);
    }
    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
    if (!type) {
        return resolve();
    }
    const endEvent = type + 'end';
    let ended = 0;
    const end = () => {
        el.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
    };
    const onEnd = (e) => {
        if (e.target === el && ++ended >= propCount) {
            end();
        }
    };
    setTimeout(() => {
        if (ended < propCount) {
            end();
        }
    }, timeout + 1);
    el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
    const styles = window.getComputedStyle(el);
    // JSDOM may return undefined for transition properties
    const getStyleProperties = (key) => (styles[key] || '').split(', ');
    const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
    const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
    const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type = null;
    let timeout = 0;
    let propCount = 0;
    /* istanbul ignore if */
    if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
            type = TRANSITION;
            timeout = transitionTimeout;
            propCount = transitionDurations.length;
        }
    }
    else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
            type = ANIMATION;
            timeout = animationTimeout;
            propCount = animationDurations.length;
        }
    }
    else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type =
            timeout > 0
                ? transitionTimeout > animationTimeout
                    ? TRANSITION
                    : ANIMATION
                : null;
        propCount = type
            ? type === TRANSITION
                ? transitionDurations.length
                : animationDurations.length
            : 0;
    }
    const hasTransform = type === TRANSITION &&
        /\b(transform|all)(,|$)/.test(getStyleProperties(`${TRANSITION}Property`).toString());
    return {
        type,
        timeout,
        propCount,
        hasTransform
    };
}
function getTimeout(delays, durations) {
    while (delays.length < durations.length) {
        delays = delays.concat(delays);
    }
    return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
// Old versions of Chromium (below 61.0.3163.100) formats floating pointer
// numbers in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down
// (i.e. acting as a floor function) causing unexpected behaviors
function toMs(s) {
    return Number(s.slice(0, -1).replace(',', '.')) * 1000;
}
// synchronously force layout to put elements into a certain state
function forceReflow() {
    return document.body.offsetHeight;
}

const positionMap = new WeakMap();
const newPositionMap = new WeakMap();
const TransitionGroupImpl = {
    name: 'TransitionGroup',
    props: /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, TransitionPropsValidators, {
        tag: String,
        moveClass: String
    }),
    setup(props, { slots }) {
        const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
        const state = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTransitionState)();
        let prevChildren;
        let children;
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated)(() => {
            // children is guaranteed to exist after initial render
            if (!prevChildren.length) {
                return;
            }
            const moveClass = props.moveClass || `${props.name || 'v'}-move`;
            if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
                return;
            }
            // we divide the work into three loops to avoid mixing DOM reads and writes
            // in each iteration - which helps prevent layout thrashing.
            prevChildren.forEach(callPendingCbs);
            prevChildren.forEach(recordPosition);
            const movedChildren = prevChildren.filter(applyTranslation);
            // force reflow to put everything in position
            forceReflow();
            movedChildren.forEach(c => {
                const el = c.el;
                const style = el.style;
                addTransitionClass(el, moveClass);
                style.transform = style.webkitTransform = style.transitionDuration = '';
                const cb = (el._moveCb = (e) => {
                    if (e && e.target !== el) {
                        return;
                    }
                    if (!e || /transform$/.test(e.propertyName)) {
                        el.removeEventListener('transitionend', cb);
                        el._moveCb = null;
                        removeTransitionClass(el, moveClass);
                    }
                });
                el.addEventListener('transitionend', cb);
            });
        });
        return () => {
            const rawProps = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.toRaw)(props);
            const cssTransitionProps = resolveTransitionProps(rawProps);
            let tag = rawProps.tag || _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment;
            prevChildren = children;
            children = slots.default ? (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren)(slots.default()) : [];
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (child.key != null) {
                    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(child, (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(child, cssTransitionProps, state, instance));
                }
                else if ((true)) {
                    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<TransitionGroup> children must be keyed.`);
                }
            }
            if (prevChildren) {
                for (let i = 0; i < prevChildren.length; i++) {
                    const child = prevChildren[i];
                    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(child, (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(child, cssTransitionProps, state, instance));
                    positionMap.set(child, child.el.getBoundingClientRect());
                }
            }
            return (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode)(tag, null, children);
        };
    }
};
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
    const el = c.el;
    if (el._moveCb) {
        el._moveCb();
    }
    if (el._enterCb) {
        el._enterCb();
    }
}
function recordPosition(c) {
    newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
    const oldPos = positionMap.get(c);
    const newPos = newPositionMap.get(c);
    const dx = oldPos.left - newPos.left;
    const dy = oldPos.top - newPos.top;
    if (dx || dy) {
        const s = c.el.style;
        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = '0s';
        return c;
    }
}
function hasCSSTransform(el, root, moveClass) {
    // Detect whether an element with the move class applied has
    // CSS transitions. Since the element may be inside an entering
    // transition at this very moment, we make a clone of it and remove
    // all other transition classes applied to ensure only the move class
    // is applied.
    const clone = el.cloneNode();
    if (el._vtc) {
        el._vtc.forEach(cls => {
            cls.split(/\s+/).forEach(c => c && clone.classList.remove(c));
        });
    }
    moveClass.split(/\s+/).forEach(c => c && clone.classList.add(c));
    clone.style.display = 'none';
    const container = (root.nodeType === 1 ? root : root.parentNode);
    container.appendChild(clone);
    const { hasTransform } = getTransitionInfo(clone);
    container.removeChild(clone);
    return hasTransform;
}

const getModelAssigner = (vnode) => {
    const fn = vnode.props['onUpdate:modelValue'] ||
        (false );
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn) ? value => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(fn, value) : fn;
};
function onCompositionStart(e) {
    e.target.composing = true;
}
function onCompositionEnd(e) {
    const target = e.target;
    if (target.composing) {
        target.composing = false;
        target.dispatchEvent(new Event('input'));
    }
}
// We are exporting the v-model runtime directly as vnode hooks so that it can
// be tree-shaken in case v-model is never used.
const vModelText = {
    created(el, { modifiers: { lazy, trim, number } }, vnode) {
        el._assign = getModelAssigner(vnode);
        const castToNumber = number || (vnode.props && vnode.props.type === 'number');
        addEventListener(el, lazy ? 'change' : 'input', e => {
            if (e.target.composing)
                return;
            let domValue = el.value;
            if (trim) {
                domValue = domValue.trim();
            }
            if (castToNumber) {
                domValue = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(domValue);
            }
            el._assign(domValue);
        });
        if (trim) {
            addEventListener(el, 'change', () => {
                el.value = el.value.trim();
            });
        }
        if (!lazy) {
            addEventListener(el, 'compositionstart', onCompositionStart);
            addEventListener(el, 'compositionend', onCompositionEnd);
            // Safari < 10.2 & UIWebView doesn't fire compositionend when
            // switching focus before confirming composition choice
            // this also fixes the issue where some browsers e.g. iOS Chrome
            // fires "change" instead of "input" on autocomplete.
            addEventListener(el, 'change', onCompositionEnd);
        }
    },
    // set value on mounted so it's after min/max for type="range"
    mounted(el, { value }) {
        el.value = value == null ? '' : value;
    },
    beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) {
        el._assign = getModelAssigner(vnode);
        // avoid clearing unresolved text. #2302
        if (el.composing)
            return;
        if (document.activeElement === el && el.type !== 'range') {
            if (lazy) {
                return;
            }
            if (trim && el.value.trim() === value) {
                return;
            }
            if ((number || el.type === 'number') && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(el.value) === value) {
                return;
            }
        }
        const newValue = value == null ? '' : value;
        if (el.value !== newValue) {
            el.value = newValue;
        }
    }
};
const vModelCheckbox = {
    // #4096 array checkboxes need to be deep traversed
    deep: true,
    created(el, _, vnode) {
        el._assign = getModelAssigner(vnode);
        addEventListener(el, 'change', () => {
            const modelValue = el._modelValue;
            const elementValue = getValue(el);
            const checked = el.checked;
            const assign = el._assign;
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(modelValue)) {
                const index = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(modelValue, elementValue);
                const found = index !== -1;
                if (checked && !found) {
                    assign(modelValue.concat(elementValue));
                }
                else if (!checked && found) {
                    const filtered = [...modelValue];
                    filtered.splice(index, 1);
                    assign(filtered);
                }
            }
            else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(modelValue)) {
                const cloned = new Set(modelValue);
                if (checked) {
                    cloned.add(elementValue);
                }
                else {
                    cloned.delete(elementValue);
                }
                assign(cloned);
            }
            else {
                assign(getCheckboxValue(el, checked));
            }
        });
    },
    // set initial checked on mount to wait for true-value/false-value
    mounted: setChecked,
    beforeUpdate(el, binding, vnode) {
        el._assign = getModelAssigner(vnode);
        setChecked(el, binding, vnode);
    }
};
function setChecked(el, { value, oldValue }, vnode) {
    el._modelValue = value;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
        el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, vnode.props.value) > -1;
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {
        el.checked = value.has(vnode.props.value);
    }
    else if (value !== oldValue) {
        el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, getCheckboxValue(el, true));
    }
}
const vModelRadio = {
    created(el, { value }, vnode) {
        el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, vnode.props.value);
        el._assign = getModelAssigner(vnode);
        addEventListener(el, 'change', () => {
            el._assign(getValue(el));
        });
    },
    beforeUpdate(el, { value, oldValue }, vnode) {
        el._assign = getModelAssigner(vnode);
        if (value !== oldValue) {
            el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, vnode.props.value);
        }
    }
};
const vModelSelect = {
    // <select multiple> value need to be deep traversed
    deep: true,
    created(el, { value, modifiers: { number } }, vnode) {
        const isSetModel = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value);
        addEventListener(el, 'change', () => {
            const selectedVal = Array.prototype.filter
                .call(el.options, (o) => o.selected)
                .map((o) => number ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(getValue(o)) : getValue(o));
            el._assign(el.multiple
                ? isSetModel
                    ? new Set(selectedVal)
                    : selectedVal
                : selectedVal[0]);
        });
        el._assign = getModelAssigner(vnode);
    },
    // set value in mounted & updated because <select> relies on its children
    // <option>s.
    mounted(el, { value }) {
        setSelected(el, value);
    },
    beforeUpdate(el, _binding, vnode) {
        el._assign = getModelAssigner(vnode);
    },
    updated(el, { value }) {
        setSelected(el, value);
    }
};
function setSelected(el, value) {
    const isMultiple = el.multiple;
    if (isMultiple && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {
        ( true) &&
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<select multiple v-model> expects an Array or Set value for its binding, ` +
                `but got ${Object.prototype.toString.call(value).slice(8, -1)}.`);
        return;
    }
    for (let i = 0, l = el.options.length; i < l; i++) {
        const option = el.options[i];
        const optionValue = getValue(option);
        if (isMultiple) {
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
                option.selected = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, optionValue) > -1;
            }
            else {
                option.selected = value.has(optionValue);
            }
        }
        else {
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(getValue(option), value)) {
                if (el.selectedIndex !== i)
                    el.selectedIndex = i;
                return;
            }
        }
    }
    if (!isMultiple && el.selectedIndex !== -1) {
        el.selectedIndex = -1;
    }
}
// retrieve raw value set via :value bindings
function getValue(el) {
    return '_value' in el ? el._value : el.value;
}
// retrieve raw value for true-value and false-value set via :true-value or :false-value bindings
function getCheckboxValue(el, checked) {
    const key = checked ? '_trueValue' : '_falseValue';
    return key in el ? el[key] : checked;
}
const vModelDynamic = {
    created(el, binding, vnode) {
        callModelHook(el, binding, vnode, null, 'created');
    },
    mounted(el, binding, vnode) {
        callModelHook(el, binding, vnode, null, 'mounted');
    },
    beforeUpdate(el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, 'beforeUpdate');
    },
    updated(el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, 'updated');
    }
};
function resolveDynamicModel(tagName, type) {
    switch (tagName) {
        case 'SELECT':
            return vModelSelect;
        case 'TEXTAREA':
            return vModelText;
        default:
            switch (type) {
                case 'checkbox':
                    return vModelCheckbox;
                case 'radio':
                    return vModelRadio;
                default:
                    return vModelText;
            }
    }
}
function callModelHook(el, binding, vnode, prevVNode, hook) {
    const modelToUse = resolveDynamicModel(el.tagName, vnode.props && vnode.props.type);
    const fn = modelToUse[hook];
    fn && fn(el, binding, vnode, prevVNode);
}
// SSR vnode transforms, only used when user includes client-oriented render
// function in SSR
function initVModelForSSR() {
    vModelText.getSSRProps = ({ value }) => ({ value });
    vModelRadio.getSSRProps = ({ value }, vnode) => {
        if (vnode.props && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(vnode.props.value, value)) {
            return { checked: true };
        }
    };
    vModelCheckbox.getSSRProps = ({ value }, vnode) => {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
            if (vnode.props && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, vnode.props.value) > -1) {
                return { checked: true };
            }
        }
        else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {
            if (vnode.props && value.has(vnode.props.value)) {
                return { checked: true };
            }
        }
        else if (value) {
            return { checked: true };
        }
    };
    vModelDynamic.getSSRProps = (binding, vnode) => {
        if (typeof vnode.type !== 'string') {
            return;
        }
        const modelToUse = resolveDynamicModel(
        // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
        vnode.type.toUpperCase(), vnode.props && vnode.props.type);
        if (modelToUse.getSSRProps) {
            return modelToUse.getSSRProps(binding, vnode);
        }
    };
}

const systemModifiers = ['ctrl', 'shift', 'alt', 'meta'];
const modifierGuards = {
    stop: e => e.stopPropagation(),
    prevent: e => e.preventDefault(),
    self: e => e.target !== e.currentTarget,
    ctrl: e => !e.ctrlKey,
    shift: e => !e.shiftKey,
    alt: e => !e.altKey,
    meta: e => !e.metaKey,
    left: e => 'button' in e && e.button !== 0,
    middle: e => 'button' in e && e.button !== 1,
    right: e => 'button' in e && e.button !== 2,
    exact: (e, modifiers) => systemModifiers.some(m => e[`${m}Key`] && !modifiers.includes(m))
};
/**
 * @private
 */
const withModifiers = (fn, modifiers) => {
    return (event, ...args) => {
        for (let i = 0; i < modifiers.length; i++) {
            const guard = modifierGuards[modifiers[i]];
            if (guard && guard(event, modifiers))
                return;
        }
        return fn(event, ...args);
    };
};
// Kept for 2.x compat.
// Note: IE11 compat for `spacebar` and `del` is removed for now.
const keyNames = {
    esc: 'escape',
    space: ' ',
    up: 'arrow-up',
    left: 'arrow-left',
    right: 'arrow-right',
    down: 'arrow-down',
    delete: 'backspace'
};
/**
 * @private
 */
const withKeys = (fn, modifiers) => {
    return (event) => {
        if (!('key' in event)) {
            return;
        }
        const eventKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event.key);
        if (modifiers.some(k => k === eventKey || keyNames[k] === eventKey)) {
            return fn(event);
        }
    };
};

const vShow = {
    beforeMount(el, { value }, { transition }) {
        el._vod = el.style.display === 'none' ? '' : el.style.display;
        if (transition && value) {
            transition.beforeEnter(el);
        }
        else {
            setDisplay(el, value);
        }
    },
    mounted(el, { value }, { transition }) {
        if (transition && value) {
            transition.enter(el);
        }
    },
    updated(el, { value, oldValue }, { transition }) {
        if (!value === !oldValue)
            return;
        if (transition) {
            if (value) {
                transition.beforeEnter(el);
                setDisplay(el, true);
                transition.enter(el);
            }
            else {
                transition.leave(el, () => {
                    setDisplay(el, false);
                });
            }
        }
        else {
            setDisplay(el, value);
        }
    },
    beforeUnmount(el, { value }) {
        setDisplay(el, value);
    }
};
function setDisplay(el, value) {
    el.style.display = value ? el._vod : 'none';
}
// SSR vnode transforms, only used when user includes client-oriented render
// function in SSR
function initVShowForSSR() {
    vShow.getSSRProps = ({ value }) => {
        if (!value) {
            return { style: { display: 'none' } };
        }
    };
}

const rendererOptions = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({ patchProp }, nodeOps);
// lazy create the renderer - this makes core renderer logic tree-shakable
// in case the user only imports reactivity utilities from Vue.
let renderer;
let enabledHydration = false;
function ensureRenderer() {
    return (renderer ||
        (renderer = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createRenderer)(rendererOptions)));
}
function ensureHydrationRenderer() {
    renderer = enabledHydration
        ? renderer
        : (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer)(rendererOptions);
    enabledHydration = true;
    return renderer;
}
// use explicit type casts here to avoid import() calls in rolled-up d.ts
const render = ((...args) => {
    ensureRenderer().render(...args);
});
const hydrate = ((...args) => {
    ensureHydrationRenderer().hydrate(...args);
});
const createApp = ((...args) => {
    const app = ensureRenderer().createApp(...args);
    if ((true)) {
        injectNativeTagCheck(app);
        injectCompilerOptionsCheck(app);
    }
    const { mount } = app;
    app.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (!container)
            return;
        const component = app._component;
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(component) && !component.render && !component.template) {
            // __UNSAFE__
            // Reason: potential execution of JS expressions in in-DOM template.
            // The user must make sure the in-DOM template is trusted. If it's
            // rendered by the server, the template should not contain any user data.
            component.template = container.innerHTML;
        }
        // clear content before mounting
        container.innerHTML = '';
        const proxy = mount(container, false, container instanceof SVGElement);
        if (container instanceof Element) {
            container.removeAttribute('v-cloak');
            container.setAttribute('data-v-app', '');
        }
        return proxy;
    };
    return app;
});
const createSSRApp = ((...args) => {
    const app = ensureHydrationRenderer().createApp(...args);
    if ((true)) {
        injectNativeTagCheck(app);
        injectCompilerOptionsCheck(app);
    }
    const { mount } = app;
    app.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (container) {
            return mount(container, true, container instanceof SVGElement);
        }
    };
    return app;
});
function injectNativeTagCheck(app) {
    // Inject `isNativeTag`
    // this is used for component name validation (dev only)
    Object.defineProperty(app.config, 'isNativeTag', {
        value: (tag) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isHTMLTag)(tag) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSVGTag)(tag),
        writable: false
    });
}
// dev only
function injectCompilerOptionsCheck(app) {
    if ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly)()) {
        const isCustomElement = app.config.isCustomElement;
        Object.defineProperty(app.config, 'isCustomElement', {
            get() {
                return isCustomElement;
            },
            set() {
                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`The \`isCustomElement\` config option is deprecated. Use ` +
                    `\`compilerOptions.isCustomElement\` instead.`);
            }
        });
        const compilerOptions = app.config.compilerOptions;
        const msg = `The \`compilerOptions\` config option is only respected when using ` +
            `a build of Vue.js that includes the runtime compiler (aka "full build"). ` +
            `Since you are using the runtime-only build, \`compilerOptions\` ` +
            `must be passed to \`@vue/compiler-dom\` in the build setup instead.\n` +
            `- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.\n` +
            `- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n` +
            `- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`;
        Object.defineProperty(app.config, 'compilerOptions', {
            get() {
                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(msg);
                return compilerOptions;
            },
            set() {
                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(msg);
            }
        });
    }
}
function normalizeContainer(container) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(container)) {
        const res = document.querySelector(container);
        if (( true) && !res) {
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Failed to mount app: mount target selector "${container}" returned null.`);
        }
        return res;
    }
    if (( true) &&
        window.ShadowRoot &&
        container instanceof window.ShadowRoot &&
        container.mode === 'closed') {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`);
    }
    return container;
}
let ssrDirectiveInitialized = false;
/**
 * @internal
 */
const initDirectivesForSSR = () => {
        if (!ssrDirectiveInitialized) {
            ssrDirectiveInitialized = true;
            initVModelForSSR();
            initVShowForSSR();
        }
    }
    ;




/***/ }),

/***/ "./node_modules/@vue/shared/dist/shared.esm-bundler.js":
/*!*************************************************************!*\
  !*** ./node_modules/@vue/shared/dist/shared.esm-bundler.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EMPTY_ARR": () => (/* binding */ EMPTY_ARR),
/* harmony export */   "EMPTY_OBJ": () => (/* binding */ EMPTY_OBJ),
/* harmony export */   "NO": () => (/* binding */ NO),
/* harmony export */   "NOOP": () => (/* binding */ NOOP),
/* harmony export */   "PatchFlagNames": () => (/* binding */ PatchFlagNames),
/* harmony export */   "camelize": () => (/* binding */ camelize),
/* harmony export */   "capitalize": () => (/* binding */ capitalize),
/* harmony export */   "def": () => (/* binding */ def),
/* harmony export */   "escapeHtml": () => (/* binding */ escapeHtml),
/* harmony export */   "escapeHtmlComment": () => (/* binding */ escapeHtmlComment),
/* harmony export */   "extend": () => (/* binding */ extend),
/* harmony export */   "genPropsAccessExp": () => (/* binding */ genPropsAccessExp),
/* harmony export */   "generateCodeFrame": () => (/* binding */ generateCodeFrame),
/* harmony export */   "getGlobalThis": () => (/* binding */ getGlobalThis),
/* harmony export */   "hasChanged": () => (/* binding */ hasChanged),
/* harmony export */   "hasOwn": () => (/* binding */ hasOwn),
/* harmony export */   "hyphenate": () => (/* binding */ hyphenate),
/* harmony export */   "includeBooleanAttr": () => (/* binding */ includeBooleanAttr),
/* harmony export */   "invokeArrayFns": () => (/* binding */ invokeArrayFns),
/* harmony export */   "isArray": () => (/* binding */ isArray),
/* harmony export */   "isBooleanAttr": () => (/* binding */ isBooleanAttr),
/* harmony export */   "isBuiltInDirective": () => (/* binding */ isBuiltInDirective),
/* harmony export */   "isDate": () => (/* binding */ isDate),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "isGloballyWhitelisted": () => (/* binding */ isGloballyWhitelisted),
/* harmony export */   "isHTMLTag": () => (/* binding */ isHTMLTag),
/* harmony export */   "isIntegerKey": () => (/* binding */ isIntegerKey),
/* harmony export */   "isKnownHtmlAttr": () => (/* binding */ isKnownHtmlAttr),
/* harmony export */   "isKnownSvgAttr": () => (/* binding */ isKnownSvgAttr),
/* harmony export */   "isMap": () => (/* binding */ isMap),
/* harmony export */   "isModelListener": () => (/* binding */ isModelListener),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isOn": () => (/* binding */ isOn),
/* harmony export */   "isPlainObject": () => (/* binding */ isPlainObject),
/* harmony export */   "isPromise": () => (/* binding */ isPromise),
/* harmony export */   "isReservedProp": () => (/* binding */ isReservedProp),
/* harmony export */   "isSSRSafeAttrName": () => (/* binding */ isSSRSafeAttrName),
/* harmony export */   "isSVGTag": () => (/* binding */ isSVGTag),
/* harmony export */   "isSet": () => (/* binding */ isSet),
/* harmony export */   "isSpecialBooleanAttr": () => (/* binding */ isSpecialBooleanAttr),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "isSymbol": () => (/* binding */ isSymbol),
/* harmony export */   "isVoidTag": () => (/* binding */ isVoidTag),
/* harmony export */   "looseEqual": () => (/* binding */ looseEqual),
/* harmony export */   "looseIndexOf": () => (/* binding */ looseIndexOf),
/* harmony export */   "makeMap": () => (/* binding */ makeMap),
/* harmony export */   "normalizeClass": () => (/* binding */ normalizeClass),
/* harmony export */   "normalizeProps": () => (/* binding */ normalizeProps),
/* harmony export */   "normalizeStyle": () => (/* binding */ normalizeStyle),
/* harmony export */   "objectToString": () => (/* binding */ objectToString),
/* harmony export */   "parseStringStyle": () => (/* binding */ parseStringStyle),
/* harmony export */   "propsToAttrMap": () => (/* binding */ propsToAttrMap),
/* harmony export */   "remove": () => (/* binding */ remove),
/* harmony export */   "slotFlagsText": () => (/* binding */ slotFlagsText),
/* harmony export */   "stringifyStyle": () => (/* binding */ stringifyStyle),
/* harmony export */   "toDisplayString": () => (/* binding */ toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* binding */ toHandlerKey),
/* harmony export */   "toNumber": () => (/* binding */ toNumber),
/* harmony export */   "toRawType": () => (/* binding */ toRawType),
/* harmony export */   "toTypeString": () => (/* binding */ toTypeString)
/* harmony export */ });
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 * IMPORTANT: all calls of this function must be prefixed with
 * \/\*#\_\_PURE\_\_\*\/
 * So that rollup can tree-shake them if necessary.
 */
function makeMap(str, expectsLowerCase) {
    const map = Object.create(null);
    const list = str.split(',');
    for (let i = 0; i < list.length; i++) {
        map[list[i]] = true;
    }
    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];
}

/**
 * dev only flag -> name mapping
 */
const PatchFlagNames = {
    [1 /* PatchFlags.TEXT */]: `TEXT`,
    [2 /* PatchFlags.CLASS */]: `CLASS`,
    [4 /* PatchFlags.STYLE */]: `STYLE`,
    [8 /* PatchFlags.PROPS */]: `PROPS`,
    [16 /* PatchFlags.FULL_PROPS */]: `FULL_PROPS`,
    [32 /* PatchFlags.HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,
    [64 /* PatchFlags.STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,
    [128 /* PatchFlags.KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,
    [256 /* PatchFlags.UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,
    [512 /* PatchFlags.NEED_PATCH */]: `NEED_PATCH`,
    [1024 /* PatchFlags.DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,
    [2048 /* PatchFlags.DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,
    [-1 /* PatchFlags.HOISTED */]: `HOISTED`,
    [-2 /* PatchFlags.BAIL */]: `BAIL`
};

/**
 * Dev only
 */
const slotFlagsText = {
    [1 /* SlotFlags.STABLE */]: 'STABLE',
    [2 /* SlotFlags.DYNAMIC */]: 'DYNAMIC',
    [3 /* SlotFlags.FORWARDED */]: 'FORWARDED'
};

const GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +
    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +
    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';
const isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);

const range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
    // Split the content into individual lines but capture the newline sequence
    // that separated each line. This is important because the actual sequence is
    // needed to properly take into account the full line length for offset
    // comparison
    let lines = source.split(/(\r?\n)/);
    // Separate the lines and newline sequences into separate arrays for easier referencing
    const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
    lines = lines.filter((_, idx) => idx % 2 === 0);
    let count = 0;
    const res = [];
    for (let i = 0; i < lines.length; i++) {
        count +=
            lines[i].length +
                ((newlineSequences[i] && newlineSequences[i].length) || 0);
        if (count >= start) {
            for (let j = i - range; j <= i + range || end > count; j++) {
                if (j < 0 || j >= lines.length)
                    continue;
                const line = j + 1;
                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
                const lineLength = lines[j].length;
                const newLineSeqLength = (newlineSequences[j] && newlineSequences[j].length) || 0;
                if (j === i) {
                    // push underline
                    const pad = start - (count - (lineLength + newLineSeqLength));
                    const length = Math.max(1, end > count ? lineLength - pad : end - start);
                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));
                }
                else if (j > i) {
                    if (end > count) {
                        const length = Math.max(Math.min(end - count, lineLength), 1);
                        res.push(`   |  ` + '^'.repeat(length));
                    }
                    count += lineLength + newLineSeqLength;
                }
            }
            break;
        }
    }
    return res.join('\n');
}

function normalizeStyle(value) {
    if (isArray(value)) {
        const res = {};
        for (let i = 0; i < value.length; i++) {
            const item = value[i];
            const normalized = isString(item)
                ? parseStringStyle(item)
                : normalizeStyle(item);
            if (normalized) {
                for (const key in normalized) {
                    res[key] = normalized[key];
                }
            }
        }
        return res;
    }
    else if (isString(value)) {
        return value;
    }
    else if (isObject(value)) {
        return value;
    }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*.*?\*\//gs;
function parseStringStyle(cssText) {
    const ret = {};
    cssText
        .replace(styleCommentRE, '')
        .split(listDelimiterRE)
        .forEach(item => {
        if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
    });
    return ret;
}
function stringifyStyle(styles) {
    let ret = '';
    if (!styles || isString(styles)) {
        return ret;
    }
    for (const key in styles) {
        const value = styles[key];
        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
        if (isString(value) || typeof value === 'number') {
            // only render valid values
            ret += `${normalizedKey}:${value};`;
        }
    }
    return ret;
}
function normalizeClass(value) {
    let res = '';
    if (isString(value)) {
        res = value;
    }
    else if (isArray(value)) {
        for (let i = 0; i < value.length; i++) {
            const normalized = normalizeClass(value[i]);
            if (normalized) {
                res += normalized + ' ';
            }
        }
    }
    else if (isObject(value)) {
        for (const name in value) {
            if (value[name]) {
                res += name + ' ';
            }
        }
    }
    return res.trim();
}
function normalizeProps(props) {
    if (!props)
        return null;
    let { class: klass, style } = props;
    if (klass && !isString(klass)) {
        props.class = normalizeClass(klass);
    }
    if (style) {
        props.style = normalizeStyle(style);
    }
    return props;
}

// These tag configs are shared between compiler-dom and runtime-dom, so they
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element
const HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +
    'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +
    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +
    'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +
    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +
    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +
    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +
    'option,output,progress,select,textarea,details,dialog,menu,' +
    'summary,template,blockquote,iframe,tfoot';
// https://developer.mozilla.org/en-US/docs/Web/SVG/Element
const SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +
    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +
    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +
    'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +
    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +
    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +
    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +
    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +
    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +
    'text,textPath,title,tspan,unknown,use,view';
const VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */
const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */
const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */
const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);

/**
 * On the client we only need to offer special cases for boolean attributes that
 * have different names from their corresponding dom properties:
 * - itemscope -> N/A
 * - allowfullscreen -> allowFullscreen
 * - formnovalidate -> formNoValidate
 * - ismap -> isMap
 * - nomodule -> noModule
 * - novalidate -> noValidate
 * - readonly -> readOnly
 */
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);
/**
 * The full list is needed during SSR to produce the correct initial markup.
 */
const isBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs +
    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +
    `loop,open,required,reversed,scoped,seamless,` +
    `checked,muted,multiple,selected`);
/**
 * Boolean attributes should be included if the value is truthy or ''.
 * e.g. `<select multiple>` compiles to `{ multiple: '' }`
 */
function includeBooleanAttr(value) {
    return !!value || value === '';
}
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
    if (attrValidationCache.hasOwnProperty(name)) {
        return attrValidationCache[name];
    }
    const isUnsafe = unsafeAttrCharRE.test(name);
    if (isUnsafe) {
        console.error(`unsafe attribute name: ${name}`);
    }
    return (attrValidationCache[name] = !isUnsafe);
}
const propsToAttrMap = {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
};
/**
 * Known attributes, this is used for stringification of runtime static nodes
 * so that we don't stringify bindings that cannot be set from HTML.
 * Don't also forget to allow `data-*` and `aria-*`!
 * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
 */
const isKnownHtmlAttr = /*#__PURE__*/ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +
    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +
    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +
    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +
    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +
    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +
    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +
    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +
    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +
    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +
    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +
    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +
    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +
    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +
    `value,width,wrap`);
/**
 * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute
 */
const isKnownSvgAttr = /*#__PURE__*/ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` +
    `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` +
    `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` +
    `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` +
    `color-interpolation-filters,color-profile,color-rendering,` +
    `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` +
    `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` +
    `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` +
    `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` +
    `font-family,font-size,font-size-adjust,font-stretch,font-style,` +
    `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` +
    `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` +
    `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` +
    `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` +
    `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` +
    `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` +
    `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` +
    `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` +
    `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` +
    `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` +
    `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` +
    `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` +
    `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` +
    `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` +
    `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` +
    `specularConstant,specularExponent,speed,spreadMethod,startOffset,` +
    `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` +
    `strikethrough-position,strikethrough-thickness,string,stroke,` +
    `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` +
    `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` +
    `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` +
    `text-decoration,text-rendering,textLength,to,transform,transform-origin,` +
    `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` +
    `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` +
    `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` +
    `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` +
    `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` +
    `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` +
    `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);

const escapeRE = /["'&<>]/;
function escapeHtml(string) {
    const str = '' + string;
    const match = escapeRE.exec(str);
    if (!match) {
        return str;
    }
    let html = '';
    let escaped;
    let index;
    let lastIndex = 0;
    for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
            case 34: // "
                escaped = '&quot;';
                break;
            case 38: // &
                escaped = '&amp;';
                break;
            case 39: // '
                escaped = '&#39;';
                break;
            case 60: // <
                escaped = '&lt;';
                break;
            case 62: // >
                escaped = '&gt;';
                break;
            default:
                continue;
        }
        if (lastIndex !== index) {
            html += str.slice(lastIndex, index);
        }
        lastIndex = index + 1;
        html += escaped;
    }
    return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
}
// https://www.w3.org/TR/html52/syntax.html#comments
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
    return src.replace(commentStripRE, '');
}

function looseCompareArrays(a, b) {
    if (a.length !== b.length)
        return false;
    let equal = true;
    for (let i = 0; equal && i < a.length; i++) {
        equal = looseEqual(a[i], b[i]);
    }
    return equal;
}
function looseEqual(a, b) {
    if (a === b)
        return true;
    let aValidType = isDate(a);
    let bValidType = isDate(b);
    if (aValidType || bValidType) {
        return aValidType && bValidType ? a.getTime() === b.getTime() : false;
    }
    aValidType = isSymbol(a);
    bValidType = isSymbol(b);
    if (aValidType || bValidType) {
        return a === b;
    }
    aValidType = isArray(a);
    bValidType = isArray(b);
    if (aValidType || bValidType) {
        return aValidType && bValidType ? looseCompareArrays(a, b) : false;
    }
    aValidType = isObject(a);
    bValidType = isObject(b);
    if (aValidType || bValidType) {
        /* istanbul ignore if: this if will probably never be called */
        if (!aValidType || !bValidType) {
            return false;
        }
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) {
            return false;
        }
        for (const key in a) {
            const aHasKey = a.hasOwnProperty(key);
            const bHasKey = b.hasOwnProperty(key);
            if ((aHasKey && !bHasKey) ||
                (!aHasKey && bHasKey) ||
                !looseEqual(a[key], b[key])) {
                return false;
            }
        }
    }
    return String(a) === String(b);
}
function looseIndexOf(arr, val) {
    return arr.findIndex(item => looseEqual(item, val));
}

/**
 * For converting {{ interpolation }} values to displayed strings.
 * @private
 */
const toDisplayString = (val) => {
    return isString(val)
        ? val
        : val == null
            ? ''
            : isArray(val) ||
                (isObject(val) &&
                    (val.toString === objectToString || !isFunction(val.toString)))
                ? JSON.stringify(val, replacer, 2)
                : String(val);
};
const replacer = (_key, val) => {
    // can't use isRef here since @vue/shared has no deps
    if (val && val.__v_isRef) {
        return replacer(_key, val.value);
    }
    else if (isMap(val)) {
        return {
            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {
                entries[`${key} =>`] = val;
                return entries;
            }, {})
        };
    }
    else if (isSet(val)) {
        return {
            [`Set(${val.size})`]: [...val.values()]
        };
    }
    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
        return String(val);
    }
    return val;
};

const EMPTY_OBJ = ( true)
    ? Object.freeze({})
    : 0;
const EMPTY_ARR = ( true) ? Object.freeze([]) : 0;
const NOOP = () => { };
/**
 * Always return false.
 */
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith('onUpdate:');
const extend = Object.assign;
const remove = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
        arr.splice(i, 1);
    }
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === '[object Map]';
const isSet = (val) => toTypeString(val) === '[object Set]';
const isDate = (val) => toTypeString(val) === '[object Date]';
const isFunction = (val) => typeof val === 'function';
const isString = (val) => typeof val === 'string';
const isSymbol = (val) => typeof val === 'symbol';
const isObject = (val) => val !== null && typeof val === 'object';
const isPromise = (val) => {
    return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
    // extract "RawType" from strings like "[object RawType]"
    return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === '[object Object]';
const isIntegerKey = (key) => isString(key) &&
    key !== 'NaN' &&
    key[0] !== '-' &&
    '' + parseInt(key, 10) === key;
const isReservedProp = /*#__PURE__*/ makeMap(
// the leading comma is intentional so empty string "" is also included
',key,ref,ref_for,ref_key,' +
    'onVnodeBeforeMount,onVnodeMounted,' +
    'onVnodeBeforeUpdate,onVnodeUpdated,' +
    'onVnodeBeforeUnmount,onVnodeUnmounted');
const isBuiltInDirective = /*#__PURE__*/ makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo');
const cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return ((str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    });
};
const camelizeRE = /-(\w)/g;
/**
 * @private
 */
const camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
});
const hyphenateRE = /\B([A-Z])/g;
/**
 * @private
 */
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());
/**
 * @private
 */
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
/**
 * @private
 */
const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
// compare whether a value has changed, accounting for NaN.
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
    for (let i = 0; i < fns.length; i++) {
        fns[i](arg);
    }
};
const def = (obj, key, value) => {
    Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value
    });
};
const toNumber = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
    return (_globalThis ||
        (_globalThis =
            typeof globalThis !== 'undefined'
                ? globalThis
                : typeof self !== 'undefined'
                    ? self
                    : typeof window !== 'undefined'
                        ? window
                        : typeof __webpack_require__.g !== 'undefined'
                            ? __webpack_require__.g
                            : {}));
};
const identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
function genPropsAccessExp(name) {
    return identRE.test(name)
        ? `__props.${name}`
        : `__props[${JSON.stringify(name)}]`;
}




/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-2.use!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/app/App.vue?vue&type=script&lang=ts&setup=true":
/*!******************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-2.use!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/app/App.vue?vue&type=script&lang=ts&setup=true ***!
  \******************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");
/* harmony import */ var _AppInput_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AppInput.vue */ "./src/app/AppInput.vue");
/* harmony import */ var _AppItem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AppItem */ "./src/app/AppItem.vue");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.defineComponent)({
  __name: 'App',
  setup: function setup(__props, _ref) {
    var expose = _ref.expose;
    expose();
    var inputValue = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)('');
    var inputItems = (0,vue__WEBPACK_IMPORTED_MODULE_0__.reactive)([]);
    var data = {
      id: 12,
      text: 'Hello world!!!'
    };
    var handlerInput = function handlerInput(e) {
      var _ref2 = e.target,
        value = _ref2.value;

      // inputValue.value = value;
      inputItems.push({
        id: Date.now(),
        text: value
      });
    };
    var __returned__ = {
      inputValue: inputValue,
      inputItems: inputItems,
      data: data,
      handlerInput: handlerInput,
      AppInput: _AppInput_vue__WEBPACK_IMPORTED_MODULE_1__["default"],
      get AppItem() {
        return _AppItem__WEBPACK_IMPORTED_MODULE_2__["default"];
      }
    };
    Object.defineProperty(__returned__, '__isScriptSetup', {
      enumerable: false,
      value: true
    });
    return __returned__;
  }
}));

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-2.use!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/app/AppItem.vue?vue&type=script&lang=ts&setup=true":
/*!**********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-2.use!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/app/AppItem.vue?vue&type=script&lang=ts&setup=true ***!
  \**********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.defineComponent)({
  __name: 'AppItem',
  props: {
    result: {
      type: Object,
      required: true
    }
  },
  setup: function setup(__props, _ref) {
    var expose = _ref.expose;
    expose();
    var props = __props;
    var result = (0,vue__WEBPACK_IMPORTED_MODULE_0__.reactive)(props.result);
    var __returned__ = {
      props: props,
      result: result
    };
    Object.defineProperty(__returned__, '__isScriptSetup', {
      enumerable: false,
      value: true
    });
    return __returned__;
  }
}));

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-2.use!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/app/App.vue?vue&type=template&id=7e7f006c&scoped=true&ts=true":
/*!*******************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-2.use!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/app/App.vue?vue&type=template&id=7e7f006c&scoped=true&ts=true ***!
  \*******************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");

var _withScopeId = function _withScopeId(n) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.pushScopeId)("data-v-7e7f006c"), n = n(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.popScopeId)(), n;
};
var _hoisted_1 = {
  "class": "app"
};
function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_1, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)($setup["AppInput"], {
    modelValue: $setup.inputValue,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = function ($event) {
      return $setup.inputValue = $event;
    }),
    onInput: $setup.handlerInput
  }, null, 8 /* PROPS */, ["modelValue"]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)(" " + (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($setup.inputValue) + " ", 1 /* TEXT */), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)($setup["AppItem"], {
    result: $setup.data
  })])]);
}

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-2.use!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/app/AppInput.vue?vue&type=template&id=44dfd750&scoped=true":
/*!****************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-2.use!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/app/AppInput.vue?vue&type=template&id=44dfd750&scoped=true ***!
  \****************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");

var _withScopeId = function _withScopeId(n) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.pushScopeId)("data-v-44dfd750"), n = n(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.popScopeId)(), n;
};
var _hoisted_1 = {
  "class": "app"
};
var _hoisted_2 = /*#__PURE__*/_withScopeId(function () {
  return /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("input", {
    type: "text"
  }, null, -1 /* HOISTED */);
});
var _hoisted_3 = [_hoisted_2];
function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_1, _hoisted_3);
}

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-2.use!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/app/AppItem.vue?vue&type=template&id=4c969706&ts=true":
/*!***********************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-2.use!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/app/AppItem.vue?vue&type=template&id=4c969706&ts=true ***!
  \***********************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");

function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($setup.result) + " ", 1 /* TEXT */), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", null, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($setup.result.id), 1 /* TEXT */), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", null, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($setup.result.text), 1 /* TEXT */)]);
}

/***/ }),

/***/ "./src/vue-shim.d.ts":
/*!***************************!*\
  !*** ./src/vue-shim.d.ts ***!
  \***************************/
/***/ (() => {



/***/ }),

/***/ "./src/scss/main.scss":
/*!****************************!*\
  !*** ./src/scss/main.scss ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-1.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/sass-resources-loader/lib/loader.js??clonedRuleSet-1.use[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/app/App.vue?vue&type=style&index=0&id=7e7f006c&lang=scss&scoped=true":
/*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-1.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/sass-resources-loader/lib/loader.js??clonedRuleSet-1.use[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/app/App.vue?vue&type=style&index=0&id=7e7f006c&lang=scss&scoped=true ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-1.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/sass-resources-loader/lib/loader.js??clonedRuleSet-1.use[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/app/AppInput.vue?vue&type=style&index=0&id=44dfd750&lang=scss&scoped=true":
/*!***********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-1.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/sass-resources-loader/lib/loader.js??clonedRuleSet-1.use[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/app/AppInput.vue?vue&type=style&index=0&id=44dfd750&lang=scss&scoped=true ***!
  \***********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/vue-loader/dist/exportHelper.js":
/*!******************************************************!*\
  !*** ./node_modules/vue-loader/dist/exportHelper.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// runtime helper for setting properties on components
// in a tree-shakable way
exports["default"] = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
        target[key] = val;
    }
    return target;
};


/***/ }),

/***/ "./src/app/App.vue":
/*!*************************!*\
  !*** ./src/app/App.vue ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _App_vue_vue_type_template_id_7e7f006c_scoped_true_ts_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./App.vue?vue&type=template&id=7e7f006c&scoped=true&ts=true */ "./src/app/App.vue?vue&type=template&id=7e7f006c&scoped=true&ts=true");
/* harmony import */ var _App_vue_vue_type_script_lang_ts_setup_true__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./App.vue?vue&type=script&lang=ts&setup=true */ "./src/app/App.vue?vue&type=script&lang=ts&setup=true");
/* harmony import */ var _App_vue_vue_type_style_index_0_id_7e7f006c_lang_scss_scoped_true__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./App.vue?vue&type=style&index=0&id=7e7f006c&lang=scss&scoped=true */ "./src/app/App.vue?vue&type=style&index=0&id=7e7f006c&lang=scss&scoped=true");
/* harmony import */ var _home_goodluck_Downloads_type_vue_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/vue-loader/dist/exportHelper.js */ "./node_modules/vue-loader/dist/exportHelper.js");




;


const __exports__ = /*#__PURE__*/(0,_home_goodluck_Downloads_type_vue_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_3__["default"])(_App_vue_vue_type_script_lang_ts_setup_true__WEBPACK_IMPORTED_MODULE_1__["default"], [['render',_App_vue_vue_type_template_id_7e7f006c_scoped_true_ts_true__WEBPACK_IMPORTED_MODULE_0__.render],['__scopeId',"data-v-7e7f006c"],['__file',"src/app/App.vue"]])
/* hot reload */
if (false) {}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__exports__);

/***/ }),

/***/ "./src/app/AppInput.vue":
/*!******************************!*\
  !*** ./src/app/AppInput.vue ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _AppInput_vue_vue_type_template_id_44dfd750_scoped_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AppInput.vue?vue&type=template&id=44dfd750&scoped=true */ "./src/app/AppInput.vue?vue&type=template&id=44dfd750&scoped=true");
/* harmony import */ var _AppInput_vue_vue_type_style_index_0_id_44dfd750_lang_scss_scoped_true__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AppInput.vue?vue&type=style&index=0&id=44dfd750&lang=scss&scoped=true */ "./src/app/AppInput.vue?vue&type=style&index=0&id=44dfd750&lang=scss&scoped=true");
/* harmony import */ var _home_goodluck_Downloads_type_vue_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/vue-loader/dist/exportHelper.js */ "./node_modules/vue-loader/dist/exportHelper.js");

const script = {}

;


const __exports__ = /*#__PURE__*/(0,_home_goodluck_Downloads_type_vue_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__["default"])(script, [['render',_AppInput_vue_vue_type_template_id_44dfd750_scoped_true__WEBPACK_IMPORTED_MODULE_0__.render],['__scopeId',"data-v-44dfd750"],['__file',"src/app/AppInput.vue"]])
/* hot reload */
if (false) {}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__exports__);

/***/ }),

/***/ "./src/app/AppItem.vue":
/*!*****************************!*\
  !*** ./src/app/AppItem.vue ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _AppItem_vue_vue_type_template_id_4c969706_ts_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AppItem.vue?vue&type=template&id=4c969706&ts=true */ "./src/app/AppItem.vue?vue&type=template&id=4c969706&ts=true");
/* harmony import */ var _AppItem_vue_vue_type_script_lang_ts_setup_true__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AppItem.vue?vue&type=script&lang=ts&setup=true */ "./src/app/AppItem.vue?vue&type=script&lang=ts&setup=true");
/* harmony import */ var _home_goodluck_Downloads_type_vue_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/vue-loader/dist/exportHelper.js */ "./node_modules/vue-loader/dist/exportHelper.js");




;
const __exports__ = /*#__PURE__*/(0,_home_goodluck_Downloads_type_vue_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__["default"])(_AppItem_vue_vue_type_script_lang_ts_setup_true__WEBPACK_IMPORTED_MODULE_1__["default"], [['render',_AppItem_vue_vue_type_template_id_4c969706_ts_true__WEBPACK_IMPORTED_MODULE_0__.render],['__file',"src/app/AppItem.vue"]])
/* hot reload */
if (false) {}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__exports__);

/***/ }),

/***/ "./src/app/App.vue?vue&type=script&lang=ts&setup=true":
/*!************************************************************!*\
  !*** ./src/app/App.vue?vue&type=script&lang=ts&setup=true ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_2_use_node_modules_vue_loader_dist_index_js_ruleSet_0_App_vue_vue_type_script_lang_ts_setup_true__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_2_use_node_modules_vue_loader_dist_index_js_ruleSet_0_App_vue_vue_type_script_lang_ts_setup_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-2.use!../../node_modules/vue-loader/dist/index.js??ruleSet[0]!./App.vue?vue&type=script&lang=ts&setup=true */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-2.use!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/app/App.vue?vue&type=script&lang=ts&setup=true");
 

/***/ }),

/***/ "./src/app/AppItem.vue?vue&type=script&lang=ts&setup=true":
/*!****************************************************************!*\
  !*** ./src/app/AppItem.vue?vue&type=script&lang=ts&setup=true ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_2_use_node_modules_vue_loader_dist_index_js_ruleSet_0_AppItem_vue_vue_type_script_lang_ts_setup_true__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_2_use_node_modules_vue_loader_dist_index_js_ruleSet_0_AppItem_vue_vue_type_script_lang_ts_setup_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-2.use!../../node_modules/vue-loader/dist/index.js??ruleSet[0]!./AppItem.vue?vue&type=script&lang=ts&setup=true */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-2.use!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/app/AppItem.vue?vue&type=script&lang=ts&setup=true");
 

/***/ }),

/***/ "./src/app/App.vue?vue&type=template&id=7e7f006c&scoped=true&ts=true":
/*!***************************************************************************!*\
  !*** ./src/app/App.vue?vue&type=template&id=7e7f006c&scoped=true&ts=true ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_2_use_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_App_vue_vue_type_template_id_7e7f006c_scoped_true_ts_true__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_2_use_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_App_vue_vue_type_template_id_7e7f006c_scoped_true_ts_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-2.use!../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../node_modules/vue-loader/dist/index.js??ruleSet[0]!./App.vue?vue&type=template&id=7e7f006c&scoped=true&ts=true */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-2.use!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/app/App.vue?vue&type=template&id=7e7f006c&scoped=true&ts=true");


/***/ }),

/***/ "./src/app/AppInput.vue?vue&type=template&id=44dfd750&scoped=true":
/*!************************************************************************!*\
  !*** ./src/app/AppInput.vue?vue&type=template&id=44dfd750&scoped=true ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_2_use_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_AppInput_vue_vue_type_template_id_44dfd750_scoped_true__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_2_use_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_AppInput_vue_vue_type_template_id_44dfd750_scoped_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-2.use!../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../node_modules/vue-loader/dist/index.js??ruleSet[0]!./AppInput.vue?vue&type=template&id=44dfd750&scoped=true */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-2.use!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/app/AppInput.vue?vue&type=template&id=44dfd750&scoped=true");


/***/ }),

/***/ "./src/app/AppItem.vue?vue&type=template&id=4c969706&ts=true":
/*!*******************************************************************!*\
  !*** ./src/app/AppItem.vue?vue&type=template&id=4c969706&ts=true ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_2_use_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_AppItem_vue_vue_type_template_id_4c969706_ts_true__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_2_use_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_AppItem_vue_vue_type_template_id_4c969706_ts_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-2.use!../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../node_modules/vue-loader/dist/index.js??ruleSet[0]!./AppItem.vue?vue&type=template&id=4c969706&ts=true */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-2.use!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/app/AppItem.vue?vue&type=template&id=4c969706&ts=true");


/***/ }),

/***/ "./src/app/App.vue?vue&type=style&index=0&id=7e7f006c&lang=scss&scoped=true":
/*!**********************************************************************************!*\
  !*** ./src/app/App.vue?vue&type=style&index=0&id=7e7f006c&lang=scss&scoped=true ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_1_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_sass_loader_dist_cjs_js_node_modules_sass_resources_loader_lib_loader_js_clonedRuleSet_1_use_3_node_modules_vue_loader_dist_index_js_ruleSet_0_App_vue_vue_type_style_index_0_id_7e7f006c_lang_scss_scoped_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/mini-css-extract-plugin/dist/loader.js!../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-1.use[1]!../../node_modules/vue-loader/dist/stylePostLoader.js!../../node_modules/sass-loader/dist/cjs.js!../../node_modules/sass-resources-loader/lib/loader.js??clonedRuleSet-1.use[3]!../../node_modules/vue-loader/dist/index.js??ruleSet[0]!./App.vue?vue&type=style&index=0&id=7e7f006c&lang=scss&scoped=true */ "./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-1.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/sass-resources-loader/lib/loader.js??clonedRuleSet-1.use[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/app/App.vue?vue&type=style&index=0&id=7e7f006c&lang=scss&scoped=true");


/***/ }),

/***/ "./src/app/AppInput.vue?vue&type=style&index=0&id=44dfd750&lang=scss&scoped=true":
/*!***************************************************************************************!*\
  !*** ./src/app/AppInput.vue?vue&type=style&index=0&id=44dfd750&lang=scss&scoped=true ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_1_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_sass_loader_dist_cjs_js_node_modules_sass_resources_loader_lib_loader_js_clonedRuleSet_1_use_3_node_modules_vue_loader_dist_index_js_ruleSet_0_AppInput_vue_vue_type_style_index_0_id_44dfd750_lang_scss_scoped_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/mini-css-extract-plugin/dist/loader.js!../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-1.use[1]!../../node_modules/vue-loader/dist/stylePostLoader.js!../../node_modules/sass-loader/dist/cjs.js!../../node_modules/sass-resources-loader/lib/loader.js??clonedRuleSet-1.use[3]!../../node_modules/vue-loader/dist/index.js??ruleSet[0]!./AppInput.vue?vue&type=style&index=0&id=44dfd750&lang=scss&scoped=true */ "./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-1.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/sass-resources-loader/lib/loader.js??clonedRuleSet-1.use[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0]!./src/app/AppInput.vue?vue&type=style&index=0&id=44dfd750&lang=scss&scoped=true");


/***/ }),

/***/ "./node_modules/vue/dist/vue.esm-bundler.js":
/*!**************************************************!*\
  !*** ./node_modules/vue/dist/vue.esm-bundler.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseTransition": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.BaseTransition),
/* harmony export */   "Comment": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Comment),
/* harmony export */   "EffectScope": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.EffectScope),
/* harmony export */   "Fragment": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Fragment),
/* harmony export */   "KeepAlive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.KeepAlive),
/* harmony export */   "ReactiveEffect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect),
/* harmony export */   "Static": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Static),
/* harmony export */   "Suspense": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Suspense),
/* harmony export */   "Teleport": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Teleport),
/* harmony export */   "Text": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Text),
/* harmony export */   "Transition": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Transition),
/* harmony export */   "TransitionGroup": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.TransitionGroup),
/* harmony export */   "VueElement": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.VueElement),
/* harmony export */   "callWithAsyncErrorHandling": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling),
/* harmony export */   "callWithErrorHandling": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling),
/* harmony export */   "camelize": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.camelize),
/* harmony export */   "capitalize": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.capitalize),
/* harmony export */   "cloneVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.cloneVNode),
/* harmony export */   "compatUtils": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.compatUtils),
/* harmony export */   "compile": () => (/* binding */ compileToFunction),
/* harmony export */   "computed": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.computed),
/* harmony export */   "createApp": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createApp),
/* harmony export */   "createBlock": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createBlock),
/* harmony export */   "createCommentVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode),
/* harmony export */   "createElementBlock": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createElementBlock),
/* harmony export */   "createElementVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createElementVNode),
/* harmony export */   "createHydrationRenderer": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer),
/* harmony export */   "createPropsRestProxy": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createPropsRestProxy),
/* harmony export */   "createRenderer": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createRenderer),
/* harmony export */   "createSSRApp": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSSRApp),
/* harmony export */   "createSlots": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSlots),
/* harmony export */   "createStaticVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode),
/* harmony export */   "createTextVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createTextVNode),
/* harmony export */   "createVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createVNode),
/* harmony export */   "customRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   "defineAsyncComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent),
/* harmony export */   "defineComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineComponent),
/* harmony export */   "defineCustomElement": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineCustomElement),
/* harmony export */   "defineEmits": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineEmits),
/* harmony export */   "defineExpose": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineExpose),
/* harmony export */   "defineProps": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineProps),
/* harmony export */   "defineSSRCustomElement": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineSSRCustomElement),
/* harmony export */   "devtools": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.devtools),
/* harmony export */   "effect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.effect),
/* harmony export */   "effectScope": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.effectScope),
/* harmony export */   "getCurrentInstance": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance),
/* harmony export */   "getCurrentScope": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope),
/* harmony export */   "getTransitionRawChildren": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren),
/* harmony export */   "guardReactiveProps": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.guardReactiveProps),
/* harmony export */   "h": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.h),
/* harmony export */   "handleError": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.handleError),
/* harmony export */   "hydrate": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.hydrate),
/* harmony export */   "initCustomFormatter": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter),
/* harmony export */   "initDirectivesForSSR": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.initDirectivesForSSR),
/* harmony export */   "inject": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.inject),
/* harmony export */   "isMemoSame": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isMemoSame),
/* harmony export */   "isProxy": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   "isReactive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   "isReadonly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   "isRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   "isRuntimeOnly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly),
/* harmony export */   "isShallow": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isShallow),
/* harmony export */   "isVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isVNode),
/* harmony export */   "markRaw": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   "mergeDefaults": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeDefaults),
/* harmony export */   "mergeProps": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeProps),
/* harmony export */   "nextTick": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.nextTick),
/* harmony export */   "normalizeClass": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeClass),
/* harmony export */   "normalizeProps": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeProps),
/* harmony export */   "normalizeStyle": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle),
/* harmony export */   "onActivated": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onActivated),
/* harmony export */   "onBeforeMount": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount),
/* harmony export */   "onBeforeUnmount": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount),
/* harmony export */   "onBeforeUpdate": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate),
/* harmony export */   "onDeactivated": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onDeactivated),
/* harmony export */   "onErrorCaptured": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured),
/* harmony export */   "onMounted": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onMounted),
/* harmony export */   "onRenderTracked": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked),
/* harmony export */   "onRenderTriggered": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered),
/* harmony export */   "onScopeDispose": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose),
/* harmony export */   "onServerPrefetch": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch),
/* harmony export */   "onUnmounted": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUnmounted),
/* harmony export */   "onUpdated": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUpdated),
/* harmony export */   "openBlock": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.openBlock),
/* harmony export */   "popScopeId": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.popScopeId),
/* harmony export */   "provide": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.provide),
/* harmony export */   "proxyRefs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   "pushScopeId": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.pushScopeId),
/* harmony export */   "queuePostFlushCb": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb),
/* harmony export */   "reactive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   "readonly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   "ref": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   "registerRuntimeCompiler": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler),
/* harmony export */   "render": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "renderList": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderList),
/* harmony export */   "renderSlot": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderSlot),
/* harmony export */   "resolveComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveComponent),
/* harmony export */   "resolveDirective": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDirective),
/* harmony export */   "resolveDynamicComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent),
/* harmony export */   "resolveFilter": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveFilter),
/* harmony export */   "resolveTransitionHooks": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks),
/* harmony export */   "setBlockTracking": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking),
/* harmony export */   "setDevtoolsHook": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook),
/* harmony export */   "setTransitionHooks": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks),
/* harmony export */   "shallowReactive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   "shallowRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   "ssrContextKey": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey),
/* harmony export */   "ssrUtils": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrUtils),
/* harmony export */   "stop": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.stop),
/* harmony export */   "toDisplayString": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey),
/* harmony export */   "toHandlers": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlers),
/* harmony export */   "toRaw": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   "toRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   "toRefs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   "transformVNodeArgs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs),
/* harmony export */   "triggerRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   "unref": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   "useAttrs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useAttrs),
/* harmony export */   "useCssModule": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssModule),
/* harmony export */   "useCssVars": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssVars),
/* harmony export */   "useSSRContext": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useSSRContext),
/* harmony export */   "useSlots": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useSlots),
/* harmony export */   "useTransitionState": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useTransitionState),
/* harmony export */   "vModelCheckbox": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelCheckbox),
/* harmony export */   "vModelDynamic": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelDynamic),
/* harmony export */   "vModelRadio": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelRadio),
/* harmony export */   "vModelSelect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelSelect),
/* harmony export */   "vModelText": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelText),
/* harmony export */   "vShow": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vShow),
/* harmony export */   "version": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.version),
/* harmony export */   "warn": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.warn),
/* harmony export */   "watch": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watch),
/* harmony export */   "watchEffect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchEffect),
/* harmony export */   "watchPostEffect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect),
/* harmony export */   "watchSyncEffect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchSyncEffect),
/* harmony export */   "withAsyncContext": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withAsyncContext),
/* harmony export */   "withCtx": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withCtx),
/* harmony export */   "withDefaults": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withDefaults),
/* harmony export */   "withDirectives": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withDirectives),
/* harmony export */   "withKeys": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withKeys),
/* harmony export */   "withMemo": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withMemo),
/* harmony export */   "withModifiers": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withModifiers),
/* harmony export */   "withScopeId": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withScopeId)
/* harmony export */ });
/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-dom */ "./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js");
/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/runtime-dom */ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js");
/* harmony import */ var _vue_compiler_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @vue/compiler-dom */ "./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");






function initDev() {
    {
        (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.initCustomFormatter)();
    }
}

// This entry is the "full-build" that includes both the runtime
if ((true)) {
    initDev();
}
const compileCache = Object.create(null);
function compileToFunction(template, options) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isString)(template)) {
        if (template.nodeType) {
            template = template.innerHTML;
        }
        else {
            ( true) && (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.warn)(`invalid template option: `, template);
            return _vue_shared__WEBPACK_IMPORTED_MODULE_2__.NOOP;
        }
    }
    const key = template;
    const cached = compileCache[key];
    if (cached) {
        return cached;
    }
    if (template[0] === '#') {
        const el = document.querySelector(template);
        if (( true) && !el) {
            (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.warn)(`Template element not found or is empty: ${template}`);
        }
        // __UNSAFE__
        // Reason: potential execution of JS expressions in in-DOM template.
        // The user must make sure the in-DOM template is trusted. If it's rendered
        // by the server, the template should not contain any user data.
        template = el ? el.innerHTML : ``;
    }
    const opts = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.extend)({
        hoistStatic: true,
        onError: ( true) ? onError : 0,
        onWarn: ( true) ? e => onError(e, true) : 0
    }, options);
    if (!opts.isCustomElement && typeof customElements !== 'undefined') {
        opts.isCustomElement = tag => !!customElements.get(tag);
    }
    const { code } = (0,_vue_compiler_dom__WEBPACK_IMPORTED_MODULE_3__.compile)(template, opts);
    function onError(err, asWarning = false) {
        const message = asWarning
            ? err.message
            : `Template compilation error: ${err.message}`;
        const codeFrame = err.loc &&
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.generateCodeFrame)(template, err.loc.start.offset, err.loc.end.offset);
        (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.warn)(codeFrame ? `${message}\n${codeFrame}` : message);
    }
    // The wildcard import results in a huge object with every export
    // with keys that cannot be mangled, and can be quite heavy size-wise.
    // In the global build we know `Vue` is available globally so we can avoid
    // the wildcard object.
    const render = (new Function('Vue', code)(_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__));
    render._rc = true;
    return (compileCache[key] = render);
}
(0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.registerRuntimeCompiler)(compileToFunction);




/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _vue_shim_d_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vue-shim.d.ts */ "./src/vue-shim.d.ts");
/* harmony import */ var _vue_shim_d_ts__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_vue_shim_d_ts__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _scss_main_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scss/main.scss */ "./src/scss/main.scss");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");
/* harmony import */ var _app_App_vue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/App.vue */ "./src/app/App.vue");




(0,vue__WEBPACK_IMPORTED_MODULE_2__.createApp)({
  components: {
    'vue-test': _app_App_vue__WEBPACK_IMPORTED_MODULE_3__["default"]
  },
  template: '<vue-test />'
}).mount('#app');
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUVBQXFFLHNEQUFTO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNkNBQUk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsS0FBcUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9EQUFPO0FBQ25CLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsb0RBQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbURBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxLQUFxQztBQUM5QztBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1Q0FBdUM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxpREFBSTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0EsZ0ZBQWdGLEVBQUUsWUFBWTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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akI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSSxtREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsYUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNB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QkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOE1BQThNO0FBQzFOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0RBQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjLEdBQUcsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxzQkFBc0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEtBQUs7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsaUNBQWlDLFdBQVc7V0FDNUM7V0FDQTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsR0FBRztXQUNIO1dBQ0E7V0FDQSxDQUFDOzs7OztXQ1BEOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNOeUI7QUFDQztBQUNNO0FBRUE7QUFFaENrQiw4Q0FBUyxDQUFDO0VBQ1JFLFVBQVUsRUFBRTtJQUNWLFVBQVUsRUFBRUQsb0RBQUdBO0VBQ2pCLENBQUM7RUFDREUsUUFBUSxFQUFFO0FBQ1osQ0FBQyxDQUFDLENBQUNDLEtBQUssQ0FBQyxNQUFNLENBQUMsQyIsInNvdXJjZXMiOlsid2VicGFjazovL3R5cGUtdnVlLy4vbm9kZV9tb2R1bGVzL0B2dWUvY29tcGlsZXItY29yZS9kaXN0L2NvbXBpbGVyLWNvcmUuZXNtLWJ1bmRsZXIuanMiLCJ3ZWJwYWNrOi8vdHlwZS12dWUvLi9ub2RlX21vZHVsZXMvQHZ1ZS9jb21waWxlci1kb20vZGlzdC9jb21waWxlci1kb20uZXNtLWJ1bmRsZXIuanMiLCJ3ZWJwYWNrOi8vdHlwZS12dWUvLi9ub2RlX21vZHVsZXMvQHZ1ZS9yZWFjdGl2aXR5L2Rpc3QvcmVhY3Rpdml0eS5lc20tYnVuZGxlci5qcyIsIndlYnBhY2s6Ly90eXBlLXZ1ZS8uL25vZGVfbW9kdWxlcy9AdnVlL3J1bnRpbWUtY29yZS9kaXN0L3J1bnRpbWUtY29yZS5lc20tYnVuZGxlci5qcyIsIndlYnBhY2s6Ly90eXBlLXZ1ZS8uL25vZGVfbW9kdWxlcy9AdnVlL3J1bnRpbWUtZG9tL2Rpc3QvcnVudGltZS1kb20uZXNtLWJ1bmRsZXIuanMiLCJ3ZWJwYWNrOi8vdHlwZS12dWUvLi9ub2RlX21vZHVsZXMvQHZ1ZS9zaGFyZWQvZGlzdC9zaGFyZWQuZXNtLWJ1bmRsZXIuanMiLCJ3ZWJwYWNrOi8vdHlwZS12dWUvLi9zcmMvYXBwL0FwcC52dWUiLCJ3ZWJwYWNrOi8vdHlwZS12dWUvLi9zcmMvYXBwL0FwcEl0ZW0udnVlIiwid2VicGFjazovL3R5cGUtdnVlLy4vc3JjL2FwcC9BcHBJbnB1dC52dWUiLCJ3ZWJwYWNrOi8vdHlwZS12dWUvLi9zcmMvc2Nzcy9tYWluLnNjc3MiLCJ3ZWJwYWNrOi8vdHlwZS12dWUvLi9zcmMvYXBwL0FwcC52dWU/MGU2YiIsIndlYnBhY2s6Ly90eXBlLXZ1ZS8uL3NyYy9hcHAvQXBwSW5wdXQudnVlP2U4ZjYiLCJ3ZWJwYWNrOi8vdHlwZS12dWUvLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2V4cG9ydEhlbHBlci5qcyIsIndlYnBhY2s6Ly90eXBlLXZ1ZS8uL3NyYy9hcHAvQXBwLnZ1ZT9iYTE1Iiwid2VicGFjazovL3R5cGUtdnVlLy4vc3JjL2FwcC9BcHBJbnB1dC52dWU/MTM5YiIsIndlYnBhY2s6Ly90eXBlLXZ1ZS8uL3NyYy9hcHAvQXBwSXRlbS52dWU/NDMyMCIsIndlYnBhY2s6Ly90eXBlLXZ1ZS8uL3NyYy9hcHAvQXBwLnZ1ZT9iZDMyIiwid2VicGFjazovL3R5cGUtdnVlLy4vc3JjL2FwcC9BcHBJdGVtLnZ1ZT8wN2JiIiwid2VicGFjazovL3R5cGUtdnVlLy4vbm9kZV9tb2R1bGVzL3Z1ZS9kaXN0L3Z1ZS5lc20tYnVuZGxlci5qcyIsIndlYnBhY2s6Ly90eXBlLXZ1ZS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly90eXBlLXZ1ZS93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly90eXBlLXZ1ZS93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vdHlwZS12dWUvd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly90eXBlLXZ1ZS93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL3R5cGUtdnVlL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vdHlwZS12dWUvLi9zcmMvaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNTdHJpbmcsIGh5cGhlbmF0ZSwgTk9PUCwgZXh0ZW5kLCBpc09iamVjdCwgTk8sIGlzQXJyYXksIG1ha2VNYXAsIGlzU3ltYm9sLCBFTVBUWV9PQkosIGNhcGl0YWxpemUsIGNhbWVsaXplIGFzIGNhbWVsaXplJDEsIFBhdGNoRmxhZ05hbWVzLCBzbG90RmxhZ3NUZXh0LCBpc09uLCBpc0J1aWx0SW5EaXJlY3RpdmUsIGlzUmVzZXJ2ZWRQcm9wLCB0b0hhbmRsZXJLZXkgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5leHBvcnQgeyBnZW5lcmF0ZUNvZGVGcmFtZSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuZnVuY3Rpb24gZGVmYXVsdE9uRXJyb3IoZXJyb3IpIHtcbiAgICB0aHJvdyBlcnJvcjtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRPbldhcm4obXNnKSB7XG4gICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNvbnNvbGUud2FybihgW1Z1ZSB3YXJuXSAke21zZy5tZXNzYWdlfWApO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXJFcnJvcihjb2RlLCBsb2MsIG1lc3NhZ2VzLCBhZGRpdGlvbmFsTWVzc2FnZSkge1xuICAgIGNvbnN0IG1zZyA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCAhdHJ1ZVxuICAgICAgICA/IChtZXNzYWdlcyB8fCBlcnJvck1lc3NhZ2VzKVtjb2RlXSArIChhZGRpdGlvbmFsTWVzc2FnZSB8fCBgYClcbiAgICAgICAgOiBjb2RlO1xuICAgIGNvbnN0IGVycm9yID0gbmV3IFN5bnRheEVycm9yKFN0cmluZyhtc2cpKTtcbiAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgICBlcnJvci5sb2MgPSBsb2M7XG4gICAgcmV0dXJuIGVycm9yO1xufVxuY29uc3QgZXJyb3JNZXNzYWdlcyA9IHtcbiAgICAvLyBwYXJzZSBlcnJvcnNcbiAgICBbMCAvKiBFcnJvckNvZGVzLkFCUlVQVF9DTE9TSU5HX09GX0VNUFRZX0NPTU1FTlQgKi9dOiAnSWxsZWdhbCBjb21tZW50LicsXG4gICAgWzEgLyogRXJyb3JDb2Rlcy5DREFUQV9JTl9IVE1MX0NPTlRFTlQgKi9dOiAnQ0RBVEEgc2VjdGlvbiBpcyBhbGxvd2VkIG9ubHkgaW4gWE1MIGNvbnRleHQuJyxcbiAgICBbMiAvKiBFcnJvckNvZGVzLkRVUExJQ0FURV9BVFRSSUJVVEUgKi9dOiAnRHVwbGljYXRlIGF0dHJpYnV0ZS4nLFxuICAgIFszIC8qIEVycm9yQ29kZXMuRU5EX1RBR19XSVRIX0FUVFJJQlVURVMgKi9dOiAnRW5kIHRhZyBjYW5ub3QgaGF2ZSBhdHRyaWJ1dGVzLicsXG4gICAgWzQgLyogRXJyb3JDb2Rlcy5FTkRfVEFHX1dJVEhfVFJBSUxJTkdfU09MSURVUyAqL106IFwiSWxsZWdhbCAnLycgaW4gdGFncy5cIixcbiAgICBbNSAvKiBFcnJvckNvZGVzLkVPRl9CRUZPUkVfVEFHX05BTUUgKi9dOiAnVW5leHBlY3RlZCBFT0YgaW4gdGFnLicsXG4gICAgWzYgLyogRXJyb3JDb2Rlcy5FT0ZfSU5fQ0RBVEEgKi9dOiAnVW5leHBlY3RlZCBFT0YgaW4gQ0RBVEEgc2VjdGlvbi4nLFxuICAgIFs3IC8qIEVycm9yQ29kZXMuRU9GX0lOX0NPTU1FTlQgKi9dOiAnVW5leHBlY3RlZCBFT0YgaW4gY29tbWVudC4nLFxuICAgIFs4IC8qIEVycm9yQ29kZXMuRU9GX0lOX1NDUklQVF9IVE1MX0NPTU1FTlRfTElLRV9URVhUICovXTogJ1VuZXhwZWN0ZWQgRU9GIGluIHNjcmlwdC4nLFxuICAgIFs5IC8qIEVycm9yQ29kZXMuRU9GX0lOX1RBRyAqL106ICdVbmV4cGVjdGVkIEVPRiBpbiB0YWcuJyxcbiAgICBbMTAgLyogRXJyb3JDb2Rlcy5JTkNPUlJFQ1RMWV9DTE9TRURfQ09NTUVOVCAqL106ICdJbmNvcnJlY3RseSBjbG9zZWQgY29tbWVudC4nLFxuICAgIFsxMSAvKiBFcnJvckNvZGVzLklOQ09SUkVDVExZX09QRU5FRF9DT01NRU5UICovXTogJ0luY29ycmVjdGx5IG9wZW5lZCBjb21tZW50LicsXG4gICAgWzEyIC8qIEVycm9yQ29kZXMuSU5WQUxJRF9GSVJTVF9DSEFSQUNURVJfT0ZfVEFHX05BTUUgKi9dOiBcIklsbGVnYWwgdGFnIG5hbWUuIFVzZSAnJmx0OycgdG8gcHJpbnQgJzwnLlwiLFxuICAgIFsxMyAvKiBFcnJvckNvZGVzLk1JU1NJTkdfQVRUUklCVVRFX1ZBTFVFICovXTogJ0F0dHJpYnV0ZSB2YWx1ZSB3YXMgZXhwZWN0ZWQuJyxcbiAgICBbMTQgLyogRXJyb3JDb2Rlcy5NSVNTSU5HX0VORF9UQUdfTkFNRSAqL106ICdFbmQgdGFnIG5hbWUgd2FzIGV4cGVjdGVkLicsXG4gICAgWzE1IC8qIEVycm9yQ29kZXMuTUlTU0lOR19XSElURVNQQUNFX0JFVFdFRU5fQVRUUklCVVRFUyAqL106ICdXaGl0ZXNwYWNlIHdhcyBleHBlY3RlZC4nLFxuICAgIFsxNiAvKiBFcnJvckNvZGVzLk5FU1RFRF9DT01NRU5UICovXTogXCJVbmV4cGVjdGVkICc8IS0tJyBpbiBjb21tZW50LlwiLFxuICAgIFsxNyAvKiBFcnJvckNvZGVzLlVORVhQRUNURURfQ0hBUkFDVEVSX0lOX0FUVFJJQlVURV9OQU1FICovXTogJ0F0dHJpYnV0ZSBuYW1lIGNhbm5vdCBjb250YWluIFUrMDAyMiAoXCIpLCBVKzAwMjcgKFxcJyksIGFuZCBVKzAwM0MgKDwpLicsXG4gICAgWzE4IC8qIEVycm9yQ29kZXMuVU5FWFBFQ1RFRF9DSEFSQUNURVJfSU5fVU5RVU9URURfQVRUUklCVVRFX1ZBTFVFICovXTogJ1VucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZSBjYW5ub3QgY29udGFpbiBVKzAwMjIgKFwiKSwgVSswMDI3IChcXCcpLCBVKzAwM0MgKDwpLCBVKzAwM0QgKD0pLCBhbmQgVSswMDYwIChgKS4nLFxuICAgIFsxOSAvKiBFcnJvckNvZGVzLlVORVhQRUNURURfRVFVQUxTX1NJR05fQkVGT1JFX0FUVFJJQlVURV9OQU1FICovXTogXCJBdHRyaWJ1dGUgbmFtZSBjYW5ub3Qgc3RhcnQgd2l0aCAnPScuXCIsXG4gICAgWzIxIC8qIEVycm9yQ29kZXMuVU5FWFBFQ1RFRF9RVUVTVElPTl9NQVJLX0lOU1RFQURfT0ZfVEFHX05BTUUgKi9dOiBcIic8PycgaXMgYWxsb3dlZCBvbmx5IGluIFhNTCBjb250ZXh0LlwiLFxuICAgIFsyMCAvKiBFcnJvckNvZGVzLlVORVhQRUNURURfTlVMTF9DSEFSQUNURVIgKi9dOiBgVW5leHBlY3RlZCBudWxsIGNoYXJhY3Rlci5gLFxuICAgIFsyMiAvKiBFcnJvckNvZGVzLlVORVhQRUNURURfU09MSURVU19JTl9UQUcgKi9dOiBcIklsbGVnYWwgJy8nIGluIHRhZ3MuXCIsXG4gICAgLy8gVnVlLXNwZWNpZmljIHBhcnNlIGVycm9yc1xuICAgIFsyMyAvKiBFcnJvckNvZGVzLlhfSU5WQUxJRF9FTkRfVEFHICovXTogJ0ludmFsaWQgZW5kIHRhZy4nLFxuICAgIFsyNCAvKiBFcnJvckNvZGVzLlhfTUlTU0lOR19FTkRfVEFHICovXTogJ0VsZW1lbnQgaXMgbWlzc2luZyBlbmQgdGFnLicsXG4gICAgWzI1IC8qIEVycm9yQ29kZXMuWF9NSVNTSU5HX0lOVEVSUE9MQVRJT05fRU5EICovXTogJ0ludGVycG9sYXRpb24gZW5kIHNpZ24gd2FzIG5vdCBmb3VuZC4nLFxuICAgIFsyNyAvKiBFcnJvckNvZGVzLlhfTUlTU0lOR19EWU5BTUlDX0RJUkVDVElWRV9BUkdVTUVOVF9FTkQgKi9dOiAnRW5kIGJyYWNrZXQgZm9yIGR5bmFtaWMgZGlyZWN0aXZlIGFyZ3VtZW50IHdhcyBub3QgZm91bmQuICcgK1xuICAgICAgICAnTm90ZSB0aGF0IGR5bmFtaWMgZGlyZWN0aXZlIGFyZ3VtZW50IGNhbm5vdCBjb250YWluIHNwYWNlcy4nLFxuICAgIFsyNiAvKiBFcnJvckNvZGVzLlhfTUlTU0lOR19ESVJFQ1RJVkVfTkFNRSAqL106ICdMZWdhbCBkaXJlY3RpdmUgbmFtZSB3YXMgZXhwZWN0ZWQuJyxcbiAgICAvLyB0cmFuc2Zvcm0gZXJyb3JzXG4gICAgWzI4IC8qIEVycm9yQ29kZXMuWF9WX0lGX05PX0VYUFJFU1NJT04gKi9dOiBgdi1pZi92LWVsc2UtaWYgaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXG4gICAgWzI5IC8qIEVycm9yQ29kZXMuWF9WX0lGX1NBTUVfS0VZICovXTogYHYtaWYvZWxzZSBicmFuY2hlcyBtdXN0IHVzZSB1bmlxdWUga2V5cy5gLFxuICAgIFszMCAvKiBFcnJvckNvZGVzLlhfVl9FTFNFX05PX0FESkFDRU5UX0lGICovXTogYHYtZWxzZS92LWVsc2UtaWYgaGFzIG5vIGFkamFjZW50IHYtaWYgb3Igdi1lbHNlLWlmLmAsXG4gICAgWzMxIC8qIEVycm9yQ29kZXMuWF9WX0ZPUl9OT19FWFBSRVNTSU9OICovXTogYHYtZm9yIGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxuICAgIFszMiAvKiBFcnJvckNvZGVzLlhfVl9GT1JfTUFMRk9STUVEX0VYUFJFU1NJT04gKi9dOiBgdi1mb3IgaGFzIGludmFsaWQgZXhwcmVzc2lvbi5gLFxuICAgIFszMyAvKiBFcnJvckNvZGVzLlhfVl9GT1JfVEVNUExBVEVfS0VZX1BMQUNFTUVOVCAqL106IGA8dGVtcGxhdGUgdi1mb3I+IGtleSBzaG91bGQgYmUgcGxhY2VkIG9uIHRoZSA8dGVtcGxhdGU+IHRhZy5gLFxuICAgIFszNCAvKiBFcnJvckNvZGVzLlhfVl9CSU5EX05PX0VYUFJFU1NJT04gKi9dOiBgdi1iaW5kIGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxuICAgIFszNSAvKiBFcnJvckNvZGVzLlhfVl9PTl9OT19FWFBSRVNTSU9OICovXTogYHYtb24gaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXG4gICAgWzM2IC8qIEVycm9yQ29kZXMuWF9WX1NMT1RfVU5FWFBFQ1RFRF9ESVJFQ1RJVkVfT05fU0xPVF9PVVRMRVQgKi9dOiBgVW5leHBlY3RlZCBjdXN0b20gZGlyZWN0aXZlIG9uIDxzbG90PiBvdXRsZXQuYCxcbiAgICBbMzcgLyogRXJyb3JDb2Rlcy5YX1ZfU0xPVF9NSVhFRF9TTE9UX1VTQUdFICovXTogYE1peGVkIHYtc2xvdCB1c2FnZSBvbiBib3RoIHRoZSBjb21wb25lbnQgYW5kIG5lc3RlZCA8dGVtcGxhdGU+LmAgK1xuICAgICAgICBgV2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgbmFtZWQgc2xvdHMsIGFsbCBzbG90cyBzaG91bGQgdXNlIDx0ZW1wbGF0ZT4gYCArXG4gICAgICAgIGBzeW50YXggdG8gYXZvaWQgc2NvcGUgYW1iaWd1aXR5LmAsXG4gICAgWzM4IC8qIEVycm9yQ29kZXMuWF9WX1NMT1RfRFVQTElDQVRFX1NMT1RfTkFNRVMgKi9dOiBgRHVwbGljYXRlIHNsb3QgbmFtZXMgZm91bmQuIGAsXG4gICAgWzM5IC8qIEVycm9yQ29kZXMuWF9WX1NMT1RfRVhUUkFORU9VU19ERUZBVUxUX1NMT1RfQ0hJTERSRU4gKi9dOiBgRXh0cmFuZW91cyBjaGlsZHJlbiBmb3VuZCB3aGVuIGNvbXBvbmVudCBhbHJlYWR5IGhhcyBleHBsaWNpdGx5IG5hbWVkIGAgK1xuICAgICAgICBgZGVmYXVsdCBzbG90LiBUaGVzZSBjaGlsZHJlbiB3aWxsIGJlIGlnbm9yZWQuYCxcbiAgICBbNDAgLyogRXJyb3JDb2Rlcy5YX1ZfU0xPVF9NSVNQTEFDRUQgKi9dOiBgdi1zbG90IGNhbiBvbmx5IGJlIHVzZWQgb24gY29tcG9uZW50cyBvciA8dGVtcGxhdGU+IHRhZ3MuYCxcbiAgICBbNDEgLyogRXJyb3JDb2Rlcy5YX1ZfTU9ERUxfTk9fRVhQUkVTU0lPTiAqL106IGB2LW1vZGVsIGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxuICAgIFs0MiAvKiBFcnJvckNvZGVzLlhfVl9NT0RFTF9NQUxGT1JNRURfRVhQUkVTU0lPTiAqL106IGB2LW1vZGVsIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBKYXZhU2NyaXB0IG1lbWJlciBleHByZXNzaW9uLmAsXG4gICAgWzQzIC8qIEVycm9yQ29kZXMuWF9WX01PREVMX09OX1NDT1BFX1ZBUklBQkxFICovXTogYHYtbW9kZWwgY2Fubm90IGJlIHVzZWQgb24gdi1mb3Igb3Igdi1zbG90IHNjb3BlIHZhcmlhYmxlcyBiZWNhdXNlIHRoZXkgYXJlIG5vdCB3cml0YWJsZS5gLFxuICAgIFs0NCAvKiBFcnJvckNvZGVzLlhfVl9NT0RFTF9PTl9QUk9QUyAqL106IGB2LW1vZGVsIGNhbm5vdCBiZSB1c2VkIG9uIGEgcHJvcCwgYmVjYXVzZSBsb2NhbCBwcm9wIGJpbmRpbmdzIGFyZSBub3Qgd3JpdGFibGUuXFxuVXNlIGEgdi1iaW5kIGJpbmRpbmcgY29tYmluZWQgd2l0aCBhIHYtb24gbGlzdGVuZXIgdGhhdCBlbWl0cyB1cGRhdGU6eCBldmVudCBpbnN0ZWFkLmAsXG4gICAgWzQ1IC8qIEVycm9yQ29kZXMuWF9JTlZBTElEX0VYUFJFU1NJT04gKi9dOiBgRXJyb3IgcGFyc2luZyBKYXZhU2NyaXB0IGV4cHJlc3Npb246IGAsXG4gICAgWzQ2IC8qIEVycm9yQ29kZXMuWF9LRUVQX0FMSVZFX0lOVkFMSURfQ0hJTERSRU4gKi9dOiBgPEtlZXBBbGl2ZT4gZXhwZWN0cyBleGFjdGx5IG9uZSBjaGlsZCBjb21wb25lbnQuYCxcbiAgICAvLyBnZW5lcmljIGVycm9yc1xuICAgIFs0NyAvKiBFcnJvckNvZGVzLlhfUFJFRklYX0lEX05PVF9TVVBQT1JURUQgKi9dOiBgXCJwcmVmaXhJZGVudGlmaWVyc1wiIG9wdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnVpbGQgb2YgY29tcGlsZXIuYCxcbiAgICBbNDggLyogRXJyb3JDb2Rlcy5YX01PRFVMRV9NT0RFX05PVF9TVVBQT1JURUQgKi9dOiBgRVMgbW9kdWxlIG1vZGUgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJ1aWxkIG9mIGNvbXBpbGVyLmAsXG4gICAgWzQ5IC8qIEVycm9yQ29kZXMuWF9DQUNIRV9IQU5ETEVSX05PVF9TVVBQT1JURUQgKi9dOiBgXCJjYWNoZUhhbmRsZXJzXCIgb3B0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIHdoZW4gdGhlIFwicHJlZml4SWRlbnRpZmllcnNcIiBvcHRpb24gaXMgZW5hYmxlZC5gLFxuICAgIFs1MCAvKiBFcnJvckNvZGVzLlhfU0NPUEVfSURfTk9UX1NVUFBPUlRFRCAqL106IGBcInNjb3BlSWRcIiBvcHRpb24gaXMgb25seSBzdXBwb3J0ZWQgaW4gbW9kdWxlIG1vZGUuYCxcbiAgICAvLyBqdXN0IHRvIGZ1bGZpbGwgdHlwZXNcbiAgICBbNTEgLyogRXJyb3JDb2Rlcy5fX0VYVEVORF9QT0lOVF9fICovXTogYGBcbn07XG5cbmNvbnN0IEZSQUdNRU5UID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBGcmFnbWVudGAgOiBgYCk7XG5jb25zdCBURUxFUE9SVCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgVGVsZXBvcnRgIDogYGApO1xuY29uc3QgU1VTUEVOU0UgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYFN1c3BlbnNlYCA6IGBgKTtcbmNvbnN0IEtFRVBfQUxJVkUgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYEtlZXBBbGl2ZWAgOiBgYCk7XG5jb25zdCBCQVNFX1RSQU5TSVRJT04gPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYEJhc2VUcmFuc2l0aW9uYCA6IGBgKTtcbmNvbnN0IE9QRU5fQkxPQ0sgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYG9wZW5CbG9ja2AgOiBgYCk7XG5jb25zdCBDUkVBVEVfQkxPQ0sgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNyZWF0ZUJsb2NrYCA6IGBgKTtcbmNvbnN0IENSRUFURV9FTEVNRU5UX0JMT0NLID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBjcmVhdGVFbGVtZW50QmxvY2tgIDogYGApO1xuY29uc3QgQ1JFQVRFX1ZOT0RFID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBjcmVhdGVWTm9kZWAgOiBgYCk7XG5jb25zdCBDUkVBVEVfRUxFTUVOVF9WTk9ERSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY3JlYXRlRWxlbWVudFZOb2RlYCA6IGBgKTtcbmNvbnN0IENSRUFURV9DT01NRU5UID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBjcmVhdGVDb21tZW50Vk5vZGVgIDogYGApO1xuY29uc3QgQ1JFQVRFX1RFWFQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNyZWF0ZVRleHRWTm9kZWAgOiBgYCk7XG5jb25zdCBDUkVBVEVfU1RBVElDID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBjcmVhdGVTdGF0aWNWTm9kZWAgOiBgYCk7XG5jb25zdCBSRVNPTFZFX0NPTVBPTkVOVCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgcmVzb2x2ZUNvbXBvbmVudGAgOiBgYCk7XG5jb25zdCBSRVNPTFZFX0RZTkFNSUNfQ09NUE9ORU5UID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGByZXNvbHZlRHluYW1pY0NvbXBvbmVudGAgOiBgYCk7XG5jb25zdCBSRVNPTFZFX0RJUkVDVElWRSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgcmVzb2x2ZURpcmVjdGl2ZWAgOiBgYCk7XG5jb25zdCBSRVNPTFZFX0ZJTFRFUiA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgcmVzb2x2ZUZpbHRlcmAgOiBgYCk7XG5jb25zdCBXSVRIX0RJUkVDVElWRVMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHdpdGhEaXJlY3RpdmVzYCA6IGBgKTtcbmNvbnN0IFJFTkRFUl9MSVNUID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGByZW5kZXJMaXN0YCA6IGBgKTtcbmNvbnN0IFJFTkRFUl9TTE9UID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGByZW5kZXJTbG90YCA6IGBgKTtcbmNvbnN0IENSRUFURV9TTE9UUyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY3JlYXRlU2xvdHNgIDogYGApO1xuY29uc3QgVE9fRElTUExBWV9TVFJJTkcgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHRvRGlzcGxheVN0cmluZ2AgOiBgYCk7XG5jb25zdCBNRVJHRV9QUk9QUyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgbWVyZ2VQcm9wc2AgOiBgYCk7XG5jb25zdCBOT1JNQUxJWkVfQ0xBU1MgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYG5vcm1hbGl6ZUNsYXNzYCA6IGBgKTtcbmNvbnN0IE5PUk1BTElaRV9TVFlMRSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgbm9ybWFsaXplU3R5bGVgIDogYGApO1xuY29uc3QgTk9STUFMSVpFX1BST1BTID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBub3JtYWxpemVQcm9wc2AgOiBgYCk7XG5jb25zdCBHVUFSRF9SRUFDVElWRV9QUk9QUyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgZ3VhcmRSZWFjdGl2ZVByb3BzYCA6IGBgKTtcbmNvbnN0IFRPX0hBTkRMRVJTID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB0b0hhbmRsZXJzYCA6IGBgKTtcbmNvbnN0IENBTUVMSVpFID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBjYW1lbGl6ZWAgOiBgYCk7XG5jb25zdCBDQVBJVEFMSVpFID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBjYXBpdGFsaXplYCA6IGBgKTtcbmNvbnN0IFRPX0hBTkRMRVJfS0VZID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB0b0hhbmRsZXJLZXlgIDogYGApO1xuY29uc3QgU0VUX0JMT0NLX1RSQUNLSU5HID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBzZXRCbG9ja1RyYWNraW5nYCA6IGBgKTtcbmNvbnN0IFBVU0hfU0NPUEVfSUQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHB1c2hTY29wZUlkYCA6IGBgKTtcbmNvbnN0IFBPUF9TQ09QRV9JRCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgcG9wU2NvcGVJZGAgOiBgYCk7XG5jb25zdCBXSVRIX0NUWCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgd2l0aEN0eGAgOiBgYCk7XG5jb25zdCBVTlJFRiA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdW5yZWZgIDogYGApO1xuY29uc3QgSVNfUkVGID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBpc1JlZmAgOiBgYCk7XG5jb25zdCBXSVRIX01FTU8gPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHdpdGhNZW1vYCA6IGBgKTtcbmNvbnN0IElTX01FTU9fU0FNRSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgaXNNZW1vU2FtZWAgOiBgYCk7XG4vLyBOYW1lIG1hcHBpbmcgZm9yIHJ1bnRpbWUgaGVscGVycyB0aGF0IG5lZWQgdG8gYmUgaW1wb3J0ZWQgZnJvbSAndnVlJyBpblxuLy8gZ2VuZXJhdGVkIGNvZGUuIE1ha2Ugc3VyZSB0aGVzZSBhcmUgY29ycmVjdGx5IGV4cG9ydGVkIGluIHRoZSBydW50aW1lIVxuY29uc3QgaGVscGVyTmFtZU1hcCA9IHtcbiAgICBbRlJBR01FTlRdOiBgRnJhZ21lbnRgLFxuICAgIFtURUxFUE9SVF06IGBUZWxlcG9ydGAsXG4gICAgW1NVU1BFTlNFXTogYFN1c3BlbnNlYCxcbiAgICBbS0VFUF9BTElWRV06IGBLZWVwQWxpdmVgLFxuICAgIFtCQVNFX1RSQU5TSVRJT05dOiBgQmFzZVRyYW5zaXRpb25gLFxuICAgIFtPUEVOX0JMT0NLXTogYG9wZW5CbG9ja2AsXG4gICAgW0NSRUFURV9CTE9DS106IGBjcmVhdGVCbG9ja2AsXG4gICAgW0NSRUFURV9FTEVNRU5UX0JMT0NLXTogYGNyZWF0ZUVsZW1lbnRCbG9ja2AsXG4gICAgW0NSRUFURV9WTk9ERV06IGBjcmVhdGVWTm9kZWAsXG4gICAgW0NSRUFURV9FTEVNRU5UX1ZOT0RFXTogYGNyZWF0ZUVsZW1lbnRWTm9kZWAsXG4gICAgW0NSRUFURV9DT01NRU5UXTogYGNyZWF0ZUNvbW1lbnRWTm9kZWAsXG4gICAgW0NSRUFURV9URVhUXTogYGNyZWF0ZVRleHRWTm9kZWAsXG4gICAgW0NSRUFURV9TVEFUSUNdOiBgY3JlYXRlU3RhdGljVk5vZGVgLFxuICAgIFtSRVNPTFZFX0NPTVBPTkVOVF06IGByZXNvbHZlQ29tcG9uZW50YCxcbiAgICBbUkVTT0xWRV9EWU5BTUlDX0NPTVBPTkVOVF06IGByZXNvbHZlRHluYW1pY0NvbXBvbmVudGAsXG4gICAgW1JFU09MVkVfRElSRUNUSVZFXTogYHJlc29sdmVEaXJlY3RpdmVgLFxuICAgIFtSRVNPTFZFX0ZJTFRFUl06IGByZXNvbHZlRmlsdGVyYCxcbiAgICBbV0lUSF9ESVJFQ1RJVkVTXTogYHdpdGhEaXJlY3RpdmVzYCxcbiAgICBbUkVOREVSX0xJU1RdOiBgcmVuZGVyTGlzdGAsXG4gICAgW1JFTkRFUl9TTE9UXTogYHJlbmRlclNsb3RgLFxuICAgIFtDUkVBVEVfU0xPVFNdOiBgY3JlYXRlU2xvdHNgLFxuICAgIFtUT19ESVNQTEFZX1NUUklOR106IGB0b0Rpc3BsYXlTdHJpbmdgLFxuICAgIFtNRVJHRV9QUk9QU106IGBtZXJnZVByb3BzYCxcbiAgICBbTk9STUFMSVpFX0NMQVNTXTogYG5vcm1hbGl6ZUNsYXNzYCxcbiAgICBbTk9STUFMSVpFX1NUWUxFXTogYG5vcm1hbGl6ZVN0eWxlYCxcbiAgICBbTk9STUFMSVpFX1BST1BTXTogYG5vcm1hbGl6ZVByb3BzYCxcbiAgICBbR1VBUkRfUkVBQ1RJVkVfUFJPUFNdOiBgZ3VhcmRSZWFjdGl2ZVByb3BzYCxcbiAgICBbVE9fSEFORExFUlNdOiBgdG9IYW5kbGVyc2AsXG4gICAgW0NBTUVMSVpFXTogYGNhbWVsaXplYCxcbiAgICBbQ0FQSVRBTElaRV06IGBjYXBpdGFsaXplYCxcbiAgICBbVE9fSEFORExFUl9LRVldOiBgdG9IYW5kbGVyS2V5YCxcbiAgICBbU0VUX0JMT0NLX1RSQUNLSU5HXTogYHNldEJsb2NrVHJhY2tpbmdgLFxuICAgIFtQVVNIX1NDT1BFX0lEXTogYHB1c2hTY29wZUlkYCxcbiAgICBbUE9QX1NDT1BFX0lEXTogYHBvcFNjb3BlSWRgLFxuICAgIFtXSVRIX0NUWF06IGB3aXRoQ3R4YCxcbiAgICBbVU5SRUZdOiBgdW5yZWZgLFxuICAgIFtJU19SRUZdOiBgaXNSZWZgLFxuICAgIFtXSVRIX01FTU9dOiBgd2l0aE1lbW9gLFxuICAgIFtJU19NRU1PX1NBTUVdOiBgaXNNZW1vU2FtZWBcbn07XG5mdW5jdGlvbiByZWdpc3RlclJ1bnRpbWVIZWxwZXJzKGhlbHBlcnMpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGhlbHBlcnMpLmZvckVhY2gocyA9PiB7XG4gICAgICAgIGhlbHBlck5hbWVNYXBbc10gPSBoZWxwZXJzW3NdO1xuICAgIH0pO1xufVxuXG4vLyBBU1QgVXRpbGl0aWVzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU29tZSBleHByZXNzaW9ucywgZS5nLiBzZXF1ZW5jZSBhbmQgY29uZGl0aW9uYWwgZXhwcmVzc2lvbnMsIGFyZSBuZXZlclxuLy8gYXNzb2NpYXRlZCB3aXRoIHRlbXBsYXRlIG5vZGVzLCBzbyB0aGVpciBzb3VyY2UgbG9jYXRpb25zIGFyZSBqdXN0IGEgc3R1Yi5cbi8vIENvbnRhaW5lciB0eXBlcyBsaWtlIENvbXBvdW5kRXhwcmVzc2lvbiBhbHNvIGRvbid0IG5lZWQgYSByZWFsIGxvY2F0aW9uLlxuY29uc3QgbG9jU3R1YiA9IHtcbiAgICBzb3VyY2U6ICcnLFxuICAgIHN0YXJ0OiB7IGxpbmU6IDEsIGNvbHVtbjogMSwgb2Zmc2V0OiAwIH0sXG4gICAgZW5kOiB7IGxpbmU6IDEsIGNvbHVtbjogMSwgb2Zmc2V0OiAwIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVSb290KGNoaWxkcmVuLCBsb2MgPSBsb2NTdHViKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMCAvKiBOb2RlVHlwZXMuUk9PVCAqLyxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIGhlbHBlcnM6IFtdLFxuICAgICAgICBjb21wb25lbnRzOiBbXSxcbiAgICAgICAgZGlyZWN0aXZlczogW10sXG4gICAgICAgIGhvaXN0czogW10sXG4gICAgICAgIGltcG9ydHM6IFtdLFxuICAgICAgICBjYWNoZWQ6IDAsXG4gICAgICAgIHRlbXBzOiAwLFxuICAgICAgICBjb2RlZ2VuTm9kZTogdW5kZWZpbmVkLFxuICAgICAgICBsb2NcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlVk5vZGVDYWxsKGNvbnRleHQsIHRhZywgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcywgZGlyZWN0aXZlcywgaXNCbG9jayA9IGZhbHNlLCBkaXNhYmxlVHJhY2tpbmcgPSBmYWxzZSwgaXNDb21wb25lbnQgPSBmYWxzZSwgbG9jID0gbG9jU3R1Yikge1xuICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgIGlmIChpc0Jsb2NrKSB7XG4gICAgICAgICAgICBjb250ZXh0LmhlbHBlcihPUEVOX0JMT0NLKTtcbiAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKGdldFZOb2RlQmxvY2tIZWxwZXIoY29udGV4dC5pblNTUiwgaXNDb21wb25lbnQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKGdldFZOb2RlSGVscGVyKGNvbnRleHQuaW5TU1IsIGlzQ29tcG9uZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpcmVjdGl2ZXMpIHtcbiAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKFdJVEhfRElSRUNUSVZFUyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMTMgLyogTm9kZVR5cGVzLlZOT0RFX0NBTEwgKi8sXG4gICAgICAgIHRhZyxcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBwYXRjaEZsYWcsXG4gICAgICAgIGR5bmFtaWNQcm9wcyxcbiAgICAgICAgZGlyZWN0aXZlcyxcbiAgICAgICAgaXNCbG9jayxcbiAgICAgICAgZGlzYWJsZVRyYWNraW5nLFxuICAgICAgICBpc0NvbXBvbmVudCxcbiAgICAgICAgbG9jXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5RXhwcmVzc2lvbihlbGVtZW50cywgbG9jID0gbG9jU3R1Yikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDE3IC8qIE5vZGVUeXBlcy5KU19BUlJBWV9FWFBSRVNTSU9OICovLFxuICAgICAgICBsb2MsXG4gICAgICAgIGVsZW1lbnRzXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdEV4cHJlc3Npb24ocHJvcGVydGllcywgbG9jID0gbG9jU3R1Yikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDE1IC8qIE5vZGVUeXBlcy5KU19PQkpFQ1RfRVhQUkVTU0lPTiAqLyxcbiAgICAgICAgbG9jLFxuICAgICAgICBwcm9wZXJ0aWVzXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdFByb3BlcnR5KGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAxNiAvKiBOb2RlVHlwZXMuSlNfUFJPUEVSVFkgKi8sXG4gICAgICAgIGxvYzogbG9jU3R1YixcbiAgICAgICAga2V5OiBpc1N0cmluZyhrZXkpID8gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihrZXksIHRydWUpIDoga2V5LFxuICAgICAgICB2YWx1ZVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGNvbnRlbnQsIGlzU3RhdGljID0gZmFsc2UsIGxvYyA9IGxvY1N0dWIsIGNvbnN0VHlwZSA9IDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi8pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLyxcbiAgICAgICAgbG9jLFxuICAgICAgICBjb250ZW50LFxuICAgICAgICBpc1N0YXRpYyxcbiAgICAgICAgY29uc3RUeXBlOiBpc1N0YXRpYyA/IDMgLyogQ29uc3RhbnRUeXBlcy5DQU5fU1RSSU5HSUZZICovIDogY29uc3RUeXBlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUludGVycG9sYXRpb24oY29udGVudCwgbG9jKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogNSAvKiBOb2RlVHlwZXMuSU5URVJQT0xBVElPTiAqLyxcbiAgICAgICAgbG9jLFxuICAgICAgICBjb250ZW50OiBpc1N0cmluZyhjb250ZW50KVxuICAgICAgICAgICAgPyBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGNvbnRlbnQsIGZhbHNlLCBsb2MpXG4gICAgICAgICAgICA6IGNvbnRlbnRcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKGNoaWxkcmVuLCBsb2MgPSBsb2NTdHViKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogOCAvKiBOb2RlVHlwZXMuQ09NUE9VTkRfRVhQUkVTU0lPTiAqLyxcbiAgICAgICAgbG9jLFxuICAgICAgICBjaGlsZHJlblxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVDYWxsRXhwcmVzc2lvbihjYWxsZWUsIGFyZ3MgPSBbXSwgbG9jID0gbG9jU3R1Yikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDE0IC8qIE5vZGVUeXBlcy5KU19DQUxMX0VYUFJFU1NJT04gKi8sXG4gICAgICAgIGxvYyxcbiAgICAgICAgY2FsbGVlLFxuICAgICAgICBhcmd1bWVudHM6IGFyZ3NcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKHBhcmFtcywgcmV0dXJucyA9IHVuZGVmaW5lZCwgbmV3bGluZSA9IGZhbHNlLCBpc1Nsb3QgPSBmYWxzZSwgbG9jID0gbG9jU3R1Yikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDE4IC8qIE5vZGVUeXBlcy5KU19GVU5DVElPTl9FWFBSRVNTSU9OICovLFxuICAgICAgICBwYXJhbXMsXG4gICAgICAgIHJldHVybnMsXG4gICAgICAgIG5ld2xpbmUsXG4gICAgICAgIGlzU2xvdCxcbiAgICAgICAgbG9jXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbmRpdGlvbmFsRXhwcmVzc2lvbih0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUsIG5ld2xpbmUgPSB0cnVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMTkgLyogTm9kZVR5cGVzLkpTX0NPTkRJVElPTkFMX0VYUFJFU1NJT04gKi8sXG4gICAgICAgIHRlc3QsXG4gICAgICAgIGNvbnNlcXVlbnQsXG4gICAgICAgIGFsdGVybmF0ZSxcbiAgICAgICAgbmV3bGluZSxcbiAgICAgICAgbG9jOiBsb2NTdHViXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlRXhwcmVzc2lvbihpbmRleCwgdmFsdWUsIGlzVk5vZGUgPSBmYWxzZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDIwIC8qIE5vZGVUeXBlcy5KU19DQUNIRV9FWFBSRVNTSU9OICovLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGlzVk5vZGUsXG4gICAgICAgIGxvYzogbG9jU3R1YlxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVCbG9ja1N0YXRlbWVudChib2R5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMjEgLyogTm9kZVR5cGVzLkpTX0JMT0NLX1NUQVRFTUVOVCAqLyxcbiAgICAgICAgYm9keSxcbiAgICAgICAgbG9jOiBsb2NTdHViXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRlbXBsYXRlTGl0ZXJhbChlbGVtZW50cykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDIyIC8qIE5vZGVUeXBlcy5KU19URU1QTEFURV9MSVRFUkFMICovLFxuICAgICAgICBlbGVtZW50cyxcbiAgICAgICAgbG9jOiBsb2NTdHViXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUlmU3RhdGVtZW50KHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDIzIC8qIE5vZGVUeXBlcy5KU19JRl9TVEFURU1FTlQgKi8sXG4gICAgICAgIHRlc3QsXG4gICAgICAgIGNvbnNlcXVlbnQsXG4gICAgICAgIGFsdGVybmF0ZSxcbiAgICAgICAgbG9jOiBsb2NTdHViXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbm1lbnRFeHByZXNzaW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMjQgLyogTm9kZVR5cGVzLkpTX0FTU0lHTk1FTlRfRVhQUkVTU0lPTiAqLyxcbiAgICAgICAgbGVmdCxcbiAgICAgICAgcmlnaHQsXG4gICAgICAgIGxvYzogbG9jU3R1YlxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTZXF1ZW5jZUV4cHJlc3Npb24oZXhwcmVzc2lvbnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAyNSAvKiBOb2RlVHlwZXMuSlNfU0VRVUVOQ0VfRVhQUkVTU0lPTiAqLyxcbiAgICAgICAgZXhwcmVzc2lvbnMsXG4gICAgICAgIGxvYzogbG9jU3R1YlxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVSZXR1cm5TdGF0ZW1lbnQocmV0dXJucykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDI2IC8qIE5vZGVUeXBlcy5KU19SRVRVUk5fU1RBVEVNRU5UICovLFxuICAgICAgICByZXR1cm5zLFxuICAgICAgICBsb2M6IGxvY1N0dWJcbiAgICB9O1xufVxuXG5jb25zdCBpc1N0YXRpY0V4cCA9IChwKSA9PiBwLnR5cGUgPT09IDQgLyogTm9kZVR5cGVzLlNJTVBMRV9FWFBSRVNTSU9OICovICYmIHAuaXNTdGF0aWM7XG5jb25zdCBpc0J1aWx0SW5UeXBlID0gKHRhZywgZXhwZWN0ZWQpID0+IHRhZyA9PT0gZXhwZWN0ZWQgfHwgdGFnID09PSBoeXBoZW5hdGUoZXhwZWN0ZWQpO1xuZnVuY3Rpb24gaXNDb3JlQ29tcG9uZW50KHRhZykge1xuICAgIGlmIChpc0J1aWx0SW5UeXBlKHRhZywgJ1RlbGVwb3J0JykpIHtcbiAgICAgICAgcmV0dXJuIFRFTEVQT1JUO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0J1aWx0SW5UeXBlKHRhZywgJ1N1c3BlbnNlJykpIHtcbiAgICAgICAgcmV0dXJuIFNVU1BFTlNFO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0J1aWx0SW5UeXBlKHRhZywgJ0tlZXBBbGl2ZScpKSB7XG4gICAgICAgIHJldHVybiBLRUVQX0FMSVZFO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0J1aWx0SW5UeXBlKHRhZywgJ0Jhc2VUcmFuc2l0aW9uJykpIHtcbiAgICAgICAgcmV0dXJuIEJBU0VfVFJBTlNJVElPTjtcbiAgICB9XG59XG5jb25zdCBub25JZGVudGlmaWVyUkUgPSAvXlxcZHxbXlxcJFxcd10vO1xuY29uc3QgaXNTaW1wbGVJZGVudGlmaWVyID0gKG5hbWUpID0+ICFub25JZGVudGlmaWVyUkUudGVzdChuYW1lKTtcbmNvbnN0IHZhbGlkRmlyc3RJZGVudENoYXJSRSA9IC9bQS1aYS16XyRcXHhBMC1cXHVGRkZGXS87XG5jb25zdCB2YWxpZElkZW50Q2hhclJFID0gL1tcXC5cXD9cXHckXFx4QTAtXFx1RkZGRl0vO1xuY29uc3Qgd2hpdGVzcGFjZVJFID0gL1xccytbLltdXFxzKnxcXHMqWy5bXVxccysvZztcbi8qKlxuICogU2ltcGxlIGxleGVyIHRvIGNoZWNrIGlmIGFuIGV4cHJlc3Npb24gaXMgYSBtZW1iZXIgZXhwcmVzc2lvbi4gVGhpcyBpc1xuICogbGF4IGFuZCBvbmx5IGNoZWNrcyB2YWxpZGl0eSBhdCB0aGUgcm9vdCBsZXZlbCAoaS5lLiBkb2VzIG5vdCB2YWxpZGF0ZSBleHBzXG4gKiBpbnNpZGUgc3F1YXJlIGJyYWNrZXRzKSwgYnV0IGl0J3Mgb2sgc2luY2UgdGhlc2UgYXJlIG9ubHkgdXNlZCBvbiB0ZW1wbGF0ZVxuICogZXhwcmVzc2lvbnMgYW5kIGZhbHNlIHBvc2l0aXZlcyBhcmUgaW52YWxpZCBleHByZXNzaW9ucyBpbiB0aGUgZmlyc3QgcGxhY2UuXG4gKi9cbmNvbnN0IGlzTWVtYmVyRXhwcmVzc2lvbkJyb3dzZXIgPSAocGF0aCkgPT4ge1xuICAgIC8vIHJlbW92ZSB3aGl0ZXNwYWNlcyBhcm91bmQgLiBvciBbIGZpcnN0XG4gICAgcGF0aCA9IHBhdGgudHJpbSgpLnJlcGxhY2Uod2hpdGVzcGFjZVJFLCBzID0+IHMudHJpbSgpKTtcbiAgICBsZXQgc3RhdGUgPSAwIC8qIE1lbWJlckV4cExleFN0YXRlLmluTWVtYmVyRXhwICovO1xuICAgIGxldCBzdGF0ZVN0YWNrID0gW107XG4gICAgbGV0IGN1cnJlbnRPcGVuQnJhY2tldENvdW50ID0gMDtcbiAgICBsZXQgY3VycmVudE9wZW5QYXJlbnNDb3VudCA9IDA7XG4gICAgbGV0IGN1cnJlbnRTdHJpbmdUeXBlID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hhciA9IHBhdGguY2hhckF0KGkpO1xuICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIDAgLyogTWVtYmVyRXhwTGV4U3RhdGUuaW5NZW1iZXJFeHAgKi86XG4gICAgICAgICAgICAgICAgaWYgKGNoYXIgPT09ICdbJykge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZVN0YWNrLnB1c2goc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDEgLyogTWVtYmVyRXhwTGV4U3RhdGUuaW5CcmFja2V0cyAqLztcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE9wZW5CcmFja2V0Q291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gJygnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlU3RhY2sucHVzaChzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMiAvKiBNZW1iZXJFeHBMZXhTdGF0ZS5pblBhcmVucyAqLztcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE9wZW5QYXJlbnNDb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghKGkgPT09IDAgPyB2YWxpZEZpcnN0SWRlbnRDaGFyUkUgOiB2YWxpZElkZW50Q2hhclJFKS50ZXN0KGNoYXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEgLyogTWVtYmVyRXhwTGV4U3RhdGUuaW5CcmFja2V0cyAqLzpcbiAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gYCdgIHx8IGNoYXIgPT09IGBcImAgfHwgY2hhciA9PT0gJ2AnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlU3RhY2sucHVzaChzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMyAvKiBNZW1iZXJFeHBMZXhTdGF0ZS5pblN0cmluZyAqLztcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0cmluZ1R5cGUgPSBjaGFyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSBgW2ApIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE9wZW5CcmFja2V0Q291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gYF1gKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghLS1jdXJyZW50T3BlbkJyYWNrZXRDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyIC8qIE1lbWJlckV4cExleFN0YXRlLmluUGFyZW5zICovOlxuICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSBgJ2AgfHwgY2hhciA9PT0gYFwiYCB8fCBjaGFyID09PSAnYCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVTdGFjay5wdXNoKHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAzIC8qIE1lbWJlckV4cExleFN0YXRlLmluU3RyaW5nICovO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RyaW5nVHlwZSA9IGNoYXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09IGAoYCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50T3BlblBhcmVuc0NvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09IGApYCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZXhwIGVuZHMgYXMgYSBjYWxsIHRoZW4gaXQgc2hvdWxkIG5vdCBiZSBjb25zaWRlcmVkIHZhbGlkXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBwYXRoLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIS0tY3VycmVudE9wZW5QYXJlbnNDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzIC8qIE1lbWJlckV4cExleFN0YXRlLmluU3RyaW5nICovOlxuICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSBjdXJyZW50U3RyaW5nVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHN0YXRlU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdHJpbmdUeXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICFjdXJyZW50T3BlbkJyYWNrZXRDb3VudCAmJiAhY3VycmVudE9wZW5QYXJlbnNDb3VudDtcbn07XG5jb25zdCBpc01lbWJlckV4cHJlc3Npb25Ob2RlID0gTk9PUFxuICAgIDtcbmNvbnN0IGlzTWVtYmVyRXhwcmVzc2lvbiA9IGlzTWVtYmVyRXhwcmVzc2lvbkJyb3dzZXJcbiAgICA7XG5mdW5jdGlvbiBnZXRJbm5lclJhbmdlKGxvYywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBsb2Muc291cmNlLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICBjb25zdCBuZXdMb2MgPSB7XG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgc3RhcnQ6IGFkdmFuY2VQb3NpdGlvbldpdGhDbG9uZShsb2Muc3RhcnQsIGxvYy5zb3VyY2UsIG9mZnNldCksXG4gICAgICAgIGVuZDogbG9jLmVuZFxuICAgIH07XG4gICAgaWYgKGxlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgIG5ld0xvYy5lbmQgPSBhZHZhbmNlUG9zaXRpb25XaXRoQ2xvbmUobG9jLnN0YXJ0LCBsb2Muc291cmNlLCBvZmZzZXQgKyBsZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3TG9jO1xufVxuZnVuY3Rpb24gYWR2YW5jZVBvc2l0aW9uV2l0aENsb25lKHBvcywgc291cmNlLCBudW1iZXJPZkNoYXJhY3RlcnMgPSBzb3VyY2UubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFkdmFuY2VQb3NpdGlvbldpdGhNdXRhdGlvbihleHRlbmQoe30sIHBvcyksIHNvdXJjZSwgbnVtYmVyT2ZDaGFyYWN0ZXJzKTtcbn1cbi8vIGFkdmFuY2UgYnkgbXV0YXRpb24gd2l0aG91dCBjbG9uaW5nIChmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyksIHNpbmNlIHRoaXNcbi8vIGdldHMgY2FsbGVkIGEgbG90IGluIHRoZSBwYXJzZXJcbmZ1bmN0aW9uIGFkdmFuY2VQb3NpdGlvbldpdGhNdXRhdGlvbihwb3MsIHNvdXJjZSwgbnVtYmVyT2ZDaGFyYWN0ZXJzID0gc291cmNlLmxlbmd0aCkge1xuICAgIGxldCBsaW5lc0NvdW50ID0gMDtcbiAgICBsZXQgbGFzdE5ld0xpbmVQb3MgPSAtMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mQ2hhcmFjdGVyczsgaSsrKSB7XG4gICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpKSA9PT0gMTAgLyogbmV3bGluZSBjaGFyIGNvZGUgKi8pIHtcbiAgICAgICAgICAgIGxpbmVzQ291bnQrKztcbiAgICAgICAgICAgIGxhc3ROZXdMaW5lUG9zID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwb3Mub2Zmc2V0ICs9IG51bWJlck9mQ2hhcmFjdGVycztcbiAgICBwb3MubGluZSArPSBsaW5lc0NvdW50O1xuICAgIHBvcy5jb2x1bW4gPVxuICAgICAgICBsYXN0TmV3TGluZVBvcyA9PT0gLTFcbiAgICAgICAgICAgID8gcG9zLmNvbHVtbiArIG51bWJlck9mQ2hhcmFjdGVyc1xuICAgICAgICAgICAgOiBudW1iZXJPZkNoYXJhY3RlcnMgLSBsYXN0TmV3TGluZVBvcztcbiAgICByZXR1cm4gcG9zO1xufVxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbXNnKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCBgdW5leHBlY3RlZCBjb21waWxlciBjb25kaXRpb25gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kRGlyKG5vZGUsIG5hbWUsIGFsbG93RW1wdHkgPSBmYWxzZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwID0gbm9kZS5wcm9wc1tpXTtcbiAgICAgICAgaWYgKHAudHlwZSA9PT0gNyAvKiBOb2RlVHlwZXMuRElSRUNUSVZFICovICYmXG4gICAgICAgICAgICAoYWxsb3dFbXB0eSB8fCBwLmV4cCkgJiZcbiAgICAgICAgICAgIChpc1N0cmluZyhuYW1lKSA/IHAubmFtZSA9PT0gbmFtZSA6IG5hbWUudGVzdChwLm5hbWUpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kUHJvcChub2RlLCBuYW1lLCBkeW5hbWljT25seSA9IGZhbHNlLCBhbGxvd0VtcHR5ID0gZmFsc2UpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUucHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcCA9IG5vZGUucHJvcHNbaV07XG4gICAgICAgIGlmIChwLnR5cGUgPT09IDYgLyogTm9kZVR5cGVzLkFUVFJJQlVURSAqLykge1xuICAgICAgICAgICAgaWYgKGR5bmFtaWNPbmx5KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHAubmFtZSA9PT0gbmFtZSAmJiAocC52YWx1ZSB8fCBhbGxvd0VtcHR5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHAubmFtZSA9PT0gJ2JpbmQnICYmXG4gICAgICAgICAgICAocC5leHAgfHwgYWxsb3dFbXB0eSkgJiZcbiAgICAgICAgICAgIGlzU3RhdGljQXJnT2YocC5hcmcsIG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzU3RhdGljQXJnT2YoYXJnLCBuYW1lKSB7XG4gICAgcmV0dXJuICEhKGFyZyAmJiBpc1N0YXRpY0V4cChhcmcpICYmIGFyZy5jb250ZW50ID09PSBuYW1lKTtcbn1cbmZ1bmN0aW9uIGhhc0R5bmFtaWNLZXlWQmluZChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUucHJvcHMuc29tZShwID0+IHAudHlwZSA9PT0gNyAvKiBOb2RlVHlwZXMuRElSRUNUSVZFICovICYmXG4gICAgICAgIHAubmFtZSA9PT0gJ2JpbmQnICYmXG4gICAgICAgICghcC5hcmcgfHwgLy8gdi1iaW5kPVwib2JqXCJcbiAgICAgICAgICAgIHAuYXJnLnR5cGUgIT09IDQgLyogTm9kZVR5cGVzLlNJTVBMRV9FWFBSRVNTSU9OICovIHx8IC8vIHYtYmluZDpbX2N0eC5mb29dXG4gICAgICAgICAgICAhcC5hcmcuaXNTdGF0aWMpIC8vIHYtYmluZDpbZm9vXVxuICAgICk7XG59XG5mdW5jdGlvbiBpc1RleHQobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IDUgLyogTm9kZVR5cGVzLklOVEVSUE9MQVRJT04gKi8gfHwgbm9kZS50eXBlID09PSAyIC8qIE5vZGVUeXBlcy5URVhUICovO1xufVxuZnVuY3Rpb24gaXNWU2xvdChwKSB7XG4gICAgcmV0dXJuIHAudHlwZSA9PT0gNyAvKiBOb2RlVHlwZXMuRElSRUNUSVZFICovICYmIHAubmFtZSA9PT0gJ3Nsb3QnO1xufVxuZnVuY3Rpb24gaXNUZW1wbGF0ZU5vZGUobm9kZSkge1xuICAgIHJldHVybiAobm9kZS50eXBlID09PSAxIC8qIE5vZGVUeXBlcy5FTEVNRU5UICovICYmIG5vZGUudGFnVHlwZSA9PT0gMyAvKiBFbGVtZW50VHlwZXMuVEVNUExBVEUgKi8pO1xufVxuZnVuY3Rpb24gaXNTbG90T3V0bGV0KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSAxIC8qIE5vZGVUeXBlcy5FTEVNRU5UICovICYmIG5vZGUudGFnVHlwZSA9PT0gMiAvKiBFbGVtZW50VHlwZXMuU0xPVCAqLztcbn1cbmZ1bmN0aW9uIGdldFZOb2RlSGVscGVyKHNzciwgaXNDb21wb25lbnQpIHtcbiAgICByZXR1cm4gc3NyIHx8IGlzQ29tcG9uZW50ID8gQ1JFQVRFX1ZOT0RFIDogQ1JFQVRFX0VMRU1FTlRfVk5PREU7XG59XG5mdW5jdGlvbiBnZXRWTm9kZUJsb2NrSGVscGVyKHNzciwgaXNDb21wb25lbnQpIHtcbiAgICByZXR1cm4gc3NyIHx8IGlzQ29tcG9uZW50ID8gQ1JFQVRFX0JMT0NLIDogQ1JFQVRFX0VMRU1FTlRfQkxPQ0s7XG59XG5jb25zdCBwcm9wc0hlbHBlclNldCA9IG5ldyBTZXQoW05PUk1BTElaRV9QUk9QUywgR1VBUkRfUkVBQ1RJVkVfUFJPUFNdKTtcbmZ1bmN0aW9uIGdldFVubm9ybWFsaXplZFByb3BzKHByb3BzLCBjYWxsUGF0aCA9IFtdKSB7XG4gICAgaWYgKHByb3BzICYmXG4gICAgICAgICFpc1N0cmluZyhwcm9wcykgJiZcbiAgICAgICAgcHJvcHMudHlwZSA9PT0gMTQgLyogTm9kZVR5cGVzLkpTX0NBTExfRVhQUkVTU0lPTiAqLykge1xuICAgICAgICBjb25zdCBjYWxsZWUgPSBwcm9wcy5jYWxsZWU7XG4gICAgICAgIGlmICghaXNTdHJpbmcoY2FsbGVlKSAmJiBwcm9wc0hlbHBlclNldC5oYXMoY2FsbGVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFVubm9ybWFsaXplZFByb3BzKHByb3BzLmFyZ3VtZW50c1swXSwgY2FsbFBhdGguY29uY2F0KHByb3BzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtwcm9wcywgY2FsbFBhdGhdO1xufVxuZnVuY3Rpb24gaW5qZWN0UHJvcChub2RlLCBwcm9wLCBjb250ZXh0KSB7XG4gICAgbGV0IHByb3BzV2l0aEluamVjdGlvbjtcbiAgICAvKipcbiAgICAgKiAxLiBtZXJnZVByb3BzKC4uLilcbiAgICAgKiAyLiB0b0hhbmRsZXJzKC4uLilcbiAgICAgKiAzLiBub3JtYWxpemVQcm9wcyguLi4pXG4gICAgICogNC4gbm9ybWFsaXplUHJvcHMoZ3VhcmRSZWFjdGl2ZVByb3BzKC4uLikpXG4gICAgICpcbiAgICAgKiB3ZSBuZWVkIHRvIGdldCB0aGUgcmVhbCBwcm9wcyBiZWZvcmUgbm9ybWFsaXphdGlvblxuICAgICAqL1xuICAgIGxldCBwcm9wcyA9IG5vZGUudHlwZSA9PT0gMTMgLyogTm9kZVR5cGVzLlZOT0RFX0NBTEwgKi8gPyBub2RlLnByb3BzIDogbm9kZS5hcmd1bWVudHNbMl07XG4gICAgbGV0IGNhbGxQYXRoID0gW107XG4gICAgbGV0IHBhcmVudENhbGw7XG4gICAgaWYgKHByb3BzICYmXG4gICAgICAgICFpc1N0cmluZyhwcm9wcykgJiZcbiAgICAgICAgcHJvcHMudHlwZSA9PT0gMTQgLyogTm9kZVR5cGVzLkpTX0NBTExfRVhQUkVTU0lPTiAqLykge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRVbm5vcm1hbGl6ZWRQcm9wcyhwcm9wcyk7XG4gICAgICAgIHByb3BzID0gcmV0WzBdO1xuICAgICAgICBjYWxsUGF0aCA9IHJldFsxXTtcbiAgICAgICAgcGFyZW50Q2FsbCA9IGNhbGxQYXRoW2NhbGxQYXRoLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBpZiAocHJvcHMgPT0gbnVsbCB8fCBpc1N0cmluZyhwcm9wcykpIHtcbiAgICAgICAgcHJvcHNXaXRoSW5qZWN0aW9uID0gY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihbcHJvcF0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9wcy50eXBlID09PSAxNCAvKiBOb2RlVHlwZXMuSlNfQ0FMTF9FWFBSRVNTSU9OICovKSB7XG4gICAgICAgIC8vIG1lcmdlZCBwcm9wcy4uLiBhZGQgb3Vyc1xuICAgICAgICAvLyBvbmx5IGluamVjdCBrZXkgdG8gb2JqZWN0IGxpdGVyYWwgaWYgaXQncyB0aGUgZmlyc3QgYXJndW1lbnQgc28gdGhhdFxuICAgICAgICAvLyBpZiBkb2Vzbid0IG92ZXJyaWRlIHVzZXIgcHJvdmlkZWQga2V5c1xuICAgICAgICBjb25zdCBmaXJzdCA9IHByb3BzLmFyZ3VtZW50c1swXTtcbiAgICAgICAgaWYgKCFpc1N0cmluZyhmaXJzdCkgJiYgZmlyc3QudHlwZSA9PT0gMTUgLyogTm9kZVR5cGVzLkpTX09CSkVDVF9FWFBSRVNTSU9OICovKSB7XG4gICAgICAgICAgICAvLyAjNjYzMVxuICAgICAgICAgICAgaWYgKCFoYXNQcm9wKHByb3AsIGZpcnN0KSkge1xuICAgICAgICAgICAgICAgIGZpcnN0LnByb3BlcnRpZXMudW5zaGlmdChwcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwcm9wcy5jYWxsZWUgPT09IFRPX0hBTkRMRVJTKSB7XG4gICAgICAgICAgICAgICAgLy8gIzIzNjZcbiAgICAgICAgICAgICAgICBwcm9wc1dpdGhJbmplY3Rpb24gPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihNRVJHRV9QUk9QUyksIFtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihbcHJvcF0pLFxuICAgICAgICAgICAgICAgICAgICBwcm9wc1xuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvcHMuYXJndW1lbnRzLnVuc2hpZnQoY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihbcHJvcF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAhcHJvcHNXaXRoSW5qZWN0aW9uICYmIChwcm9wc1dpdGhJbmplY3Rpb24gPSBwcm9wcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb3BzLnR5cGUgPT09IDE1IC8qIE5vZGVUeXBlcy5KU19PQkpFQ1RfRVhQUkVTU0lPTiAqLykge1xuICAgICAgICBpZiAoIWhhc1Byb3AocHJvcCwgcHJvcHMpKSB7XG4gICAgICAgICAgICBwcm9wcy5wcm9wZXJ0aWVzLnVuc2hpZnQocHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvcHNXaXRoSW5qZWN0aW9uID0gcHJvcHM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBzaW5nbGUgdi1iaW5kIHdpdGggZXhwcmVzc2lvbiwgcmV0dXJuIGEgbWVyZ2VkIHJlcGxhY2VtZW50XG4gICAgICAgIHByb3BzV2l0aEluamVjdGlvbiA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKE1FUkdFX1BST1BTKSwgW1xuICAgICAgICAgICAgY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihbcHJvcF0pLFxuICAgICAgICAgICAgcHJvcHNcbiAgICAgICAgXSk7XG4gICAgICAgIC8vIGluIHRoZSBjYXNlIG9mIG5lc3RlZCBoZWxwZXIgY2FsbCwgZS5nLiBgbm9ybWFsaXplUHJvcHMoZ3VhcmRSZWFjdGl2ZVByb3BzKHByb3BzKSlgLFxuICAgICAgICAvLyBpdCB3aWxsIGJlIHJld3JpdHRlbiBhcyBgbm9ybWFsaXplUHJvcHMobWVyZ2VQcm9wcyh7IGtleTogMCB9LCBwcm9wcykpYCxcbiAgICAgICAgLy8gdGhlIGBndWFyZFJlYWN0aXZlUHJvcHNgIHdpbGwgbm8gbG9uZ2VyIGJlIG5lZWRlZFxuICAgICAgICBpZiAocGFyZW50Q2FsbCAmJiBwYXJlbnRDYWxsLmNhbGxlZSA9PT0gR1VBUkRfUkVBQ1RJVkVfUFJPUFMpIHtcbiAgICAgICAgICAgIHBhcmVudENhbGwgPSBjYWxsUGF0aFtjYWxsUGF0aC5sZW5ndGggLSAyXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS50eXBlID09PSAxMyAvKiBOb2RlVHlwZXMuVk5PREVfQ0FMTCAqLykge1xuICAgICAgICBpZiAocGFyZW50Q2FsbCkge1xuICAgICAgICAgICAgcGFyZW50Q2FsbC5hcmd1bWVudHNbMF0gPSBwcm9wc1dpdGhJbmplY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlLnByb3BzID0gcHJvcHNXaXRoSW5qZWN0aW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAocGFyZW50Q2FsbCkge1xuICAgICAgICAgICAgcGFyZW50Q2FsbC5hcmd1bWVudHNbMF0gPSBwcm9wc1dpdGhJbmplY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlLmFyZ3VtZW50c1syXSA9IHByb3BzV2l0aEluamVjdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIGNoZWNrIGV4aXN0aW5nIGtleSB0byBhdm9pZCBvdmVycmlkaW5nIHVzZXIgcHJvdmlkZWQga2V5c1xuZnVuY3Rpb24gaGFzUHJvcChwcm9wLCBwcm9wcykge1xuICAgIGxldCByZXN1bHQgPSBmYWxzZTtcbiAgICBpZiAocHJvcC5rZXkudHlwZSA9PT0gNCAvKiBOb2RlVHlwZXMuU0lNUExFX0VYUFJFU1NJT04gKi8pIHtcbiAgICAgICAgY29uc3QgcHJvcEtleU5hbWUgPSBwcm9wLmtleS5jb250ZW50O1xuICAgICAgICByZXN1bHQgPSBwcm9wcy5wcm9wZXJ0aWVzLnNvbWUocCA9PiBwLmtleS50eXBlID09PSA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLyAmJlxuICAgICAgICAgICAgcC5rZXkuY29udGVudCA9PT0gcHJvcEtleU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdG9WYWxpZEFzc2V0SWQobmFtZSwgdHlwZSkge1xuICAgIC8vIHNlZSBpc3N1ZSM0NDIyLCB3ZSBuZWVkIGFkZGluZyBpZGVudGlmaWVyIG9uIHZhbGlkQXNzZXRJZCBpZiB2YXJpYWJsZSBgbmFtZWAgaGFzIHNwZWNpZmljIGNoYXJhY3RlclxuICAgIHJldHVybiBgXyR7dHlwZX1fJHtuYW1lLnJlcGxhY2UoL1teXFx3XS9nLCAoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gc2VhcmNoVmFsdWUgPT09ICctJyA/ICdfJyA6IG5hbWUuY2hhckNvZGVBdChyZXBsYWNlVmFsdWUpLnRvU3RyaW5nKCk7XG4gICAgfSl9YDtcbn1cbi8vIENoZWNrIGlmIGEgbm9kZSBjb250YWlucyBleHByZXNzaW9ucyB0aGF0IHJlZmVyZW5jZSBjdXJyZW50IGNvbnRleHQgc2NvcGUgaWRzXG5mdW5jdGlvbiBoYXNTY29wZVJlZihub2RlLCBpZHMpIHtcbiAgICBpZiAoIW5vZGUgfHwgT2JqZWN0LmtleXMoaWRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICBjYXNlIDEgLyogTm9kZVR5cGVzLkVMRU1FTlQgKi86XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUucHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gbm9kZS5wcm9wc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocC50eXBlID09PSA3IC8qIE5vZGVUeXBlcy5ESVJFQ1RJVkUgKi8gJiZcbiAgICAgICAgICAgICAgICAgICAgKGhhc1Njb3BlUmVmKHAuYXJnLCBpZHMpIHx8IGhhc1Njb3BlUmVmKHAuZXhwLCBpZHMpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5zb21lKGMgPT4gaGFzU2NvcGVSZWYoYywgaWRzKSk7XG4gICAgICAgIGNhc2UgMTEgLyogTm9kZVR5cGVzLkZPUiAqLzpcbiAgICAgICAgICAgIGlmIChoYXNTY29wZVJlZihub2RlLnNvdXJjZSwgaWRzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4uc29tZShjID0+IGhhc1Njb3BlUmVmKGMsIGlkcykpO1xuICAgICAgICBjYXNlIDkgLyogTm9kZVR5cGVzLklGICovOlxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuYnJhbmNoZXMuc29tZShiID0+IGhhc1Njb3BlUmVmKGIsIGlkcykpO1xuICAgICAgICBjYXNlIDEwIC8qIE5vZGVUeXBlcy5JRl9CUkFOQ0ggKi86XG4gICAgICAgICAgICBpZiAoaGFzU2NvcGVSZWYobm9kZS5jb25kaXRpb24sIGlkcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLnNvbWUoYyA9PiBoYXNTY29wZVJlZihjLCBpZHMpKTtcbiAgICAgICAgY2FzZSA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLzpcbiAgICAgICAgICAgIHJldHVybiAoIW5vZGUuaXNTdGF0aWMgJiZcbiAgICAgICAgICAgICAgICBpc1NpbXBsZUlkZW50aWZpZXIobm9kZS5jb250ZW50KSAmJlxuICAgICAgICAgICAgICAgICEhaWRzW25vZGUuY29udGVudF0pO1xuICAgICAgICBjYXNlIDggLyogTm9kZVR5cGVzLkNPTVBPVU5EX0VYUFJFU1NJT04gKi86XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5zb21lKGMgPT4gaXNPYmplY3QoYykgJiYgaGFzU2NvcGVSZWYoYywgaWRzKSk7XG4gICAgICAgIGNhc2UgNSAvKiBOb2RlVHlwZXMuSU5URVJQT0xBVElPTiAqLzpcbiAgICAgICAgY2FzZSAxMiAvKiBOb2RlVHlwZXMuVEVYVF9DQUxMICovOlxuICAgICAgICAgICAgcmV0dXJuIGhhc1Njb3BlUmVmKG5vZGUuY29udGVudCwgaWRzKTtcbiAgICAgICAgY2FzZSAyIC8qIE5vZGVUeXBlcy5URVhUICovOlxuICAgICAgICBjYXNlIDMgLyogTm9kZVR5cGVzLkNPTU1FTlQgKi86XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSA7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0TWVtb2VkVk5vZGVDYWxsKG5vZGUpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSAxNCAvKiBOb2RlVHlwZXMuSlNfQ0FMTF9FWFBSRVNTSU9OICovICYmIG5vZGUuY2FsbGVlID09PSBXSVRIX01FTU8pIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuYXJndW1lbnRzWzFdLnJldHVybnM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYWtlQmxvY2sobm9kZSwgeyBoZWxwZXIsIHJlbW92ZUhlbHBlciwgaW5TU1IgfSkge1xuICAgIGlmICghbm9kZS5pc0Jsb2NrKSB7XG4gICAgICAgIG5vZGUuaXNCbG9jayA9IHRydWU7XG4gICAgICAgIHJlbW92ZUhlbHBlcihnZXRWTm9kZUhlbHBlcihpblNTUiwgbm9kZS5pc0NvbXBvbmVudCkpO1xuICAgICAgICBoZWxwZXIoT1BFTl9CTE9DSyk7XG4gICAgICAgIGhlbHBlcihnZXRWTm9kZUJsb2NrSGVscGVyKGluU1NSLCBub2RlLmlzQ29tcG9uZW50KSk7XG4gICAgfVxufVxuXG5jb25zdCBkZXByZWNhdGlvbkRhdGEgPSB7XG4gICAgW1wiQ09NUElMRVJfSVNfT05fRUxFTUVOVFwiIC8qIENvbXBpbGVyRGVwcmVjYXRpb25UeXBlcy5DT01QSUxFUl9JU19PTl9FTEVNRU5UICovXToge1xuICAgICAgICBtZXNzYWdlOiBgUGxhdGZvcm0tbmF0aXZlIGVsZW1lbnRzIHdpdGggXCJpc1wiIHByb3Agd2lsbCBubyBsb25nZXIgYmUgYCArXG4gICAgICAgICAgICBgdHJlYXRlZCBhcyBjb21wb25lbnRzIGluIFZ1ZSAzIHVubGVzcyB0aGUgXCJpc1wiIHZhbHVlIGlzIGV4cGxpY2l0bHkgYCArXG4gICAgICAgICAgICBgcHJlZml4ZWQgd2l0aCBcInZ1ZTpcIi5gLFxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My1taWdyYXRpb24udnVlanMub3JnL2JyZWFraW5nLWNoYW5nZXMvY3VzdG9tLWVsZW1lbnRzLWludGVyb3AuaHRtbGBcbiAgICB9LFxuICAgIFtcIkNPTVBJTEVSX1ZfQklORF9TWU5DXCIgLyogQ29tcGlsZXJEZXByZWNhdGlvblR5cGVzLkNPTVBJTEVSX1ZfQklORF9TWU5DICovXToge1xuICAgICAgICBtZXNzYWdlOiBrZXkgPT4gYC5zeW5jIG1vZGlmaWVyIGZvciB2LWJpbmQgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHYtbW9kZWwgd2l0aCBgICtcbiAgICAgICAgICAgIGBhcmd1bWVudCBpbnN0ZWFkLiBcXGB2LWJpbmQ6JHtrZXl9LnN5bmNcXGAgc2hvdWxkIGJlIGNoYW5nZWQgdG8gYCArXG4gICAgICAgICAgICBgXFxgdi1tb2RlbDoke2tleX1cXGAuYCxcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMtbWlncmF0aW9uLnZ1ZWpzLm9yZy9icmVha2luZy1jaGFuZ2VzL3YtbW9kZWwuaHRtbGBcbiAgICB9LFxuICAgIFtcIkNPTVBJTEVSX1ZfQklORF9QUk9QXCIgLyogQ29tcGlsZXJEZXByZWNhdGlvblR5cGVzLkNPTVBJTEVSX1ZfQklORF9QUk9QICovXToge1xuICAgICAgICBtZXNzYWdlOiBgLnByb3AgbW9kaWZpZXIgZm9yIHYtYmluZCBoYXMgYmVlbiByZW1vdmVkIGFuZCBubyBsb25nZXIgbmVjZXNzYXJ5LiBgICtcbiAgICAgICAgICAgIGBWdWUgMyB3aWxsIGF1dG9tYXRpY2FsbHkgc2V0IGEgYmluZGluZyBhcyBET00gcHJvcGVydHkgd2hlbiBhcHByb3ByaWF0ZS5gXG4gICAgfSxcbiAgICBbXCJDT01QSUxFUl9WX0JJTkRfT0JKRUNUX09SREVSXCIgLyogQ29tcGlsZXJEZXByZWNhdGlvblR5cGVzLkNPTVBJTEVSX1ZfQklORF9PQkpFQ1RfT1JERVIgKi9dOiB7XG4gICAgICAgIG1lc3NhZ2U6IGB2LWJpbmQ9XCJvYmpcIiB1c2FnZSBpcyBub3cgb3JkZXIgc2Vuc2l0aXZlIGFuZCBiZWhhdmVzIGxpa2UgSmF2YVNjcmlwdCBgICtcbiAgICAgICAgICAgIGBvYmplY3Qgc3ByZWFkOiBpdCB3aWxsIG5vdyBvdmVyd3JpdGUgYW4gZXhpc3Rpbmcgbm9uLW1lcmdlYWJsZSBhdHRyaWJ1dGUgYCArXG4gICAgICAgICAgICBgdGhhdCBhcHBlYXJzIGJlZm9yZSB2LWJpbmQgaW4gdGhlIGNhc2Ugb2YgY29uZmxpY3QuIGAgK1xuICAgICAgICAgICAgYFRvIHJldGFpbiAyLnggYmVoYXZpb3IsIG1vdmUgdi1iaW5kIHRvIG1ha2UgaXQgdGhlIGZpcnN0IGF0dHJpYnV0ZS4gYCArXG4gICAgICAgICAgICBgWW91IGNhbiBhbHNvIHN1cHByZXNzIHRoaXMgd2FybmluZyBpZiB0aGUgdXNhZ2UgaXMgaW50ZW5kZWQuYCxcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMtbWlncmF0aW9uLnZ1ZWpzLm9yZy9icmVha2luZy1jaGFuZ2VzL3YtYmluZC5odG1sYFxuICAgIH0sXG4gICAgW1wiQ09NUElMRVJfVl9PTl9OQVRJVkVcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfVl9PTl9OQVRJVkUgKi9dOiB7XG4gICAgICAgIG1lc3NhZ2U6IGAubmF0aXZlIG1vZGlmaWVyIGZvciB2LW9uIGhhcyBiZWVuIHJlbW92ZWQgYXMgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeS5gLFxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My1taWdyYXRpb24udnVlanMub3JnL2JyZWFraW5nLWNoYW5nZXMvdi1vbi1uYXRpdmUtbW9kaWZpZXItcmVtb3ZlZC5odG1sYFxuICAgIH0sXG4gICAgW1wiQ09NUElMRVJfVl9JRl9WX0ZPUl9QUkVDRURFTkNFXCIgLyogQ29tcGlsZXJEZXByZWNhdGlvblR5cGVzLkNPTVBJTEVSX1ZfSUZfVl9GT1JfUFJFQ0VERU5DRSAqL106IHtcbiAgICAgICAgbWVzc2FnZTogYHYtaWYgLyB2LWZvciBwcmVjZWRlbmNlIHdoZW4gdXNlZCBvbiB0aGUgc2FtZSBlbGVtZW50IGhhcyBjaGFuZ2VkIGAgK1xuICAgICAgICAgICAgYGluIFZ1ZSAzOiB2LWlmIG5vdyB0YWtlcyBoaWdoZXIgcHJlY2VkZW5jZSBhbmQgd2lsbCBubyBsb25nZXIgaGF2ZSBgICtcbiAgICAgICAgICAgIGBhY2Nlc3MgdG8gdi1mb3Igc2NvcGUgdmFyaWFibGVzLiBJdCBpcyBiZXN0IHRvIGF2b2lkIHRoZSBhbWJpZ3VpdHkgYCArXG4gICAgICAgICAgICBgd2l0aCA8dGVtcGxhdGU+IHRhZ3Mgb3IgdXNlIGEgY29tcHV0ZWQgcHJvcGVydHkgdGhhdCBmaWx0ZXJzIHYtZm9yIGAgK1xuICAgICAgICAgICAgYGRhdGEgc291cmNlLmAsXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy92LWlmLXYtZm9yLmh0bWxgXG4gICAgfSxcbiAgICBbXCJDT01QSUxFUl9OQVRJVkVfVEVNUExBVEVcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfTkFUSVZFX1RFTVBMQVRFICovXToge1xuICAgICAgICBtZXNzYWdlOiBgPHRlbXBsYXRlPiB3aXRoIG5vIHNwZWNpYWwgZGlyZWN0aXZlcyB3aWxsIHJlbmRlciBhcyBhIG5hdGl2ZSB0ZW1wbGF0ZSBgICtcbiAgICAgICAgICAgIGBlbGVtZW50IGluc3RlYWQgb2YgaXRzIGlubmVyIGNvbnRlbnQgaW4gVnVlIDMuYFxuICAgIH0sXG4gICAgW1wiQ09NUElMRVJfSU5MSU5FX1RFTVBMQVRFXCIgLyogQ29tcGlsZXJEZXByZWNhdGlvblR5cGVzLkNPTVBJTEVSX0lOTElORV9URU1QTEFURSAqL106IHtcbiAgICAgICAgbWVzc2FnZTogYFwiaW5saW5lLXRlbXBsYXRlXCIgaGFzIGJlZW4gcmVtb3ZlZCBpbiBWdWUgMy5gLFxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My1taWdyYXRpb24udnVlanMub3JnL2JyZWFraW5nLWNoYW5nZXMvaW5saW5lLXRlbXBsYXRlLWF0dHJpYnV0ZS5odG1sYFxuICAgIH0sXG4gICAgW1wiQ09NUElMRVJfRklMVEVSXCIgLyogQ29tcGlsZXJEZXByZWNhdGlvblR5cGVzLkNPTVBJTEVSX0ZJTFRFUlMgKi9dOiB7XG4gICAgICAgIG1lc3NhZ2U6IGBmaWx0ZXJzIGhhdmUgYmVlbiByZW1vdmVkIGluIFZ1ZSAzLiBgICtcbiAgICAgICAgICAgIGBUaGUgXCJ8XCIgc3ltYm9sIHdpbGwgYmUgdHJlYXRlZCBhcyBuYXRpdmUgSmF2YVNjcmlwdCBiaXR3aXNlIE9SIG9wZXJhdG9yLiBgICtcbiAgICAgICAgICAgIGBVc2UgbWV0aG9kIGNhbGxzIG9yIGNvbXB1dGVkIHByb3BlcnRpZXMgaW5zdGVhZC5gLFxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My1taWdyYXRpb24udnVlanMub3JnL2JyZWFraW5nLWNoYW5nZXMvZmlsdGVycy5odG1sYFxuICAgIH1cbn07XG5mdW5jdGlvbiBnZXRDb21wYXRWYWx1ZShrZXksIGNvbnRleHQpIHtcbiAgICBjb25zdCBjb25maWcgPSBjb250ZXh0Lm9wdGlvbnNcbiAgICAgICAgPyBjb250ZXh0Lm9wdGlvbnMuY29tcGF0Q29uZmlnXG4gICAgICAgIDogY29udGV4dC5jb21wYXRDb25maWc7XG4gICAgY29uc3QgdmFsdWUgPSBjb25maWcgJiYgY29uZmlnW2tleV07XG4gICAgaWYgKGtleSA9PT0gJ01PREUnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSB8fCAzOyAvLyBjb21waWxlciBkZWZhdWx0cyB0byB2MyBiZWhhdmlvclxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQ29tcGF0RW5hYmxlZChrZXksIGNvbnRleHQpIHtcbiAgICBjb25zdCBtb2RlID0gZ2V0Q29tcGF0VmFsdWUoJ01PREUnLCBjb250ZXh0KTtcbiAgICBjb25zdCB2YWx1ZSA9IGdldENvbXBhdFZhbHVlKGtleSwgY29udGV4dCk7XG4gICAgLy8gaW4gdjMgbW9kZSwgb25seSBlbmFibGUgaWYgZXhwbGljaXRseSBzZXQgdG8gdHJ1ZVxuICAgIC8vIG90aGVyd2lzZSBlbmFibGUgZm9yIGFueSBub24tZmFsc2UgdmFsdWVcbiAgICByZXR1cm4gbW9kZSA9PT0gMyA/IHZhbHVlID09PSB0cnVlIDogdmFsdWUgIT09IGZhbHNlO1xufVxuZnVuY3Rpb24gY2hlY2tDb21wYXRFbmFibGVkKGtleSwgY29udGV4dCwgbG9jLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgZW5hYmxlZCA9IGlzQ29tcGF0RW5hYmxlZChrZXksIGNvbnRleHQpO1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgZW5hYmxlZCkge1xuICAgICAgICB3YXJuRGVwcmVjYXRpb24oa2V5LCBjb250ZXh0LCBsb2MsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gZW5hYmxlZDtcbn1cbmZ1bmN0aW9uIHdhcm5EZXByZWNhdGlvbihrZXksIGNvbnRleHQsIGxvYywgLi4uYXJncykge1xuICAgIGNvbnN0IHZhbCA9IGdldENvbXBhdFZhbHVlKGtleSwgY29udGV4dCk7XG4gICAgaWYgKHZhbCA9PT0gJ3N1cHByZXNzLXdhcm5pbmcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBtZXNzYWdlLCBsaW5rIH0gPSBkZXByZWNhdGlvbkRhdGFba2V5XTtcbiAgICBjb25zdCBtc2cgPSBgKGRlcHJlY2F0aW9uICR7a2V5fSkgJHt0eXBlb2YgbWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJyA/IG1lc3NhZ2UoLi4uYXJncykgOiBtZXNzYWdlfSR7bGluayA/IGBcXG4gIERldGFpbHM6ICR7bGlua31gIDogYGB9YDtcbiAgICBjb25zdCBlcnIgPSBuZXcgU3ludGF4RXJyb3IobXNnKTtcbiAgICBlcnIuY29kZSA9IGtleTtcbiAgICBpZiAobG9jKVxuICAgICAgICBlcnIubG9jID0gbG9jO1xuICAgIGNvbnRleHQub25XYXJuKGVycik7XG59XG5cbi8vIFRoZSBkZWZhdWx0IGRlY29kZXIgb25seSBwcm92aWRlcyBlc2NhcGVzIGZvciBjaGFyYWN0ZXJzIHJlc2VydmVkIGFzIHBhcnQgb2Zcbi8vIHRoZSB0ZW1wbGF0ZSBzeW50YXgsIGFuZCBpcyBvbmx5IHVzZWQgaWYgdGhlIGN1c3RvbSByZW5kZXJlciBkaWQgbm90IHByb3ZpZGVcbi8vIGEgcGxhdGZvcm0tc3BlY2lmaWMgZGVjb2Rlci5cbmNvbnN0IGRlY29kZVJFID0gLyYoZ3R8bHR8YW1wfGFwb3N8cXVvdCk7L2c7XG5jb25zdCBkZWNvZGVNYXAgPSB7XG4gICAgZ3Q6ICc+JyxcbiAgICBsdDogJzwnLFxuICAgIGFtcDogJyYnLFxuICAgIGFwb3M6IFwiJ1wiLFxuICAgIHF1b3Q6ICdcIidcbn07XG5jb25zdCBkZWZhdWx0UGFyc2VyT3B0aW9ucyA9IHtcbiAgICBkZWxpbWl0ZXJzOiBbYHt7YCwgYH19YF0sXG4gICAgZ2V0TmFtZXNwYWNlOiAoKSA9PiAwIC8qIE5hbWVzcGFjZXMuSFRNTCAqLyxcbiAgICBnZXRUZXh0TW9kZTogKCkgPT4gMCAvKiBUZXh0TW9kZXMuREFUQSAqLyxcbiAgICBpc1ZvaWRUYWc6IE5PLFxuICAgIGlzUHJlVGFnOiBOTyxcbiAgICBpc0N1c3RvbUVsZW1lbnQ6IE5PLFxuICAgIGRlY29kZUVudGl0aWVzOiAocmF3VGV4dCkgPT4gcmF3VGV4dC5yZXBsYWNlKGRlY29kZVJFLCAoXywgcDEpID0+IGRlY29kZU1hcFtwMV0pLFxuICAgIG9uRXJyb3I6IGRlZmF1bHRPbkVycm9yLFxuICAgIG9uV2FybjogZGVmYXVsdE9uV2FybixcbiAgICBjb21tZW50czogKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXG59O1xuZnVuY3Rpb24gYmFzZVBhcnNlKGNvbnRlbnQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVQYXJzZXJDb250ZXh0KGNvbnRlbnQsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xuICAgIHJldHVybiBjcmVhdGVSb290KHBhcnNlQ2hpbGRyZW4oY29udGV4dCwgMCAvKiBUZXh0TW9kZXMuREFUQSAqLywgW10pLCBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQpKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhcnNlckNvbnRleHQoY29udGVudCwgcmF3T3B0aW9ucykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRQYXJzZXJPcHRpb25zKTtcbiAgICBsZXQga2V5O1xuICAgIGZvciAoa2V5IGluIHJhd09wdGlvbnMpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBvcHRpb25zW2tleV0gPVxuICAgICAgICAgICAgcmF3T3B0aW9uc1trZXldID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IGRlZmF1bHRQYXJzZXJPcHRpb25zW2tleV1cbiAgICAgICAgICAgICAgICA6IHJhd09wdGlvbnNba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgY29sdW1uOiAxLFxuICAgICAgICBsaW5lOiAxLFxuICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgIG9yaWdpbmFsU291cmNlOiBjb250ZW50LFxuICAgICAgICBzb3VyY2U6IGNvbnRlbnQsXG4gICAgICAgIGluUHJlOiBmYWxzZSxcbiAgICAgICAgaW5WUHJlOiBmYWxzZSxcbiAgICAgICAgb25XYXJuOiBvcHRpb25zLm9uV2FyblxuICAgIH07XG59XG5mdW5jdGlvbiBwYXJzZUNoaWxkcmVuKGNvbnRleHQsIG1vZGUsIGFuY2VzdG9ycykge1xuICAgIGNvbnN0IHBhcmVudCA9IGxhc3QoYW5jZXN0b3JzKTtcbiAgICBjb25zdCBucyA9IHBhcmVudCA/IHBhcmVudC5ucyA6IDAgLyogTmFtZXNwYWNlcy5IVE1MICovO1xuICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgd2hpbGUgKCFpc0VuZChjb250ZXh0LCBtb2RlLCBhbmNlc3RvcnMpKSB7XG4gICAgICAgIGNvbnN0IHMgPSBjb250ZXh0LnNvdXJjZTtcbiAgICAgICAgbGV0IG5vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtb2RlID09PSAwIC8qIFRleHRNb2Rlcy5EQVRBICovIHx8IG1vZGUgPT09IDEgLyogVGV4dE1vZGVzLlJDREFUQSAqLykge1xuICAgICAgICAgICAgaWYgKCFjb250ZXh0LmluVlByZSAmJiBzdGFydHNXaXRoKHMsIGNvbnRleHQub3B0aW9ucy5kZWxpbWl0ZXJzWzBdKSkge1xuICAgICAgICAgICAgICAgIC8vICd7eydcbiAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VJbnRlcnBvbGF0aW9uKGNvbnRleHQsIG1vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW9kZSA9PT0gMCAvKiBUZXh0TW9kZXMuREFUQSAqLyAmJiBzWzBdID09PSAnPCcpIHtcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9wYXJzaW5nLmh0bWwjdGFnLW9wZW4tc3RhdGVcbiAgICAgICAgICAgICAgICBpZiAocy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDUgLyogRXJyb3JDb2Rlcy5FT0ZfQkVGT1JFX1RBR19OQU1FICovLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc1sxXSA9PT0gJyEnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCNtYXJrdXAtZGVjbGFyYXRpb24tb3Blbi1zdGF0ZVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRzV2l0aChzLCAnPCEtLScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VDb21tZW50KGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0c1dpdGgocywgJzwhRE9DVFlQRScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgRE9DVFlQRSBieSBhIGxpbWl0YXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VCb2d1c0NvbW1lbnQoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnRzV2l0aChzLCAnPCFbQ0RBVEFbJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChucyAhPT0gMCAvKiBOYW1lc3BhY2VzLkhUTUwgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VDREFUQShjb250ZXh0LCBhbmNlc3RvcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDEgLyogRXJyb3JDb2Rlcy5DREFUQV9JTl9IVE1MX0NPTlRFTlQgKi8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUJvZ3VzQ29tbWVudChjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxMSAvKiBFcnJvckNvZGVzLklOQ09SUkVDVExZX09QRU5FRF9DT01NRU5UICovKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUJvZ3VzQ29tbWVudChjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzWzFdID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvcGFyc2luZy5odG1sI2VuZC10YWctb3Blbi1zdGF0ZVxuICAgICAgICAgICAgICAgICAgICBpZiAocy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCA1IC8qIEVycm9yQ29kZXMuRU9GX0JFRk9SRV9UQUdfTkFNRSAqLywgMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc1syXSA9PT0gJz4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTQgLyogRXJyb3JDb2Rlcy5NSVNTSU5HX0VORF9UQUdfTkFNRSAqLywgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgvW2Etel0vaS50ZXN0KHNbMl0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMjMgLyogRXJyb3JDb2Rlcy5YX0lOVkFMSURfRU5EX1RBRyAqLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZVRhZyhjb250ZXh0LCAxIC8qIFRhZ1R5cGUuRW5kICovLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTIgLyogRXJyb3JDb2Rlcy5JTlZBTElEX0ZJUlNUX0NIQVJBQ1RFUl9PRl9UQUdfTkFNRSAqLywgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VCb2d1c0NvbW1lbnQoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoL1thLXpdL2kudGVzdChzWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VFbGVtZW50KGNvbnRleHQsIGFuY2VzdG9ycyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIDIueCA8dGVtcGxhdGU+IHdpdGggbm8gZGlyZWN0aXZlIGNvbXBhdFxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNDb21wYXRFbmFibGVkKFwiQ09NUElMRVJfTkFUSVZFX1RFTVBMQVRFXCIgLyogQ29tcGlsZXJEZXByZWNhdGlvblR5cGVzLkNPTVBJTEVSX05BVElWRV9URU1QTEFURSAqLywgY29udGV4dCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudGFnID09PSAndGVtcGxhdGUnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhbm9kZS5wcm9wcy5zb21lKHAgPT4gcC50eXBlID09PSA3IC8qIE5vZGVUeXBlcy5ESVJFQ1RJVkUgKi8gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1NwZWNpYWxUZW1wbGF0ZURpcmVjdGl2ZShwLm5hbWUpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybkRlcHJlY2F0aW9uKFwiQ09NUElMRVJfTkFUSVZFX1RFTVBMQVRFXCIgLyogQ29tcGlsZXJEZXByZWNhdGlvblR5cGVzLkNPTVBJTEVSX05BVElWRV9URU1QTEFURSAqLywgY29udGV4dCwgbm9kZS5sb2MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc1sxXSA9PT0gJz8nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAyMSAvKiBFcnJvckNvZGVzLlVORVhQRUNURURfUVVFU1RJT05fTUFSS19JTlNURUFEX09GX1RBR19OQU1FICovLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcnNlQm9ndXNDb21tZW50KGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDEyIC8qIEVycm9yQ29kZXMuSU5WQUxJRF9GSVJTVF9DSEFSQUNURVJfT0ZfVEFHX05BTUUgKi8sIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUgPSBwYXJzZVRleHQoY29udGV4dCwgbW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHB1c2hOb2RlKG5vZGVzLCBub2RlW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHB1c2hOb2RlKG5vZGVzLCBub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBXaGl0ZXNwYWNlIGhhbmRsaW5nIHN0cmF0ZWd5IGxpa2UgdjJcbiAgICBsZXQgcmVtb3ZlZFdoaXRlc3BhY2UgPSBmYWxzZTtcbiAgICBpZiAobW9kZSAhPT0gMiAvKiBUZXh0TW9kZXMuUkFXVEVYVCAqLyAmJiBtb2RlICE9PSAxIC8qIFRleHRNb2Rlcy5SQ0RBVEEgKi8pIHtcbiAgICAgICAgY29uc3Qgc2hvdWxkQ29uZGVuc2UgPSBjb250ZXh0Lm9wdGlvbnMud2hpdGVzcGFjZSAhPT0gJ3ByZXNlcnZlJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gMiAvKiBOb2RlVHlwZXMuVEVYVCAqLykge1xuICAgICAgICAgICAgICAgIGlmICghY29udGV4dC5pblByZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIS9bXlxcdFxcclxcblxcZiBdLy50ZXN0KG5vZGUuY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBub2Rlc1tpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gbm9kZXNbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGlmOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gLSB0aGUgd2hpdGVzcGFjZSBpcyB0aGUgZmlyc3Qgb3IgbGFzdCBub2RlLCBvcjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gKGNvbmRlbnNlIG1vZGUpIHRoZSB3aGl0ZXNwYWNlIGlzIGJldHdlZW4gdHdvcyBjb21tZW50cywgb3I6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAtIChjb25kZW5zZSBtb2RlKSB0aGUgd2hpdGVzcGFjZSBpcyBiZXR3ZWVuIGNvbW1lbnQgYW5kIGVsZW1lbnQsIG9yOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gLSAoY29uZGVuc2UgbW9kZSkgdGhlIHdoaXRlc3BhY2UgaXMgYmV0d2VlbiB0d28gZWxlbWVudHMgQU5EIGNvbnRhaW5zIG5ld2xpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJldiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFuZXh0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNob3VsZENvbmRlbnNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgocHJldi50eXBlID09PSAzIC8qIE5vZGVUeXBlcy5DT01NRU5UICovICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0LnR5cGUgPT09IDMgLyogTm9kZVR5cGVzLkNPTU1FTlQgKi8pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocHJldi50eXBlID09PSAzIC8qIE5vZGVUeXBlcy5DT01NRU5UICovICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC50eXBlID09PSAxIC8qIE5vZGVUeXBlcy5FTEVNRU5UICovKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHByZXYudHlwZSA9PT0gMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQudHlwZSA9PT0gMyAvKiBOb2RlVHlwZXMuQ09NTUVOVCAqLykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwcmV2LnR5cGUgPT09IDEgLyogTm9kZVR5cGVzLkVMRU1FTlQgKi8gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0LnR5cGUgPT09IDEgLyogTm9kZVR5cGVzLkVMRU1FTlQgKi8gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvW1xcclxcbl0vLnRlc3Qobm9kZS5jb250ZW50KSkpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWRXaGl0ZXNwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1tpXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHRoZSB3aGl0ZXNwYWNlIGlzIGNvbmRlbnNlZCBpbnRvIGEgc2luZ2xlIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5jb250ZW50ID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNob3VsZENvbmRlbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiBjb25kZW5zZSBtb2RlLCBjb25zZWN1dGl2ZSB3aGl0ZXNwYWNlcyBpbiB0ZXh0IGFyZSBjb25kZW5zZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvd24gdG8gYSBzaW5nbGUgc3BhY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNvbnRlbnQgPSBub2RlLmNvbnRlbnQucmVwbGFjZSgvW1xcdFxcclxcblxcZiBdKy9nLCAnICcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyAjNjQxMCBub3JtYWxpemUgd2luZG93cyBuZXdsaW5lcyBpbiA8cHJlPjpcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gU1NSLCBicm93c2VycyBub3JtYWxpemUgc2VydmVyLXJlbmRlcmVkIFxcclxcbiBpbnRvIGEgc2luZ2xlIFxcblxuICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgRE9NXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY29udGVudCA9IG5vZGUuY29udGVudC5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSBjb21tZW50IG5vZGVzIGlmIGRlc2lyZWQgYnkgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMyAvKiBOb2RlVHlwZXMuQ09NTUVOVCAqLyAmJiAhY29udGV4dC5vcHRpb25zLmNvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZFdoaXRlc3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG5vZGVzW2ldID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGV4dC5pblByZSAmJiBwYXJlbnQgJiYgY29udGV4dC5vcHRpb25zLmlzUHJlVGFnKHBhcmVudC50YWcpKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgbGVhZGluZyBuZXdsaW5lIHBlciBodG1sIHNwZWNcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2dyb3VwaW5nLWNvbnRlbnQuaHRtbCN0aGUtcHJlLWVsZW1lbnRcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gbm9kZXNbMF07XG4gICAgICAgICAgICBpZiAoZmlyc3QgJiYgZmlyc3QudHlwZSA9PT0gMiAvKiBOb2RlVHlwZXMuVEVYVCAqLykge1xuICAgICAgICAgICAgICAgIGZpcnN0LmNvbnRlbnQgPSBmaXJzdC5jb250ZW50LnJlcGxhY2UoL15cXHI/XFxuLywgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZW1vdmVkV2hpdGVzcGFjZSA/IG5vZGVzLmZpbHRlcihCb29sZWFuKSA6IG5vZGVzO1xufVxuZnVuY3Rpb24gcHVzaE5vZGUobm9kZXMsIG5vZGUpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSAyIC8qIE5vZGVUeXBlcy5URVhUICovKSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSBsYXN0KG5vZGVzKTtcbiAgICAgICAgLy8gTWVyZ2UgaWYgYm90aCB0aGlzIGFuZCB0aGUgcHJldmlvdXMgbm9kZSBhcmUgdGV4dCBhbmQgdGhvc2UgYXJlXG4gICAgICAgIC8vIGNvbnNlY3V0aXZlLiBUaGlzIGhhcHBlbnMgZm9yIGNhc2VzIGxpa2UgXCJhIDwgYlwiLlxuICAgICAgICBpZiAocHJldiAmJlxuICAgICAgICAgICAgcHJldi50eXBlID09PSAyIC8qIE5vZGVUeXBlcy5URVhUICovICYmXG4gICAgICAgICAgICBwcmV2LmxvYy5lbmQub2Zmc2V0ID09PSBub2RlLmxvYy5zdGFydC5vZmZzZXQpIHtcbiAgICAgICAgICAgIHByZXYuY29udGVudCArPSBub2RlLmNvbnRlbnQ7XG4gICAgICAgICAgICBwcmV2LmxvYy5lbmQgPSBub2RlLmxvYy5lbmQ7XG4gICAgICAgICAgICBwcmV2LmxvYy5zb3VyY2UgKz0gbm9kZS5sb2Muc291cmNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5vZGVzLnB1c2gobm9kZSk7XG59XG5mdW5jdGlvbiBwYXJzZUNEQVRBKGNvbnRleHQsIGFuY2VzdG9ycykge1xuICAgIGFkdmFuY2VCeShjb250ZXh0LCA5KTtcbiAgICBjb25zdCBub2RlcyA9IHBhcnNlQ2hpbGRyZW4oY29udGV4dCwgMyAvKiBUZXh0TW9kZXMuQ0RBVEEgKi8sIGFuY2VzdG9ycyk7XG4gICAgaWYgKGNvbnRleHQuc291cmNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgNiAvKiBFcnJvckNvZGVzLkVPRl9JTl9DREFUQSAqLyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgMyk7XG4gICAgfVxuICAgIHJldHVybiBub2Rlcztcbn1cbmZ1bmN0aW9uIHBhcnNlQ29tbWVudChjb250ZXh0KSB7XG4gICAgY29uc3Qgc3RhcnQgPSBnZXRDdXJzb3IoY29udGV4dCk7XG4gICAgbGV0IGNvbnRlbnQ7XG4gICAgLy8gUmVndWxhciBjb21tZW50LlxuICAgIGNvbnN0IG1hdGNoID0gLy0tKFxcISk/Pi8uZXhlYyhjb250ZXh0LnNvdXJjZSk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgICBjb250ZW50ID0gY29udGV4dC5zb3VyY2Uuc2xpY2UoNCk7XG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCBjb250ZXh0LnNvdXJjZS5sZW5ndGgpO1xuICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgNyAvKiBFcnJvckNvZGVzLkVPRl9JTl9DT01NRU5UICovKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChtYXRjaC5pbmRleCA8PSAzKSB7XG4gICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMCAvKiBFcnJvckNvZGVzLkFCUlVQVF9DTE9TSU5HX09GX0VNUFRZX0NPTU1FTlQgKi8pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDEwIC8qIEVycm9yQ29kZXMuSU5DT1JSRUNUTFlfQ0xPU0VEX0NPTU1FTlQgKi8pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRlbnQgPSBjb250ZXh0LnNvdXJjZS5zbGljZSg0LCBtYXRjaC5pbmRleCk7XG4gICAgICAgIC8vIEFkdmFuY2luZyB3aXRoIHJlcG9ydGluZyBuZXN0ZWQgY29tbWVudHMuXG4gICAgICAgIGNvbnN0IHMgPSBjb250ZXh0LnNvdXJjZS5zbGljZSgwLCBtYXRjaC5pbmRleCk7XG4gICAgICAgIGxldCBwcmV2SW5kZXggPSAxLCBuZXN0ZWRJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlICgobmVzdGVkSW5kZXggPSBzLmluZGV4T2YoJzwhLS0nLCBwcmV2SW5kZXgpKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCBuZXN0ZWRJbmRleCAtIHByZXZJbmRleCArIDEpO1xuICAgICAgICAgICAgaWYgKG5lc3RlZEluZGV4ICsgNCA8IHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDE2IC8qIEVycm9yQ29kZXMuTkVTVEVEX0NPTU1FTlQgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldkluZGV4ID0gbmVzdGVkSW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCAtIHByZXZJbmRleCArIDEpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAzIC8qIE5vZGVUeXBlcy5DT01NRU5UICovLFxuICAgICAgICBjb250ZW50LFxuICAgICAgICBsb2M6IGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydClcbiAgICB9O1xufVxuZnVuY3Rpb24gcGFyc2VCb2d1c0NvbW1lbnQoY29udGV4dCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xuICAgIGNvbnN0IGNvbnRlbnRTdGFydCA9IGNvbnRleHQuc291cmNlWzFdID09PSAnPycgPyAxIDogMjtcbiAgICBsZXQgY29udGVudDtcbiAgICBjb25zdCBjbG9zZUluZGV4ID0gY29udGV4dC5zb3VyY2UuaW5kZXhPZignPicpO1xuICAgIGlmIChjbG9zZUluZGV4ID09PSAtMSkge1xuICAgICAgICBjb250ZW50ID0gY29udGV4dC5zb3VyY2Uuc2xpY2UoY29udGVudFN0YXJ0KTtcbiAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIGNvbnRleHQuc291cmNlLmxlbmd0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb250ZW50ID0gY29udGV4dC5zb3VyY2Uuc2xpY2UoY29udGVudFN0YXJ0LCBjbG9zZUluZGV4KTtcbiAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIGNsb3NlSW5kZXggKyAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMyAvKiBOb2RlVHlwZXMuQ09NTUVOVCAqLyxcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgbG9jOiBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlRWxlbWVudChjb250ZXh0LCBhbmNlc3RvcnMpIHtcbiAgICAvLyBTdGFydCB0YWcuXG4gICAgY29uc3Qgd2FzSW5QcmUgPSBjb250ZXh0LmluUHJlO1xuICAgIGNvbnN0IHdhc0luVlByZSA9IGNvbnRleHQuaW5WUHJlO1xuICAgIGNvbnN0IHBhcmVudCA9IGxhc3QoYW5jZXN0b3JzKTtcbiAgICBjb25zdCBlbGVtZW50ID0gcGFyc2VUYWcoY29udGV4dCwgMCAvKiBUYWdUeXBlLlN0YXJ0ICovLCBwYXJlbnQpO1xuICAgIGNvbnN0IGlzUHJlQm91bmRhcnkgPSBjb250ZXh0LmluUHJlICYmICF3YXNJblByZTtcbiAgICBjb25zdCBpc1ZQcmVCb3VuZGFyeSA9IGNvbnRleHQuaW5WUHJlICYmICF3YXNJblZQcmU7XG4gICAgaWYgKGVsZW1lbnQuaXNTZWxmQ2xvc2luZyB8fCBjb250ZXh0Lm9wdGlvbnMuaXNWb2lkVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgICAvLyAjNDAzMCBzZWxmLWNsb3NpbmcgPHByZT4gdGFnXG4gICAgICAgIGlmIChpc1ByZUJvdW5kYXJ5KSB7XG4gICAgICAgICAgICBjb250ZXh0LmluUHJlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVlByZUJvdW5kYXJ5KSB7XG4gICAgICAgICAgICBjb250ZXh0LmluVlByZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgICAvLyBDaGlsZHJlbi5cbiAgICBhbmNlc3RvcnMucHVzaChlbGVtZW50KTtcbiAgICBjb25zdCBtb2RlID0gY29udGV4dC5vcHRpb25zLmdldFRleHRNb2RlKGVsZW1lbnQsIHBhcmVudCk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBwYXJzZUNoaWxkcmVuKGNvbnRleHQsIG1vZGUsIGFuY2VzdG9ycyk7XG4gICAgYW5jZXN0b3JzLnBvcCgpO1xuICAgIC8vIDIueCBpbmxpbmUtdGVtcGxhdGUgY29tcGF0XG4gICAge1xuICAgICAgICBjb25zdCBpbmxpbmVUZW1wbGF0ZVByb3AgPSBlbGVtZW50LnByb3BzLmZpbmQocCA9PiBwLnR5cGUgPT09IDYgLyogTm9kZVR5cGVzLkFUVFJJQlVURSAqLyAmJiBwLm5hbWUgPT09ICdpbmxpbmUtdGVtcGxhdGUnKTtcbiAgICAgICAgaWYgKGlubGluZVRlbXBsYXRlUHJvcCAmJlxuICAgICAgICAgICAgY2hlY2tDb21wYXRFbmFibGVkKFwiQ09NUElMRVJfSU5MSU5FX1RFTVBMQVRFXCIgLyogQ29tcGlsZXJEZXByZWNhdGlvblR5cGVzLkNPTVBJTEVSX0lOTElORV9URU1QTEFURSAqLywgY29udGV4dCwgaW5saW5lVGVtcGxhdGVQcm9wLmxvYykpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvYyA9IGdldFNlbGVjdGlvbihjb250ZXh0LCBlbGVtZW50LmxvYy5lbmQpO1xuICAgICAgICAgICAgaW5saW5lVGVtcGxhdGVQcm9wLnZhbHVlID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IDIgLyogTm9kZVR5cGVzLlRFWFQgKi8sXG4gICAgICAgICAgICAgICAgY29udGVudDogbG9jLnNvdXJjZSxcbiAgICAgICAgICAgICAgICBsb2NcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxlbWVudC5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIC8vIEVuZCB0YWcuXG4gICAgaWYgKHN0YXJ0c1dpdGhFbmRUYWdPcGVuKGNvbnRleHQuc291cmNlLCBlbGVtZW50LnRhZykpIHtcbiAgICAgICAgcGFyc2VUYWcoY29udGV4dCwgMSAvKiBUYWdUeXBlLkVuZCAqLywgcGFyZW50KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAyNCAvKiBFcnJvckNvZGVzLlhfTUlTU0lOR19FTkRfVEFHICovLCAwLCBlbGVtZW50LmxvYy5zdGFydCk7XG4gICAgICAgIGlmIChjb250ZXh0LnNvdXJjZS5sZW5ndGggPT09IDAgJiYgZWxlbWVudC50YWcudG9Mb3dlckNhc2UoKSA9PT0gJ3NjcmlwdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gY2hpbGRyZW5bMF07XG4gICAgICAgICAgICBpZiAoZmlyc3QgJiYgc3RhcnRzV2l0aChmaXJzdC5sb2Muc291cmNlLCAnPCEtLScpKSB7XG4gICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDggLyogRXJyb3JDb2Rlcy5FT0ZfSU5fU0NSSVBUX0hUTUxfQ09NTUVOVF9MSUtFX1RFWFQgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsZW1lbnQubG9jID0gZ2V0U2VsZWN0aW9uKGNvbnRleHQsIGVsZW1lbnQubG9jLnN0YXJ0KTtcbiAgICBpZiAoaXNQcmVCb3VuZGFyeSkge1xuICAgICAgICBjb250ZXh0LmluUHJlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpc1ZQcmVCb3VuZGFyeSkge1xuICAgICAgICBjb250ZXh0LmluVlByZSA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbn1cbmNvbnN0IGlzU3BlY2lhbFRlbXBsYXRlRGlyZWN0aXZlID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGBpZixlbHNlLGVsc2UtaWYsZm9yLHNsb3RgKTtcbmZ1bmN0aW9uIHBhcnNlVGFnKGNvbnRleHQsIHR5cGUsIHBhcmVudCkge1xuICAgIC8vIFRhZyBvcGVuLlxuICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xuICAgIGNvbnN0IG1hdGNoID0gL148XFwvPyhbYS16XVteXFx0XFxyXFxuXFxmIC8+XSopL2kuZXhlYyhjb250ZXh0LnNvdXJjZSk7XG4gICAgY29uc3QgdGFnID0gbWF0Y2hbMV07XG4gICAgY29uc3QgbnMgPSBjb250ZXh0Lm9wdGlvbnMuZ2V0TmFtZXNwYWNlKHRhZywgcGFyZW50KTtcbiAgICBhZHZhbmNlQnkoY29udGV4dCwgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICBhZHZhbmNlU3BhY2VzKGNvbnRleHQpO1xuICAgIC8vIHNhdmUgY3VycmVudCBzdGF0ZSBpbiBjYXNlIHdlIG5lZWQgdG8gcmUtcGFyc2UgYXR0cmlidXRlcyB3aXRoIHYtcHJlXG4gICAgY29uc3QgY3Vyc29yID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xuICAgIGNvbnN0IGN1cnJlbnRTb3VyY2UgPSBjb250ZXh0LnNvdXJjZTtcbiAgICAvLyBjaGVjayA8cHJlPiB0YWdcbiAgICBpZiAoY29udGV4dC5vcHRpb25zLmlzUHJlVGFnKHRhZykpIHtcbiAgICAgICAgY29udGV4dC5pblByZSA9IHRydWU7XG4gICAgfVxuICAgIC8vIEF0dHJpYnV0ZXMuXG4gICAgbGV0IHByb3BzID0gcGFyc2VBdHRyaWJ1dGVzKGNvbnRleHQsIHR5cGUpO1xuICAgIC8vIGNoZWNrIHYtcHJlXG4gICAgaWYgKHR5cGUgPT09IDAgLyogVGFnVHlwZS5TdGFydCAqLyAmJlxuICAgICAgICAhY29udGV4dC5pblZQcmUgJiZcbiAgICAgICAgcHJvcHMuc29tZShwID0+IHAudHlwZSA9PT0gNyAvKiBOb2RlVHlwZXMuRElSRUNUSVZFICovICYmIHAubmFtZSA9PT0gJ3ByZScpKSB7XG4gICAgICAgIGNvbnRleHQuaW5WUHJlID0gdHJ1ZTtcbiAgICAgICAgLy8gcmVzZXQgY29udGV4dFxuICAgICAgICBleHRlbmQoY29udGV4dCwgY3Vyc29yKTtcbiAgICAgICAgY29udGV4dC5zb3VyY2UgPSBjdXJyZW50U291cmNlO1xuICAgICAgICAvLyByZS1wYXJzZSBhdHRycyBhbmQgZmlsdGVyIG91dCB2LXByZSBpdHNlbGZcbiAgICAgICAgcHJvcHMgPSBwYXJzZUF0dHJpYnV0ZXMoY29udGV4dCwgdHlwZSkuZmlsdGVyKHAgPT4gcC5uYW1lICE9PSAndi1wcmUnKTtcbiAgICB9XG4gICAgLy8gVGFnIGNsb3NlLlxuICAgIGxldCBpc1NlbGZDbG9zaW5nID0gZmFsc2U7XG4gICAgaWYgKGNvbnRleHQuc291cmNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgOSAvKiBFcnJvckNvZGVzLkVPRl9JTl9UQUcgKi8pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaXNTZWxmQ2xvc2luZyA9IHN0YXJ0c1dpdGgoY29udGV4dC5zb3VyY2UsICcvPicpO1xuICAgICAgICBpZiAodHlwZSA9PT0gMSAvKiBUYWdUeXBlLkVuZCAqLyAmJiBpc1NlbGZDbG9zaW5nKSB7XG4gICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgNCAvKiBFcnJvckNvZGVzLkVORF9UQUdfV0lUSF9UUkFJTElOR19TT0xJRFVTICovKTtcbiAgICAgICAgfVxuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgaXNTZWxmQ2xvc2luZyA/IDIgOiAxKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IDEgLyogVGFnVHlwZS5FbmQgKi8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyAyLnggZGVwcmVjYXRpb24gY2hlY2tzXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICBpc0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9WX0lGX1ZfRk9SX1BSRUNFREVOQ0VcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfVl9JRl9WX0ZPUl9QUkVDRURFTkNFICovLCBjb250ZXh0KSkge1xuICAgICAgICBsZXQgaGFzSWYgPSBmYWxzZTtcbiAgICAgICAgbGV0IGhhc0ZvciA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gcHJvcHNbaV07XG4gICAgICAgICAgICBpZiAocC50eXBlID09PSA3IC8qIE5vZGVUeXBlcy5ESVJFQ1RJVkUgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAocC5uYW1lID09PSAnaWYnKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc0lmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocC5uYW1lID09PSAnZm9yJykge1xuICAgICAgICAgICAgICAgICAgICBoYXNGb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNJZiAmJiBoYXNGb3IpIHtcbiAgICAgICAgICAgICAgICB3YXJuRGVwcmVjYXRpb24oXCJDT01QSUxFUl9WX0lGX1ZfRk9SX1BSRUNFREVOQ0VcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfVl9JRl9WX0ZPUl9QUkVDRURFTkNFICovLCBjb250ZXh0LCBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgdGFnVHlwZSA9IDAgLyogRWxlbWVudFR5cGVzLkVMRU1FTlQgKi87XG4gICAgaWYgKCFjb250ZXh0LmluVlByZSkge1xuICAgICAgICBpZiAodGFnID09PSAnc2xvdCcpIHtcbiAgICAgICAgICAgIHRhZ1R5cGUgPSAyIC8qIEVsZW1lbnRUeXBlcy5TTE9UICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICAgICAgaWYgKHByb3BzLnNvbWUocCA9PiBwLnR5cGUgPT09IDcgLyogTm9kZVR5cGVzLkRJUkVDVElWRSAqLyAmJiBpc1NwZWNpYWxUZW1wbGF0ZURpcmVjdGl2ZShwLm5hbWUpKSkge1xuICAgICAgICAgICAgICAgIHRhZ1R5cGUgPSAzIC8qIEVsZW1lbnRUeXBlcy5URU1QTEFURSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0NvbXBvbmVudCh0YWcsIHByb3BzLCBjb250ZXh0KSkge1xuICAgICAgICAgICAgdGFnVHlwZSA9IDEgLyogRWxlbWVudFR5cGVzLkNPTVBPTkVOVCAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAxIC8qIE5vZGVUeXBlcy5FTEVNRU5UICovLFxuICAgICAgICBucyxcbiAgICAgICAgdGFnLFxuICAgICAgICB0YWdUeXBlLFxuICAgICAgICBwcm9wcyxcbiAgICAgICAgaXNTZWxmQ2xvc2luZyxcbiAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICBsb2M6IGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydCksXG4gICAgICAgIGNvZGVnZW5Ob2RlOiB1bmRlZmluZWQgLy8gdG8gYmUgY3JlYXRlZCBkdXJpbmcgdHJhbnNmb3JtIHBoYXNlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGlzQ29tcG9uZW50KHRhZywgcHJvcHMsIGNvbnRleHQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gY29udGV4dC5vcHRpb25zO1xuICAgIGlmIChvcHRpb25zLmlzQ3VzdG9tRWxlbWVudCh0YWcpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2NvbXBvbmVudCcgfHxcbiAgICAgICAgL15bQS1aXS8udGVzdCh0YWcpIHx8XG4gICAgICAgIGlzQ29yZUNvbXBvbmVudCh0YWcpIHx8XG4gICAgICAgIChvcHRpb25zLmlzQnVpbHRJbkNvbXBvbmVudCAmJiBvcHRpb25zLmlzQnVpbHRJbkNvbXBvbmVudCh0YWcpKSB8fFxuICAgICAgICAob3B0aW9ucy5pc05hdGl2ZVRhZyAmJiAhb3B0aW9ucy5pc05hdGl2ZVRhZyh0YWcpKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gYXQgdGhpcyBwb2ludCB0aGUgdGFnIHNob3VsZCBiZSBhIG5hdGl2ZSB0YWcsIGJ1dCBjaGVjayBmb3IgcG90ZW50aWFsIFwiaXNcIlxuICAgIC8vIGNhc3RpbmdcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHAgPSBwcm9wc1tpXTtcbiAgICAgICAgaWYgKHAudHlwZSA9PT0gNiAvKiBOb2RlVHlwZXMuQVRUUklCVVRFICovKSB7XG4gICAgICAgICAgICBpZiAocC5uYW1lID09PSAnaXMnICYmIHAudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAocC52YWx1ZS5jb250ZW50LnN0YXJ0c1dpdGgoJ3Z1ZTonKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2tDb21wYXRFbmFibGVkKFwiQ09NUElMRVJfSVNfT05fRUxFTUVOVFwiIC8qIENvbXBpbGVyRGVwcmVjYXRpb25UeXBlcy5DT01QSUxFUl9JU19PTl9FTEVNRU5UICovLCBjb250ZXh0LCBwLmxvYykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZGlyZWN0aXZlXG4gICAgICAgICAgICAvLyB2LWlzIChUT0RPIERlcHJlY2F0ZSlcbiAgICAgICAgICAgIGlmIChwLm5hbWUgPT09ICdpcycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICAgLy8gOmlzIG9uIHBsYWluIGVsZW1lbnQgLSBvbmx5IHRyZWF0IGFzIGNvbXBvbmVudCBpbiBjb21wYXQgbW9kZVxuICAgICAgICAgICAgcC5uYW1lID09PSAnYmluZCcgJiZcbiAgICAgICAgICAgICAgICBpc1N0YXRpY0FyZ09mKHAuYXJnLCAnaXMnKSAmJlxuICAgICAgICAgICAgICAgIHRydWUgJiZcbiAgICAgICAgICAgICAgICBjaGVja0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9JU19PTl9FTEVNRU5UXCIgLyogQ29tcGlsZXJEZXByZWNhdGlvblR5cGVzLkNPTVBJTEVSX0lTX09OX0VMRU1FTlQgKi8sIGNvbnRleHQsIHAubG9jKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VBdHRyaWJ1dGVzKGNvbnRleHQsIHR5cGUpIHtcbiAgICBjb25zdCBwcm9wcyA9IFtdO1xuICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgIHdoaWxlIChjb250ZXh0LnNvdXJjZS5sZW5ndGggPiAwICYmXG4gICAgICAgICFzdGFydHNXaXRoKGNvbnRleHQuc291cmNlLCAnPicpICYmXG4gICAgICAgICFzdGFydHNXaXRoKGNvbnRleHQuc291cmNlLCAnLz4nKSkge1xuICAgICAgICBpZiAoc3RhcnRzV2l0aChjb250ZXh0LnNvdXJjZSwgJy8nKSkge1xuICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDIyIC8qIEVycm9yQ29kZXMuVU5FWFBFQ1RFRF9TT0xJRFVTX0lOX1RBRyAqLyk7XG4gICAgICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgMSk7XG4gICAgICAgICAgICBhZHZhbmNlU3BhY2VzKGNvbnRleHQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IDEgLyogVGFnVHlwZS5FbmQgKi8pIHtcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAzIC8qIEVycm9yQ29kZXMuRU5EX1RBR19XSVRIX0FUVFJJQlVURVMgKi8pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF0dHIgPSBwYXJzZUF0dHJpYnV0ZShjb250ZXh0LCBhdHRyaWJ1dGVOYW1lcyk7XG4gICAgICAgIC8vIFRyaW0gd2hpdGVzcGFjZSBiZXR3ZWVuIGNsYXNzXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy9jb3JlL2lzc3Vlcy80MjUxXG4gICAgICAgIGlmIChhdHRyLnR5cGUgPT09IDYgLyogTm9kZVR5cGVzLkFUVFJJQlVURSAqLyAmJlxuICAgICAgICAgICAgYXR0ci52YWx1ZSAmJlxuICAgICAgICAgICAgYXR0ci5uYW1lID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgICBhdHRyLnZhbHVlLmNvbnRlbnQgPSBhdHRyLnZhbHVlLmNvbnRlbnQucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gMCAvKiBUYWdUeXBlLlN0YXJ0ICovKSB7XG4gICAgICAgICAgICBwcm9wcy5wdXNoKGF0dHIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgvXlteXFx0XFxyXFxuXFxmIC8+XS8udGVzdChjb250ZXh0LnNvdXJjZSkpIHtcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxNSAvKiBFcnJvckNvZGVzLk1JU1NJTkdfV0hJVEVTUEFDRV9CRVRXRUVOX0FUVFJJQlVURVMgKi8pO1xuICAgICAgICB9XG4gICAgICAgIGFkdmFuY2VTcGFjZXMoY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBwcm9wcztcbn1cbmZ1bmN0aW9uIHBhcnNlQXR0cmlidXRlKGNvbnRleHQsIG5hbWVTZXQpIHtcbiAgICAvLyBOYW1lLlxuICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xuICAgIGNvbnN0IG1hdGNoID0gL15bXlxcdFxcclxcblxcZiAvPl1bXlxcdFxcclxcblxcZiAvPj1dKi8uZXhlYyhjb250ZXh0LnNvdXJjZSk7XG4gICAgY29uc3QgbmFtZSA9IG1hdGNoWzBdO1xuICAgIGlmIChuYW1lU2V0LmhhcyhuYW1lKSkge1xuICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMiAvKiBFcnJvckNvZGVzLkRVUExJQ0FURV9BVFRSSUJVVEUgKi8pO1xuICAgIH1cbiAgICBuYW1lU2V0LmFkZChuYW1lKTtcbiAgICBpZiAobmFtZVswXSA9PT0gJz0nKSB7XG4gICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxOSAvKiBFcnJvckNvZGVzLlVORVhQRUNURURfRVFVQUxTX1NJR05fQkVGT1JFX0FUVFJJQlVURV9OQU1FICovKTtcbiAgICB9XG4gICAge1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gL1tcIic8XS9nO1xuICAgICAgICBsZXQgbTtcbiAgICAgICAgd2hpbGUgKChtID0gcGF0dGVybi5leGVjKG5hbWUpKSkge1xuICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDE3IC8qIEVycm9yQ29kZXMuVU5FWFBFQ1RFRF9DSEFSQUNURVJfSU5fQVRUUklCVVRFX05BTUUgKi8sIG0uaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkdmFuY2VCeShjb250ZXh0LCBuYW1lLmxlbmd0aCk7XG4gICAgLy8gVmFsdWVcbiAgICBsZXQgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgaWYgKC9eW1xcdFxcclxcblxcZiBdKj0vLnRlc3QoY29udGV4dC5zb3VyY2UpKSB7XG4gICAgICAgIGFkdmFuY2VTcGFjZXMoY29udGV4dCk7XG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCAxKTtcbiAgICAgICAgYWR2YW5jZVNwYWNlcyhjb250ZXh0KTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUF0dHJpYnV0ZVZhbHVlKGNvbnRleHQpO1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTMgLyogRXJyb3JDb2Rlcy5NSVNTSU5HX0FUVFJJQlVURV9WQUxVRSAqLyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbG9jID0gZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0KTtcbiAgICBpZiAoIWNvbnRleHQuaW5WUHJlICYmIC9eKHYtW0EtWmEtejAtOS1dfDp8XFwufEB8IykvLnRlc3QobmFtZSkpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSAvKD86XnYtKFthLXowLTktXSspKT8oPzooPzo6fF5cXC58XkB8XiMpKFxcW1teXFxdXStcXF18W15cXC5dKykpPyguKyk/JC9pLmV4ZWMobmFtZSk7XG4gICAgICAgIGxldCBpc1Byb3BTaG9ydGhhbmQgPSBzdGFydHNXaXRoKG5hbWUsICcuJyk7XG4gICAgICAgIGxldCBkaXJOYW1lID0gbWF0Y2hbMV0gfHxcbiAgICAgICAgICAgIChpc1Byb3BTaG9ydGhhbmQgfHwgc3RhcnRzV2l0aChuYW1lLCAnOicpXG4gICAgICAgICAgICAgICAgPyAnYmluZCdcbiAgICAgICAgICAgICAgICA6IHN0YXJ0c1dpdGgobmFtZSwgJ0AnKVxuICAgICAgICAgICAgICAgICAgICA/ICdvbidcbiAgICAgICAgICAgICAgICAgICAgOiAnc2xvdCcpO1xuICAgICAgICBsZXQgYXJnO1xuICAgICAgICBpZiAobWF0Y2hbMl0pIHtcbiAgICAgICAgICAgIGNvbnN0IGlzU2xvdCA9IGRpck5hbWUgPT09ICdzbG90JztcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gbmFtZS5sYXN0SW5kZXhPZihtYXRjaFsyXSk7XG4gICAgICAgICAgICBjb25zdCBsb2MgPSBnZXRTZWxlY3Rpb24oY29udGV4dCwgZ2V0TmV3UG9zaXRpb24oY29udGV4dCwgc3RhcnQsIHN0YXJ0T2Zmc2V0KSwgZ2V0TmV3UG9zaXRpb24oY29udGV4dCwgc3RhcnQsIHN0YXJ0T2Zmc2V0ICsgbWF0Y2hbMl0ubGVuZ3RoICsgKChpc1Nsb3QgJiYgbWF0Y2hbM10pIHx8ICcnKS5sZW5ndGgpKTtcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gbWF0Y2hbMl07XG4gICAgICAgICAgICBsZXQgaXNTdGF0aWMgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGNvbnRlbnQuc3RhcnRzV2l0aCgnWycpKSB7XG4gICAgICAgICAgICAgICAgaXNTdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRlbnQuZW5kc1dpdGgoJ10nKSkge1xuICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMjcgLyogRXJyb3JDb2Rlcy5YX01JU1NJTkdfRFlOQU1JQ19ESVJFQ1RJVkVfQVJHVU1FTlRfRU5EICovKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5zbGljZSgxLCBjb250ZW50Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzU2xvdCkge1xuICAgICAgICAgICAgICAgIC8vICMxMjQxIHNwZWNpYWwgY2FzZSBmb3Igdi1zbG90OiB2dWV0aWZ5IHJlbGllcyBleHRlbnNpdmVseSBvbiBzbG90XG4gICAgICAgICAgICAgICAgLy8gbmFtZXMgY29udGFpbmluZyBkb3RzLiB2LXNsb3QgZG9lc24ndCBoYXZlIGFueSBtb2RpZmllcnMgYW5kIFZ1ZSAyLnhcbiAgICAgICAgICAgICAgICAvLyBzdXBwb3J0cyBzdWNoIHVzYWdlIHNvIHdlIGFyZSBrZWVwaW5nIGl0IGNvbnNpc3RlbnQgd2l0aCAyLnguXG4gICAgICAgICAgICAgICAgY29udGVudCArPSBtYXRjaFszXSB8fCAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFyZyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLyxcbiAgICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgICAgIGlzU3RhdGljLFxuICAgICAgICAgICAgICAgIGNvbnN0VHlwZTogaXNTdGF0aWNcbiAgICAgICAgICAgICAgICAgICAgPyAzIC8qIENvbnN0YW50VHlwZXMuQ0FOX1NUUklOR0lGWSAqL1xuICAgICAgICAgICAgICAgICAgICA6IDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi8sXG4gICAgICAgICAgICAgICAgbG9jXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5pc1F1b3RlZCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVMb2MgPSB2YWx1ZS5sb2M7XG4gICAgICAgICAgICB2YWx1ZUxvYy5zdGFydC5vZmZzZXQrKztcbiAgICAgICAgICAgIHZhbHVlTG9jLnN0YXJ0LmNvbHVtbisrO1xuICAgICAgICAgICAgdmFsdWVMb2MuZW5kID0gYWR2YW5jZVBvc2l0aW9uV2l0aENsb25lKHZhbHVlTG9jLnN0YXJ0LCB2YWx1ZS5jb250ZW50KTtcbiAgICAgICAgICAgIHZhbHVlTG9jLnNvdXJjZSA9IHZhbHVlTG9jLnNvdXJjZS5zbGljZSgxLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kaWZpZXJzID0gbWF0Y2hbM10gPyBtYXRjaFszXS5zbGljZSgxKS5zcGxpdCgnLicpIDogW107XG4gICAgICAgIGlmIChpc1Byb3BTaG9ydGhhbmQpXG4gICAgICAgICAgICBtb2RpZmllcnMucHVzaCgncHJvcCcpO1xuICAgICAgICAvLyAyLnggY29tcGF0IHYtYmluZDpmb28uc3luYyAtPiB2LW1vZGVsOmZvb1xuICAgICAgICBpZiAoZGlyTmFtZSA9PT0gJ2JpbmQnICYmIGFyZykge1xuICAgICAgICAgICAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcygnc3luYycpICYmXG4gICAgICAgICAgICAgICAgY2hlY2tDb21wYXRFbmFibGVkKFwiQ09NUElMRVJfVl9CSU5EX1NZTkNcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfVl9CSU5EX1NZTkMgKi8sIGNvbnRleHQsIGxvYywgYXJnLmxvYy5zb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgZGlyTmFtZSA9ICdtb2RlbCc7XG4gICAgICAgICAgICAgICAgbW9kaWZpZXJzLnNwbGljZShtb2RpZmllcnMuaW5kZXhPZignc3luYycpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgbW9kaWZpZXJzLmluY2x1ZGVzKCdwcm9wJykpIHtcbiAgICAgICAgICAgICAgICBjaGVja0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9WX0JJTkRfUFJPUFwiIC8qIENvbXBpbGVyRGVwcmVjYXRpb25UeXBlcy5DT01QSUxFUl9WX0JJTkRfUFJPUCAqLywgY29udGV4dCwgbG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogNyAvKiBOb2RlVHlwZXMuRElSRUNUSVZFICovLFxuICAgICAgICAgICAgbmFtZTogZGlyTmFtZSxcbiAgICAgICAgICAgIGV4cDogdmFsdWUgJiYge1xuICAgICAgICAgICAgICAgIHR5cGU6IDQgLyogTm9kZVR5cGVzLlNJTVBMRV9FWFBSRVNTSU9OICovLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHZhbHVlLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgaXNTdGF0aWM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIC8vIFRyZWF0IGFzIG5vbi1jb25zdGFudCBieSBkZWZhdWx0LiBUaGlzIGNhbiBiZSBwb3RlbnRpYWxseSBzZXQgdG9cbiAgICAgICAgICAgICAgICAvLyBvdGhlciB2YWx1ZXMgYnkgYHRyYW5zZm9ybUV4cHJlc3Npb25gIHRvIG1ha2UgaXQgZWxpZ2libGUgZm9yIGhvaXN0aW5nLlxuICAgICAgICAgICAgICAgIGNvbnN0VHlwZTogMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLyxcbiAgICAgICAgICAgICAgICBsb2M6IHZhbHVlLmxvY1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZyxcbiAgICAgICAgICAgIG1vZGlmaWVycyxcbiAgICAgICAgICAgIGxvY1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBtaXNzaW5nIGRpcmVjdGl2ZSBuYW1lIG9yIGlsbGVnYWwgZGlyZWN0aXZlIG5hbWVcbiAgICBpZiAoIWNvbnRleHQuaW5WUHJlICYmIHN0YXJ0c1dpdGgobmFtZSwgJ3YtJykpIHtcbiAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDI2IC8qIEVycm9yQ29kZXMuWF9NSVNTSU5HX0RJUkVDVElWRV9OQU1FICovKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogNiAvKiBOb2RlVHlwZXMuQVRUUklCVVRFICovLFxuICAgICAgICBuYW1lLFxuICAgICAgICB2YWx1ZTogdmFsdWUgJiYge1xuICAgICAgICAgICAgdHlwZTogMiAvKiBOb2RlVHlwZXMuVEVYVCAqLyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHZhbHVlLmNvbnRlbnQsXG4gICAgICAgICAgICBsb2M6IHZhbHVlLmxvY1xuICAgICAgICB9LFxuICAgICAgICBsb2NcbiAgICB9O1xufVxuZnVuY3Rpb24gcGFyc2VBdHRyaWJ1dGVWYWx1ZShjb250ZXh0KSB7XG4gICAgY29uc3Qgc3RhcnQgPSBnZXRDdXJzb3IoY29udGV4dCk7XG4gICAgbGV0IGNvbnRlbnQ7XG4gICAgY29uc3QgcXVvdGUgPSBjb250ZXh0LnNvdXJjZVswXTtcbiAgICBjb25zdCBpc1F1b3RlZCA9IHF1b3RlID09PSBgXCJgIHx8IHF1b3RlID09PSBgJ2A7XG4gICAgaWYgKGlzUXVvdGVkKSB7XG4gICAgICAgIC8vIFF1b3RlZCB2YWx1ZS5cbiAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIDEpO1xuICAgICAgICBjb25zdCBlbmRJbmRleCA9IGNvbnRleHQuc291cmNlLmluZGV4T2YocXVvdGUpO1xuICAgICAgICBpZiAoZW5kSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gcGFyc2VUZXh0RGF0YShjb250ZXh0LCBjb250ZXh0LnNvdXJjZS5sZW5ndGgsIDQgLyogVGV4dE1vZGVzLkFUVFJJQlVURV9WQUxVRSAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb250ZW50ID0gcGFyc2VUZXh0RGF0YShjb250ZXh0LCBlbmRJbmRleCwgNCAvKiBUZXh0TW9kZXMuQVRUUklCVVRFX1ZBTFVFICovKTtcbiAgICAgICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gVW5xdW90ZWRcbiAgICAgICAgY29uc3QgbWF0Y2ggPSAvXlteXFx0XFxyXFxuXFxmID5dKy8uZXhlYyhjb250ZXh0LnNvdXJjZSk7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdW5leHBlY3RlZENoYXJzID0gL1tcIic8PWBdL2c7XG4gICAgICAgIGxldCBtO1xuICAgICAgICB3aGlsZSAoKG0gPSB1bmV4cGVjdGVkQ2hhcnMuZXhlYyhtYXRjaFswXSkpKSB7XG4gICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTggLyogRXJyb3JDb2Rlcy5VTkVYUEVDVEVEX0NIQVJBQ1RFUl9JTl9VTlFVT1RFRF9BVFRSSUJVVEVfVkFMVUUgKi8sIG0uaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRlbnQgPSBwYXJzZVRleHREYXRhKGNvbnRleHQsIG1hdGNoWzBdLmxlbmd0aCwgNCAvKiBUZXh0TW9kZXMuQVRUUklCVVRFX1ZBTFVFICovKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY29udGVudCwgaXNRdW90ZWQsIGxvYzogZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0KSB9O1xufVxuZnVuY3Rpb24gcGFyc2VJbnRlcnBvbGF0aW9uKGNvbnRleHQsIG1vZGUpIHtcbiAgICBjb25zdCBbb3BlbiwgY2xvc2VdID0gY29udGV4dC5vcHRpb25zLmRlbGltaXRlcnM7XG4gICAgY29uc3QgY2xvc2VJbmRleCA9IGNvbnRleHQuc291cmNlLmluZGV4T2YoY2xvc2UsIG9wZW4ubGVuZ3RoKTtcbiAgICBpZiAoY2xvc2VJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDI1IC8qIEVycm9yQ29kZXMuWF9NSVNTSU5HX0lOVEVSUE9MQVRJT05fRU5EICovKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnQgPSBnZXRDdXJzb3IoY29udGV4dCk7XG4gICAgYWR2YW5jZUJ5KGNvbnRleHQsIG9wZW4ubGVuZ3RoKTtcbiAgICBjb25zdCBpbm5lclN0YXJ0ID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xuICAgIGNvbnN0IGlubmVyRW5kID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xuICAgIGNvbnN0IHJhd0NvbnRlbnRMZW5ndGggPSBjbG9zZUluZGV4IC0gb3Blbi5sZW5ndGg7XG4gICAgY29uc3QgcmF3Q29udGVudCA9IGNvbnRleHQuc291cmNlLnNsaWNlKDAsIHJhd0NvbnRlbnRMZW5ndGgpO1xuICAgIGNvbnN0IHByZVRyaW1Db250ZW50ID0gcGFyc2VUZXh0RGF0YShjb250ZXh0LCByYXdDb250ZW50TGVuZ3RoLCBtb2RlKTtcbiAgICBjb25zdCBjb250ZW50ID0gcHJlVHJpbUNvbnRlbnQudHJpbSgpO1xuICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gcHJlVHJpbUNvbnRlbnQuaW5kZXhPZihjb250ZW50KTtcbiAgICBpZiAoc3RhcnRPZmZzZXQgPiAwKSB7XG4gICAgICAgIGFkdmFuY2VQb3NpdGlvbldpdGhNdXRhdGlvbihpbm5lclN0YXJ0LCByYXdDb250ZW50LCBzdGFydE9mZnNldCk7XG4gICAgfVxuICAgIGNvbnN0IGVuZE9mZnNldCA9IHJhd0NvbnRlbnRMZW5ndGggLSAocHJlVHJpbUNvbnRlbnQubGVuZ3RoIC0gY29udGVudC5sZW5ndGggLSBzdGFydE9mZnNldCk7XG4gICAgYWR2YW5jZVBvc2l0aW9uV2l0aE11dGF0aW9uKGlubmVyRW5kLCByYXdDb250ZW50LCBlbmRPZmZzZXQpO1xuICAgIGFkdmFuY2VCeShjb250ZXh0LCBjbG9zZS5sZW5ndGgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDUgLyogTm9kZVR5cGVzLklOVEVSUE9MQVRJT04gKi8sXG4gICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgIHR5cGU6IDQgLyogTm9kZVR5cGVzLlNJTVBMRV9FWFBSRVNTSU9OICovLFxuICAgICAgICAgICAgaXNTdGF0aWM6IGZhbHNlLFxuICAgICAgICAgICAgLy8gU2V0IGBpc0NvbnN0YW50YCB0byBmYWxzZSBieSBkZWZhdWx0IGFuZCB3aWxsIGRlY2lkZSBpbiB0cmFuc2Zvcm1FeHByZXNzaW9uXG4gICAgICAgICAgICBjb25zdFR5cGU6IDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi8sXG4gICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgbG9jOiBnZXRTZWxlY3Rpb24oY29udGV4dCwgaW5uZXJTdGFydCwgaW5uZXJFbmQpXG4gICAgICAgIH0sXG4gICAgICAgIGxvYzogZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0KVxuICAgIH07XG59XG5mdW5jdGlvbiBwYXJzZVRleHQoY29udGV4dCwgbW9kZSkge1xuICAgIGNvbnN0IGVuZFRva2VucyA9IG1vZGUgPT09IDMgLyogVGV4dE1vZGVzLkNEQVRBICovID8gWyddXT4nXSA6IFsnPCcsIGNvbnRleHQub3B0aW9ucy5kZWxpbWl0ZXJzWzBdXTtcbiAgICBsZXQgZW5kSW5kZXggPSBjb250ZXh0LnNvdXJjZS5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmRUb2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBjb250ZXh0LnNvdXJjZS5pbmRleE9mKGVuZFRva2Vuc1tpXSwgMSk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEgJiYgZW5kSW5kZXggPiBpbmRleCkge1xuICAgICAgICAgICAgZW5kSW5kZXggPSBpbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcbiAgICBjb25zdCBjb250ZW50ID0gcGFyc2VUZXh0RGF0YShjb250ZXh0LCBlbmRJbmRleCwgbW9kZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMiAvKiBOb2RlVHlwZXMuVEVYVCAqLyxcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgbG9jOiBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQpXG4gICAgfTtcbn1cbi8qKlxuICogR2V0IHRleHQgZGF0YSB3aXRoIGEgZ2l2ZW4gbGVuZ3RoIGZyb20gdGhlIGN1cnJlbnQgbG9jYXRpb24uXG4gKiBUaGlzIHRyYW5zbGF0ZXMgSFRNTCBlbnRpdGllcyBpbiB0aGUgdGV4dCBkYXRhLlxuICovXG5mdW5jdGlvbiBwYXJzZVRleHREYXRhKGNvbnRleHQsIGxlbmd0aCwgbW9kZSkge1xuICAgIGNvbnN0IHJhd1RleHQgPSBjb250ZXh0LnNvdXJjZS5zbGljZSgwLCBsZW5ndGgpO1xuICAgIGFkdmFuY2VCeShjb250ZXh0LCBsZW5ndGgpO1xuICAgIGlmIChtb2RlID09PSAyIC8qIFRleHRNb2Rlcy5SQVdURVhUICovIHx8XG4gICAgICAgIG1vZGUgPT09IDMgLyogVGV4dE1vZGVzLkNEQVRBICovIHx8XG4gICAgICAgICFyYXdUZXh0LmluY2x1ZGVzKCcmJykpIHtcbiAgICAgICAgcmV0dXJuIHJhd1RleHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBEQVRBIG9yIFJDREFUQSBjb250YWluaW5nIFwiJlwiXCIuIEVudGl0eSBkZWNvZGluZyByZXF1aXJlZC5cbiAgICAgICAgcmV0dXJuIGNvbnRleHQub3B0aW9ucy5kZWNvZGVFbnRpdGllcyhyYXdUZXh0LCBtb2RlID09PSA0IC8qIFRleHRNb2Rlcy5BVFRSSUJVVEVfVkFMVUUgKi8pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEN1cnNvcihjb250ZXh0KSB7XG4gICAgY29uc3QgeyBjb2x1bW4sIGxpbmUsIG9mZnNldCB9ID0gY29udGV4dDtcbiAgICByZXR1cm4geyBjb2x1bW4sIGxpbmUsIG9mZnNldCB9O1xufVxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0LCBlbmQpIHtcbiAgICBlbmQgPSBlbmQgfHwgZ2V0Q3Vyc29yKGNvbnRleHQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBlbmQsXG4gICAgICAgIHNvdXJjZTogY29udGV4dC5vcmlnaW5hbFNvdXJjZS5zbGljZShzdGFydC5vZmZzZXQsIGVuZC5vZmZzZXQpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGxhc3QoeHMpIHtcbiAgICByZXR1cm4geHNbeHMubGVuZ3RoIC0gMV07XG59XG5mdW5jdGlvbiBzdGFydHNXaXRoKHNvdXJjZSwgc2VhcmNoU3RyaW5nKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5zdGFydHNXaXRoKHNlYXJjaFN0cmluZyk7XG59XG5mdW5jdGlvbiBhZHZhbmNlQnkoY29udGV4dCwgbnVtYmVyT2ZDaGFyYWN0ZXJzKSB7XG4gICAgY29uc3QgeyBzb3VyY2UgfSA9IGNvbnRleHQ7XG4gICAgYWR2YW5jZVBvc2l0aW9uV2l0aE11dGF0aW9uKGNvbnRleHQsIHNvdXJjZSwgbnVtYmVyT2ZDaGFyYWN0ZXJzKTtcbiAgICBjb250ZXh0LnNvdXJjZSA9IHNvdXJjZS5zbGljZShudW1iZXJPZkNoYXJhY3RlcnMpO1xufVxuZnVuY3Rpb24gYWR2YW5jZVNwYWNlcyhjb250ZXh0KSB7XG4gICAgY29uc3QgbWF0Y2ggPSAvXltcXHRcXHJcXG5cXGYgXSsvLmV4ZWMoY29udGV4dC5zb3VyY2UpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXROZXdQb3NpdGlvbihjb250ZXh0LCBzdGFydCwgbnVtYmVyT2ZDaGFyYWN0ZXJzKSB7XG4gICAgcmV0dXJuIGFkdmFuY2VQb3NpdGlvbldpdGhDbG9uZShzdGFydCwgY29udGV4dC5vcmlnaW5hbFNvdXJjZS5zbGljZShzdGFydC5vZmZzZXQsIG51bWJlck9mQ2hhcmFjdGVycyksIG51bWJlck9mQ2hhcmFjdGVycyk7XG59XG5mdW5jdGlvbiBlbWl0RXJyb3IoY29udGV4dCwgY29kZSwgb2Zmc2V0LCBsb2MgPSBnZXRDdXJzb3IoY29udGV4dCkpIHtcbiAgICBpZiAob2Zmc2V0KSB7XG4gICAgICAgIGxvYy5vZmZzZXQgKz0gb2Zmc2V0O1xuICAgICAgICBsb2MuY29sdW1uICs9IG9mZnNldDtcbiAgICB9XG4gICAgY29udGV4dC5vcHRpb25zLm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcihjb2RlLCB7XG4gICAgICAgIHN0YXJ0OiBsb2MsXG4gICAgICAgIGVuZDogbG9jLFxuICAgICAgICBzb3VyY2U6ICcnXG4gICAgfSkpO1xufVxuZnVuY3Rpb24gaXNFbmQoY29udGV4dCwgbW9kZSwgYW5jZXN0b3JzKSB7XG4gICAgY29uc3QgcyA9IGNvbnRleHQuc291cmNlO1xuICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICBjYXNlIDAgLyogVGV4dE1vZGVzLkRBVEEgKi86XG4gICAgICAgICAgICBpZiAoc3RhcnRzV2l0aChzLCAnPC8nKSkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IHByb2JhYmx5IGJhZCBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBhbmNlc3RvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0c1dpdGhFbmRUYWdPcGVuKHMsIGFuY2VzdG9yc1tpXS50YWcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEgLyogVGV4dE1vZGVzLlJDREFUQSAqLzpcbiAgICAgICAgY2FzZSAyIC8qIFRleHRNb2Rlcy5SQVdURVhUICovOiB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBsYXN0KGFuY2VzdG9ycyk7XG4gICAgICAgICAgICBpZiAocGFyZW50ICYmIHN0YXJ0c1dpdGhFbmRUYWdPcGVuKHMsIHBhcmVudC50YWcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDMgLyogVGV4dE1vZGVzLkNEQVRBICovOlxuICAgICAgICAgICAgaWYgKHN0YXJ0c1dpdGgocywgJ11dPicpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuICFzO1xufVxuZnVuY3Rpb24gc3RhcnRzV2l0aEVuZFRhZ09wZW4oc291cmNlLCB0YWcpIHtcbiAgICByZXR1cm4gKHN0YXJ0c1dpdGgoc291cmNlLCAnPC8nKSAmJlxuICAgICAgICBzb3VyY2Uuc2xpY2UoMiwgMiArIHRhZy5sZW5ndGgpLnRvTG93ZXJDYXNlKCkgPT09IHRhZy50b0xvd2VyQ2FzZSgpICYmXG4gICAgICAgIC9bXFx0XFxyXFxuXFxmIC8+XS8udGVzdChzb3VyY2VbMiArIHRhZy5sZW5ndGhdIHx8ICc+JykpO1xufVxuXG5mdW5jdGlvbiBob2lzdFN0YXRpYyhyb290LCBjb250ZXh0KSB7XG4gICAgd2Fsayhyb290LCBjb250ZXh0LCBcbiAgICAvLyBSb290IG5vZGUgaXMgdW5mb3J0dW5hdGVseSBub24taG9pc3RhYmxlIGR1ZSB0byBwb3RlbnRpYWwgcGFyZW50XG4gICAgLy8gZmFsbHRocm91Z2ggYXR0cmlidXRlcy5cbiAgICBpc1NpbmdsZUVsZW1lbnRSb290KHJvb3QsIHJvb3QuY2hpbGRyZW5bMF0pKTtcbn1cbmZ1bmN0aW9uIGlzU2luZ2xlRWxlbWVudFJvb3Qocm9vdCwgY2hpbGQpIHtcbiAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSByb290O1xuICAgIHJldHVybiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICAgIGNoaWxkLnR5cGUgPT09IDEgLyogTm9kZVR5cGVzLkVMRU1FTlQgKi8gJiZcbiAgICAgICAgIWlzU2xvdE91dGxldChjaGlsZCkpO1xufVxuZnVuY3Rpb24gd2Fsayhub2RlLCBjb250ZXh0LCBkb05vdEhvaXN0Tm9kZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gbm9kZTtcbiAgICBjb25zdCBvcmlnaW5hbENvdW50ID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGxldCBob2lzdGVkQ291bnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgLy8gb25seSBwbGFpbiBlbGVtZW50cyAmIHRleHQgY2FsbHMgYXJlIGVsaWdpYmxlIGZvciBob2lzdGluZy5cbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IDEgLyogTm9kZVR5cGVzLkVMRU1FTlQgKi8gJiZcbiAgICAgICAgICAgIGNoaWxkLnRhZ1R5cGUgPT09IDAgLyogRWxlbWVudFR5cGVzLkVMRU1FTlQgKi8pIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnN0YW50VHlwZSA9IGRvTm90SG9pc3ROb2RlXG4gICAgICAgICAgICAgICAgPyAwIC8qIENvbnN0YW50VHlwZXMuTk9UX0NPTlNUQU5UICovXG4gICAgICAgICAgICAgICAgOiBnZXRDb25zdGFudFR5cGUoY2hpbGQsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKGNvbnN0YW50VHlwZSA+IDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uc3RhbnRUeXBlID49IDIgLyogQ29uc3RhbnRUeXBlcy5DQU5fSE9JU1QgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuY29kZWdlbk5vZGUucGF0Y2hGbGFnID1cbiAgICAgICAgICAgICAgICAgICAgICAgIC0xIC8qIFBhdGNoRmxhZ3MuSE9JU1RFRCAqLyArICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgIC8qIEhPSVNURUQgKi9gIDogYGApO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5jb2RlZ2VuTm9kZSA9IGNvbnRleHQuaG9pc3QoY2hpbGQuY29kZWdlbk5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBob2lzdGVkQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbm9kZSBtYXkgY29udGFpbiBkeW5hbWljIGNoaWxkcmVuLCBidXQgaXRzIHByb3BzIG1heSBiZSBlbGlnaWJsZSBmb3JcbiAgICAgICAgICAgICAgICAvLyBob2lzdGluZy5cbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlZ2VuTm9kZSA9IGNoaWxkLmNvZGVnZW5Ob2RlO1xuICAgICAgICAgICAgICAgIGlmIChjb2RlZ2VuTm9kZS50eXBlID09PSAxMyAvKiBOb2RlVHlwZXMuVk5PREVfQ0FMTCAqLykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmbGFnID0gZ2V0UGF0Y2hGbGFnKGNvZGVnZW5Ob2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCghZmxhZyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxhZyA9PT0gNTEyIC8qIFBhdGNoRmxhZ3MuTkVFRF9QQVRDSCAqLyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxhZyA9PT0gMSAvKiBQYXRjaEZsYWdzLlRFWFQgKi8pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRHZW5lcmF0ZWRQcm9wc0NvbnN0YW50VHlwZShjaGlsZCwgY29udGV4dCkgPj1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyIC8qIENvbnN0YW50VHlwZXMuQ0FOX0hPSVNUICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wcyA9IGdldE5vZGVQcm9wcyhjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlZ2VuTm9kZS5wcm9wcyA9IGNvbnRleHQuaG9pc3QocHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlZ2VuTm9kZS5keW5hbWljUHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVnZW5Ob2RlLmR5bmFtaWNQcm9wcyA9IGNvbnRleHQuaG9pc3QoY29kZWdlbk5vZGUuZHluYW1pY1Byb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB3YWxrIGZ1cnRoZXJcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IDEgLyogTm9kZVR5cGVzLkVMRU1FTlQgKi8pIHtcbiAgICAgICAgICAgIGNvbnN0IGlzQ29tcG9uZW50ID0gY2hpbGQudGFnVHlwZSA9PT0gMSAvKiBFbGVtZW50VHlwZXMuQ09NUE9ORU5UICovO1xuICAgICAgICAgICAgaWYgKGlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zY29wZXMudlNsb3QrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdhbGsoY2hpbGQsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKGlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zY29wZXMudlNsb3QtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGlsZC50eXBlID09PSAxMSAvKiBOb2RlVHlwZXMuRk9SICovKSB7XG4gICAgICAgICAgICAvLyBEbyBub3QgaG9pc3Qgdi1mb3Igc2luZ2xlIGNoaWxkIGJlY2F1c2UgaXQgaGFzIHRvIGJlIGEgYmxvY2tcbiAgICAgICAgICAgIHdhbGsoY2hpbGQsIGNvbnRleHQsIGNoaWxkLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hpbGQudHlwZSA9PT0gOSAvKiBOb2RlVHlwZXMuSUYgKi8pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGQuYnJhbmNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgaG9pc3Qgdi1pZiBzaW5nbGUgY2hpbGQgYmVjYXVzZSBpdCBoYXMgdG8gYmUgYSBibG9ja1xuICAgICAgICAgICAgICAgIHdhbGsoY2hpbGQuYnJhbmNoZXNbaV0sIGNvbnRleHQsIGNoaWxkLmJyYW5jaGVzW2ldLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhvaXN0ZWRDb3VudCAmJiBjb250ZXh0LnRyYW5zZm9ybUhvaXN0KSB7XG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtSG9pc3QoY2hpbGRyZW4sIGNvbnRleHQsIG5vZGUpO1xuICAgIH1cbiAgICAvLyBhbGwgY2hpbGRyZW4gd2VyZSBob2lzdGVkIC0gdGhlIGVudGlyZSBjaGlsZHJlbiBhcnJheSBpcyBob2lzdGFibGUuXG4gICAgaWYgKGhvaXN0ZWRDb3VudCAmJlxuICAgICAgICBob2lzdGVkQ291bnQgPT09IG9yaWdpbmFsQ291bnQgJiZcbiAgICAgICAgbm9kZS50eXBlID09PSAxIC8qIE5vZGVUeXBlcy5FTEVNRU5UICovICYmXG4gICAgICAgIG5vZGUudGFnVHlwZSA9PT0gMCAvKiBFbGVtZW50VHlwZXMuRUxFTUVOVCAqLyAmJlxuICAgICAgICBub2RlLmNvZGVnZW5Ob2RlICYmXG4gICAgICAgIG5vZGUuY29kZWdlbk5vZGUudHlwZSA9PT0gMTMgLyogTm9kZVR5cGVzLlZOT0RFX0NBTEwgKi8gJiZcbiAgICAgICAgaXNBcnJheShub2RlLmNvZGVnZW5Ob2RlLmNoaWxkcmVuKSkge1xuICAgICAgICBub2RlLmNvZGVnZW5Ob2RlLmNoaWxkcmVuID0gY29udGV4dC5ob2lzdChjcmVhdGVBcnJheUV4cHJlc3Npb24obm9kZS5jb2RlZ2VuTm9kZS5jaGlsZHJlbikpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldENvbnN0YW50VHlwZShub2RlLCBjb250ZXh0KSB7XG4gICAgY29uc3QgeyBjb25zdGFudENhY2hlIH0gPSBjb250ZXh0O1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLzpcbiAgICAgICAgICAgIGlmIChub2RlLnRhZ1R5cGUgIT09IDAgLyogRWxlbWVudFR5cGVzLkVMRU1FTlQgKi8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZCA9IGNvbnN0YW50Q2FjaGUuZ2V0KG5vZGUpO1xuICAgICAgICAgICAgaWYgKGNhY2hlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvZGVnZW5Ob2RlID0gbm9kZS5jb2RlZ2VuTm9kZTtcbiAgICAgICAgICAgIGlmIChjb2RlZ2VuTm9kZS50eXBlICE9PSAxMyAvKiBOb2RlVHlwZXMuVk5PREVfQ0FMTCAqLykge1xuICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIENvbnN0YW50VHlwZXMuTk9UX0NPTlNUQU5UICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvZGVnZW5Ob2RlLmlzQmxvY2sgJiZcbiAgICAgICAgICAgICAgICBub2RlLnRhZyAhPT0gJ3N2ZycgJiZcbiAgICAgICAgICAgICAgICBub2RlLnRhZyAhPT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmbGFnID0gZ2V0UGF0Y2hGbGFnKGNvZGVnZW5Ob2RlKTtcbiAgICAgICAgICAgIGlmICghZmxhZykge1xuICAgICAgICAgICAgICAgIGxldCByZXR1cm5UeXBlID0gMyAvKiBDb25zdGFudFR5cGVzLkNBTl9TVFJJTkdJRlkgKi87XG4gICAgICAgICAgICAgICAgLy8gRWxlbWVudCBpdHNlbGYgaGFzIG5vIHBhdGNoIGZsYWcuIEhvd2V2ZXIgd2Ugc3RpbGwgbmVlZCB0byBjaGVjazpcbiAgICAgICAgICAgICAgICAvLyAxLiBFdmVuIGZvciBhIG5vZGUgd2l0aCBubyBwYXRjaCBmbGFnLCBpdCBpcyBwb3NzaWJsZSBmb3IgaXQgdG8gY29udGFpblxuICAgICAgICAgICAgICAgIC8vIG5vbi1ob2lzdGFibGUgZXhwcmVzc2lvbnMgdGhhdCByZWZlcnMgdG8gc2NvcGUgdmFyaWFibGVzLCBlLmcuIGNvbXBpbGVyXG4gICAgICAgICAgICAgICAgLy8gaW5qZWN0ZWQga2V5cyBvciBjYWNoZWQgZXZlbnQgaGFuZGxlcnMuIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIGFsd2F5c1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRoZSBjb2RlZ2VuTm9kZSdzIHByb3BzIHRvIGJlIHN1cmUuXG4gICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJhdGVkUHJvcHNUeXBlID0gZ2V0R2VuZXJhdGVkUHJvcHNDb25zdGFudFR5cGUobm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRlZFByb3BzVHlwZSA9PT0gMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdGFudENhY2hlLnNldChub2RlLCAwIC8qIENvbnN0YW50VHlwZXMuTk9UX0NPTlNUQU5UICovKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChnZW5lcmF0ZWRQcm9wc1R5cGUgPCByZXR1cm5UeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBnZW5lcmF0ZWRQcm9wc1R5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIDIuIGl0cyBjaGlsZHJlbi5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRUeXBlID0gZ2V0Q29uc3RhbnRUeXBlKG5vZGUuY2hpbGRyZW5baV0sIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRUeXBlID09PSAwIC8qIENvbnN0YW50VHlwZXMuTk9UX0NPTlNUQU5UICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdGFudENhY2hlLnNldChub2RlLCAwIC8qIENvbnN0YW50VHlwZXMuTk9UX0NPTlNUQU5UICovKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIENvbnN0YW50VHlwZXMuTk9UX0NPTlNUQU5UICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZFR5cGUgPCByZXR1cm5UeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gY2hpbGRUeXBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIDMuIGlmIHRoZSB0eXBlIGlzIG5vdCBhbHJlYWR5IENBTl9TS0lQX1BBVENIIHdoaWNoIGlzIHRoZSBsb3dlc3Qgbm9uLTBcbiAgICAgICAgICAgICAgICAvLyB0eXBlLCBjaGVjayBpZiBhbnkgb2YgdGhlIHByb3BzIGNhbiBjYXVzZSB0aGUgdHlwZSB0byBiZSBsb3dlcmVkXG4gICAgICAgICAgICAgICAgLy8gd2UgY2FuIHNraXAgY2FuX3BhdGNoIGJlY2F1c2UgaXQncyBndWFyYW50ZWVkIGJ5IHRoZSBhYnNlbmNlIG9mIGFcbiAgICAgICAgICAgICAgICAvLyBwYXRjaEZsYWcuXG4gICAgICAgICAgICAgICAgaWYgKHJldHVyblR5cGUgPiAxIC8qIENvbnN0YW50VHlwZXMuQ0FOX1NLSVBfUEFUQ0ggKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLnByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gbm9kZS5wcm9wc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwLnR5cGUgPT09IDcgLyogTm9kZVR5cGVzLkRJUkVDVElWRSAqLyAmJiBwLm5hbWUgPT09ICdiaW5kJyAmJiBwLmV4cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cFR5cGUgPSBnZXRDb25zdGFudFR5cGUocC5leHAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHBUeXBlID09PSAwIC8qIENvbnN0YW50VHlwZXMuTk9UX0NPTlNUQU5UICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0YW50Q2FjaGUuc2V0KG5vZGUsIDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cFR5cGUgPCByZXR1cm5UeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBleHBUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBvbmx5IHN2Zy9mb3JlaWduT2JqZWN0IGNvdWxkIGJlIGJsb2NrIGhlcmUsIGhvd2V2ZXIgaWYgdGhleSBhcmVcbiAgICAgICAgICAgICAgICAvLyBzdGF0aWMgdGhlbiB0aGV5IGRvbid0IG5lZWQgdG8gYmUgYmxvY2tzIHNpbmNlIHRoZXJlIHdpbGwgYmUgbm9cbiAgICAgICAgICAgICAgICAvLyBuZXN0ZWQgdXBkYXRlcy5cbiAgICAgICAgICAgICAgICBpZiAoY29kZWdlbk5vZGUuaXNCbG9jaykge1xuICAgICAgICAgICAgICAgICAgICAvLyBleGNlcHQgc2V0IGN1c3RvbSBkaXJlY3RpdmVzLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUucHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBub2RlLnByb3BzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAudHlwZSA9PT0gNyAvKiBOb2RlVHlwZXMuRElSRUNUSVZFICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRDYWNoZS5zZXQobm9kZSwgMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZW1vdmVIZWxwZXIoT1BFTl9CTE9DSyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVtb3ZlSGVscGVyKGdldFZOb2RlQmxvY2tIZWxwZXIoY29udGV4dC5pblNTUiwgY29kZWdlbk5vZGUuaXNDb21wb25lbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgY29kZWdlbk5vZGUuaXNCbG9jayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmhlbHBlcihnZXRWTm9kZUhlbHBlcihjb250ZXh0LmluU1NSLCBjb2RlZ2VuTm9kZS5pc0NvbXBvbmVudCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdGFudENhY2hlLnNldChub2RlLCByZXR1cm5UeXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0YW50Q2FjaGUuc2V0KG5vZGUsIDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi8pO1xuICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIENvbnN0YW50VHlwZXMuTk9UX0NPTlNUQU5UICovO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIDIgLyogTm9kZVR5cGVzLlRFWFQgKi86XG4gICAgICAgIGNhc2UgMyAvKiBOb2RlVHlwZXMuQ09NTUVOVCAqLzpcbiAgICAgICAgICAgIHJldHVybiAzIC8qIENvbnN0YW50VHlwZXMuQ0FOX1NUUklOR0lGWSAqLztcbiAgICAgICAgY2FzZSA5IC8qIE5vZGVUeXBlcy5JRiAqLzpcbiAgICAgICAgY2FzZSAxMSAvKiBOb2RlVHlwZXMuRk9SICovOlxuICAgICAgICBjYXNlIDEwIC8qIE5vZGVUeXBlcy5JRl9CUkFOQ0ggKi86XG4gICAgICAgICAgICByZXR1cm4gMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLztcbiAgICAgICAgY2FzZSA1IC8qIE5vZGVUeXBlcy5JTlRFUlBPTEFUSU9OICovOlxuICAgICAgICBjYXNlIDEyIC8qIE5vZGVUeXBlcy5URVhUX0NBTEwgKi86XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29uc3RhbnRUeXBlKG5vZGUuY29udGVudCwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgNCAvKiBOb2RlVHlwZXMuU0lNUExFX0VYUFJFU1NJT04gKi86XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jb25zdFR5cGU7XG4gICAgICAgIGNhc2UgOCAvKiBOb2RlVHlwZXMuQ09NUE9VTkRfRVhQUkVTU0lPTiAqLzpcbiAgICAgICAgICAgIGxldCByZXR1cm5UeXBlID0gMyAvKiBDb25zdGFudFR5cGVzLkNBTl9TVFJJTkdJRlkgKi87XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGNoaWxkKSB8fCBpc1N5bWJvbChjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkVHlwZSA9IGdldENvbnN0YW50VHlwZShjaGlsZCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkVHlwZSA9PT0gMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGRUeXBlIDwgcmV0dXJuVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gY2hpbGRUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXR1cm5UeXBlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkgO1xuICAgICAgICAgICAgcmV0dXJuIDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi87XG4gICAgfVxufVxuY29uc3QgYWxsb3dIb2lzdGVkSGVscGVyU2V0ID0gbmV3IFNldChbXG4gICAgTk9STUFMSVpFX0NMQVNTLFxuICAgIE5PUk1BTElaRV9TVFlMRSxcbiAgICBOT1JNQUxJWkVfUFJPUFMsXG4gICAgR1VBUkRfUkVBQ1RJVkVfUFJPUFNcbl0pO1xuZnVuY3Rpb24gZ2V0Q29uc3RhbnRUeXBlT2ZIZWxwZXJDYWxsKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgaWYgKHZhbHVlLnR5cGUgPT09IDE0IC8qIE5vZGVUeXBlcy5KU19DQUxMX0VYUFJFU1NJT04gKi8gJiZcbiAgICAgICAgIWlzU3RyaW5nKHZhbHVlLmNhbGxlZSkgJiZcbiAgICAgICAgYWxsb3dIb2lzdGVkSGVscGVyU2V0Lmhhcyh2YWx1ZS5jYWxsZWUpKSB7XG4gICAgICAgIGNvbnN0IGFyZyA9IHZhbHVlLmFyZ3VtZW50c1swXTtcbiAgICAgICAgaWYgKGFyZy50eXBlID09PSA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLykge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbnN0YW50VHlwZShhcmcsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFyZy50eXBlID09PSAxNCAvKiBOb2RlVHlwZXMuSlNfQ0FMTF9FWFBSRVNTSU9OICovKSB7XG4gICAgICAgICAgICAvLyBpbiB0aGUgY2FzZSBvZiBuZXN0ZWQgaGVscGVyIGNhbGwsIGUuZy4gYG5vcm1hbGl6ZVByb3BzKGd1YXJkUmVhY3RpdmVQcm9wcyhleHApKWBcbiAgICAgICAgICAgIHJldHVybiBnZXRDb25zdGFudFR5cGVPZkhlbHBlckNhbGwoYXJnLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLztcbn1cbmZ1bmN0aW9uIGdldEdlbmVyYXRlZFByb3BzQ29uc3RhbnRUeXBlKG5vZGUsIGNvbnRleHQpIHtcbiAgICBsZXQgcmV0dXJuVHlwZSA9IDMgLyogQ29uc3RhbnRUeXBlcy5DQU5fU1RSSU5HSUZZICovO1xuICAgIGNvbnN0IHByb3BzID0gZ2V0Tm9kZVByb3BzKG5vZGUpO1xuICAgIGlmIChwcm9wcyAmJiBwcm9wcy50eXBlID09PSAxNSAvKiBOb2RlVHlwZXMuSlNfT0JKRUNUX0VYUFJFU1NJT04gKi8pIHtcbiAgICAgICAgY29uc3QgeyBwcm9wZXJ0aWVzIH0gPSBwcm9wcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IHByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICBjb25zdCBrZXlUeXBlID0gZ2V0Q29uc3RhbnRUeXBlKGtleSwgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAoa2V5VHlwZSA9PT0gMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLykge1xuICAgICAgICAgICAgICAgIHJldHVybiBrZXlUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleVR5cGUgPCByZXR1cm5UeXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IGtleVR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdmFsdWVUeXBlO1xuICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT09IDQgLyogTm9kZVR5cGVzLlNJTVBMRV9FWFBSRVNTSU9OICovKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlID0gZ2V0Q29uc3RhbnRUeXBlKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLnR5cGUgPT09IDE0IC8qIE5vZGVUeXBlcy5KU19DQUxMX0VYUFJFU1NJT04gKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBzb21lIGhlbHBlciBjYWxscyBjYW4gYmUgaG9pc3RlZCxcbiAgICAgICAgICAgICAgICAvLyBzdWNoIGFzIHRoZSBgbm9ybWFsaXplUHJvcHNgIGdlbmVyYXRlZCBieSB0aGUgY29tcGlsZXIgZm9yIHByZS1ub3JtYWxpemUgY2xhc3MsXG4gICAgICAgICAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHdlIG5lZWQgdG8gcmVzcGVjdCB0aGUgQ29uc3RhbnRUeXBlIG9mIHRoZSBoZWxwZXIncyBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICB2YWx1ZVR5cGUgPSBnZXRDb25zdGFudFR5cGVPZkhlbHBlckNhbGwodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlID0gMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZVR5cGUgPT09IDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlVHlwZSA8IHJldHVyblR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gdmFsdWVUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5UeXBlO1xufVxuZnVuY3Rpb24gZ2V0Tm9kZVByb3BzKG5vZGUpIHtcbiAgICBjb25zdCBjb2RlZ2VuTm9kZSA9IG5vZGUuY29kZWdlbk5vZGU7XG4gICAgaWYgKGNvZGVnZW5Ob2RlLnR5cGUgPT09IDEzIC8qIE5vZGVUeXBlcy5WTk9ERV9DQUxMICovKSB7XG4gICAgICAgIHJldHVybiBjb2RlZ2VuTm9kZS5wcm9wcztcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRQYXRjaEZsYWcobm9kZSkge1xuICAgIGNvbnN0IGZsYWcgPSBub2RlLnBhdGNoRmxhZztcbiAgICByZXR1cm4gZmxhZyA/IHBhcnNlSW50KGZsYWcsIDEwKSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHJhbnNmb3JtQ29udGV4dChyb290LCB7IGZpbGVuYW1lID0gJycsIHByZWZpeElkZW50aWZpZXJzID0gZmFsc2UsIGhvaXN0U3RhdGljID0gZmFsc2UsIGNhY2hlSGFuZGxlcnMgPSBmYWxzZSwgbm9kZVRyYW5zZm9ybXMgPSBbXSwgZGlyZWN0aXZlVHJhbnNmb3JtcyA9IHt9LCB0cmFuc2Zvcm1Ib2lzdCA9IG51bGwsIGlzQnVpbHRJbkNvbXBvbmVudCA9IE5PT1AsIGlzQ3VzdG9tRWxlbWVudCA9IE5PT1AsIGV4cHJlc3Npb25QbHVnaW5zID0gW10sIHNjb3BlSWQgPSBudWxsLCBzbG90dGVkID0gdHJ1ZSwgc3NyID0gZmFsc2UsIGluU1NSID0gZmFsc2UsIHNzckNzc1ZhcnMgPSBgYCwgYmluZGluZ01ldGFkYXRhID0gRU1QVFlfT0JKLCBpbmxpbmUgPSBmYWxzZSwgaXNUUyA9IGZhbHNlLCBvbkVycm9yID0gZGVmYXVsdE9uRXJyb3IsIG9uV2FybiA9IGRlZmF1bHRPbldhcm4sIGNvbXBhdENvbmZpZyB9KSB7XG4gICAgY29uc3QgbmFtZU1hdGNoID0gZmlsZW5hbWUucmVwbGFjZSgvXFw/LiokLywgJycpLm1hdGNoKC8oW14vXFxcXF0rKVxcLlxcdyskLyk7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgLy8gb3B0aW9uc1xuICAgICAgICBzZWxmTmFtZTogbmFtZU1hdGNoICYmIGNhcGl0YWxpemUoY2FtZWxpemUkMShuYW1lTWF0Y2hbMV0pKSxcbiAgICAgICAgcHJlZml4SWRlbnRpZmllcnMsXG4gICAgICAgIGhvaXN0U3RhdGljLFxuICAgICAgICBjYWNoZUhhbmRsZXJzLFxuICAgICAgICBub2RlVHJhbnNmb3JtcyxcbiAgICAgICAgZGlyZWN0aXZlVHJhbnNmb3JtcyxcbiAgICAgICAgdHJhbnNmb3JtSG9pc3QsXG4gICAgICAgIGlzQnVpbHRJbkNvbXBvbmVudCxcbiAgICAgICAgaXNDdXN0b21FbGVtZW50LFxuICAgICAgICBleHByZXNzaW9uUGx1Z2lucyxcbiAgICAgICAgc2NvcGVJZCxcbiAgICAgICAgc2xvdHRlZCxcbiAgICAgICAgc3NyLFxuICAgICAgICBpblNTUixcbiAgICAgICAgc3NyQ3NzVmFycyxcbiAgICAgICAgYmluZGluZ01ldGFkYXRhLFxuICAgICAgICBpbmxpbmUsXG4gICAgICAgIGlzVFMsXG4gICAgICAgIG9uRXJyb3IsXG4gICAgICAgIG9uV2FybixcbiAgICAgICAgY29tcGF0Q29uZmlnLFxuICAgICAgICAvLyBzdGF0ZVxuICAgICAgICByb290LFxuICAgICAgICBoZWxwZXJzOiBuZXcgTWFwKCksXG4gICAgICAgIGNvbXBvbmVudHM6IG5ldyBTZXQoKSxcbiAgICAgICAgZGlyZWN0aXZlczogbmV3IFNldCgpLFxuICAgICAgICBob2lzdHM6IFtdLFxuICAgICAgICBpbXBvcnRzOiBbXSxcbiAgICAgICAgY29uc3RhbnRDYWNoZTogbmV3IE1hcCgpLFxuICAgICAgICB0ZW1wczogMCxcbiAgICAgICAgY2FjaGVkOiAwLFxuICAgICAgICBpZGVudGlmaWVyczogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgc2NvcGVzOiB7XG4gICAgICAgICAgICB2Rm9yOiAwLFxuICAgICAgICAgICAgdlNsb3Q6IDAsXG4gICAgICAgICAgICB2UHJlOiAwLFxuICAgICAgICAgICAgdk9uY2U6IDBcbiAgICAgICAgfSxcbiAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICBjdXJyZW50Tm9kZTogcm9vdCxcbiAgICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgICAgaW5WT25jZTogZmFsc2UsXG4gICAgICAgIC8vIG1ldGhvZHNcbiAgICAgICAgaGVscGVyKG5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gY29udGV4dC5oZWxwZXJzLmdldChuYW1lKSB8fCAwO1xuICAgICAgICAgICAgY29udGV4dC5oZWxwZXJzLnNldChuYW1lLCBjb3VudCArIDEpO1xuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUhlbHBlcihuYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBjb3VudCA9IGNvbnRleHQuaGVscGVycy5nZXQobmFtZSk7XG4gICAgICAgICAgICBpZiAoY291bnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Q291bnQgPSBjb3VudCAtIDE7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5oZWxwZXJzLmRlbGV0ZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuaGVscGVycy5zZXQobmFtZSwgY3VycmVudENvdW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGhlbHBlclN0cmluZyhuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gYF8ke2hlbHBlck5hbWVNYXBbY29udGV4dC5oZWxwZXIobmFtZSldfWA7XG4gICAgICAgIH0sXG4gICAgICAgIHJlcGxhY2VOb2RlKG5vZGUpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgIGlmICghY29udGV4dC5jdXJyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vZGUgYmVpbmcgcmVwbGFjZWQgaXMgYWxyZWFkeSByZW1vdmVkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlcGxhY2Ugcm9vdCBub2RlLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQucGFyZW50LmNoaWxkcmVuW2NvbnRleHQuY2hpbGRJbmRleF0gPSBjb250ZXh0LmN1cnJlbnROb2RlID0gbm9kZTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlTm9kZShub2RlKSB7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFjb250ZXh0LnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlbW92ZSByb290IG5vZGUuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsaXN0ID0gY29udGV4dC5wYXJlbnQuY2hpbGRyZW47XG4gICAgICAgICAgICBjb25zdCByZW1vdmFsSW5kZXggPSBub2RlXG4gICAgICAgICAgICAgICAgPyBsaXN0LmluZGV4T2Yobm9kZSlcbiAgICAgICAgICAgICAgICA6IGNvbnRleHQuY3VycmVudE5vZGVcbiAgICAgICAgICAgICAgICAgICAgPyBjb250ZXh0LmNoaWxkSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgOiAtMTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiByZW1vdmFsSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBub2RlIGJlaW5nIHJlbW92ZWQgaXMgbm90IGEgY2hpbGQgb2YgY3VycmVudCBwYXJlbnRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbm9kZSB8fCBub2RlID09PSBjb250ZXh0LmN1cnJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gY3VycmVudCBub2RlIHJlbW92ZWRcbiAgICAgICAgICAgICAgICBjb250ZXh0LmN1cnJlbnROb2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm9uTm9kZVJlbW92ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHNpYmxpbmcgbm9kZSByZW1vdmVkXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuY2hpbGRJbmRleCA+IHJlbW92YWxJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmNoaWxkSW5kZXgtLTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbk5vZGVSZW1vdmVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKHJlbW92YWxJbmRleCwgMSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTm9kZVJlbW92ZWQ6ICgpID0+IHsgfSxcbiAgICAgICAgYWRkSWRlbnRpZmllcnMoZXhwKSB7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUlkZW50aWZpZXJzKGV4cCkge1xuICAgICAgICB9LFxuICAgICAgICBob2lzdChleHApIHtcbiAgICAgICAgICAgIGlmIChpc1N0cmluZyhleHApKVxuICAgICAgICAgICAgICAgIGV4cCA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oZXhwKTtcbiAgICAgICAgICAgIGNvbnRleHQuaG9pc3RzLnB1c2goZXhwKTtcbiAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGBfaG9pc3RlZF8ke2NvbnRleHQuaG9pc3RzLmxlbmd0aH1gLCBmYWxzZSwgZXhwLmxvYywgMiAvKiBDb25zdGFudFR5cGVzLkNBTl9IT0lTVCAqLyk7XG4gICAgICAgICAgICBpZGVudGlmaWVyLmhvaXN0ZWQgPSBleHA7XG4gICAgICAgICAgICByZXR1cm4gaWRlbnRpZmllcjtcbiAgICAgICAgfSxcbiAgICAgICAgY2FjaGUoZXhwLCBpc1ZOb2RlID0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVDYWNoZUV4cHJlc3Npb24oY29udGV4dC5jYWNoZWQrKywgZXhwLCBpc1ZOb2RlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAge1xuICAgICAgICBjb250ZXh0LmZpbHRlcnMgPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0O1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtKHJvb3QsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlVHJhbnNmb3JtQ29udGV4dChyb290LCBvcHRpb25zKTtcbiAgICB0cmF2ZXJzZU5vZGUocm9vdCwgY29udGV4dCk7XG4gICAgaWYgKG9wdGlvbnMuaG9pc3RTdGF0aWMpIHtcbiAgICAgICAgaG9pc3RTdGF0aWMocm9vdCwgY29udGV4dCk7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5zc3IpIHtcbiAgICAgICAgY3JlYXRlUm9vdENvZGVnZW4ocm9vdCwgY29udGV4dCk7XG4gICAgfVxuICAgIC8vIGZpbmFsaXplIG1ldGEgaW5mb3JtYXRpb25cbiAgICByb290LmhlbHBlcnMgPSBbLi4uY29udGV4dC5oZWxwZXJzLmtleXMoKV07XG4gICAgcm9vdC5jb21wb25lbnRzID0gWy4uLmNvbnRleHQuY29tcG9uZW50c107XG4gICAgcm9vdC5kaXJlY3RpdmVzID0gWy4uLmNvbnRleHQuZGlyZWN0aXZlc107XG4gICAgcm9vdC5pbXBvcnRzID0gY29udGV4dC5pbXBvcnRzO1xuICAgIHJvb3QuaG9pc3RzID0gY29udGV4dC5ob2lzdHM7XG4gICAgcm9vdC50ZW1wcyA9IGNvbnRleHQudGVtcHM7XG4gICAgcm9vdC5jYWNoZWQgPSBjb250ZXh0LmNhY2hlZDtcbiAgICB7XG4gICAgICAgIHJvb3QuZmlsdGVycyA9IFsuLi5jb250ZXh0LmZpbHRlcnNdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvb3RDb2RlZ2VuKHJvb3QsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7IGhlbHBlciB9ID0gY29udGV4dDtcbiAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSByb290O1xuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlblswXTtcbiAgICAgICAgLy8gaWYgdGhlIHNpbmdsZSBjaGlsZCBpcyBhbiBlbGVtZW50LCB0dXJuIGl0IGludG8gYSBibG9jay5cbiAgICAgICAgaWYgKGlzU2luZ2xlRWxlbWVudFJvb3Qocm9vdCwgY2hpbGQpICYmIGNoaWxkLmNvZGVnZW5Ob2RlKSB7XG4gICAgICAgICAgICAvLyBzaW5nbGUgZWxlbWVudCByb290IGlzIG5ldmVyIGhvaXN0ZWQgc28gY29kZWdlbk5vZGUgd2lsbCBuZXZlciBiZVxuICAgICAgICAgICAgLy8gU2ltcGxlRXhwcmVzc2lvbk5vZGVcbiAgICAgICAgICAgIGNvbnN0IGNvZGVnZW5Ob2RlID0gY2hpbGQuY29kZWdlbk5vZGU7XG4gICAgICAgICAgICBpZiAoY29kZWdlbk5vZGUudHlwZSA9PT0gMTMgLyogTm9kZVR5cGVzLlZOT0RFX0NBTEwgKi8pIHtcbiAgICAgICAgICAgICAgICBtYWtlQmxvY2soY29kZWdlbk5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm9vdC5jb2RlZ2VuTm9kZSA9IGNvZGVnZW5Ob2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gLSBzaW5nbGUgPHNsb3QvPiwgSWZOb2RlLCBGb3JOb2RlOiBhbHJlYWR5IGJsb2Nrcy5cbiAgICAgICAgICAgIC8vIC0gc2luZ2xlIHRleHQgbm9kZTogYWx3YXlzIHBhdGNoZWQuXG4gICAgICAgICAgICAvLyByb290IGNvZGVnZW4gZmFsbHMgdGhyb3VnaCB2aWEgZ2VuTm9kZSgpXG4gICAgICAgICAgICByb290LmNvZGVnZW5Ob2RlID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyByb290IGhhcyBtdWx0aXBsZSBub2RlcyAtIHJldHVybiBhIGZyYWdtZW50IGJsb2NrLlxuICAgICAgICBsZXQgcGF0Y2hGbGFnID0gNjQgLyogUGF0Y2hGbGFncy5TVEFCTEVfRlJBR01FTlQgKi87XG4gICAgICAgIGxldCBwYXRjaEZsYWdUZXh0ID0gUGF0Y2hGbGFnTmFtZXNbNjQgLyogUGF0Y2hGbGFncy5TVEFCTEVfRlJBR01FTlQgKi9dO1xuICAgICAgICAvLyBjaGVjayBpZiB0aGUgZnJhZ21lbnQgYWN0dWFsbHkgY29udGFpbnMgYSBzaW5nbGUgdmFsaWQgY2hpbGQgd2l0aFxuICAgICAgICAvLyB0aGUgcmVzdCBiZWluZyBjb21tZW50c1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICBjaGlsZHJlbi5maWx0ZXIoYyA9PiBjLnR5cGUgIT09IDMgLyogTm9kZVR5cGVzLkNPTU1FTlQgKi8pLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcGF0Y2hGbGFnIHw9IDIwNDggLyogUGF0Y2hGbGFncy5ERVZfUk9PVF9GUkFHTUVOVCAqLztcbiAgICAgICAgICAgIHBhdGNoRmxhZ1RleHQgKz0gYCwgJHtQYXRjaEZsYWdOYW1lc1syMDQ4IC8qIFBhdGNoRmxhZ3MuREVWX1JPT1RfRlJBR01FTlQgKi9dfWA7XG4gICAgICAgIH1cbiAgICAgICAgcm9vdC5jb2RlZ2VuTm9kZSA9IGNyZWF0ZVZOb2RlQ2FsbChjb250ZXh0LCBoZWxwZXIoRlJBR01FTlQpLCB1bmRlZmluZWQsIHJvb3QuY2hpbGRyZW4sIHBhdGNoRmxhZyArICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgIC8qICR7cGF0Y2hGbGFnVGV4dH0gKi9gIDogYGApLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSwgdW5kZWZpbmVkLCBmYWxzZSAvKiBpc0NvbXBvbmVudCAqLyk7XG4gICAgfVxuICAgIGVsc2UgO1xufVxuZnVuY3Rpb24gdHJhdmVyc2VDaGlsZHJlbihwYXJlbnQsIGNvbnRleHQpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgY29uc3Qgbm9kZVJlbW92ZWQgPSAoKSA9PiB7XG4gICAgICAgIGktLTtcbiAgICB9O1xuICAgIGZvciAoOyBpIDwgcGFyZW50LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gcGFyZW50LmNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoaXNTdHJpbmcoY2hpbGQpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnRleHQucGFyZW50ID0gcGFyZW50O1xuICAgICAgICBjb250ZXh0LmNoaWxkSW5kZXggPSBpO1xuICAgICAgICBjb250ZXh0Lm9uTm9kZVJlbW92ZWQgPSBub2RlUmVtb3ZlZDtcbiAgICAgICAgdHJhdmVyc2VOb2RlKGNoaWxkLCBjb250ZXh0KTtcbiAgICB9XG59XG5mdW5jdGlvbiB0cmF2ZXJzZU5vZGUobm9kZSwgY29udGV4dCkge1xuICAgIGNvbnRleHQuY3VycmVudE5vZGUgPSBub2RlO1xuICAgIC8vIGFwcGx5IHRyYW5zZm9ybSBwbHVnaW5zXG4gICAgY29uc3QgeyBub2RlVHJhbnNmb3JtcyB9ID0gY29udGV4dDtcbiAgICBjb25zdCBleGl0Rm5zID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlVHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBvbkV4aXQgPSBub2RlVHJhbnNmb3Jtc1tpXShub2RlLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKG9uRXhpdCkge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkob25FeGl0KSkge1xuICAgICAgICAgICAgICAgIGV4aXRGbnMucHVzaCguLi5vbkV4aXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhpdEZucy5wdXNoKG9uRXhpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb250ZXh0LmN1cnJlbnROb2RlKSB7XG4gICAgICAgICAgICAvLyBub2RlIHdhcyByZW1vdmVkXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBub2RlIG1heSBoYXZlIGJlZW4gcmVwbGFjZWRcbiAgICAgICAgICAgIG5vZGUgPSBjb250ZXh0LmN1cnJlbnROb2RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgMyAvKiBOb2RlVHlwZXMuQ09NTUVOVCAqLzpcbiAgICAgICAgICAgIGlmICghY29udGV4dC5zc3IpIHtcbiAgICAgICAgICAgICAgICAvLyBpbmplY3QgaW1wb3J0IGZvciB0aGUgQ29tbWVudCBzeW1ib2wsIHdoaWNoIGlzIG5lZWRlZCBmb3IgY3JlYXRpbmdcbiAgICAgICAgICAgICAgICAvLyBjb21tZW50IG5vZGVzIHdpdGggYGNyZWF0ZVZOb2RlYFxuICAgICAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKENSRUFURV9DT01NRU5UKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDUgLyogTm9kZVR5cGVzLklOVEVSUE9MQVRJT04gKi86XG4gICAgICAgICAgICAvLyBubyBuZWVkIHRvIHRyYXZlcnNlLCBidXQgd2UgbmVlZCB0byBpbmplY3QgdG9TdHJpbmcgaGVscGVyXG4gICAgICAgICAgICBpZiAoIWNvbnRleHQuc3NyKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5oZWxwZXIoVE9fRElTUExBWV9TVFJJTkcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIGZvciBjb250YWluZXIgdHlwZXMsIGZ1cnRoZXIgdHJhdmVyc2UgZG93bndhcmRzXG4gICAgICAgIGNhc2UgOSAvKiBOb2RlVHlwZXMuSUYgKi86XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuYnJhbmNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0cmF2ZXJzZU5vZGUobm9kZS5icmFuY2hlc1tpXSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMCAvKiBOb2RlVHlwZXMuSUZfQlJBTkNIICovOlxuICAgICAgICBjYXNlIDExIC8qIE5vZGVUeXBlcy5GT1IgKi86XG4gICAgICAgIGNhc2UgMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLzpcbiAgICAgICAgY2FzZSAwIC8qIE5vZGVUeXBlcy5ST09UICovOlxuICAgICAgICAgICAgdHJhdmVyc2VDaGlsZHJlbihub2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBleGl0IHRyYW5zZm9ybXNcbiAgICBjb250ZXh0LmN1cnJlbnROb2RlID0gbm9kZTtcbiAgICBsZXQgaSA9IGV4aXRGbnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgZXhpdEZuc1tpXSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0cnVjdHVyYWxEaXJlY3RpdmVUcmFuc2Zvcm0obmFtZSwgZm4pIHtcbiAgICBjb25zdCBtYXRjaGVzID0gaXNTdHJpbmcobmFtZSlcbiAgICAgICAgPyAobikgPT4gbiA9PT0gbmFtZVxuICAgICAgICA6IChuKSA9PiBuYW1lLnRlc3Qobik7XG4gICAgcmV0dXJuIChub2RlLCBjb250ZXh0KSA9PiB7XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IDEgLyogTm9kZVR5cGVzLkVMRU1FTlQgKi8pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IG5vZGU7XG4gICAgICAgICAgICAvLyBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZSB0cmFuc2Zvcm1zIGFyZSBub3QgY29uY2VybmVkIHdpdGggc2xvdHNcbiAgICAgICAgICAgIC8vIGFzIHRoZXkgYXJlIGhhbmRsZWQgc2VwYXJhdGVseSBpbiB2U2xvdC50c1xuICAgICAgICAgICAgaWYgKG5vZGUudGFnVHlwZSA9PT0gMyAvKiBFbGVtZW50VHlwZXMuVEVNUExBVEUgKi8gJiYgcHJvcHMuc29tZShpc1ZTbG90KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGV4aXRGbnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wID0gcHJvcHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHByb3AudHlwZSA9PT0gNyAvKiBOb2RlVHlwZXMuRElSRUNUSVZFICovICYmIG1hdGNoZXMocHJvcC5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZXMgYXJlIHJlbW92ZWQgdG8gYXZvaWQgaW5maW5pdGUgcmVjdXJzaW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsc28gd2UgcmVtb3ZlIHRoZW0gKmJlZm9yZSogYXBwbHlpbmcgc28gdGhhdCBpdCBjYW4gZnVydGhlclxuICAgICAgICAgICAgICAgICAgICAvLyB0cmF2ZXJzZSBpdHNlbGYgaW4gY2FzZSBpdCBtb3ZlcyB0aGUgbm9kZSBhcm91bmRcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9uRXhpdCA9IGZuKG5vZGUsIHByb3AsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob25FeGl0KVxuICAgICAgICAgICAgICAgICAgICAgICAgZXhpdEZucy5wdXNoKG9uRXhpdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV4aXRGbnM7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5jb25zdCBQVVJFX0FOTk9UQVRJT04gPSBgLyojX19QVVJFX18qL2A7XG5jb25zdCBhbGlhc0hlbHBlciA9IChzKSA9PiBgJHtoZWxwZXJOYW1lTWFwW3NdfTogXyR7aGVscGVyTmFtZU1hcFtzXX1gO1xuZnVuY3Rpb24gY3JlYXRlQ29kZWdlbkNvbnRleHQoYXN0LCB7IG1vZGUgPSAnZnVuY3Rpb24nLCBwcmVmaXhJZGVudGlmaWVycyA9IG1vZGUgPT09ICdtb2R1bGUnLCBzb3VyY2VNYXAgPSBmYWxzZSwgZmlsZW5hbWUgPSBgdGVtcGxhdGUudnVlLmh0bWxgLCBzY29wZUlkID0gbnVsbCwgb3B0aW1pemVJbXBvcnRzID0gZmFsc2UsIHJ1bnRpbWVHbG9iYWxOYW1lID0gYFZ1ZWAsIHJ1bnRpbWVNb2R1bGVOYW1lID0gYHZ1ZWAsIHNzclJ1bnRpbWVNb2R1bGVOYW1lID0gJ3Z1ZS9zZXJ2ZXItcmVuZGVyZXInLCBzc3IgPSBmYWxzZSwgaXNUUyA9IGZhbHNlLCBpblNTUiA9IGZhbHNlIH0pIHtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBtb2RlLFxuICAgICAgICBwcmVmaXhJZGVudGlmaWVycyxcbiAgICAgICAgc291cmNlTWFwLFxuICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgc2NvcGVJZCxcbiAgICAgICAgb3B0aW1pemVJbXBvcnRzLFxuICAgICAgICBydW50aW1lR2xvYmFsTmFtZSxcbiAgICAgICAgcnVudGltZU1vZHVsZU5hbWUsXG4gICAgICAgIHNzclJ1bnRpbWVNb2R1bGVOYW1lLFxuICAgICAgICBzc3IsXG4gICAgICAgIGlzVFMsXG4gICAgICAgIGluU1NSLFxuICAgICAgICBzb3VyY2U6IGFzdC5sb2Muc291cmNlLFxuICAgICAgICBjb2RlOiBgYCxcbiAgICAgICAgY29sdW1uOiAxLFxuICAgICAgICBsaW5lOiAxLFxuICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgIGluZGVudExldmVsOiAwLFxuICAgICAgICBwdXJlOiBmYWxzZSxcbiAgICAgICAgbWFwOiB1bmRlZmluZWQsXG4gICAgICAgIGhlbHBlcihrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBgXyR7aGVscGVyTmFtZU1hcFtrZXldfWA7XG4gICAgICAgIH0sXG4gICAgICAgIHB1c2goY29kZSwgbm9kZSkge1xuICAgICAgICAgICAgY29udGV4dC5jb2RlICs9IGNvZGU7XG4gICAgICAgIH0sXG4gICAgICAgIGluZGVudCgpIHtcbiAgICAgICAgICAgIG5ld2xpbmUoKytjb250ZXh0LmluZGVudExldmVsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVpbmRlbnQod2l0aG91dE5ld0xpbmUgPSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKHdpdGhvdXROZXdMaW5lKSB7XG4gICAgICAgICAgICAgICAgLS1jb250ZXh0LmluZGVudExldmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3bGluZSgtLWNvbnRleHQuaW5kZW50TGV2ZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBuZXdsaW5lKCkge1xuICAgICAgICAgICAgbmV3bGluZShjb250ZXh0LmluZGVudExldmVsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gbmV3bGluZShuKSB7XG4gICAgICAgIGNvbnRleHQucHVzaCgnXFxuJyArIGAgIGAucmVwZWF0KG4pKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQ7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZShhc3QsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVDb2RlZ2VuQ29udGV4dChhc3QsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLm9uQ29udGV4dENyZWF0ZWQpXG4gICAgICAgIG9wdGlvbnMub25Db250ZXh0Q3JlYXRlZChjb250ZXh0KTtcbiAgICBjb25zdCB7IG1vZGUsIHB1c2gsIHByZWZpeElkZW50aWZpZXJzLCBpbmRlbnQsIGRlaW5kZW50LCBuZXdsaW5lLCBzY29wZUlkLCBzc3IgfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgaGFzSGVscGVycyA9IGFzdC5oZWxwZXJzLmxlbmd0aCA+IDA7XG4gICAgY29uc3QgdXNlV2l0aEJsb2NrID0gIXByZWZpeElkZW50aWZpZXJzICYmIG1vZGUgIT09ICdtb2R1bGUnO1xuICAgIC8vIHByZWFtYmxlc1xuICAgIC8vIGluIHNldHVwKCkgaW5saW5lIG1vZGUsIHRoZSBwcmVhbWJsZSBpcyBnZW5lcmF0ZWQgaW4gYSBzdWIgY29udGV4dFxuICAgIC8vIGFuZCByZXR1cm5lZCBzZXBhcmF0ZWx5LlxuICAgIGNvbnN0IHByZWFtYmxlQ29udGV4dCA9IGNvbnRleHQ7XG4gICAge1xuICAgICAgICBnZW5GdW5jdGlvblByZWFtYmxlKGFzdCwgcHJlYW1ibGVDb250ZXh0KTtcbiAgICB9XG4gICAgLy8gZW50ZXIgcmVuZGVyIGZ1bmN0aW9uXG4gICAgY29uc3QgZnVuY3Rpb25OYW1lID0gc3NyID8gYHNzclJlbmRlcmAgOiBgcmVuZGVyYDtcbiAgICBjb25zdCBhcmdzID0gc3NyID8gWydfY3R4JywgJ19wdXNoJywgJ19wYXJlbnQnLCAnX2F0dHJzJ10gOiBbJ19jdHgnLCAnX2NhY2hlJ107XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXJncy5qb2luKCcsICcpO1xuICAgIHtcbiAgICAgICAgcHVzaChgZnVuY3Rpb24gJHtmdW5jdGlvbk5hbWV9KCR7c2lnbmF0dXJlfSkge2ApO1xuICAgIH1cbiAgICBpbmRlbnQoKTtcbiAgICBpZiAodXNlV2l0aEJsb2NrKSB7XG4gICAgICAgIHB1c2goYHdpdGggKF9jdHgpIHtgKTtcbiAgICAgICAgaW5kZW50KCk7XG4gICAgICAgIC8vIGZ1bmN0aW9uIG1vZGUgY29uc3QgZGVjbGFyYXRpb25zIHNob3VsZCBiZSBpbnNpZGUgd2l0aCBibG9ja1xuICAgICAgICAvLyBhbHNvIHRoZXkgc2hvdWxkIGJlIHJlbmFtZWQgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggdXNlciBwcm9wZXJ0aWVzXG4gICAgICAgIGlmIChoYXNIZWxwZXJzKSB7XG4gICAgICAgICAgICBwdXNoKGBjb25zdCB7ICR7YXN0LmhlbHBlcnMubWFwKGFsaWFzSGVscGVyKS5qb2luKCcsICcpfSB9ID0gX1Z1ZWApO1xuICAgICAgICAgICAgcHVzaChgXFxuYCk7XG4gICAgICAgICAgICBuZXdsaW5lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZ2VuZXJhdGUgYXNzZXQgcmVzb2x1dGlvbiBzdGF0ZW1lbnRzXG4gICAgaWYgKGFzdC5jb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgICBnZW5Bc3NldHMoYXN0LmNvbXBvbmVudHMsICdjb21wb25lbnQnLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGFzdC5kaXJlY3RpdmVzLmxlbmd0aCB8fCBhc3QudGVtcHMgPiAwKSB7XG4gICAgICAgICAgICBuZXdsaW5lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFzdC5kaXJlY3RpdmVzLmxlbmd0aCkge1xuICAgICAgICBnZW5Bc3NldHMoYXN0LmRpcmVjdGl2ZXMsICdkaXJlY3RpdmUnLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGFzdC50ZW1wcyA+IDApIHtcbiAgICAgICAgICAgIG5ld2xpbmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXN0LmZpbHRlcnMgJiYgYXN0LmZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgIG5ld2xpbmUoKTtcbiAgICAgICAgZ2VuQXNzZXRzKGFzdC5maWx0ZXJzLCAnZmlsdGVyJywgY29udGV4dCk7XG4gICAgICAgIG5ld2xpbmUoKTtcbiAgICB9XG4gICAgaWYgKGFzdC50ZW1wcyA+IDApIHtcbiAgICAgICAgcHVzaChgbGV0IGApO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzdC50ZW1wczsgaSsrKSB7XG4gICAgICAgICAgICBwdXNoKGAke2kgPiAwID8gYCwgYCA6IGBgfV90ZW1wJHtpfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhc3QuY29tcG9uZW50cy5sZW5ndGggfHwgYXN0LmRpcmVjdGl2ZXMubGVuZ3RoIHx8IGFzdC50ZW1wcykge1xuICAgICAgICBwdXNoKGBcXG5gKTtcbiAgICAgICAgbmV3bGluZSgpO1xuICAgIH1cbiAgICAvLyBnZW5lcmF0ZSB0aGUgVk5vZGUgdHJlZSBleHByZXNzaW9uXG4gICAgaWYgKCFzc3IpIHtcbiAgICAgICAgcHVzaChgcmV0dXJuIGApO1xuICAgIH1cbiAgICBpZiAoYXN0LmNvZGVnZW5Ob2RlKSB7XG4gICAgICAgIGdlbk5vZGUoYXN0LmNvZGVnZW5Ob2RlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHB1c2goYG51bGxgKTtcbiAgICB9XG4gICAgaWYgKHVzZVdpdGhCbG9jaykge1xuICAgICAgICBkZWluZGVudCgpO1xuICAgICAgICBwdXNoKGB9YCk7XG4gICAgfVxuICAgIGRlaW5kZW50KCk7XG4gICAgcHVzaChgfWApO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFzdCxcbiAgICAgICAgY29kZTogY29udGV4dC5jb2RlLFxuICAgICAgICBwcmVhbWJsZTogYGAsXG4gICAgICAgIC8vIFNvdXJjZU1hcEdlbmVyYXRvciBkb2VzIGhhdmUgdG9KU09OKCkgbWV0aG9kIGJ1dCBpdCdzIG5vdCBpbiB0aGUgdHlwZXNcbiAgICAgICAgbWFwOiBjb250ZXh0Lm1hcCA/IGNvbnRleHQubWFwLnRvSlNPTigpIDogdW5kZWZpbmVkXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdlbkZ1bmN0aW9uUHJlYW1ibGUoYXN0LCBjb250ZXh0KSB7XG4gICAgY29uc3QgeyBzc3IsIHByZWZpeElkZW50aWZpZXJzLCBwdXNoLCBuZXdsaW5lLCBydW50aW1lTW9kdWxlTmFtZSwgcnVudGltZUdsb2JhbE5hbWUsIHNzclJ1bnRpbWVNb2R1bGVOYW1lIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IFZ1ZUJpbmRpbmcgPSBydW50aW1lR2xvYmFsTmFtZTtcbiAgICAvLyBHZW5lcmF0ZSBjb25zdCBkZWNsYXJhdGlvbiBmb3IgaGVscGVyc1xuICAgIC8vIEluIHByZWZpeCBtb2RlLCB3ZSBwbGFjZSB0aGUgY29uc3QgZGVjbGFyYXRpb24gYXQgdG9wIHNvIGl0J3MgZG9uZVxuICAgIC8vIG9ubHkgb25jZTsgQnV0IGlmIHdlIG5vdCBwcmVmaXhpbmcsIHdlIHBsYWNlIHRoZSBkZWNsYXJhdGlvbiBpbnNpZGUgdGhlXG4gICAgLy8gd2l0aCBibG9jayBzbyBpdCBkb2Vzbid0IGluY3VyIHRoZSBgaW5gIGNoZWNrIGNvc3QgZm9yIGV2ZXJ5IGhlbHBlciBhY2Nlc3MuXG4gICAgaWYgKGFzdC5oZWxwZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gXCJ3aXRoXCIgbW9kZS5cbiAgICAgICAgICAgIC8vIHNhdmUgVnVlIGluIGEgc2VwYXJhdGUgdmFyaWFibGUgdG8gYXZvaWQgY29sbGlzaW9uXG4gICAgICAgICAgICBwdXNoKGBjb25zdCBfVnVlID0gJHtWdWVCaW5kaW5nfVxcbmApO1xuICAgICAgICAgICAgLy8gaW4gXCJ3aXRoXCIgbW9kZSwgaGVscGVycyBhcmUgZGVjbGFyZWQgaW5zaWRlIHRoZSB3aXRoIGJsb2NrIHRvIGF2b2lkXG4gICAgICAgICAgICAvLyBoYXMgY2hlY2sgY29zdCwgYnV0IGhvaXN0cyBhcmUgbGlmdGVkIG91dCBvZiB0aGUgZnVuY3Rpb24gLSB3ZSBuZWVkXG4gICAgICAgICAgICAvLyB0byBwcm92aWRlIHRoZSBoZWxwZXIgaGVyZS5cbiAgICAgICAgICAgIGlmIChhc3QuaG9pc3RzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRpY0hlbHBlcnMgPSBbXG4gICAgICAgICAgICAgICAgICAgIENSRUFURV9WTk9ERSxcbiAgICAgICAgICAgICAgICAgICAgQ1JFQVRFX0VMRU1FTlRfVk5PREUsXG4gICAgICAgICAgICAgICAgICAgIENSRUFURV9DT01NRU5ULFxuICAgICAgICAgICAgICAgICAgICBDUkVBVEVfVEVYVCxcbiAgICAgICAgICAgICAgICAgICAgQ1JFQVRFX1NUQVRJQ1xuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihoZWxwZXIgPT4gYXN0LmhlbHBlcnMuaW5jbHVkZXMoaGVscGVyKSlcbiAgICAgICAgICAgICAgICAgICAgLm1hcChhbGlhc0hlbHBlcilcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgICAgICAgICAgICAgcHVzaChgY29uc3QgeyAke3N0YXRpY0hlbHBlcnN9IH0gPSBfVnVlXFxuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2VuSG9pc3RzKGFzdC5ob2lzdHMsIGNvbnRleHQpO1xuICAgIG5ld2xpbmUoKTtcbiAgICBwdXNoKGByZXR1cm4gYCk7XG59XG5mdW5jdGlvbiBnZW5Bc3NldHMoYXNzZXRzLCB0eXBlLCB7IGhlbHBlciwgcHVzaCwgbmV3bGluZSwgaXNUUyB9KSB7XG4gICAgY29uc3QgcmVzb2x2ZXIgPSBoZWxwZXIodHlwZSA9PT0gJ2ZpbHRlcidcbiAgICAgICAgPyBSRVNPTFZFX0ZJTFRFUlxuICAgICAgICA6IHR5cGUgPT09ICdjb21wb25lbnQnXG4gICAgICAgICAgICA/IFJFU09MVkVfQ09NUE9ORU5UXG4gICAgICAgICAgICA6IFJFU09MVkVfRElSRUNUSVZFKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzc2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgaWQgPSBhc3NldHNbaV07XG4gICAgICAgIC8vIHBvdGVudGlhbCBjb21wb25lbnQgaW1wbGljaXQgc2VsZi1yZWZlcmVuY2UgaW5mZXJyZWQgZnJvbSBTRkMgZmlsZW5hbWVcbiAgICAgICAgY29uc3QgbWF5YmVTZWxmUmVmZXJlbmNlID0gaWQuZW5kc1dpdGgoJ19fc2VsZicpO1xuICAgICAgICBpZiAobWF5YmVTZWxmUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICBpZCA9IGlkLnNsaWNlKDAsIC02KTtcbiAgICAgICAgfVxuICAgICAgICBwdXNoKGBjb25zdCAke3RvVmFsaWRBc3NldElkKGlkLCB0eXBlKX0gPSAke3Jlc29sdmVyfSgke0pTT04uc3RyaW5naWZ5KGlkKX0ke21heWJlU2VsZlJlZmVyZW5jZSA/IGAsIHRydWVgIDogYGB9KSR7aXNUUyA/IGAhYCA6IGBgfWApO1xuICAgICAgICBpZiAoaSA8IGFzc2V0cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBuZXdsaW5lKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZW5Ib2lzdHMoaG9pc3RzLCBjb250ZXh0KSB7XG4gICAgaWYgKCFob2lzdHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29udGV4dC5wdXJlID0gdHJ1ZTtcbiAgICBjb25zdCB7IHB1c2gsIG5ld2xpbmUsIGhlbHBlciwgc2NvcGVJZCwgbW9kZSB9ID0gY29udGV4dDtcbiAgICBuZXdsaW5lKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBob2lzdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZXhwID0gaG9pc3RzW2ldO1xuICAgICAgICBpZiAoZXhwKSB7XG4gICAgICAgICAgICBwdXNoKGBjb25zdCBfaG9pc3RlZF8ke2kgKyAxfSA9ICR7YGB9YCk7XG4gICAgICAgICAgICBnZW5Ob2RlKGV4cCwgY29udGV4dCk7XG4gICAgICAgICAgICBuZXdsaW5lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29udGV4dC5wdXJlID0gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1RleHQkMShuKSB7XG4gICAgcmV0dXJuIChpc1N0cmluZyhuKSB8fFxuICAgICAgICBuLnR5cGUgPT09IDQgLyogTm9kZVR5cGVzLlNJTVBMRV9FWFBSRVNTSU9OICovIHx8XG4gICAgICAgIG4udHlwZSA9PT0gMiAvKiBOb2RlVHlwZXMuVEVYVCAqLyB8fFxuICAgICAgICBuLnR5cGUgPT09IDUgLyogTm9kZVR5cGVzLklOVEVSUE9MQVRJT04gKi8gfHxcbiAgICAgICAgbi50eXBlID09PSA4IC8qIE5vZGVUeXBlcy5DT01QT1VORF9FWFBSRVNTSU9OICovKTtcbn1cbmZ1bmN0aW9uIGdlbk5vZGVMaXN0QXNBcnJheShub2RlcywgY29udGV4dCkge1xuICAgIGNvbnN0IG11bHRpbGluZXMgPSBub2Rlcy5sZW5ndGggPiAzIHx8XG4gICAgICAgICgoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSAmJiBub2Rlcy5zb21lKG4gPT4gaXNBcnJheShuKSB8fCAhaXNUZXh0JDEobikpKTtcbiAgICBjb250ZXh0LnB1c2goYFtgKTtcbiAgICBtdWx0aWxpbmVzICYmIGNvbnRleHQuaW5kZW50KCk7XG4gICAgZ2VuTm9kZUxpc3Qobm9kZXMsIGNvbnRleHQsIG11bHRpbGluZXMpO1xuICAgIG11bHRpbGluZXMgJiYgY29udGV4dC5kZWluZGVudCgpO1xuICAgIGNvbnRleHQucHVzaChgXWApO1xufVxuZnVuY3Rpb24gZ2VuTm9kZUxpc3Qobm9kZXMsIGNvbnRleHQsIG11bHRpbGluZXMgPSBmYWxzZSwgY29tbWEgPSB0cnVlKSB7XG4gICAgY29uc3QgeyBwdXNoLCBuZXdsaW5lIH0gPSBjb250ZXh0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAoaXNTdHJpbmcobm9kZSkpIHtcbiAgICAgICAgICAgIHB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgICAgICAgZ2VuTm9kZUxpc3RBc0FycmF5KG5vZGUsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2VuTm9kZShub2RlLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA8IG5vZGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGlmIChtdWx0aWxpbmVzKSB7XG4gICAgICAgICAgICAgICAgY29tbWEgJiYgcHVzaCgnLCcpO1xuICAgICAgICAgICAgICAgIG5ld2xpbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbW1hICYmIHB1c2goJywgJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZW5Ob2RlKG5vZGUsIGNvbnRleHQpIHtcbiAgICBpZiAoaXNTdHJpbmcobm9kZSkpIHtcbiAgICAgICAgY29udGV4dC5wdXNoKG5vZGUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChub2RlKSkge1xuICAgICAgICBjb250ZXh0LnB1c2goY29udGV4dC5oZWxwZXIobm9kZSkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLzpcbiAgICAgICAgY2FzZSA5IC8qIE5vZGVUeXBlcy5JRiAqLzpcbiAgICAgICAgY2FzZSAxMSAvKiBOb2RlVHlwZXMuRk9SICovOlxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICAgICAgYXNzZXJ0KG5vZGUuY29kZWdlbk5vZGUgIT0gbnVsbCwgYENvZGVnZW4gbm9kZSBpcyBtaXNzaW5nIGZvciBlbGVtZW50L2lmL2ZvciBub2RlLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYEFwcGx5IGFwcHJvcHJpYXRlIHRyYW5zZm9ybXMgZmlyc3QuYCk7XG4gICAgICAgICAgICBnZW5Ob2RlKG5vZGUuY29kZWdlbk5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMiAvKiBOb2RlVHlwZXMuVEVYVCAqLzpcbiAgICAgICAgICAgIGdlblRleHQobm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLzpcbiAgICAgICAgICAgIGdlbkV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1IC8qIE5vZGVUeXBlcy5JTlRFUlBPTEFUSU9OICovOlxuICAgICAgICAgICAgZ2VuSW50ZXJwb2xhdGlvbihub2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEyIC8qIE5vZGVUeXBlcy5URVhUX0NBTEwgKi86XG4gICAgICAgICAgICBnZW5Ob2RlKG5vZGUuY29kZWdlbk5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgOCAvKiBOb2RlVHlwZXMuQ09NUE9VTkRfRVhQUkVTU0lPTiAqLzpcbiAgICAgICAgICAgIGdlbkNvbXBvdW5kRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMgLyogTm9kZVR5cGVzLkNPTU1FTlQgKi86XG4gICAgICAgICAgICBnZW5Db21tZW50KG5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTMgLyogTm9kZVR5cGVzLlZOT0RFX0NBTEwgKi86XG4gICAgICAgICAgICBnZW5WTm9kZUNhbGwobm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxNCAvKiBOb2RlVHlwZXMuSlNfQ0FMTF9FWFBSRVNTSU9OICovOlxuICAgICAgICAgICAgZ2VuQ2FsbEV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxNSAvKiBOb2RlVHlwZXMuSlNfT0JKRUNUX0VYUFJFU1NJT04gKi86XG4gICAgICAgICAgICBnZW5PYmplY3RFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTcgLyogTm9kZVR5cGVzLkpTX0FSUkFZX0VYUFJFU1NJT04gKi86XG4gICAgICAgICAgICBnZW5BcnJheUV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOCAvKiBOb2RlVHlwZXMuSlNfRlVOQ1RJT05fRVhQUkVTU0lPTiAqLzpcbiAgICAgICAgICAgIGdlbkZ1bmN0aW9uRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE5IC8qIE5vZGVUeXBlcy5KU19DT05ESVRJT05BTF9FWFBSRVNTSU9OICovOlxuICAgICAgICAgICAgZ2VuQ29uZGl0aW9uYWxFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjAgLyogTm9kZVR5cGVzLkpTX0NBQ0hFX0VYUFJFU1NJT04gKi86XG4gICAgICAgICAgICBnZW5DYWNoZUV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMSAvKiBOb2RlVHlwZXMuSlNfQkxPQ0tfU1RBVEVNRU5UICovOlxuICAgICAgICAgICAgZ2VuTm9kZUxpc3Qobm9kZS5ib2R5LCBjb250ZXh0LCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gU1NSIG9ubHkgdHlwZXNcbiAgICAgICAgY2FzZSAyMiAvKiBOb2RlVHlwZXMuSlNfVEVNUExBVEVfTElURVJBTCAqLzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIzIC8qIE5vZGVUeXBlcy5KU19JRl9TVEFURU1FTlQgKi86XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNCAvKiBOb2RlVHlwZXMuSlNfQVNTSUdOTUVOVF9FWFBSRVNTSU9OICovOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjUgLyogTm9kZVR5cGVzLkpTX1NFUVVFTkNFX0VYUFJFU1NJT04gKi86XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNiAvKiBOb2RlVHlwZXMuSlNfUkVUVVJOX1NUQVRFTUVOVCAqLzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBjYXNlIDEwIC8qIE5vZGVUeXBlcy5JRl9CUkFOQ0ggKi86XG4gICAgICAgICAgICAvLyBub29wXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQoZmFsc2UsIGB1bmhhbmRsZWQgY29kZWdlbiBub2RlIHR5cGU6ICR7bm9kZS50eXBlfWApO1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBleGhhdXN0IGFsbCBwb3NzaWJsZSB0eXBlc1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4aGF1c3RpdmVDaGVjayA9IG5vZGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aGF1c3RpdmVDaGVjaztcbiAgICAgICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZW5UZXh0KG5vZGUsIGNvbnRleHQpIHtcbiAgICBjb250ZXh0LnB1c2goSlNPTi5zdHJpbmdpZnkobm9kZS5jb250ZW50KSwgbm9kZSk7XG59XG5mdW5jdGlvbiBnZW5FeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7IGNvbnRlbnQsIGlzU3RhdGljIH0gPSBub2RlO1xuICAgIGNvbnRleHQucHVzaChpc1N0YXRpYyA/IEpTT04uc3RyaW5naWZ5KGNvbnRlbnQpIDogY29udGVudCwgbm9kZSk7XG59XG5mdW5jdGlvbiBnZW5JbnRlcnBvbGF0aW9uKG5vZGUsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7IHB1c2gsIGhlbHBlciwgcHVyZSB9ID0gY29udGV4dDtcbiAgICBpZiAocHVyZSlcbiAgICAgICAgcHVzaChQVVJFX0FOTk9UQVRJT04pO1xuICAgIHB1c2goYCR7aGVscGVyKFRPX0RJU1BMQVlfU1RSSU5HKX0oYCk7XG4gICAgZ2VuTm9kZShub2RlLmNvbnRlbnQsIGNvbnRleHQpO1xuICAgIHB1c2goYClgKTtcbn1cbmZ1bmN0aW9uIGdlbkNvbXBvdW5kRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKGlzU3RyaW5nKGNoaWxkKSkge1xuICAgICAgICAgICAgY29udGV4dC5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdlbk5vZGUoY2hpbGQsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2VuRXhwcmVzc2lvbkFzUHJvcGVydHlLZXkobm9kZSwgY29udGV4dCkge1xuICAgIGNvbnN0IHsgcHVzaCB9ID0gY29udGV4dDtcbiAgICBpZiAobm9kZS50eXBlID09PSA4IC8qIE5vZGVUeXBlcy5DT01QT1VORF9FWFBSRVNTSU9OICovKSB7XG4gICAgICAgIHB1c2goYFtgKTtcbiAgICAgICAgZ2VuQ29tcG91bmRFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xuICAgICAgICBwdXNoKGBdYCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUuaXNTdGF0aWMpIHtcbiAgICAgICAgLy8gb25seSBxdW90ZSBrZXlzIGlmIG5lY2Vzc2FyeVxuICAgICAgICBjb25zdCB0ZXh0ID0gaXNTaW1wbGVJZGVudGlmaWVyKG5vZGUuY29udGVudClcbiAgICAgICAgICAgID8gbm9kZS5jb250ZW50XG4gICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KG5vZGUuY29udGVudCk7XG4gICAgICAgIHB1c2godGV4dCwgbm9kZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwdXNoKGBbJHtub2RlLmNvbnRlbnR9XWAsIG5vZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdlbkNvbW1lbnQobm9kZSwgY29udGV4dCkge1xuICAgIGNvbnN0IHsgcHVzaCwgaGVscGVyLCBwdXJlIH0gPSBjb250ZXh0O1xuICAgIGlmIChwdXJlKSB7XG4gICAgICAgIHB1c2goUFVSRV9BTk5PVEFUSU9OKTtcbiAgICB9XG4gICAgcHVzaChgJHtoZWxwZXIoQ1JFQVRFX0NPTU1FTlQpfSgke0pTT04uc3RyaW5naWZ5KG5vZGUuY29udGVudCl9KWAsIG5vZGUpO1xufVxuZnVuY3Rpb24gZ2VuVk5vZGVDYWxsKG5vZGUsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7IHB1c2gsIGhlbHBlciwgcHVyZSB9ID0gY29udGV4dDtcbiAgICBjb25zdCB7IHRhZywgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcywgZGlyZWN0aXZlcywgaXNCbG9jaywgZGlzYWJsZVRyYWNraW5nLCBpc0NvbXBvbmVudCB9ID0gbm9kZTtcbiAgICBpZiAoZGlyZWN0aXZlcykge1xuICAgICAgICBwdXNoKGhlbHBlcihXSVRIX0RJUkVDVElWRVMpICsgYChgKTtcbiAgICB9XG4gICAgaWYgKGlzQmxvY2spIHtcbiAgICAgICAgcHVzaChgKCR7aGVscGVyKE9QRU5fQkxPQ0spfSgke2Rpc2FibGVUcmFja2luZyA/IGB0cnVlYCA6IGBgfSksIGApO1xuICAgIH1cbiAgICBpZiAocHVyZSkge1xuICAgICAgICBwdXNoKFBVUkVfQU5OT1RBVElPTik7XG4gICAgfVxuICAgIGNvbnN0IGNhbGxIZWxwZXIgPSBpc0Jsb2NrXG4gICAgICAgID8gZ2V0Vk5vZGVCbG9ja0hlbHBlcihjb250ZXh0LmluU1NSLCBpc0NvbXBvbmVudClcbiAgICAgICAgOiBnZXRWTm9kZUhlbHBlcihjb250ZXh0LmluU1NSLCBpc0NvbXBvbmVudCk7XG4gICAgcHVzaChoZWxwZXIoY2FsbEhlbHBlcikgKyBgKGAsIG5vZGUpO1xuICAgIGdlbk5vZGVMaXN0KGdlbk51bGxhYmxlQXJncyhbdGFnLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzXSksIGNvbnRleHQpO1xuICAgIHB1c2goYClgKTtcbiAgICBpZiAoaXNCbG9jaykge1xuICAgICAgICBwdXNoKGApYCk7XG4gICAgfVxuICAgIGlmIChkaXJlY3RpdmVzKSB7XG4gICAgICAgIHB1c2goYCwgYCk7XG4gICAgICAgIGdlbk5vZGUoZGlyZWN0aXZlcywgY29udGV4dCk7XG4gICAgICAgIHB1c2goYClgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZW5OdWxsYWJsZUFyZ3MoYXJncykge1xuICAgIGxldCBpID0gYXJncy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpZiAoYXJnc1tpXSAhPSBudWxsKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBhcmdzLnNsaWNlKDAsIGkgKyAxKS5tYXAoYXJnID0+IGFyZyB8fCBgbnVsbGApO1xufVxuLy8gSmF2YVNjcmlwdFxuZnVuY3Rpb24gZ2VuQ2FsbEV4cHJlc3Npb24obm9kZSwgY29udGV4dCkge1xuICAgIGNvbnN0IHsgcHVzaCwgaGVscGVyLCBwdXJlIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IGNhbGxlZSA9IGlzU3RyaW5nKG5vZGUuY2FsbGVlKSA/IG5vZGUuY2FsbGVlIDogaGVscGVyKG5vZGUuY2FsbGVlKTtcbiAgICBpZiAocHVyZSkge1xuICAgICAgICBwdXNoKFBVUkVfQU5OT1RBVElPTik7XG4gICAgfVxuICAgIHB1c2goY2FsbGVlICsgYChgLCBub2RlKTtcbiAgICBnZW5Ob2RlTGlzdChub2RlLmFyZ3VtZW50cywgY29udGV4dCk7XG4gICAgcHVzaChgKWApO1xufVxuZnVuY3Rpb24gZ2VuT2JqZWN0RXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XG4gICAgY29uc3QgeyBwdXNoLCBpbmRlbnQsIGRlaW5kZW50LCBuZXdsaW5lIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IHsgcHJvcGVydGllcyB9ID0gbm9kZTtcbiAgICBpZiAoIXByb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICAgIHB1c2goYHt9YCwgbm9kZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbXVsdGlsaW5lcyA9IHByb3BlcnRpZXMubGVuZ3RoID4gMSB8fFxuICAgICAgICAoKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkgJiZcbiAgICAgICAgICAgIHByb3BlcnRpZXMuc29tZShwID0+IHAudmFsdWUudHlwZSAhPT0gNCAvKiBOb2RlVHlwZXMuU0lNUExFX0VYUFJFU1NJT04gKi8pKTtcbiAgICBwdXNoKG11bHRpbGluZXMgPyBge2AgOiBgeyBgKTtcbiAgICBtdWx0aWxpbmVzICYmIGluZGVudCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IHByb3BlcnRpZXNbaV07XG4gICAgICAgIC8vIGtleVxuICAgICAgICBnZW5FeHByZXNzaW9uQXNQcm9wZXJ0eUtleShrZXksIGNvbnRleHQpO1xuICAgICAgICBwdXNoKGA6IGApO1xuICAgICAgICAvLyB2YWx1ZVxuICAgICAgICBnZW5Ob2RlKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGkgPCBwcm9wZXJ0aWVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIC8vIHdpbGwgb25seSByZWFjaCB0aGlzIGlmIGl0J3MgbXVsdGlsaW5lc1xuICAgICAgICAgICAgcHVzaChgLGApO1xuICAgICAgICAgICAgbmV3bGluZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG11bHRpbGluZXMgJiYgZGVpbmRlbnQoKTtcbiAgICBwdXNoKG11bHRpbGluZXMgPyBgfWAgOiBgIH1gKTtcbn1cbmZ1bmN0aW9uIGdlbkFycmF5RXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XG4gICAgZ2VuTm9kZUxpc3RBc0FycmF5KG5vZGUuZWxlbWVudHMsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gZ2VuRnVuY3Rpb25FeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7IHB1c2gsIGluZGVudCwgZGVpbmRlbnQgfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgeyBwYXJhbXMsIHJldHVybnMsIGJvZHksIG5ld2xpbmUsIGlzU2xvdCB9ID0gbm9kZTtcbiAgICBpZiAoaXNTbG90KSB7XG4gICAgICAgIC8vIHdyYXAgc2xvdCBmdW5jdGlvbnMgd2l0aCBvd25lciBjb250ZXh0XG4gICAgICAgIHB1c2goYF8ke2hlbHBlck5hbWVNYXBbV0lUSF9DVFhdfShgKTtcbiAgICB9XG4gICAgcHVzaChgKGAsIG5vZGUpO1xuICAgIGlmIChpc0FycmF5KHBhcmFtcykpIHtcbiAgICAgICAgZ2VuTm9kZUxpc3QocGFyYW1zLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFyYW1zKSB7XG4gICAgICAgIGdlbk5vZGUocGFyYW1zLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcHVzaChgKSA9PiBgKTtcbiAgICBpZiAobmV3bGluZSB8fCBib2R5KSB7XG4gICAgICAgIHB1c2goYHtgKTtcbiAgICAgICAgaW5kZW50KCk7XG4gICAgfVxuICAgIGlmIChyZXR1cm5zKSB7XG4gICAgICAgIGlmIChuZXdsaW5lKSB7XG4gICAgICAgICAgICBwdXNoKGByZXR1cm4gYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkocmV0dXJucykpIHtcbiAgICAgICAgICAgIGdlbk5vZGVMaXN0QXNBcnJheShyZXR1cm5zLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdlbk5vZGUocmV0dXJucywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYm9keSkge1xuICAgICAgICBnZW5Ob2RlKGJvZHksIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAobmV3bGluZSB8fCBib2R5KSB7XG4gICAgICAgIGRlaW5kZW50KCk7XG4gICAgICAgIHB1c2goYH1gKTtcbiAgICB9XG4gICAgaWYgKGlzU2xvdCkge1xuICAgICAgICBpZiAobm9kZS5pc05vblNjb3BlZFNsb3QpIHtcbiAgICAgICAgICAgIHB1c2goYCwgdW5kZWZpbmVkLCB0cnVlYCk7XG4gICAgICAgIH1cbiAgICAgICAgcHVzaChgKWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdlbkNvbmRpdGlvbmFsRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XG4gICAgY29uc3QgeyB0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUsIG5ld2xpbmU6IG5lZWROZXdsaW5lIH0gPSBub2RlO1xuICAgIGNvbnN0IHsgcHVzaCwgaW5kZW50LCBkZWluZGVudCwgbmV3bGluZSB9ID0gY29udGV4dDtcbiAgICBpZiAodGVzdC50eXBlID09PSA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLykge1xuICAgICAgICBjb25zdCBuZWVkc1BhcmVucyA9ICFpc1NpbXBsZUlkZW50aWZpZXIodGVzdC5jb250ZW50KTtcbiAgICAgICAgbmVlZHNQYXJlbnMgJiYgcHVzaChgKGApO1xuICAgICAgICBnZW5FeHByZXNzaW9uKHRlc3QsIGNvbnRleHQpO1xuICAgICAgICBuZWVkc1BhcmVucyAmJiBwdXNoKGApYCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwdXNoKGAoYCk7XG4gICAgICAgIGdlbk5vZGUodGVzdCwgY29udGV4dCk7XG4gICAgICAgIHB1c2goYClgKTtcbiAgICB9XG4gICAgbmVlZE5ld2xpbmUgJiYgaW5kZW50KCk7XG4gICAgY29udGV4dC5pbmRlbnRMZXZlbCsrO1xuICAgIG5lZWROZXdsaW5lIHx8IHB1c2goYCBgKTtcbiAgICBwdXNoKGA/IGApO1xuICAgIGdlbk5vZGUoY29uc2VxdWVudCwgY29udGV4dCk7XG4gICAgY29udGV4dC5pbmRlbnRMZXZlbC0tO1xuICAgIG5lZWROZXdsaW5lICYmIG5ld2xpbmUoKTtcbiAgICBuZWVkTmV3bGluZSB8fCBwdXNoKGAgYCk7XG4gICAgcHVzaChgOiBgKTtcbiAgICBjb25zdCBpc05lc3RlZCA9IGFsdGVybmF0ZS50eXBlID09PSAxOSAvKiBOb2RlVHlwZXMuSlNfQ09ORElUSU9OQUxfRVhQUkVTU0lPTiAqLztcbiAgICBpZiAoIWlzTmVzdGVkKSB7XG4gICAgICAgIGNvbnRleHQuaW5kZW50TGV2ZWwrKztcbiAgICB9XG4gICAgZ2VuTm9kZShhbHRlcm5hdGUsIGNvbnRleHQpO1xuICAgIGlmICghaXNOZXN0ZWQpIHtcbiAgICAgICAgY29udGV4dC5pbmRlbnRMZXZlbC0tO1xuICAgIH1cbiAgICBuZWVkTmV3bGluZSAmJiBkZWluZGVudCh0cnVlIC8qIHdpdGhvdXQgbmV3bGluZSAqLyk7XG59XG5mdW5jdGlvbiBnZW5DYWNoZUV4cHJlc3Npb24obm9kZSwgY29udGV4dCkge1xuICAgIGNvbnN0IHsgcHVzaCwgaGVscGVyLCBpbmRlbnQsIGRlaW5kZW50LCBuZXdsaW5lIH0gPSBjb250ZXh0O1xuICAgIHB1c2goYF9jYWNoZVske25vZGUuaW5kZXh9XSB8fCAoYCk7XG4gICAgaWYgKG5vZGUuaXNWTm9kZSkge1xuICAgICAgICBpbmRlbnQoKTtcbiAgICAgICAgcHVzaChgJHtoZWxwZXIoU0VUX0JMT0NLX1RSQUNLSU5HKX0oLTEpLGApO1xuICAgICAgICBuZXdsaW5lKCk7XG4gICAgfVxuICAgIHB1c2goYF9jYWNoZVske25vZGUuaW5kZXh9XSA9IGApO1xuICAgIGdlbk5vZGUobm9kZS52YWx1ZSwgY29udGV4dCk7XG4gICAgaWYgKG5vZGUuaXNWTm9kZSkge1xuICAgICAgICBwdXNoKGAsYCk7XG4gICAgICAgIG5ld2xpbmUoKTtcbiAgICAgICAgcHVzaChgJHtoZWxwZXIoU0VUX0JMT0NLX1RSQUNLSU5HKX0oMSksYCk7XG4gICAgICAgIG5ld2xpbmUoKTtcbiAgICAgICAgcHVzaChgX2NhY2hlWyR7bm9kZS5pbmRleH1dYCk7XG4gICAgICAgIGRlaW5kZW50KCk7XG4gICAgfVxuICAgIHB1c2goYClgKTtcbn1cblxuZnVuY3Rpb24gd2Fsa0lkZW50aWZpZXJzKHJvb3QsIG9uSWRlbnRpZmllciwgaW5jbHVkZUFsbCA9IGZhbHNlLCBwYXJlbnRTdGFjayA9IFtdLCBrbm93bklkcyA9IE9iamVjdC5jcmVhdGUobnVsbCkpIHtcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1JlZmVyZW5jZWRJZGVudGlmaWVyKGlkLCBwYXJlbnQsIHBhcmVudFN0YWNrKSB7XG4gICAge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNJbkRlc3RydWN0dXJlQXNzaWdubWVudChwYXJlbnQsIHBhcmVudFN0YWNrKSB7XG4gICAgaWYgKHBhcmVudCAmJlxuICAgICAgICAocGFyZW50LnR5cGUgPT09ICdPYmplY3RQcm9wZXJ0eScgfHwgcGFyZW50LnR5cGUgPT09ICdBcnJheVBhdHRlcm4nKSkge1xuICAgICAgICBsZXQgaSA9IHBhcmVudFN0YWNrLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgY29uc3QgcCA9IHBhcmVudFN0YWNrW2ldO1xuICAgICAgICAgICAgaWYgKHAudHlwZSA9PT0gJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocC50eXBlICE9PSAnT2JqZWN0UHJvcGVydHknICYmICFwLnR5cGUuZW5kc1dpdGgoJ1BhdHRlcm4nKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHdhbGtGdW5jdGlvblBhcmFtcyhub2RlLCBvbklkZW50KSB7XG4gICAgZm9yIChjb25zdCBwIG9mIG5vZGUucGFyYW1zKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZXh0cmFjdElkZW50aWZpZXJzKHApKSB7XG4gICAgICAgICAgICBvbklkZW50KGlkKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHdhbGtCbG9ja0RlY2xhcmF0aW9ucyhibG9jaywgb25JZGVudCkge1xuICAgIGZvciAoY29uc3Qgc3RtdCBvZiBibG9jay5ib2R5KSB7XG4gICAgICAgIGlmIChzdG10LnR5cGUgPT09ICdWYXJpYWJsZURlY2xhcmF0aW9uJykge1xuICAgICAgICAgICAgaWYgKHN0bXQuZGVjbGFyZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGVjbCBvZiBzdG10LmRlY2xhcmF0aW9ucykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaWQgb2YgZXh0cmFjdElkZW50aWZpZXJzKGRlY2wuaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uSWRlbnQoaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdG10LnR5cGUgPT09ICdGdW5jdGlvbkRlY2xhcmF0aW9uJyB8fFxuICAgICAgICAgICAgc3RtdC50eXBlID09PSAnQ2xhc3NEZWNsYXJhdGlvbicpIHtcbiAgICAgICAgICAgIGlmIChzdG10LmRlY2xhcmUgfHwgIXN0bXQuaWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBvbklkZW50KHN0bXQuaWQpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZXh0cmFjdElkZW50aWZpZXJzKHBhcmFtLCBub2RlcyA9IFtdKSB7XG4gICAgc3dpdGNoIChwYXJhbS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ0lkZW50aWZpZXInOlxuICAgICAgICAgICAgbm9kZXMucHVzaChwYXJhbSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTWVtYmVyRXhwcmVzc2lvbic6XG4gICAgICAgICAgICBsZXQgb2JqZWN0ID0gcGFyYW07XG4gICAgICAgICAgICB3aGlsZSAob2JqZWN0LnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJykge1xuICAgICAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5vYmplY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2Rlcy5wdXNoKG9iamVjdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnT2JqZWN0UGF0dGVybic6XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgcGFyYW0ucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wLnR5cGUgPT09ICdSZXN0RWxlbWVudCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFjdElkZW50aWZpZXJzKHByb3AuYXJndW1lbnQsIG5vZGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhY3RJZGVudGlmaWVycyhwcm9wLnZhbHVlLCBub2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0FycmF5UGF0dGVybic6XG4gICAgICAgICAgICBwYXJhbS5lbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICBleHRyYWN0SWRlbnRpZmllcnMoZWxlbWVudCwgbm9kZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUmVzdEVsZW1lbnQnOlxuICAgICAgICAgICAgZXh0cmFjdElkZW50aWZpZXJzKHBhcmFtLmFyZ3VtZW50LCBub2Rlcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQXNzaWdubWVudFBhdHRlcm4nOlxuICAgICAgICAgICAgZXh0cmFjdElkZW50aWZpZXJzKHBhcmFtLmxlZnQsIG5vZGVzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXM7XG59XG5jb25zdCBpc0Z1bmN0aW9uVHlwZSA9IChub2RlKSA9PiB7XG4gICAgcmV0dXJuIC9GdW5jdGlvbig/OkV4cHJlc3Npb258RGVjbGFyYXRpb24pJHxNZXRob2QkLy50ZXN0KG5vZGUudHlwZSk7XG59O1xuY29uc3QgaXNTdGF0aWNQcm9wZXJ0eSA9IChub2RlKSA9PiBub2RlICYmXG4gICAgKG5vZGUudHlwZSA9PT0gJ09iamVjdFByb3BlcnR5JyB8fCBub2RlLnR5cGUgPT09ICdPYmplY3RNZXRob2QnKSAmJlxuICAgICFub2RlLmNvbXB1dGVkO1xuY29uc3QgaXNTdGF0aWNQcm9wZXJ0eUtleSA9IChub2RlLCBwYXJlbnQpID0+IGlzU3RhdGljUHJvcGVydHkocGFyZW50KSAmJiBwYXJlbnQua2V5ID09PSBub2RlO1xuXG4vLyB0aGVzZSBrZXl3b3JkcyBzaG91bGQgbm90IGFwcGVhciBpbnNpZGUgZXhwcmVzc2lvbnMsIGJ1dCBvcGVyYXRvcnMgbGlrZVxuLy8gdHlwZW9mLCBpbnN0YW5jZW9mIGFuZCBpbiBhcmUgYWxsb3dlZFxuY29uc3QgcHJvaGliaXRlZEtleXdvcmRSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArXG4gICAgKCdkbyxpZixmb3IsbGV0LG5ldyx0cnksdmFyLGNhc2UsZWxzZSx3aXRoLGF3YWl0LGJyZWFrLGNhdGNoLGNsYXNzLGNvbnN0LCcgK1xuICAgICAgICAnc3VwZXIsdGhyb3csd2hpbGUseWllbGQsZGVsZXRlLGV4cG9ydCxpbXBvcnQscmV0dXJuLHN3aXRjaCxkZWZhdWx0LCcgK1xuICAgICAgICAnZXh0ZW5kcyxmaW5hbGx5LGNvbnRpbnVlLGRlYnVnZ2VyLGZ1bmN0aW9uLGFyZ3VtZW50cyx0eXBlb2Ysdm9pZCcpXG4gICAgICAgIC5zcGxpdCgnLCcpXG4gICAgICAgIC5qb2luKCdcXFxcYnxcXFxcYicpICtcbiAgICAnXFxcXGInKTtcbi8vIHN0cmlwIHN0cmluZ3MgaW4gZXhwcmVzc2lvbnNcbmNvbnN0IHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcbi8qKlxuICogVmFsaWRhdGUgYSBub24tcHJlZml4ZWQgZXhwcmVzc2lvbi5cbiAqIFRoaXMgaXMgb25seSBjYWxsZWQgd2hlbiB1c2luZyB0aGUgaW4tYnJvd3NlciBydW50aW1lIGNvbXBpbGVyIHNpbmNlIGl0XG4gKiBkb2Vzbid0IHByZWZpeCBleHByZXNzaW9ucy5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihub2RlLCBjb250ZXh0LCBhc1BhcmFtcyA9IGZhbHNlLCBhc1Jhd1N0YXRlbWVudHMgPSBmYWxzZSkge1xuICAgIGNvbnN0IGV4cCA9IG5vZGUuY29udGVudDtcbiAgICAvLyBlbXB0eSBleHByZXNzaW9ucyBhcmUgdmFsaWRhdGVkIHBlci1kaXJlY3RpdmUgc2luY2Ugc29tZSBkaXJlY3RpdmVzXG4gICAgLy8gZG8gYWxsb3cgZW1wdHkgZXhwcmVzc2lvbnMuXG4gICAgaWYgKCFleHAudHJpbSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgbmV3IEZ1bmN0aW9uKGFzUmF3U3RhdGVtZW50c1xuICAgICAgICAgICAgPyBgICR7ZXhwfSBgXG4gICAgICAgICAgICA6IGByZXR1cm4gJHthc1BhcmFtcyA/IGAoJHtleHB9KSA9PiB7fWAgOiBgKCR7ZXhwfSlgfWApO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IGUubWVzc2FnZTtcbiAgICAgICAgY29uc3Qga2V5d29yZE1hdGNoID0gZXhwXG4gICAgICAgICAgICAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJylcbiAgICAgICAgICAgIC5tYXRjaChwcm9oaWJpdGVkS2V5d29yZFJFKTtcbiAgICAgICAgaWYgKGtleXdvcmRNYXRjaCkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGBhdm9pZCB1c2luZyBKYXZhU2NyaXB0IGtleXdvcmQgYXMgcHJvcGVydHkgbmFtZTogXCIke2tleXdvcmRNYXRjaFswXX1cImA7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDUgLyogRXJyb3JDb2Rlcy5YX0lOVkFMSURfRVhQUkVTU0lPTiAqLywgbm9kZS5sb2MsIHVuZGVmaW5lZCwgbWVzc2FnZSkpO1xuICAgIH1cbn1cblxuY29uc3QgdHJhbnNmb3JtRXhwcmVzc2lvbiA9IChub2RlLCBjb250ZXh0KSA9PiB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gNSAvKiBOb2RlVHlwZXMuSU5URVJQT0xBVElPTiAqLykge1xuICAgICAgICBub2RlLmNvbnRlbnQgPSBwcm9jZXNzRXhwcmVzc2lvbihub2RlLmNvbnRlbnQsIGNvbnRleHQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlLnR5cGUgPT09IDEgLyogTm9kZVR5cGVzLkVMRU1FTlQgKi8pIHtcbiAgICAgICAgLy8gaGFuZGxlIGRpcmVjdGl2ZXMgb24gZWxlbWVudFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUucHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGRpciA9IG5vZGUucHJvcHNbaV07XG4gICAgICAgICAgICAvLyBkbyBub3QgcHJvY2VzcyBmb3Igdi1vbiAmIHYtZm9yIHNpbmNlIHRoZXkgYXJlIHNwZWNpYWwgaGFuZGxlZFxuICAgICAgICAgICAgaWYgKGRpci50eXBlID09PSA3IC8qIE5vZGVUeXBlcy5ESVJFQ1RJVkUgKi8gJiYgZGlyLm5hbWUgIT09ICdmb3InKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwID0gZGlyLmV4cDtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmcgPSBkaXIuYXJnO1xuICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBwcm9jZXNzIGV4cCBpZiB0aGlzIGlzIHYtb246YXJnIC0gd2UgbmVlZCBzcGVjaWFsIGhhbmRsaW5nXG4gICAgICAgICAgICAgICAgLy8gZm9yIHdyYXBwaW5nIGlubGluZSBzdGF0ZW1lbnRzLlxuICAgICAgICAgICAgICAgIGlmIChleHAgJiZcbiAgICAgICAgICAgICAgICAgICAgZXhwLnR5cGUgPT09IDQgLyogTm9kZVR5cGVzLlNJTVBMRV9FWFBSRVNTSU9OICovICYmXG4gICAgICAgICAgICAgICAgICAgICEoZGlyLm5hbWUgPT09ICdvbicgJiYgYXJnKSkge1xuICAgICAgICAgICAgICAgICAgICBkaXIuZXhwID0gcHJvY2Vzc0V4cHJlc3Npb24oZXhwLCBjb250ZXh0LCBcbiAgICAgICAgICAgICAgICAgICAgLy8gc2xvdCBhcmdzIG11c3QgYmUgcHJvY2Vzc2VkIGFzIGZ1bmN0aW9uIHBhcmFtc1xuICAgICAgICAgICAgICAgICAgICBkaXIubmFtZSA9PT0gJ3Nsb3QnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFyZyAmJiBhcmcudHlwZSA9PT0gNCAvKiBOb2RlVHlwZXMuU0lNUExFX0VYUFJFU1NJT04gKi8gJiYgIWFyZy5pc1N0YXRpYykge1xuICAgICAgICAgICAgICAgICAgICBkaXIuYXJnID0gcHJvY2Vzc0V4cHJlc3Npb24oYXJnLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuLy8gSW1wb3J0YW50OiBzaW5jZSB0aGlzIGZ1bmN0aW9uIHVzZXMgTm9kZS5qcyBvbmx5IGRlcGVuZGVuY2llcywgaXQgc2hvdWxkXG4vLyBhbHdheXMgYmUgdXNlZCB3aXRoIGEgbGVhZGluZyAhdHJ1ZSBjaGVjayBzbyB0aGF0IGl0IGNhbiBiZVxuLy8gdHJlZS1zaGFrZW4gZnJvbSB0aGUgYnJvd3NlciBidWlsZC5cbmZ1bmN0aW9uIHByb2Nlc3NFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQsIFxuLy8gc29tZSBleHByZXNzaW9ucyBsaWtlIHYtc2xvdCBwcm9wcyAmIHYtZm9yIGFsaWFzZXMgc2hvdWxkIGJlIHBhcnNlZCBhc1xuLy8gZnVuY3Rpb24gcGFyYW1zXG5hc1BhcmFtcyA9IGZhbHNlLCBcbi8vIHYtb24gaGFuZGxlciB2YWx1ZXMgbWF5IGNvbnRhaW4gbXVsdGlwbGUgc3RhdGVtZW50c1xuYXNSYXdTdGF0ZW1lbnRzID0gZmFsc2UsIGxvY2FsVmFycyA9IE9iamVjdC5jcmVhdGUoY29udGV4dC5pZGVudGlmaWVycykpIHtcbiAgICB7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgIC8vIHNpbXBsZSBpbi1icm93c2VyIHZhbGlkYXRpb24gKHNhbWUgbG9naWMgaW4gMi54KVxuICAgICAgICAgICAgdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihub2RlLCBjb250ZXh0LCBhc1BhcmFtcywgYXNSYXdTdGF0ZW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlFeHByZXNzaW9uKGV4cCkge1xuICAgIGlmIChpc1N0cmluZyhleHApKSB7XG4gICAgICAgIHJldHVybiBleHA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cC50eXBlID09PSA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLykge1xuICAgICAgICByZXR1cm4gZXhwLmNvbnRlbnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZXhwLmNoaWxkcmVuXG4gICAgICAgICAgICAubWFwKHN0cmluZ2lmeUV4cHJlc3Npb24pXG4gICAgICAgICAgICAuam9pbignJyk7XG4gICAgfVxufVxuXG5jb25zdCB0cmFuc2Zvcm1JZiA9IGNyZWF0ZVN0cnVjdHVyYWxEaXJlY3RpdmVUcmFuc2Zvcm0oL14oaWZ8ZWxzZXxlbHNlLWlmKSQvLCAobm9kZSwgZGlyLCBjb250ZXh0KSA9PiB7XG4gICAgcmV0dXJuIHByb2Nlc3NJZihub2RlLCBkaXIsIGNvbnRleHQsIChpZk5vZGUsIGJyYW5jaCwgaXNSb290KSA9PiB7XG4gICAgICAgIC8vICMxNTg3OiBXZSBuZWVkIHRvIGR5bmFtaWNhbGx5IGluY3JlbWVudCB0aGUga2V5IGJhc2VkIG9uIHRoZSBjdXJyZW50XG4gICAgICAgIC8vIG5vZGUncyBzaWJsaW5nIG5vZGVzLCBzaW5jZSBjaGFpbmVkIHYtaWYvZWxzZSBicmFuY2hlcyBhcmVcbiAgICAgICAgLy8gcmVuZGVyZWQgYXQgdGhlIHNhbWUgZGVwdGhcbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSBjb250ZXh0LnBhcmVudC5jaGlsZHJlbjtcbiAgICAgICAgbGV0IGkgPSBzaWJsaW5ncy5pbmRleE9mKGlmTm9kZSk7XG4gICAgICAgIGxldCBrZXkgPSAwO1xuICAgICAgICB3aGlsZSAoaS0tID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBzaWJsaW5nc1tpXTtcbiAgICAgICAgICAgIGlmIChzaWJsaW5nICYmIHNpYmxpbmcudHlwZSA9PT0gOSAvKiBOb2RlVHlwZXMuSUYgKi8pIHtcbiAgICAgICAgICAgICAgICBrZXkgKz0gc2libGluZy5icmFuY2hlcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXhpdCBjYWxsYmFjay4gQ29tcGxldGUgdGhlIGNvZGVnZW5Ob2RlIHdoZW4gYWxsIGNoaWxkcmVuIGhhdmUgYmVlblxuICAgICAgICAvLyB0cmFuc2Zvcm1lZC5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgICAgICAgICAgICBpZk5vZGUuY29kZWdlbk5vZGUgPSBjcmVhdGVDb2RlZ2VuTm9kZUZvckJyYW5jaChicmFuY2gsIGtleSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBhdHRhY2ggdGhpcyBicmFuY2gncyBjb2RlZ2VuIG5vZGUgdG8gdGhlIHYtaWYgcm9vdC5cbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRDb25kaXRpb24gPSBnZXRQYXJlbnRDb25kaXRpb24oaWZOb2RlLmNvZGVnZW5Ob2RlKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRDb25kaXRpb24uYWx0ZXJuYXRlID0gY3JlYXRlQ29kZWdlbk5vZGVGb3JCcmFuY2goYnJhbmNoLCBrZXkgKyBpZk5vZGUuYnJhbmNoZXMubGVuZ3RoIC0gMSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG59KTtcbi8vIHRhcmdldC1hZ25vc3RpYyB0cmFuc2Zvcm0gdXNlZCBmb3IgYm90aCBDbGllbnQgYW5kIFNTUlxuZnVuY3Rpb24gcHJvY2Vzc0lmKG5vZGUsIGRpciwgY29udGV4dCwgcHJvY2Vzc0NvZGVnZW4pIHtcbiAgICBpZiAoZGlyLm5hbWUgIT09ICdlbHNlJyAmJlxuICAgICAgICAoIWRpci5leHAgfHwgIWRpci5leHAuY29udGVudC50cmltKCkpKSB7XG4gICAgICAgIGNvbnN0IGxvYyA9IGRpci5leHAgPyBkaXIuZXhwLmxvYyA6IG5vZGUubG9jO1xuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigyOCAvKiBFcnJvckNvZGVzLlhfVl9JRl9OT19FWFBSRVNTSU9OICovLCBkaXIubG9jKSk7XG4gICAgICAgIGRpci5leHAgPSBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGB0cnVlYCwgZmFsc2UsIGxvYyk7XG4gICAgfVxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgdHJ1ZSAmJiBkaXIuZXhwKSB7XG4gICAgICAgIHZhbGlkYXRlQnJvd3NlckV4cHJlc3Npb24oZGlyLmV4cCwgY29udGV4dCk7XG4gICAgfVxuICAgIGlmIChkaXIubmFtZSA9PT0gJ2lmJykge1xuICAgICAgICBjb25zdCBicmFuY2ggPSBjcmVhdGVJZkJyYW5jaChub2RlLCBkaXIpO1xuICAgICAgICBjb25zdCBpZk5vZGUgPSB7XG4gICAgICAgICAgICB0eXBlOiA5IC8qIE5vZGVUeXBlcy5JRiAqLyxcbiAgICAgICAgICAgIGxvYzogbm9kZS5sb2MsXG4gICAgICAgICAgICBicmFuY2hlczogW2JyYW5jaF1cbiAgICAgICAgfTtcbiAgICAgICAgY29udGV4dC5yZXBsYWNlTm9kZShpZk5vZGUpO1xuICAgICAgICBpZiAocHJvY2Vzc0NvZGVnZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzQ29kZWdlbihpZk5vZGUsIGJyYW5jaCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGxvY2F0ZSB0aGUgYWRqYWNlbnQgdi1pZlxuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IGNvbnRleHQucGFyZW50LmNoaWxkcmVuO1xuICAgICAgICBjb25zdCBjb21tZW50cyA9IFtdO1xuICAgICAgICBsZXQgaSA9IHNpYmxpbmdzLmluZGV4T2Yobm9kZSk7XG4gICAgICAgIHdoaWxlIChpLS0gPj0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBzaWJsaW5nc1tpXTtcbiAgICAgICAgICAgIGlmIChzaWJsaW5nICYmIHNpYmxpbmcudHlwZSA9PT0gMyAvKiBOb2RlVHlwZXMuQ09NTUVOVCAqLykge1xuICAgICAgICAgICAgICAgIGNvbnRleHQucmVtb3ZlTm9kZShzaWJsaW5nKTtcbiAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY29tbWVudHMudW5zaGlmdChzaWJsaW5nKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaWJsaW5nICYmXG4gICAgICAgICAgICAgICAgc2libGluZy50eXBlID09PSAyIC8qIE5vZGVUeXBlcy5URVhUICovICYmXG4gICAgICAgICAgICAgICAgIXNpYmxpbmcuY29udGVudC50cmltKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5yZW1vdmVOb2RlKHNpYmxpbmcpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNpYmxpbmcgJiYgc2libGluZy50eXBlID09PSA5IC8qIE5vZGVUeXBlcy5JRiAqLykge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHYtZWxzZSB3YXMgZm9sbG93ZWQgYnkgdi1lbHNlLWlmXG4gICAgICAgICAgICAgICAgaWYgKGRpci5uYW1lID09PSAnZWxzZS1pZicgJiZcbiAgICAgICAgICAgICAgICAgICAgc2libGluZy5icmFuY2hlc1tzaWJsaW5nLmJyYW5jaGVzLmxlbmd0aCAtIDFdLmNvbmRpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDMwIC8qIEVycm9yQ29kZXMuWF9WX0VMU0VfTk9fQURKQUNFTlRfSUYgKi8sIG5vZGUubG9jKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG1vdmUgdGhlIG5vZGUgdG8gdGhlIGlmIG5vZGUncyBicmFuY2hlc1xuICAgICAgICAgICAgICAgIGNvbnRleHQucmVtb3ZlTm9kZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJyYW5jaCA9IGNyZWF0ZUlmQnJhbmNoKG5vZGUsIGRpcik7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgICAgICAgICBjb21tZW50cy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gIzM2MTkgaWdub3JlIGNvbW1lbnRzIGlmIHRoZSB2LWlmIGlzIGRpcmVjdCBjaGlsZCBvZiA8dHJhbnNpdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgIShjb250ZXh0LnBhcmVudCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5wYXJlbnQudHlwZSA9PT0gMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNCdWlsdEluVHlwZShjb250ZXh0LnBhcmVudC50YWcsICd0cmFuc2l0aW9uJykpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyYW5jaC5jaGlsZHJlbiA9IFsuLi5jb21tZW50cywgLi4uYnJhbmNoLmNoaWxkcmVuXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgdXNlciBpcyBmb3JjaW5nIHNhbWUga2V5IG9uIGRpZmZlcmVudCBicmFuY2hlc1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgIXRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYnJhbmNoLnVzZXJLZXk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpYmxpbmcuYnJhbmNoZXMuZm9yRWFjaCgoeyB1c2VyS2V5IH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTYW1lS2V5KHVzZXJLZXksIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMjkgLyogRXJyb3JDb2Rlcy5YX1ZfSUZfU0FNRV9LRVkgKi8sIGJyYW5jaC51c2VyS2V5LmxvYykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNpYmxpbmcuYnJhbmNoZXMucHVzaChicmFuY2gpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uRXhpdCA9IHByb2Nlc3NDb2RlZ2VuICYmIHByb2Nlc3NDb2RlZ2VuKHNpYmxpbmcsIGJyYW5jaCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBicmFuY2ggd2FzIHJlbW92ZWQsIGl0IHdpbGwgbm90IGJlIHRyYXZlcnNlZC5cbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdG8gdHJhdmVyc2UgaGVyZS5cbiAgICAgICAgICAgICAgICB0cmF2ZXJzZU5vZGUoYnJhbmNoLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAvLyBjYWxsIG9uIGV4aXRcbiAgICAgICAgICAgICAgICBpZiAob25FeGl0KVxuICAgICAgICAgICAgICAgICAgICBvbkV4aXQoKTtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdG8gcmVzZXQgY3VycmVudE5vZGUgYWZ0ZXIgdHJhdmVyc2FsIHRvIGluZGljYXRlIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBub2RlIGhhcyBiZWVuIHJlbW92ZWQuXG4gICAgICAgICAgICAgICAgY29udGV4dC5jdXJyZW50Tm9kZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzMCAvKiBFcnJvckNvZGVzLlhfVl9FTFNFX05PX0FESkFDRU5UX0lGICovLCBub2RlLmxvYykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVJZkJyYW5jaChub2RlLCBkaXIpIHtcbiAgICBjb25zdCBpc1RlbXBsYXRlSWYgPSBub2RlLnRhZ1R5cGUgPT09IDMgLyogRWxlbWVudFR5cGVzLlRFTVBMQVRFICovO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDEwIC8qIE5vZGVUeXBlcy5JRl9CUkFOQ0ggKi8sXG4gICAgICAgIGxvYzogbm9kZS5sb2MsXG4gICAgICAgIGNvbmRpdGlvbjogZGlyLm5hbWUgPT09ICdlbHNlJyA/IHVuZGVmaW5lZCA6IGRpci5leHAsXG4gICAgICAgIGNoaWxkcmVuOiBpc1RlbXBsYXRlSWYgJiYgIWZpbmREaXIobm9kZSwgJ2ZvcicpID8gbm9kZS5jaGlsZHJlbiA6IFtub2RlXSxcbiAgICAgICAgdXNlcktleTogZmluZFByb3Aobm9kZSwgYGtleWApLFxuICAgICAgICBpc1RlbXBsYXRlSWZcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ29kZWdlbk5vZGVGb3JCcmFuY2goYnJhbmNoLCBrZXlJbmRleCwgY29udGV4dCkge1xuICAgIGlmIChicmFuY2guY29uZGl0aW9uKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVDb25kaXRpb25hbEV4cHJlc3Npb24oYnJhbmNoLmNvbmRpdGlvbiwgY3JlYXRlQ2hpbGRyZW5Db2RlZ2VuTm9kZShicmFuY2gsIGtleUluZGV4LCBjb250ZXh0KSwgXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0byBwYXNzIGluIGFzQmxvY2s6IHRydWUgc28gdGhhdCB0aGUgY29tbWVudCBub2RlIGNhbGxcbiAgICAgICAgLy8gY2xvc2VzIHRoZSBjdXJyZW50IGJsb2NrLlxuICAgICAgICBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihDUkVBVEVfQ09NTUVOVCksIFtcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdcInYtaWZcIicgOiAnXCJcIicsXG4gICAgICAgICAgICAndHJ1ZSdcbiAgICAgICAgXSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNoaWxkcmVuQ29kZWdlbk5vZGUoYnJhbmNoLCBrZXlJbmRleCwgY29udGV4dCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW5Db2RlZ2VuTm9kZShicmFuY2gsIGtleUluZGV4LCBjb250ZXh0KSB7XG4gICAgY29uc3QgeyBoZWxwZXIgfSA9IGNvbnRleHQ7XG4gICAgY29uc3Qga2V5UHJvcGVydHkgPSBjcmVhdGVPYmplY3RQcm9wZXJ0eShga2V5YCwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgJHtrZXlJbmRleH1gLCBmYWxzZSwgbG9jU3R1YiwgMiAvKiBDb25zdGFudFR5cGVzLkNBTl9IT0lTVCAqLykpO1xuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IGJyYW5jaDtcbiAgICBjb25zdCBmaXJzdENoaWxkID0gY2hpbGRyZW5bMF07XG4gICAgY29uc3QgbmVlZEZyYWdtZW50V3JhcHBlciA9IGNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBmaXJzdENoaWxkLnR5cGUgIT09IDEgLyogTm9kZVR5cGVzLkVMRU1FTlQgKi87XG4gICAgaWYgKG5lZWRGcmFnbWVudFdyYXBwZXIpIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBmaXJzdENoaWxkLnR5cGUgPT09IDExIC8qIE5vZGVUeXBlcy5GT1IgKi8pIHtcbiAgICAgICAgICAgIC8vIG9wdGltaXplIGF3YXkgbmVzdGVkIGZyYWdtZW50cyB3aGVuIGNoaWxkIGlzIGEgRm9yTm9kZVxuICAgICAgICAgICAgY29uc3Qgdm5vZGVDYWxsID0gZmlyc3RDaGlsZC5jb2RlZ2VuTm9kZTtcbiAgICAgICAgICAgIGluamVjdFByb3Aodm5vZGVDYWxsLCBrZXlQcm9wZXJ0eSwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gdm5vZGVDYWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHBhdGNoRmxhZyA9IDY0IC8qIFBhdGNoRmxhZ3MuU1RBQkxFX0ZSQUdNRU5UICovO1xuICAgICAgICAgICAgbGV0IHBhdGNoRmxhZ1RleHQgPSBQYXRjaEZsYWdOYW1lc1s2NCAvKiBQYXRjaEZsYWdzLlNUQUJMRV9GUkFHTUVOVCAqL107XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgZnJhZ21lbnQgYWN0dWFsbHkgY29udGFpbnMgYSBzaW5nbGUgdmFsaWQgY2hpbGQgd2l0aFxuICAgICAgICAgICAgLy8gdGhlIHJlc3QgYmVpbmcgY29tbWVudHNcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgICAgICAhYnJhbmNoLmlzVGVtcGxhdGVJZiAmJlxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLmZpbHRlcihjID0+IGMudHlwZSAhPT0gMyAvKiBOb2RlVHlwZXMuQ09NTUVOVCAqLykubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hGbGFnIHw9IDIwNDggLyogUGF0Y2hGbGFncy5ERVZfUk9PVF9GUkFHTUVOVCAqLztcbiAgICAgICAgICAgICAgICBwYXRjaEZsYWdUZXh0ICs9IGAsICR7UGF0Y2hGbGFnTmFtZXNbMjA0OCAvKiBQYXRjaEZsYWdzLkRFVl9ST09UX0ZSQUdNRU5UICovXX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlQ2FsbChjb250ZXh0LCBoZWxwZXIoRlJBR01FTlQpLCBjcmVhdGVPYmplY3RFeHByZXNzaW9uKFtrZXlQcm9wZXJ0eV0pLCBjaGlsZHJlbiwgcGF0Y2hGbGFnICsgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGAgLyogJHtwYXRjaEZsYWdUZXh0fSAqL2AgOiBgYCksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlLCBmYWxzZSwgZmFsc2UgLyogaXNDb21wb25lbnQgKi8sIGJyYW5jaC5sb2MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCByZXQgPSBmaXJzdENoaWxkLmNvZGVnZW5Ob2RlO1xuICAgICAgICBjb25zdCB2bm9kZUNhbGwgPSBnZXRNZW1vZWRWTm9kZUNhbGwocmV0KTtcbiAgICAgICAgLy8gQ2hhbmdlIGNyZWF0ZVZOb2RlIHRvIGNyZWF0ZUJsb2NrLlxuICAgICAgICBpZiAodm5vZGVDYWxsLnR5cGUgPT09IDEzIC8qIE5vZGVUeXBlcy5WTk9ERV9DQUxMICovKSB7XG4gICAgICAgICAgICBtYWtlQmxvY2sodm5vZGVDYWxsLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbmplY3QgYnJhbmNoIGtleVxuICAgICAgICBpbmplY3RQcm9wKHZub2RlQ2FsbCwga2V5UHJvcGVydHksIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzU2FtZUtleShhLCBiKSB7XG4gICAgaWYgKCFhIHx8IGEudHlwZSAhPT0gYi50eXBlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGEudHlwZSA9PT0gNiAvKiBOb2RlVHlwZXMuQVRUUklCVVRFICovKSB7XG4gICAgICAgIGlmIChhLnZhbHVlLmNvbnRlbnQgIT09IGIudmFsdWUuY29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RpdmVcbiAgICAgICAgY29uc3QgZXhwID0gYS5leHA7XG4gICAgICAgIGNvbnN0IGJyYW5jaEV4cCA9IGIuZXhwO1xuICAgICAgICBpZiAoZXhwLnR5cGUgIT09IGJyYW5jaEV4cC50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cC50eXBlICE9PSA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLyB8fFxuICAgICAgICAgICAgZXhwLmlzU3RhdGljICE9PSBicmFuY2hFeHAuaXNTdGF0aWMgfHxcbiAgICAgICAgICAgIGV4cC5jb250ZW50ICE9PSBicmFuY2hFeHAuY29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0UGFyZW50Q29uZGl0aW9uKG5vZGUpIHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSAxOSAvKiBOb2RlVHlwZXMuSlNfQ09ORElUSU9OQUxfRVhQUkVTU0lPTiAqLykge1xuICAgICAgICAgICAgaWYgKG5vZGUuYWx0ZXJuYXRlLnR5cGUgPT09IDE5IC8qIE5vZGVUeXBlcy5KU19DT05ESVRJT05BTF9FWFBSRVNTSU9OICovKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAyMCAvKiBOb2RlVHlwZXMuSlNfQ0FDSEVfRVhQUkVTU0lPTiAqLykge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IHRyYW5zZm9ybUZvciA9IGNyZWF0ZVN0cnVjdHVyYWxEaXJlY3RpdmVUcmFuc2Zvcm0oJ2ZvcicsIChub2RlLCBkaXIsIGNvbnRleHQpID0+IHtcbiAgICBjb25zdCB7IGhlbHBlciwgcmVtb3ZlSGVscGVyIH0gPSBjb250ZXh0O1xuICAgIHJldHVybiBwcm9jZXNzRm9yKG5vZGUsIGRpciwgY29udGV4dCwgZm9yTm9kZSA9PiB7XG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgbG9vcCByZW5kZXIgZnVuY3Rpb24gZXhwcmVzc2lvbiBub3csIGFuZCBhZGQgdGhlXG4gICAgICAgIC8vIGl0ZXJhdG9yIG9uIGV4aXQgYWZ0ZXIgYWxsIGNoaWxkcmVuIGhhdmUgYmVlbiB0cmF2ZXJzZWRcbiAgICAgICAgY29uc3QgcmVuZGVyRXhwID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oaGVscGVyKFJFTkRFUl9MSVNUKSwgW1xuICAgICAgICAgICAgZm9yTm9kZS5zb3VyY2VcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IGlzVGVtcGxhdGUgPSBpc1RlbXBsYXRlTm9kZShub2RlKTtcbiAgICAgICAgY29uc3QgbWVtbyA9IGZpbmREaXIobm9kZSwgJ21lbW8nKTtcbiAgICAgICAgY29uc3Qga2V5UHJvcCA9IGZpbmRQcm9wKG5vZGUsIGBrZXlgKTtcbiAgICAgICAgY29uc3Qga2V5RXhwID0ga2V5UHJvcCAmJlxuICAgICAgICAgICAgKGtleVByb3AudHlwZSA9PT0gNiAvKiBOb2RlVHlwZXMuQVRUUklCVVRFICovXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGtleVByb3AudmFsdWUuY29udGVudCwgdHJ1ZSlcbiAgICAgICAgICAgICAgICA6IGtleVByb3AuZXhwKTtcbiAgICAgICAgY29uc3Qga2V5UHJvcGVydHkgPSBrZXlQcm9wID8gY3JlYXRlT2JqZWN0UHJvcGVydHkoYGtleWAsIGtleUV4cCkgOiBudWxsO1xuICAgICAgICBjb25zdCBpc1N0YWJsZUZyYWdtZW50ID0gZm9yTm9kZS5zb3VyY2UudHlwZSA9PT0gNCAvKiBOb2RlVHlwZXMuU0lNUExFX0VYUFJFU1NJT04gKi8gJiZcbiAgICAgICAgICAgIGZvck5vZGUuc291cmNlLmNvbnN0VHlwZSA+IDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi87XG4gICAgICAgIGNvbnN0IGZyYWdtZW50RmxhZyA9IGlzU3RhYmxlRnJhZ21lbnRcbiAgICAgICAgICAgID8gNjQgLyogUGF0Y2hGbGFncy5TVEFCTEVfRlJBR01FTlQgKi9cbiAgICAgICAgICAgIDoga2V5UHJvcFxuICAgICAgICAgICAgICAgID8gMTI4IC8qIFBhdGNoRmxhZ3MuS0VZRURfRlJBR01FTlQgKi9cbiAgICAgICAgICAgICAgICA6IDI1NiAvKiBQYXRjaEZsYWdzLlVOS0VZRURfRlJBR01FTlQgKi87XG4gICAgICAgIGZvck5vZGUuY29kZWdlbk5vZGUgPSBjcmVhdGVWTm9kZUNhbGwoY29udGV4dCwgaGVscGVyKEZSQUdNRU5UKSwgdW5kZWZpbmVkLCByZW5kZXJFeHAsIGZyYWdtZW50RmxhZyArXG4gICAgICAgICAgICAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYCAvKiAke1BhdGNoRmxhZ05hbWVzW2ZyYWdtZW50RmxhZ119ICovYCA6IGBgKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUgLyogaXNCbG9jayAqLywgIWlzU3RhYmxlRnJhZ21lbnQgLyogZGlzYWJsZVRyYWNraW5nICovLCBmYWxzZSAvKiBpc0NvbXBvbmVudCAqLywgbm9kZS5sb2MpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgLy8gZmluaXNoIHRoZSBjb2RlZ2VuIG5vdyB0aGF0IGFsbCBjaGlsZHJlbiBoYXZlIGJlZW4gdHJhdmVyc2VkXG4gICAgICAgICAgICBsZXQgY2hpbGRCbG9jaztcbiAgICAgICAgICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IGZvck5vZGU7XG4gICAgICAgICAgICAvLyBjaGVjayA8dGVtcGxhdGUgdi1mb3I+IGtleSBwbGFjZW1lbnRcbiAgICAgICAgICAgIGlmICgoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICF0cnVlKSAmJiBpc1RlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5zb21lKGMgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYy50eXBlID09PSAxIC8qIE5vZGVUeXBlcy5FTEVNRU5UICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBmaW5kUHJvcChjLCAna2V5Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzMgLyogRXJyb3JDb2Rlcy5YX1ZfRk9SX1RFTVBMQVRFX0tFWV9QTEFDRU1FTlQgKi8sIGtleS5sb2MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmVlZEZyYWdtZW50V3JhcHBlciA9IGNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBjaGlsZHJlblswXS50eXBlICE9PSAxIC8qIE5vZGVUeXBlcy5FTEVNRU5UICovO1xuICAgICAgICAgICAgY29uc3Qgc2xvdE91dGxldCA9IGlzU2xvdE91dGxldChub2RlKVxuICAgICAgICAgICAgICAgID8gbm9kZVxuICAgICAgICAgICAgICAgIDogaXNUZW1wbGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICBpc1Nsb3RPdXRsZXQobm9kZS5jaGlsZHJlblswXSlcbiAgICAgICAgICAgICAgICAgICAgPyBub2RlLmNoaWxkcmVuWzBdIC8vIGFwaS1leHRyYWN0b3Igc29tZWhvdyBmYWlscyB0byBpbmZlciB0aGlzXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChzbG90T3V0bGV0KSB7XG4gICAgICAgICAgICAgICAgLy8gPHNsb3Qgdi1mb3I9XCIuLi5cIj4gb3IgPHRlbXBsYXRlIHYtZm9yPVwiLi4uXCI+PHNsb3QvPjwvdGVtcGxhdGU+XG4gICAgICAgICAgICAgICAgY2hpbGRCbG9jayA9IHNsb3RPdXRsZXQuY29kZWdlbk5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKGlzVGVtcGxhdGUgJiYga2V5UHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gPHRlbXBsYXRlIHYtZm9yPVwiLi4uXCIgOmtleT1cIi4uLlwiPjxzbG90Lz48L3RlbXBsYXRlPlxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGluamVjdCB0aGUga2V5IHRvIHRoZSByZW5kZXJTbG90KCkgY2FsbC5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHByb3BzIGZvciByZW5kZXJTbG90IGlzIHBhc3NlZCBhcyB0aGUgM3JkIGFyZ3VtZW50LlxuICAgICAgICAgICAgICAgICAgICBpbmplY3RQcm9wKGNoaWxkQmxvY2ssIGtleVByb3BlcnR5LCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZWVkRnJhZ21lbnRXcmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gPHRlbXBsYXRlIHYtZm9yPVwiLi4uXCI+IHdpdGggdGV4dCBvciBtdWx0aS1lbGVtZW50c1xuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBnZW5lcmF0ZSBhIGZyYWdtZW50IGJsb2NrIGZvciBlYWNoIGxvb3BcbiAgICAgICAgICAgICAgICBjaGlsZEJsb2NrID0gY3JlYXRlVk5vZGVDYWxsKGNvbnRleHQsIGhlbHBlcihGUkFHTUVOVCksIGtleVByb3BlcnR5ID8gY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihba2V5UHJvcGVydHldKSA6IHVuZGVmaW5lZCwgbm9kZS5jaGlsZHJlbiwgNjQgLyogUGF0Y2hGbGFncy5TVEFCTEVfRlJBR01FTlQgKi8gK1xuICAgICAgICAgICAgICAgICAgICAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGAgLyogJHtQYXRjaEZsYWdOYW1lc1s2NCAvKiBQYXRjaEZsYWdzLlNUQUJMRV9GUkFHTUVOVCAqL119ICovYFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBgYCksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlLCB1bmRlZmluZWQsIGZhbHNlIC8qIGlzQ29tcG9uZW50ICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vcm1hbCBlbGVtZW50IHYtZm9yLiBEaXJlY3RseSB1c2UgdGhlIGNoaWxkJ3MgY29kZWdlbk5vZGVcbiAgICAgICAgICAgICAgICAvLyBidXQgbWFyayBpdCBhcyBhIGJsb2NrLlxuICAgICAgICAgICAgICAgIGNoaWxkQmxvY2sgPSBjaGlsZHJlblswXVxuICAgICAgICAgICAgICAgICAgICAuY29kZWdlbk5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKGlzVGVtcGxhdGUgJiYga2V5UHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0UHJvcChjaGlsZEJsb2NrLCBrZXlQcm9wZXJ0eSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGlsZEJsb2NrLmlzQmxvY2sgIT09ICFpc1N0YWJsZUZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZEJsb2NrLmlzQmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN3aXRjaCBmcm9tIGJsb2NrIHRvIHZub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVIZWxwZXIoT1BFTl9CTE9DSyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVIZWxwZXIoZ2V0Vk5vZGVCbG9ja0hlbHBlcihjb250ZXh0LmluU1NSLCBjaGlsZEJsb2NrLmlzQ29tcG9uZW50KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzd2l0Y2ggZnJvbSB2bm9kZSB0byBibG9ja1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlSGVscGVyKGdldFZOb2RlSGVscGVyKGNvbnRleHQuaW5TU1IsIGNoaWxkQmxvY2suaXNDb21wb25lbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGlsZEJsb2NrLmlzQmxvY2sgPSAhaXNTdGFibGVGcmFnbWVudDtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRCbG9jay5pc0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlbHBlcihPUEVOX0JMT0NLKTtcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyKGdldFZOb2RlQmxvY2tIZWxwZXIoY29udGV4dC5pblNTUiwgY2hpbGRCbG9jay5pc0NvbXBvbmVudCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyKGdldFZOb2RlSGVscGVyKGNvbnRleHQuaW5TU1IsIGNoaWxkQmxvY2suaXNDb21wb25lbnQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVtbykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvb3AgPSBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24oY3JlYXRlRm9yTG9vcFBhcmFtcyhmb3JOb2RlLnBhcnNlUmVzdWx0LCBbXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYF9jYWNoZWRgKVxuICAgICAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICAgICAgICBsb29wLmJvZHkgPSBjcmVhdGVCbG9ja1N0YXRlbWVudChbXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbYGNvbnN0IF9tZW1vID0gKGAsIG1lbW8uZXhwLCBgKWBdKSxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBpZiAoX2NhY2hlZGAsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi4oa2V5RXhwID8gW2AgJiYgX2NhY2hlZC5rZXkgPT09IGAsIGtleUV4cF0gOiBbXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBgICYmICR7Y29udGV4dC5oZWxwZXJTdHJpbmcoSVNfTUVNT19TQU1FKX0oX2NhY2hlZCwgX21lbW8pKSByZXR1cm4gX2NhY2hlZGBcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbYGNvbnN0IF9pdGVtID0gYCwgY2hpbGRCbG9ja10pLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGBfaXRlbS5tZW1vID0gX21lbW9gKSxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgcmV0dXJuIF9pdGVtYClcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICByZW5kZXJFeHAuYXJndW1lbnRzLnB1c2gobG9vcCwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgX2NhY2hlYCksIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oU3RyaW5nKGNvbnRleHQuY2FjaGVkKyspKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW5kZXJFeHAuYXJndW1lbnRzLnB1c2goY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKGNyZWF0ZUZvckxvb3BQYXJhbXMoZm9yTm9kZS5wYXJzZVJlc3VsdCksIGNoaWxkQmxvY2ssIHRydWUgLyogZm9yY2UgbmV3bGluZSAqLykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xufSk7XG4vLyB0YXJnZXQtYWdub3N0aWMgdHJhbnNmb3JtIHVzZWQgZm9yIGJvdGggQ2xpZW50IGFuZCBTU1JcbmZ1bmN0aW9uIHByb2Nlc3NGb3Iobm9kZSwgZGlyLCBjb250ZXh0LCBwcm9jZXNzQ29kZWdlbikge1xuICAgIGlmICghZGlyLmV4cCkge1xuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzMSAvKiBFcnJvckNvZGVzLlhfVl9GT1JfTk9fRVhQUkVTU0lPTiAqLywgZGlyLmxvYykpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gcGFyc2VGb3JFeHByZXNzaW9uKFxuICAgIC8vIGNhbiBvbmx5IGJlIHNpbXBsZSBleHByZXNzaW9uIGJlY2F1c2UgdkZvciB0cmFuc2Zvcm0gaXMgYXBwbGllZFxuICAgIC8vIGJlZm9yZSBleHByZXNzaW9uIHRyYW5zZm9ybS5cbiAgICBkaXIuZXhwLCBjb250ZXh0KTtcbiAgICBpZiAoIXBhcnNlUmVzdWx0KSB7XG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDMyIC8qIEVycm9yQ29kZXMuWF9WX0ZPUl9NQUxGT1JNRURfRVhQUkVTU0lPTiAqLywgZGlyLmxvYykpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgYWRkSWRlbnRpZmllcnMsIHJlbW92ZUlkZW50aWZpZXJzLCBzY29wZXMgfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgeyBzb3VyY2UsIHZhbHVlLCBrZXksIGluZGV4IH0gPSBwYXJzZVJlc3VsdDtcbiAgICBjb25zdCBmb3JOb2RlID0ge1xuICAgICAgICB0eXBlOiAxMSAvKiBOb2RlVHlwZXMuRk9SICovLFxuICAgICAgICBsb2M6IGRpci5sb2MsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgdmFsdWVBbGlhczogdmFsdWUsXG4gICAgICAgIGtleUFsaWFzOiBrZXksXG4gICAgICAgIG9iamVjdEluZGV4QWxpYXM6IGluZGV4LFxuICAgICAgICBwYXJzZVJlc3VsdCxcbiAgICAgICAgY2hpbGRyZW46IGlzVGVtcGxhdGVOb2RlKG5vZGUpID8gbm9kZS5jaGlsZHJlbiA6IFtub2RlXVxuICAgIH07XG4gICAgY29udGV4dC5yZXBsYWNlTm9kZShmb3JOb2RlKTtcbiAgICAvLyBib29ra2VlcGluZ1xuICAgIHNjb3Blcy52Rm9yKys7XG4gICAgY29uc3Qgb25FeGl0ID0gcHJvY2Vzc0NvZGVnZW4gJiYgcHJvY2Vzc0NvZGVnZW4oZm9yTm9kZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgc2NvcGVzLnZGb3ItLTtcbiAgICAgICAgaWYgKG9uRXhpdClcbiAgICAgICAgICAgIG9uRXhpdCgpO1xuICAgIH07XG59XG5jb25zdCBmb3JBbGlhc1JFID0gLyhbXFxzXFxTXSo/KVxccysoPzppbnxvZilcXHMrKFtcXHNcXFNdKikvO1xuLy8gVGhpcyByZWdleCBkb2Vzbid0IGNvdmVyIHRoZSBjYXNlIGlmIGtleSBvciBpbmRleCBhbGlhc2VzIGhhdmUgZGVzdHJ1Y3R1cmluZyxcbi8vIGJ1dCB0aG9zZSBkbyBub3QgbWFrZSBzZW5zZSBpbiB0aGUgZmlyc3QgcGxhY2UsIHNvIHRoaXMgd29ya3MgaW4gcHJhY3RpY2UuXG5jb25zdCBmb3JJdGVyYXRvclJFID0gLywoW14sXFx9XFxdXSopKD86LChbXixcXH1cXF1dKikpPyQvO1xuY29uc3Qgc3RyaXBQYXJlbnNSRSA9IC9eXFwofFxcKSQvZztcbmZ1bmN0aW9uIHBhcnNlRm9yRXhwcmVzc2lvbihpbnB1dCwgY29udGV4dCkge1xuICAgIGNvbnN0IGxvYyA9IGlucHV0LmxvYztcbiAgICBjb25zdCBleHAgPSBpbnB1dC5jb250ZW50O1xuICAgIGNvbnN0IGluTWF0Y2ggPSBleHAubWF0Y2goZm9yQWxpYXNSRSk7XG4gICAgaWYgKCFpbk1hdGNoKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgWywgTEhTLCBSSFNdID0gaW5NYXRjaDtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHNvdXJjZTogY3JlYXRlQWxpYXNFeHByZXNzaW9uKGxvYywgUkhTLnRyaW0oKSwgZXhwLmluZGV4T2YoUkhTLCBMSFMubGVuZ3RoKSksXG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGtleTogdW5kZWZpbmVkLFxuICAgICAgICBpbmRleDogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHRydWUpIHtcbiAgICAgICAgdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihyZXN1bHQuc291cmNlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgbGV0IHZhbHVlQ29udGVudCA9IExIUy50cmltKCkucmVwbGFjZShzdHJpcFBhcmVuc1JFLCAnJykudHJpbSgpO1xuICAgIGNvbnN0IHRyaW1tZWRPZmZzZXQgPSBMSFMuaW5kZXhPZih2YWx1ZUNvbnRlbnQpO1xuICAgIGNvbnN0IGl0ZXJhdG9yTWF0Y2ggPSB2YWx1ZUNvbnRlbnQubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcbiAgICAgICAgdmFsdWVDb250ZW50ID0gdmFsdWVDb250ZW50LnJlcGxhY2UoZm9ySXRlcmF0b3JSRSwgJycpLnRyaW0oKTtcbiAgICAgICAgY29uc3Qga2V5Q29udGVudCA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xuICAgICAgICBsZXQga2V5T2Zmc2V0O1xuICAgICAgICBpZiAoa2V5Q29udGVudCkge1xuICAgICAgICAgICAga2V5T2Zmc2V0ID0gZXhwLmluZGV4T2Yoa2V5Q29udGVudCwgdHJpbW1lZE9mZnNldCArIHZhbHVlQ29udGVudC5sZW5ndGgpO1xuICAgICAgICAgICAgcmVzdWx0LmtleSA9IGNyZWF0ZUFsaWFzRXhwcmVzc2lvbihsb2MsIGtleUNvbnRlbnQsIGtleU9mZnNldCk7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHRydWUpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKHJlc3VsdC5rZXksIGNvbnRleHQsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVyYXRvck1hdGNoWzJdKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleENvbnRlbnQgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcbiAgICAgICAgICAgIGlmIChpbmRleENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuaW5kZXggPSBjcmVhdGVBbGlhc0V4cHJlc3Npb24obG9jLCBpbmRleENvbnRlbnQsIGV4cC5pbmRleE9mKGluZGV4Q29udGVudCwgcmVzdWx0LmtleVxuICAgICAgICAgICAgICAgICAgICA/IGtleU9mZnNldCArIGtleUNvbnRlbnQubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIDogdHJpbW1lZE9mZnNldCArIHZhbHVlQ29udGVudC5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihyZXN1bHQuaW5kZXgsIGNvbnRleHQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodmFsdWVDb250ZW50KSB7XG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IGNyZWF0ZUFsaWFzRXhwcmVzc2lvbihsb2MsIHZhbHVlQ29udGVudCwgdHJpbW1lZE9mZnNldCk7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgdHJ1ZSkge1xuICAgICAgICAgICAgdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihyZXN1bHQudmFsdWUsIGNvbnRleHQsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjcmVhdGVBbGlhc0V4cHJlc3Npb24ocmFuZ2UsIGNvbnRlbnQsIG9mZnNldCkge1xuICAgIHJldHVybiBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGNvbnRlbnQsIGZhbHNlLCBnZXRJbm5lclJhbmdlKHJhbmdlLCBvZmZzZXQsIGNvbnRlbnQubGVuZ3RoKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVGb3JMb29wUGFyYW1zKHsgdmFsdWUsIGtleSwgaW5kZXggfSwgbWVtb0FyZ3MgPSBbXSkge1xuICAgIHJldHVybiBjcmVhdGVQYXJhbXNMaXN0KFt2YWx1ZSwga2V5LCBpbmRleCwgLi4ubWVtb0FyZ3NdKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhcmFtc0xpc3QoYXJncykge1xuICAgIGxldCBpID0gYXJncy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpZiAoYXJnc1tpXSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gYXJnc1xuICAgICAgICAuc2xpY2UoMCwgaSArIDEpXG4gICAgICAgIC5tYXAoKGFyZywgaSkgPT4gYXJnIHx8IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYF9gLnJlcGVhdChpICsgMSksIGZhbHNlKSk7XG59XG5cbmNvbnN0IGRlZmF1bHRGYWxsYmFjayA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYHVuZGVmaW5lZGAsIGZhbHNlKTtcbi8vIEEgTm9kZVRyYW5zZm9ybSB0aGF0OlxuLy8gMS4gVHJhY2tzIHNjb3BlIGlkZW50aWZpZXJzIGZvciBzY29wZWQgc2xvdHMgc28gdGhhdCB0aGV5IGRvbid0IGdldCBwcmVmaXhlZFxuLy8gICAgYnkgdHJhbnNmb3JtRXhwcmVzc2lvbi4gVGhpcyBpcyBvbmx5IGFwcGxpZWQgaW4gbm9uLWJyb3dzZXIgYnVpbGRzIHdpdGhcbi8vICAgIHsgcHJlZml4SWRlbnRpZmllcnM6IHRydWUgfS5cbi8vIDIuIFRyYWNrIHYtc2xvdCBkZXB0aHMgc28gdGhhdCB3ZSBrbm93IGEgc2xvdCBpcyBpbnNpZGUgYW5vdGhlciBzbG90LlxuLy8gICAgTm90ZSB0aGUgZXhpdCBjYWxsYmFjayBpcyBleGVjdXRlZCBiZWZvcmUgYnVpbGRTbG90cygpIG9uIHRoZSBzYW1lIG5vZGUsXG4vLyAgICBzbyBvbmx5IG5lc3RlZCBzbG90cyBzZWUgcG9zaXRpdmUgbnVtYmVycy5cbmNvbnN0IHRyYWNrU2xvdFNjb3BlcyA9IChub2RlLCBjb250ZXh0KSA9PiB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLyAmJlxuICAgICAgICAobm9kZS50YWdUeXBlID09PSAxIC8qIEVsZW1lbnRUeXBlcy5DT01QT05FTlQgKi8gfHxcbiAgICAgICAgICAgIG5vZGUudGFnVHlwZSA9PT0gMyAvKiBFbGVtZW50VHlwZXMuVEVNUExBVEUgKi8pKSB7XG4gICAgICAgIC8vIFdlIGFyZSBvbmx5IGNoZWNraW5nIG5vbi1lbXB0eSB2LXNsb3QgaGVyZVxuICAgICAgICAvLyBzaW5jZSB3ZSBvbmx5IGNhcmUgYWJvdXQgc2xvdHMgdGhhdCBpbnRyb2R1Y2Ugc2NvcGUgdmFyaWFibGVzLlxuICAgICAgICBjb25zdCB2U2xvdCA9IGZpbmREaXIobm9kZSwgJ3Nsb3QnKTtcbiAgICAgICAgaWYgKHZTbG90KSB7XG4gICAgICAgICAgICB2U2xvdC5leHA7XG4gICAgICAgICAgICBjb250ZXh0LnNjb3Blcy52U2xvdCsrO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNjb3Blcy52U2xvdC0tO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vLyBBIE5vZGVUcmFuc2Zvcm0gdGhhdCB0cmFja3Mgc2NvcGUgaWRlbnRpZmllcnMgZm9yIHNjb3BlZCBzbG90cyB3aXRoIHYtZm9yLlxuLy8gVGhpcyB0cmFuc2Zvcm0gaXMgb25seSBhcHBsaWVkIGluIG5vbi1icm93c2VyIGJ1aWxkcyB3aXRoIHsgcHJlZml4SWRlbnRpZmllcnM6IHRydWUgfVxuY29uc3QgdHJhY2tWRm9yU2xvdFNjb3BlcyA9IChub2RlLCBjb250ZXh0KSA9PiB7XG4gICAgbGV0IHZGb3I7XG4gICAgaWYgKGlzVGVtcGxhdGVOb2RlKG5vZGUpICYmXG4gICAgICAgIG5vZGUucHJvcHMuc29tZShpc1ZTbG90KSAmJlxuICAgICAgICAodkZvciA9IGZpbmREaXIobm9kZSwgJ2ZvcicpKSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSAodkZvci5wYXJzZVJlc3VsdCA9IHBhcnNlRm9yRXhwcmVzc2lvbih2Rm9yLmV4cCwgY29udGV4dCkpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICBjb25zdCB7IHZhbHVlLCBrZXksIGluZGV4IH0gPSByZXN1bHQ7XG4gICAgICAgICAgICBjb25zdCB7IGFkZElkZW50aWZpZXJzLCByZW1vdmVJZGVudGlmaWVycyB9ID0gY29udGV4dDtcbiAgICAgICAgICAgIHZhbHVlICYmIGFkZElkZW50aWZpZXJzKHZhbHVlKTtcbiAgICAgICAgICAgIGtleSAmJiBhZGRJZGVudGlmaWVycyhrZXkpO1xuICAgICAgICAgICAgaW5kZXggJiYgYWRkSWRlbnRpZmllcnMoaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICB2YWx1ZSAmJiByZW1vdmVJZGVudGlmaWVycyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAga2V5ICYmIHJlbW92ZUlkZW50aWZpZXJzKGtleSk7XG4gICAgICAgICAgICAgICAgaW5kZXggJiYgcmVtb3ZlSWRlbnRpZmllcnMoaW5kZXgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBidWlsZENsaWVudFNsb3RGbiA9IChwcm9wcywgY2hpbGRyZW4sIGxvYykgPT4gY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKHByb3BzLCBjaGlsZHJlbiwgZmFsc2UgLyogbmV3bGluZSAqLywgdHJ1ZSAvKiBpc1Nsb3QgKi8sIGNoaWxkcmVuLmxlbmd0aCA/IGNoaWxkcmVuWzBdLmxvYyA6IGxvYyk7XG4vLyBJbnN0ZWFkIG9mIGJlaW5nIGEgRGlyZWN0aXZlVHJhbnNmb3JtLCB2LXNsb3QgcHJvY2Vzc2luZyBpcyBjYWxsZWQgZHVyaW5nXG4vLyB0cmFuc2Zvcm1FbGVtZW50IHRvIGJ1aWxkIHRoZSBzbG90cyBvYmplY3QgZm9yIGEgY29tcG9uZW50LlxuZnVuY3Rpb24gYnVpbGRTbG90cyhub2RlLCBjb250ZXh0LCBidWlsZFNsb3RGbiA9IGJ1aWxkQ2xpZW50U2xvdEZuKSB7XG4gICAgY29udGV4dC5oZWxwZXIoV0lUSF9DVFgpO1xuICAgIGNvbnN0IHsgY2hpbGRyZW4sIGxvYyB9ID0gbm9kZTtcbiAgICBjb25zdCBzbG90c1Byb3BlcnRpZXMgPSBbXTtcbiAgICBjb25zdCBkeW5hbWljU2xvdHMgPSBbXTtcbiAgICAvLyBJZiB0aGUgc2xvdCBpcyBpbnNpZGUgYSB2LWZvciBvciBhbm90aGVyIHYtc2xvdCwgZm9yY2UgaXQgdG8gYmUgZHluYW1pY1xuICAgIC8vIHNpbmNlIGl0IGxpa2VseSB1c2VzIGEgc2NvcGUgdmFyaWFibGUuXG4gICAgbGV0IGhhc0R5bmFtaWNTbG90cyA9IGNvbnRleHQuc2NvcGVzLnZTbG90ID4gMCB8fCBjb250ZXh0LnNjb3Blcy52Rm9yID4gMDtcbiAgICAvLyAxLiBDaGVjayBmb3Igc2xvdCB3aXRoIHNsb3RQcm9wcyBvbiBjb21wb25lbnQgaXRzZWxmLlxuICAgIC8vICAgIDxDb21wIHYtc2xvdD1cInsgcHJvcCB9XCIvPlxuICAgIGNvbnN0IG9uQ29tcG9uZW50U2xvdCA9IGZpbmREaXIobm9kZSwgJ3Nsb3QnLCB0cnVlKTtcbiAgICBpZiAob25Db21wb25lbnRTbG90KSB7XG4gICAgICAgIGNvbnN0IHsgYXJnLCBleHAgfSA9IG9uQ29tcG9uZW50U2xvdDtcbiAgICAgICAgaWYgKGFyZyAmJiAhaXNTdGF0aWNFeHAoYXJnKSkge1xuICAgICAgICAgICAgaGFzRHluYW1pY1Nsb3RzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzbG90c1Byb3BlcnRpZXMucHVzaChjcmVhdGVPYmplY3RQcm9wZXJ0eShhcmcgfHwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbignZGVmYXVsdCcsIHRydWUpLCBidWlsZFNsb3RGbihleHAsIGNoaWxkcmVuLCBsb2MpKSk7XG4gICAgfVxuICAgIC8vIDIuIEl0ZXJhdGUgdGhyb3VnaCBjaGlsZHJlbiBhbmQgY2hlY2sgZm9yIHRlbXBsYXRlIHNsb3RzXG4gICAgLy8gICAgPHRlbXBsYXRlIHYtc2xvdDpmb289XCJ7IHByb3AgfVwiPlxuICAgIGxldCBoYXNUZW1wbGF0ZVNsb3RzID0gZmFsc2U7XG4gICAgbGV0IGhhc05hbWVkRGVmYXVsdFNsb3QgPSBmYWxzZTtcbiAgICBjb25zdCBpbXBsaWNpdERlZmF1bHRDaGlsZHJlbiA9IFtdO1xuICAgIGNvbnN0IHNlZW5TbG90TmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgbGV0IGNvbmRpdGlvbmFsQnJhbmNoSW5kZXggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc2xvdEVsZW1lbnQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgbGV0IHNsb3REaXI7XG4gICAgICAgIGlmICghaXNUZW1wbGF0ZU5vZGUoc2xvdEVsZW1lbnQpIHx8XG4gICAgICAgICAgICAhKHNsb3REaXIgPSBmaW5kRGlyKHNsb3RFbGVtZW50LCAnc2xvdCcsIHRydWUpKSkge1xuICAgICAgICAgICAgLy8gbm90IGEgPHRlbXBsYXRlIHYtc2xvdD4sIHNraXAuXG4gICAgICAgICAgICBpZiAoc2xvdEVsZW1lbnQudHlwZSAhPT0gMyAvKiBOb2RlVHlwZXMuQ09NTUVOVCAqLykge1xuICAgICAgICAgICAgICAgIGltcGxpY2l0RGVmYXVsdENoaWxkcmVuLnB1c2goc2xvdEVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uQ29tcG9uZW50U2xvdCkge1xuICAgICAgICAgICAgLy8gYWxyZWFkeSBoYXMgb24tY29tcG9uZW50IHNsb3QgLSB0aGlzIGlzIGluY29ycmVjdCB1c2FnZS5cbiAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDM3IC8qIEVycm9yQ29kZXMuWF9WX1NMT1RfTUlYRURfU0xPVF9VU0FHRSAqLywgc2xvdERpci5sb2MpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGhhc1RlbXBsYXRlU2xvdHMgPSB0cnVlO1xuICAgICAgICBjb25zdCB7IGNoaWxkcmVuOiBzbG90Q2hpbGRyZW4sIGxvYzogc2xvdExvYyB9ID0gc2xvdEVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHsgYXJnOiBzbG90TmFtZSA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYGRlZmF1bHRgLCB0cnVlKSwgZXhwOiBzbG90UHJvcHMsIGxvYzogZGlyTG9jIH0gPSBzbG90RGlyO1xuICAgICAgICAvLyBjaGVjayBpZiBuYW1lIGlzIGR5bmFtaWMuXG4gICAgICAgIGxldCBzdGF0aWNTbG90TmFtZTtcbiAgICAgICAgaWYgKGlzU3RhdGljRXhwKHNsb3ROYW1lKSkge1xuICAgICAgICAgICAgc3RhdGljU2xvdE5hbWUgPSBzbG90TmFtZSA/IHNsb3ROYW1lLmNvbnRlbnQgOiBgZGVmYXVsdGA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoYXNEeW5hbWljU2xvdHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNsb3RGdW5jdGlvbiA9IGJ1aWxkU2xvdEZuKHNsb3RQcm9wcywgc2xvdENoaWxkcmVuLCBzbG90TG9jKTtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBzbG90IGlzIGNvbmRpdGlvbmFsICh2LWlmL3YtZm9yKVxuICAgICAgICBsZXQgdklmO1xuICAgICAgICBsZXQgdkVsc2U7XG4gICAgICAgIGxldCB2Rm9yO1xuICAgICAgICBpZiAoKHZJZiA9IGZpbmREaXIoc2xvdEVsZW1lbnQsICdpZicpKSkge1xuICAgICAgICAgICAgaGFzRHluYW1pY1Nsb3RzID0gdHJ1ZTtcbiAgICAgICAgICAgIGR5bmFtaWNTbG90cy5wdXNoKGNyZWF0ZUNvbmRpdGlvbmFsRXhwcmVzc2lvbih2SWYuZXhwLCBidWlsZER5bmFtaWNTbG90KHNsb3ROYW1lLCBzbG90RnVuY3Rpb24sIGNvbmRpdGlvbmFsQnJhbmNoSW5kZXgrKyksIGRlZmF1bHRGYWxsYmFjaykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCh2RWxzZSA9IGZpbmREaXIoc2xvdEVsZW1lbnQsIC9eZWxzZSgtaWYpPyQvLCB0cnVlIC8qIGFsbG93RW1wdHkgKi8pKSkge1xuICAgICAgICAgICAgLy8gZmluZCBhZGphY2VudCB2LWlmXG4gICAgICAgICAgICBsZXQgaiA9IGk7XG4gICAgICAgICAgICBsZXQgcHJldjtcbiAgICAgICAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgICAgICAgICBwcmV2ID0gY2hpbGRyZW5bal07XG4gICAgICAgICAgICAgICAgaWYgKHByZXYudHlwZSAhPT0gMyAvKiBOb2RlVHlwZXMuQ09NTUVOVCAqLykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldiAmJiBpc1RlbXBsYXRlTm9kZShwcmV2KSAmJiBmaW5kRGlyKHByZXYsICdpZicpKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG5vZGVcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgIC8vIGF0dGFjaCB0aGlzIHNsb3QgdG8gcHJldmlvdXMgY29uZGl0aW9uYWxcbiAgICAgICAgICAgICAgICBsZXQgY29uZGl0aW9uYWwgPSBkeW5hbWljU2xvdHNbZHluYW1pY1Nsb3RzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjb25kaXRpb25hbC5hbHRlcm5hdGUudHlwZSA9PT0gMTkgLyogTm9kZVR5cGVzLkpTX0NPTkRJVElPTkFMX0VYUFJFU1NJT04gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uYWwgPSBjb25kaXRpb25hbC5hbHRlcm5hdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbmRpdGlvbmFsLmFsdGVybmF0ZSA9IHZFbHNlLmV4cFxuICAgICAgICAgICAgICAgICAgICA/IGNyZWF0ZUNvbmRpdGlvbmFsRXhwcmVzc2lvbih2RWxzZS5leHAsIGJ1aWxkRHluYW1pY1Nsb3Qoc2xvdE5hbWUsIHNsb3RGdW5jdGlvbiwgY29uZGl0aW9uYWxCcmFuY2hJbmRleCsrKSwgZGVmYXVsdEZhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICA6IGJ1aWxkRHluYW1pY1Nsb3Qoc2xvdE5hbWUsIHNsb3RGdW5jdGlvbiwgY29uZGl0aW9uYWxCcmFuY2hJbmRleCsrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDMwIC8qIEVycm9yQ29kZXMuWF9WX0VMU0VfTk9fQURKQUNFTlRfSUYgKi8sIHZFbHNlLmxvYykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCh2Rm9yID0gZmluZERpcihzbG90RWxlbWVudCwgJ2ZvcicpKSkge1xuICAgICAgICAgICAgaGFzRHluYW1pY1Nsb3RzID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gdkZvci5wYXJzZVJlc3VsdCB8fFxuICAgICAgICAgICAgICAgIHBhcnNlRm9yRXhwcmVzc2lvbih2Rm9yLmV4cCwgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAocGFyc2VSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW5kZXIgdGhlIGR5bmFtaWMgc2xvdHMgYXMgYW4gYXJyYXkgYW5kIGFkZCBpdCB0byB0aGUgY3JlYXRlU2xvdCgpXG4gICAgICAgICAgICAgICAgLy8gYXJncy4gVGhlIHJ1bnRpbWUga25vd3MgaG93IHRvIGhhbmRsZSBpdCBhcHByb3ByaWF0ZWx5LlxuICAgICAgICAgICAgICAgIGR5bmFtaWNTbG90cy5wdXNoKGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKFJFTkRFUl9MSVNUKSwgW1xuICAgICAgICAgICAgICAgICAgICBwYXJzZVJlc3VsdC5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbihjcmVhdGVGb3JMb29wUGFyYW1zKHBhcnNlUmVzdWx0KSwgYnVpbGREeW5hbWljU2xvdChzbG90TmFtZSwgc2xvdEZ1bmN0aW9uKSwgdHJ1ZSAvKiBmb3JjZSBuZXdsaW5lICovKVxuICAgICAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDMyIC8qIEVycm9yQ29kZXMuWF9WX0ZPUl9NQUxGT1JNRURfRVhQUkVTU0lPTiAqLywgdkZvci5sb2MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGR1cGxpY2F0ZSBzdGF0aWMgbmFtZXNcbiAgICAgICAgICAgIGlmIChzdGF0aWNTbG90TmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWVuU2xvdE5hbWVzLmhhcyhzdGF0aWNTbG90TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzggLyogRXJyb3JDb2Rlcy5YX1ZfU0xPVF9EVVBMSUNBVEVfU0xPVF9OQU1FUyAqLywgZGlyTG9jKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWVuU2xvdE5hbWVzLmFkZChzdGF0aWNTbG90TmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRpY1Nsb3ROYW1lID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzTmFtZWREZWZhdWx0U2xvdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2xvdHNQcm9wZXJ0aWVzLnB1c2goY3JlYXRlT2JqZWN0UHJvcGVydHkoc2xvdE5hbWUsIHNsb3RGdW5jdGlvbikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghb25Db21wb25lbnRTbG90KSB7XG4gICAgICAgIGNvbnN0IGJ1aWxkRGVmYXVsdFNsb3RQcm9wZXJ0eSA9IChwcm9wcywgY2hpbGRyZW4pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZuID0gYnVpbGRTbG90Rm4ocHJvcHMsIGNoaWxkcmVuLCBsb2MpO1xuICAgICAgICAgICAgaWYgKGNvbnRleHQuY29tcGF0Q29uZmlnKSB7XG4gICAgICAgICAgICAgICAgZm4uaXNOb25TY29wZWRTbG90ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVPYmplY3RQcm9wZXJ0eShgZGVmYXVsdGAsIGZuKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFoYXNUZW1wbGF0ZVNsb3RzKSB7XG4gICAgICAgICAgICAvLyBpbXBsaWNpdCBkZWZhdWx0IHNsb3QgKG9uIGNvbXBvbmVudClcbiAgICAgICAgICAgIHNsb3RzUHJvcGVydGllcy5wdXNoKGJ1aWxkRGVmYXVsdFNsb3RQcm9wZXJ0eSh1bmRlZmluZWQsIGNoaWxkcmVuKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW1wbGljaXREZWZhdWx0Q2hpbGRyZW4ubGVuZ3RoICYmXG4gICAgICAgICAgICAvLyAjMzc2NlxuICAgICAgICAgICAgLy8gd2l0aCB3aGl0ZXNwYWNlOiAncHJlc2VydmUnLCB3aGl0ZXNwYWNlcyBiZXR3ZWVuIHNsb3RzIHdpbGwgZW5kIHVwIGluXG4gICAgICAgICAgICAvLyBpbXBsaWNpdERlZmF1bHRDaGlsZHJlbi4gSWdub3JlIGlmIGFsbCBpbXBsaWNpdCBjaGlsZHJlbiBhcmUgd2hpdGVzcGFjZXMuXG4gICAgICAgICAgICBpbXBsaWNpdERlZmF1bHRDaGlsZHJlbi5zb21lKG5vZGUgPT4gaXNOb25XaGl0ZXNwYWNlQ29udGVudChub2RlKSkpIHtcbiAgICAgICAgICAgIC8vIGltcGxpY2l0IGRlZmF1bHQgc2xvdCAobWl4ZWQgd2l0aCBuYW1lZCBzbG90cylcbiAgICAgICAgICAgIGlmIChoYXNOYW1lZERlZmF1bHRTbG90KSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzkgLyogRXJyb3JDb2Rlcy5YX1ZfU0xPVF9FWFRSQU5FT1VTX0RFRkFVTFRfU0xPVF9DSElMRFJFTiAqLywgaW1wbGljaXREZWZhdWx0Q2hpbGRyZW5bMF0ubG9jKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzbG90c1Byb3BlcnRpZXMucHVzaChidWlsZERlZmF1bHRTbG90UHJvcGVydHkodW5kZWZpbmVkLCBpbXBsaWNpdERlZmF1bHRDaGlsZHJlbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNsb3RGbGFnID0gaGFzRHluYW1pY1Nsb3RzXG4gICAgICAgID8gMiAvKiBTbG90RmxhZ3MuRFlOQU1JQyAqL1xuICAgICAgICA6IGhhc0ZvcndhcmRlZFNsb3RzKG5vZGUuY2hpbGRyZW4pXG4gICAgICAgICAgICA/IDMgLyogU2xvdEZsYWdzLkZPUldBUkRFRCAqL1xuICAgICAgICAgICAgOiAxIC8qIFNsb3RGbGFncy5TVEFCTEUgKi87XG4gICAgbGV0IHNsb3RzID0gY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihzbG90c1Byb3BlcnRpZXMuY29uY2F0KGNyZWF0ZU9iamVjdFByb3BlcnR5KGBfYCwgXG4gICAgLy8gMiA9IGNvbXBpbGVkIGJ1dCBkeW5hbWljID0gY2FuIHNraXAgbm9ybWFsaXphdGlvbiwgYnV0IG11c3QgcnVuIGRpZmZcbiAgICAvLyAxID0gY29tcGlsZWQgYW5kIHN0YXRpYyA9IGNhbiBza2lwIG5vcm1hbGl6YXRpb24gQU5EIGRpZmYgYXMgb3B0aW1pemVkXG4gICAgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihzbG90RmxhZyArICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgIC8qICR7c2xvdEZsYWdzVGV4dFtzbG90RmxhZ119ICovYCA6IGBgKSwgZmFsc2UpKSksIGxvYyk7XG4gICAgaWYgKGR5bmFtaWNTbG90cy5sZW5ndGgpIHtcbiAgICAgICAgc2xvdHMgPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihDUkVBVEVfU0xPVFMpLCBbXG4gICAgICAgICAgICBzbG90cyxcbiAgICAgICAgICAgIGNyZWF0ZUFycmF5RXhwcmVzc2lvbihkeW5hbWljU2xvdHMpXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzbG90cyxcbiAgICAgICAgaGFzRHluYW1pY1Nsb3RzXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRHluYW1pY1Nsb3QobmFtZSwgZm4sIGluZGV4KSB7XG4gICAgY29uc3QgcHJvcHMgPSBbXG4gICAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KGBuYW1lYCwgbmFtZSksXG4gICAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KGBmbmAsIGZuKVxuICAgIF07XG4gICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgcHJvcHMucHVzaChjcmVhdGVPYmplY3RQcm9wZXJ0eShga2V5YCwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihTdHJpbmcoaW5kZXgpLCB0cnVlKSkpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihwcm9wcyk7XG59XG5mdW5jdGlvbiBoYXNGb3J3YXJkZWRTbG90cyhjaGlsZHJlbikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgc3dpdGNoIChjaGlsZC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDEgLyogTm9kZVR5cGVzLkVMRU1FTlQgKi86XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnRhZ1R5cGUgPT09IDIgLyogRWxlbWVudFR5cGVzLlNMT1QgKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgaGFzRm9yd2FyZGVkU2xvdHMoY2hpbGQuY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgOSAvKiBOb2RlVHlwZXMuSUYgKi86XG4gICAgICAgICAgICAgICAgaWYgKGhhc0ZvcndhcmRlZFNsb3RzKGNoaWxkLmJyYW5jaGVzKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEwIC8qIE5vZGVUeXBlcy5JRl9CUkFOQ0ggKi86XG4gICAgICAgICAgICBjYXNlIDExIC8qIE5vZGVUeXBlcy5GT1IgKi86XG4gICAgICAgICAgICAgICAgaWYgKGhhc0ZvcndhcmRlZFNsb3RzKGNoaWxkLmNoaWxkcmVuKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNOb25XaGl0ZXNwYWNlQ29udGVudChub2RlKSB7XG4gICAgaWYgKG5vZGUudHlwZSAhPT0gMiAvKiBOb2RlVHlwZXMuVEVYVCAqLyAmJiBub2RlLnR5cGUgIT09IDEyIC8qIE5vZGVUeXBlcy5URVhUX0NBTEwgKi8pXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IDIgLyogTm9kZVR5cGVzLlRFWFQgKi9cbiAgICAgICAgPyAhIW5vZGUuY29udGVudC50cmltKClcbiAgICAgICAgOiBpc05vbldoaXRlc3BhY2VDb250ZW50KG5vZGUuY29udGVudCk7XG59XG5cbi8vIHNvbWUgZGlyZWN0aXZlIHRyYW5zZm9ybXMgKGUuZy4gdi1tb2RlbCkgbWF5IHJldHVybiBhIHN5bWJvbCBmb3IgcnVudGltZVxuLy8gaW1wb3J0LCB3aGljaCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkIG9mIGEgcmVzb2x2ZURpcmVjdGl2ZSBjYWxsLlxuY29uc3QgZGlyZWN0aXZlSW1wb3J0TWFwID0gbmV3IFdlYWtNYXAoKTtcbi8vIGdlbmVyYXRlIGEgSmF2YVNjcmlwdCBBU1QgZm9yIHRoaXMgZWxlbWVudCdzIGNvZGVnZW5cbmNvbnN0IHRyYW5zZm9ybUVsZW1lbnQgPSAobm9kZSwgY29udGV4dCkgPT4ge1xuICAgIC8vIHBlcmZvcm0gdGhlIHdvcmsgb24gZXhpdCwgYWZ0ZXIgYWxsIGNoaWxkIGV4cHJlc3Npb25zIGhhdmUgYmVlblxuICAgIC8vIHByb2Nlc3NlZCBhbmQgbWVyZ2VkLlxuICAgIHJldHVybiBmdW5jdGlvbiBwb3N0VHJhbnNmb3JtRWxlbWVudCgpIHtcbiAgICAgICAgbm9kZSA9IGNvbnRleHQuY3VycmVudE5vZGU7XG4gICAgICAgIGlmICghKG5vZGUudHlwZSA9PT0gMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLyAmJlxuICAgICAgICAgICAgKG5vZGUudGFnVHlwZSA9PT0gMCAvKiBFbGVtZW50VHlwZXMuRUxFTUVOVCAqLyB8fFxuICAgICAgICAgICAgICAgIG5vZGUudGFnVHlwZSA9PT0gMSAvKiBFbGVtZW50VHlwZXMuQ09NUE9ORU5UICovKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHRhZywgcHJvcHMgfSA9IG5vZGU7XG4gICAgICAgIGNvbnN0IGlzQ29tcG9uZW50ID0gbm9kZS50YWdUeXBlID09PSAxIC8qIEVsZW1lbnRUeXBlcy5DT01QT05FTlQgKi87XG4gICAgICAgIC8vIFRoZSBnb2FsIG9mIHRoZSB0cmFuc2Zvcm0gaXMgdG8gY3JlYXRlIGEgY29kZWdlbk5vZGUgaW1wbGVtZW50aW5nIHRoZVxuICAgICAgICAvLyBWTm9kZUNhbGwgaW50ZXJmYWNlLlxuICAgICAgICBsZXQgdm5vZGVUYWcgPSBpc0NvbXBvbmVudFxuICAgICAgICAgICAgPyByZXNvbHZlQ29tcG9uZW50VHlwZShub2RlLCBjb250ZXh0KVxuICAgICAgICAgICAgOiBgXCIke3RhZ31cImA7XG4gICAgICAgIGNvbnN0IGlzRHluYW1pY0NvbXBvbmVudCA9IGlzT2JqZWN0KHZub2RlVGFnKSAmJiB2bm9kZVRhZy5jYWxsZWUgPT09IFJFU09MVkVfRFlOQU1JQ19DT01QT05FTlQ7XG4gICAgICAgIGxldCB2bm9kZVByb3BzO1xuICAgICAgICBsZXQgdm5vZGVDaGlsZHJlbjtcbiAgICAgICAgbGV0IHZub2RlUGF0Y2hGbGFnO1xuICAgICAgICBsZXQgcGF0Y2hGbGFnID0gMDtcbiAgICAgICAgbGV0IHZub2RlRHluYW1pY1Byb3BzO1xuICAgICAgICBsZXQgZHluYW1pY1Byb3BOYW1lcztcbiAgICAgICAgbGV0IHZub2RlRGlyZWN0aXZlcztcbiAgICAgICAgbGV0IHNob3VsZFVzZUJsb2NrID0gXG4gICAgICAgIC8vIGR5bmFtaWMgY29tcG9uZW50IG1heSByZXNvbHZlIHRvIHBsYWluIGVsZW1lbnRzXG4gICAgICAgIGlzRHluYW1pY0NvbXBvbmVudCB8fFxuICAgICAgICAgICAgdm5vZGVUYWcgPT09IFRFTEVQT1JUIHx8XG4gICAgICAgICAgICB2bm9kZVRhZyA9PT0gU1VTUEVOU0UgfHxcbiAgICAgICAgICAgICghaXNDb21wb25lbnQgJiZcbiAgICAgICAgICAgICAgICAvLyA8c3ZnPiBhbmQgPGZvcmVpZ25PYmplY3Q+IG11c3QgYmUgZm9yY2VkIGludG8gYmxvY2tzIHNvIHRoYXQgYmxvY2tcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGVzIGluc2lkZSBnZXQgcHJvcGVyIGlzU1ZHIGZsYWcgYXQgcnVudGltZS4gKCM2MzksICM2NDMpXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0ZWNobmljYWxseSB3ZWItc3BlY2lmaWMsIGJ1dCBzcGxpdHRpbmcgdGhlIGxvZ2ljIG91dCBvZiBjb3JlXG4gICAgICAgICAgICAgICAgLy8gbGVhZHMgdG8gdG9vIG11Y2ggdW5uZWNlc3NhcnkgY29tcGxleGl0eS5cbiAgICAgICAgICAgICAgICAodGFnID09PSAnc3ZnJyB8fCB0YWcgPT09ICdmb3JlaWduT2JqZWN0JykpO1xuICAgICAgICAvLyBwcm9wc1xuICAgICAgICBpZiAocHJvcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcHJvcHNCdWlsZFJlc3VsdCA9IGJ1aWxkUHJvcHMobm9kZSwgY29udGV4dCwgdW5kZWZpbmVkLCBpc0NvbXBvbmVudCwgaXNEeW5hbWljQ29tcG9uZW50KTtcbiAgICAgICAgICAgIHZub2RlUHJvcHMgPSBwcm9wc0J1aWxkUmVzdWx0LnByb3BzO1xuICAgICAgICAgICAgcGF0Y2hGbGFnID0gcHJvcHNCdWlsZFJlc3VsdC5wYXRjaEZsYWc7XG4gICAgICAgICAgICBkeW5hbWljUHJvcE5hbWVzID0gcHJvcHNCdWlsZFJlc3VsdC5keW5hbWljUHJvcE5hbWVzO1xuICAgICAgICAgICAgY29uc3QgZGlyZWN0aXZlcyA9IHByb3BzQnVpbGRSZXN1bHQuZGlyZWN0aXZlcztcbiAgICAgICAgICAgIHZub2RlRGlyZWN0aXZlcyA9XG4gICAgICAgICAgICAgICAgZGlyZWN0aXZlcyAmJiBkaXJlY3RpdmVzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICA/IGNyZWF0ZUFycmF5RXhwcmVzc2lvbihkaXJlY3RpdmVzLm1hcChkaXIgPT4gYnVpbGREaXJlY3RpdmVBcmdzKGRpciwgY29udGV4dCkpKVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChwcm9wc0J1aWxkUmVzdWx0LnNob3VsZFVzZUJsb2NrKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkVXNlQmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNoaWxkcmVuXG4gICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmICh2bm9kZVRhZyA9PT0gS0VFUF9BTElWRSkge1xuICAgICAgICAgICAgICAgIC8vIEFsdGhvdWdoIGEgYnVpbHQtaW4gY29tcG9uZW50LCB3ZSBjb21waWxlIEtlZXBBbGl2ZSB3aXRoIHJhdyBjaGlsZHJlblxuICAgICAgICAgICAgICAgIC8vIGluc3RlYWQgb2Ygc2xvdCBmdW5jdGlvbnMgc28gdGhhdCBpdCBjYW4gYmUgdXNlZCBpbnNpZGUgVHJhbnNpdGlvblxuICAgICAgICAgICAgICAgIC8vIG9yIG90aGVyIFRyYW5zaXRpb24td3JhcHBpbmcgSE9Dcy5cbiAgICAgICAgICAgICAgICAvLyBUbyBlbnN1cmUgY29ycmVjdCB1cGRhdGVzIHdpdGggYmxvY2sgb3B0aW1pemF0aW9ucywgd2UgbmVlZCB0bzpcbiAgICAgICAgICAgICAgICAvLyAxLiBGb3JjZSBrZWVwLWFsaXZlIGludG8gYSBibG9jay4gVGhpcyBhdm9pZHMgaXRzIGNoaWxkcmVuIGJlaW5nXG4gICAgICAgICAgICAgICAgLy8gICAgY29sbGVjdGVkIGJ5IGEgcGFyZW50IGJsb2NrLlxuICAgICAgICAgICAgICAgIHNob3VsZFVzZUJsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyAyLiBGb3JjZSBrZWVwLWFsaXZlIHRvIGFsd2F5cyBiZSB1cGRhdGVkLCBzaW5jZSBpdCB1c2VzIHJhdyBjaGlsZHJlbi5cbiAgICAgICAgICAgICAgICBwYXRjaEZsYWcgfD0gMTAyNCAvKiBQYXRjaEZsYWdzLkRZTkFNSUNfU0xPVFMgKi87XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDYgLyogRXJyb3JDb2Rlcy5YX0tFRVBfQUxJVkVfSU5WQUxJRF9DSElMRFJFTiAqLywge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG5vZGUuY2hpbGRyZW5bMF0ubG9jLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBub2RlLmNoaWxkcmVuW25vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMV0ubG9jLmVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogJydcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNob3VsZEJ1aWxkQXNTbG90cyA9IGlzQ29tcG9uZW50ICYmXG4gICAgICAgICAgICAgICAgLy8gVGVsZXBvcnQgaXMgbm90IGEgcmVhbCBjb21wb25lbnQgYW5kIGhhcyBkZWRpY2F0ZWQgcnVudGltZSBoYW5kbGluZ1xuICAgICAgICAgICAgICAgIHZub2RlVGFnICE9PSBURUxFUE9SVCAmJlxuICAgICAgICAgICAgICAgIC8vIGV4cGxhaW5lZCBhYm92ZS5cbiAgICAgICAgICAgICAgICB2bm9kZVRhZyAhPT0gS0VFUF9BTElWRTtcbiAgICAgICAgICAgIGlmIChzaG91bGRCdWlsZEFzU2xvdHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNsb3RzLCBoYXNEeW5hbWljU2xvdHMgfSA9IGJ1aWxkU2xvdHMobm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgdm5vZGVDaGlsZHJlbiA9IHNsb3RzO1xuICAgICAgICAgICAgICAgIGlmIChoYXNEeW5hbWljU2xvdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hGbGFnIHw9IDEwMjQgLyogUGF0Y2hGbGFncy5EWU5BTUlDX1NMT1RTICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIHZub2RlVGFnICE9PSBURUxFUE9SVCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gY2hpbGQudHlwZTtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgZHluYW1pYyB0ZXh0IGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgY29uc3QgaGFzRHluYW1pY1RleHRDaGlsZCA9IHR5cGUgPT09IDUgLyogTm9kZVR5cGVzLklOVEVSUE9MQVRJT04gKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9PT0gOCAvKiBOb2RlVHlwZXMuQ09NUE9VTkRfRVhQUkVTU0lPTiAqLztcbiAgICAgICAgICAgICAgICBpZiAoaGFzRHluYW1pY1RleHRDaGlsZCAmJlxuICAgICAgICAgICAgICAgICAgICBnZXRDb25zdGFudFR5cGUoY2hpbGQsIGNvbnRleHQpID09PSAwIC8qIENvbnN0YW50VHlwZXMuTk9UX0NPTlNUQU5UICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoRmxhZyB8PSAxIC8qIFBhdGNoRmxhZ3MuVEVYVCAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcGFzcyBkaXJlY3RseSBpZiB0aGUgb25seSBjaGlsZCBpcyBhIHRleHQgbm9kZVxuICAgICAgICAgICAgICAgIC8vIChwbGFpbiAvIGludGVycG9sYXRpb24gLyBleHByZXNzaW9uKVxuICAgICAgICAgICAgICAgIGlmIChoYXNEeW5hbWljVGV4dENoaWxkIHx8IHR5cGUgPT09IDIgLyogTm9kZVR5cGVzLlRFWFQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgdm5vZGVDaGlsZHJlbiA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdm5vZGVDaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdm5vZGVDaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGF0Y2hGbGFnICYgZHluYW1pY1Byb3BOYW1lc1xuICAgICAgICBpZiAocGF0Y2hGbGFnICE9PSAwKSB7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lhbCBmbGFncyAobmVnYXRpdmUgYW5kIG11dHVhbGx5IGV4Y2x1c2l2ZSlcbiAgICAgICAgICAgICAgICAgICAgdm5vZGVQYXRjaEZsYWcgPSBwYXRjaEZsYWcgKyBgIC8qICR7UGF0Y2hGbGFnTmFtZXNbcGF0Y2hGbGFnXX0gKi9gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYml0d2lzZSBmbGFnc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmbGFnTmFtZXMgPSBPYmplY3Qua2V5cyhQYXRjaEZsYWdOYW1lcylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoTnVtYmVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihuID0+IG4gPiAwICYmIHBhdGNoRmxhZyAmIG4pXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKG4gPT4gUGF0Y2hGbGFnTmFtZXNbbl0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbihgLCBgKTtcbiAgICAgICAgICAgICAgICAgICAgdm5vZGVQYXRjaEZsYWcgPSBwYXRjaEZsYWcgKyBgIC8qICR7ZmxhZ05hbWVzfSAqL2A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdm5vZGVQYXRjaEZsYWcgPSBTdHJpbmcocGF0Y2hGbGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkeW5hbWljUHJvcE5hbWVzICYmIGR5bmFtaWNQcm9wTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdm5vZGVEeW5hbWljUHJvcHMgPSBzdHJpbmdpZnlEeW5hbWljUHJvcE5hbWVzKGR5bmFtaWNQcm9wTmFtZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5vZGUuY29kZWdlbk5vZGUgPSBjcmVhdGVWTm9kZUNhbGwoY29udGV4dCwgdm5vZGVUYWcsIHZub2RlUHJvcHMsIHZub2RlQ2hpbGRyZW4sIHZub2RlUGF0Y2hGbGFnLCB2bm9kZUR5bmFtaWNQcm9wcywgdm5vZGVEaXJlY3RpdmVzLCAhIXNob3VsZFVzZUJsb2NrLCBmYWxzZSAvKiBkaXNhYmxlVHJhY2tpbmcgKi8sIGlzQ29tcG9uZW50LCBub2RlLmxvYyk7XG4gICAgfTtcbn07XG5mdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50VHlwZShub2RlLCBjb250ZXh0LCBzc3IgPSBmYWxzZSkge1xuICAgIGxldCB7IHRhZyB9ID0gbm9kZTtcbiAgICAvLyAxLiBkeW5hbWljIGNvbXBvbmVudFxuICAgIGNvbnN0IGlzRXhwbGljaXREeW5hbWljID0gaXNDb21wb25lbnRUYWcodGFnKTtcbiAgICBjb25zdCBpc1Byb3AgPSBmaW5kUHJvcChub2RlLCAnaXMnKTtcbiAgICBpZiAoaXNQcm9wKSB7XG4gICAgICAgIGlmIChpc0V4cGxpY2l0RHluYW1pYyB8fFxuICAgICAgICAgICAgKGlzQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX0lTX09OX0VMRU1FTlRcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfSVNfT05fRUxFTUVOVCAqLywgY29udGV4dCkpKSB7XG4gICAgICAgICAgICBjb25zdCBleHAgPSBpc1Byb3AudHlwZSA9PT0gNiAvKiBOb2RlVHlwZXMuQVRUUklCVVRFICovXG4gICAgICAgICAgICAgICAgPyBpc1Byb3AudmFsdWUgJiYgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihpc1Byb3AudmFsdWUuY29udGVudCwgdHJ1ZSlcbiAgICAgICAgICAgICAgICA6IGlzUHJvcC5leHA7XG4gICAgICAgICAgICBpZiAoZXhwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKFJFU09MVkVfRFlOQU1JQ19DT01QT05FTlQpLCBbXG4gICAgICAgICAgICAgICAgICAgIGV4cFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUHJvcC50eXBlID09PSA2IC8qIE5vZGVUeXBlcy5BVFRSSUJVVEUgKi8gJiZcbiAgICAgICAgICAgIGlzUHJvcC52YWx1ZS5jb250ZW50LnN0YXJ0c1dpdGgoJ3Z1ZTonKSkge1xuICAgICAgICAgICAgLy8gPGJ1dHRvbiBpcz1cInZ1ZTp4eHhcIj5cbiAgICAgICAgICAgIC8vIGlmIG5vdCA8Y29tcG9uZW50Piwgb25seSBpcyB2YWx1ZSB0aGF0IHN0YXJ0cyB3aXRoIFwidnVlOlwiIHdpbGwgYmVcbiAgICAgICAgICAgIC8vIHRyZWF0ZWQgYXMgY29tcG9uZW50IGJ5IHRoZSBwYXJzZSBwaGFzZSBhbmQgcmVhY2ggaGVyZSwgdW5sZXNzIGl0J3NcbiAgICAgICAgICAgIC8vIGNvbXBhdCBtb2RlIHdoZXJlIGFsbCBpcyB2YWx1ZXMgYXJlIGNvbnNpZGVyZWQgY29tcG9uZW50c1xuICAgICAgICAgICAgdGFnID0gaXNQcm9wLnZhbHVlLmNvbnRlbnQuc2xpY2UoNCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gMS41IHYtaXMgKFRPRE86IERlcHJlY2F0ZSlcbiAgICBjb25zdCBpc0RpciA9ICFpc0V4cGxpY2l0RHluYW1pYyAmJiBmaW5kRGlyKG5vZGUsICdpcycpO1xuICAgIGlmIChpc0RpciAmJiBpc0Rpci5leHApIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKFJFU09MVkVfRFlOQU1JQ19DT01QT05FTlQpLCBbXG4gICAgICAgICAgICBpc0Rpci5leHBcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8vIDIuIGJ1aWx0LWluIGNvbXBvbmVudHMgKFRlbGVwb3J0LCBUcmFuc2l0aW9uLCBLZWVwQWxpdmUsIFN1c3BlbnNlLi4uKVxuICAgIGNvbnN0IGJ1aWx0SW4gPSBpc0NvcmVDb21wb25lbnQodGFnKSB8fCBjb250ZXh0LmlzQnVpbHRJbkNvbXBvbmVudCh0YWcpO1xuICAgIGlmIChidWlsdEluKSB7XG4gICAgICAgIC8vIGJ1aWx0LWlucyBhcmUgc2ltcGx5IGZhbGx0aHJvdWdocyAvIGhhdmUgc3BlY2lhbCBoYW5kbGluZyBkdXJpbmcgc3NyXG4gICAgICAgIC8vIHNvIHdlIGRvbid0IG5lZWQgdG8gaW1wb3J0IHRoZWlyIHJ1bnRpbWUgZXF1aXZhbGVudHNcbiAgICAgICAgaWYgKCFzc3IpXG4gICAgICAgICAgICBjb250ZXh0LmhlbHBlcihidWlsdEluKTtcbiAgICAgICAgcmV0dXJuIGJ1aWx0SW47XG4gICAgfVxuICAgIC8vIDUuIHVzZXIgY29tcG9uZW50IChyZXNvbHZlKVxuICAgIGNvbnRleHQuaGVscGVyKFJFU09MVkVfQ09NUE9ORU5UKTtcbiAgICBjb250ZXh0LmNvbXBvbmVudHMuYWRkKHRhZyk7XG4gICAgcmV0dXJuIHRvVmFsaWRBc3NldElkKHRhZywgYGNvbXBvbmVudGApO1xufVxuZnVuY3Rpb24gYnVpbGRQcm9wcyhub2RlLCBjb250ZXh0LCBwcm9wcyA9IG5vZGUucHJvcHMsIGlzQ29tcG9uZW50LCBpc0R5bmFtaWNDb21wb25lbnQsIHNzciA9IGZhbHNlKSB7XG4gICAgY29uc3QgeyB0YWcsIGxvYzogZWxlbWVudExvYywgY2hpbGRyZW4gfSA9IG5vZGU7XG4gICAgbGV0IHByb3BlcnRpZXMgPSBbXTtcbiAgICBjb25zdCBtZXJnZUFyZ3MgPSBbXTtcbiAgICBjb25zdCBydW50aW1lRGlyZWN0aXZlcyA9IFtdO1xuICAgIGNvbnN0IGhhc0NoaWxkcmVuID0gY2hpbGRyZW4ubGVuZ3RoID4gMDtcbiAgICBsZXQgc2hvdWxkVXNlQmxvY2sgPSBmYWxzZTtcbiAgICAvLyBwYXRjaEZsYWcgYW5hbHlzaXNcbiAgICBsZXQgcGF0Y2hGbGFnID0gMDtcbiAgICBsZXQgaGFzUmVmID0gZmFsc2U7XG4gICAgbGV0IGhhc0NsYXNzQmluZGluZyA9IGZhbHNlO1xuICAgIGxldCBoYXNTdHlsZUJpbmRpbmcgPSBmYWxzZTtcbiAgICBsZXQgaGFzSHlkcmF0aW9uRXZlbnRCaW5kaW5nID0gZmFsc2U7XG4gICAgbGV0IGhhc0R5bmFtaWNLZXlzID0gZmFsc2U7XG4gICAgbGV0IGhhc1Zub2RlSG9vayA9IGZhbHNlO1xuICAgIGNvbnN0IGR5bmFtaWNQcm9wTmFtZXMgPSBbXTtcbiAgICBjb25zdCBwdXNoTWVyZ2VBcmcgPSAoYXJnKSA9PiB7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgbWVyZ2VBcmdzLnB1c2goY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihkZWR1cGVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpLCBlbGVtZW50TG9jKSk7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZylcbiAgICAgICAgICAgIG1lcmdlQXJncy5wdXNoKGFyZyk7XG4gICAgfTtcbiAgICBjb25zdCBhbmFseXplUGF0Y2hGbGFnID0gKHsga2V5LCB2YWx1ZSB9KSA9PiB7XG4gICAgICAgIGlmIChpc1N0YXRpY0V4cChrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0ga2V5LmNvbnRlbnQ7XG4gICAgICAgICAgICBjb25zdCBpc0V2ZW50SGFuZGxlciA9IGlzT24obmFtZSk7XG4gICAgICAgICAgICBpZiAoaXNFdmVudEhhbmRsZXIgJiZcbiAgICAgICAgICAgICAgICAoIWlzQ29tcG9uZW50IHx8IGlzRHluYW1pY0NvbXBvbmVudCkgJiZcbiAgICAgICAgICAgICAgICAvLyBvbWl0IHRoZSBmbGFnIGZvciBjbGljayBoYW5kbGVycyBiZWNhdXNlIGh5ZHJhdGlvbiBnaXZlcyBjbGlja1xuICAgICAgICAgICAgICAgIC8vIGRlZGljYXRlZCBmYXN0IHBhdGguXG4gICAgICAgICAgICAgICAgbmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnb25jbGljaycgJiZcbiAgICAgICAgICAgICAgICAvLyBvbWl0IHYtbW9kZWwgaGFuZGxlcnNcbiAgICAgICAgICAgICAgICBuYW1lICE9PSAnb25VcGRhdGU6bW9kZWxWYWx1ZScgJiZcbiAgICAgICAgICAgICAgICAvLyBvbWl0IG9uVm5vZGVYWFggaG9va3NcbiAgICAgICAgICAgICAgICAhaXNSZXNlcnZlZFByb3AobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBoYXNIeWRyYXRpb25FdmVudEJpbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRXZlbnRIYW5kbGVyICYmIGlzUmVzZXJ2ZWRQcm9wKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaGFzVm5vZGVIb29rID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSAyMCAvKiBOb2RlVHlwZXMuSlNfQ0FDSEVfRVhQUkVTU0lPTiAqLyB8fFxuICAgICAgICAgICAgICAgICgodmFsdWUudHlwZSA9PT0gNCAvKiBOb2RlVHlwZXMuU0lNUExFX0VYUFJFU1NJT04gKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUudHlwZSA9PT0gOCAvKiBOb2RlVHlwZXMuQ09NUE9VTkRfRVhQUkVTU0lPTiAqLykgJiZcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q29uc3RhbnRUeXBlKHZhbHVlLCBjb250ZXh0KSA+IDApKSB7XG4gICAgICAgICAgICAgICAgLy8gc2tpcCBpZiB0aGUgcHJvcCBpcyBhIGNhY2hlZCBoYW5kbGVyIG9yIGhhcyBjb25zdGFudCB2YWx1ZVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYW1lID09PSAncmVmJykge1xuICAgICAgICAgICAgICAgIGhhc1JlZiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgICAgICAgaGFzQ2xhc3NCaW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICAgICAgICBoYXNTdHlsZUJpbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSAhPT0gJ2tleScgJiYgIWR5bmFtaWNQcm9wTmFtZXMuaW5jbHVkZXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBkeW5hbWljUHJvcE5hbWVzLnB1c2gobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0cmVhdCB0aGUgZHluYW1pYyBjbGFzcyBhbmQgc3R5bGUgYmluZGluZyBvZiB0aGUgY29tcG9uZW50IGFzIGR5bmFtaWMgcHJvcHNcbiAgICAgICAgICAgIGlmIChpc0NvbXBvbmVudCAmJlxuICAgICAgICAgICAgICAgIChuYW1lID09PSAnY2xhc3MnIHx8IG5hbWUgPT09ICdzdHlsZScpICYmXG4gICAgICAgICAgICAgICAgIWR5bmFtaWNQcm9wTmFtZXMuaW5jbHVkZXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBkeW5hbWljUHJvcE5hbWVzLnB1c2gobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoYXNEeW5hbWljS2V5cyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gc3RhdGljIGF0dHJpYnV0ZVxuICAgICAgICBjb25zdCBwcm9wID0gcHJvcHNbaV07XG4gICAgICAgIGlmIChwcm9wLnR5cGUgPT09IDYgLyogTm9kZVR5cGVzLkFUVFJJQlVURSAqLykge1xuICAgICAgICAgICAgY29uc3QgeyBsb2MsIG5hbWUsIHZhbHVlIH0gPSBwcm9wO1xuICAgICAgICAgICAgbGV0IGlzU3RhdGljID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAncmVmJykge1xuICAgICAgICAgICAgICAgIGhhc1JlZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuc2NvcGVzLnZGb3IgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaChjcmVhdGVPYmplY3RQcm9wZXJ0eShjcmVhdGVTaW1wbGVFeHByZXNzaW9uKCdyZWZfZm9yJywgdHJ1ZSksIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oJ3RydWUnKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNraXAgaXMgb24gPGNvbXBvbmVudD4sIG9yIGlzPVwidnVlOnh4eFwiXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lzJyAmJlxuICAgICAgICAgICAgICAgIChpc0NvbXBvbmVudFRhZyh0YWcpIHx8XG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZSAmJiB2YWx1ZS5jb250ZW50LnN0YXJ0c1dpdGgoJ3Z1ZTonKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGlzQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX0lTX09OX0VMRU1FTlRcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfSVNfT05fRUxFTUVOVCAqLywgY29udGV4dCkpKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKGNyZWF0ZU9iamVjdFByb3BlcnR5KGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24obmFtZSwgdHJ1ZSwgZ2V0SW5uZXJSYW5nZShsb2MsIDAsIG5hbWUubGVuZ3RoKSksIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24odmFsdWUgPyB2YWx1ZS5jb250ZW50IDogJycsIGlzU3RhdGljLCB2YWx1ZSA/IHZhbHVlLmxvYyA6IGxvYykpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRpcmVjdGl2ZXNcbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZSwgYXJnLCBleHAsIGxvYyB9ID0gcHJvcDtcbiAgICAgICAgICAgIGNvbnN0IGlzVkJpbmQgPSBuYW1lID09PSAnYmluZCc7XG4gICAgICAgICAgICBjb25zdCBpc1ZPbiA9IG5hbWUgPT09ICdvbic7XG4gICAgICAgICAgICAvLyBza2lwIHYtc2xvdCAtIGl0IGlzIGhhbmRsZWQgYnkgaXRzIGRlZGljYXRlZCB0cmFuc2Zvcm0uXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3Nsb3QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig0MCAvKiBFcnJvckNvZGVzLlhfVl9TTE9UX01JU1BMQUNFRCAqLywgbG9jKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2tpcCB2LW9uY2Uvdi1tZW1vIC0gdGhleSBhcmUgaGFuZGxlZCBieSBkZWRpY2F0ZWQgdHJhbnNmb3Jtcy5cbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnb25jZScgfHwgbmFtZSA9PT0gJ21lbW8nKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBza2lwIHYtaXMgYW5kIDppcyBvbiA8Y29tcG9uZW50PlxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpcycgfHxcbiAgICAgICAgICAgICAgICAoaXNWQmluZCAmJlxuICAgICAgICAgICAgICAgICAgICBpc1N0YXRpY0FyZ09mKGFyZywgJ2lzJykgJiZcbiAgICAgICAgICAgICAgICAgICAgKGlzQ29tcG9uZW50VGFnKHRhZykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChpc0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9JU19PTl9FTEVNRU5UXCIgLyogQ29tcGlsZXJEZXByZWNhdGlvblR5cGVzLkNPTVBJTEVSX0lTX09OX0VMRU1FTlQgKi8sIGNvbnRleHQpKSkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBza2lwIHYtb24gaW4gU1NSIGNvbXBpbGF0aW9uXG4gICAgICAgICAgICBpZiAoaXNWT24gJiYgc3NyKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyAjOTM4OiBlbGVtZW50cyB3aXRoIGR5bmFtaWMga2V5cyBzaG91bGQgYmUgZm9yY2VkIGludG8gYmxvY2tzXG4gICAgICAgICAgICAoaXNWQmluZCAmJiBpc1N0YXRpY0FyZ09mKGFyZywgJ2tleScpKSB8fFxuICAgICAgICAgICAgICAgIC8vIGlubGluZSBiZWZvcmUtdXBkYXRlIGhvb2tzIG5lZWQgdG8gZm9yY2UgYmxvY2sgc28gdGhhdCBpdCBpcyBpbnZva2VkXG4gICAgICAgICAgICAgICAgLy8gYmVmb3JlIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgKGlzVk9uICYmIGhhc0NoaWxkcmVuICYmIGlzU3RhdGljQXJnT2YoYXJnLCAndnVlOmJlZm9yZS11cGRhdGUnKSkpIHtcbiAgICAgICAgICAgICAgICBzaG91bGRVc2VCbG9jayA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNWQmluZCAmJiBpc1N0YXRpY0FyZ09mKGFyZywgJ3JlZicpICYmIGNvbnRleHQuc2NvcGVzLnZGb3IgPiAwKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKGNyZWF0ZU9iamVjdFByb3BlcnR5KGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oJ3JlZl9mb3InLCB0cnVlKSwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbigndHJ1ZScpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIHYtYmluZCBhbmQgdi1vbiB3aXRoIG5vIGFyZ3VtZW50XG4gICAgICAgICAgICBpZiAoIWFyZyAmJiAoaXNWQmluZCB8fCBpc1ZPbikpIHtcbiAgICAgICAgICAgICAgICBoYXNEeW5hbWljS2V5cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGV4cCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWQmluZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGF2ZSB0byBtZXJnZSBlYXJseSBmb3IgY29tcGF0IGJ1aWxkIGNoZWNrXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoTWVyZ2VBcmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAyLnggdi1iaW5kIG9iamVjdCBvcmRlciBjb21wYXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc092ZXJyaWRhYmxlS2V5cyA9IG1lcmdlQXJncy5zb21lKGFyZyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJnLnR5cGUgPT09IDE1IC8qIE5vZGVUeXBlcy5KU19PQkpFQ1RfRVhQUkVTU0lPTiAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmcucHJvcGVydGllcy5zb21lKCh7IGtleSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkudHlwZSAhPT0gNCAvKiBOb2RlVHlwZXMuU0lNUExFX0VYUFJFU1NJT04gKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFrZXkuaXNTdGF0aWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoa2V5LmNvbnRlbnQgIT09ICdjbGFzcycgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleS5jb250ZW50ICE9PSAnc3R5bGUnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaXNPbihrZXkuY29udGVudCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZHluYW1pYyBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3ZlcnJpZGFibGVLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9WX0JJTkRfT0JKRUNUX09SREVSXCIgLyogQ29tcGlsZXJEZXByZWNhdGlvblR5cGVzLkNPTVBJTEVSX1ZfQklORF9PQkpFQ1RfT1JERVIgKi8sIGNvbnRleHQsIGxvYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX1ZfQklORF9PQkpFQ1RfT1JERVJcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfVl9CSU5EX09CSkVDVF9PUkRFUiAqLywgY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VBcmdzLnVuc2hpZnQoZXhwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VBcmdzLnB1c2goZXhwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHYtb249XCJvYmpcIiAtPiB0b0hhbmRsZXJzKG9iailcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hNZXJnZUFyZyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogMTQgLyogTm9kZVR5cGVzLkpTX0NBTExfRVhQUkVTU0lPTiAqLyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGVlOiBjb250ZXh0LmhlbHBlcihUT19IQU5ETEVSUyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBpc0NvbXBvbmVudCA/IFtleHBdIDogW2V4cCwgYHRydWVgXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKGlzVkJpbmRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gMzQgLyogRXJyb3JDb2Rlcy5YX1ZfQklORF9OT19FWFBSRVNTSU9OICovXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDM1IC8qIEVycm9yQ29kZXMuWF9WX09OX05PX0VYUFJFU1NJT04gKi8sIGxvYykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGl2ZVRyYW5zZm9ybSA9IGNvbnRleHQuZGlyZWN0aXZlVHJhbnNmb3Jtc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChkaXJlY3RpdmVUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICAvLyBoYXMgYnVpbHQtaW4gZGlyZWN0aXZlIHRyYW5zZm9ybS5cbiAgICAgICAgICAgICAgICBjb25zdCB7IHByb3BzLCBuZWVkUnVudGltZSB9ID0gZGlyZWN0aXZlVHJhbnNmb3JtKHByb3AsIG5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICFzc3IgJiYgcHJvcHMuZm9yRWFjaChhbmFseXplUGF0Y2hGbGFnKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNWT24gJiYgYXJnICYmICFpc1N0YXRpY0V4cChhcmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2hNZXJnZUFyZyhjcmVhdGVPYmplY3RFeHByZXNzaW9uKHByb3BzLCBlbGVtZW50TG9jKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2goLi4ucHJvcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmVlZFJ1bnRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVudGltZURpcmVjdGl2ZXMucHVzaChwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3ltYm9sKG5lZWRSdW50aW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlSW1wb3J0TWFwLnNldChwcm9wLCBuZWVkUnVudGltZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaXNCdWlsdEluRGlyZWN0aXZlKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gYnVpbHQtaW4gdHJhbnNmb3JtLCB0aGlzIGlzIGEgdXNlciBjdXN0b20gZGlyZWN0aXZlLlxuICAgICAgICAgICAgICAgIHJ1bnRpbWVEaXJlY3RpdmVzLnB1c2gocHJvcCk7XG4gICAgICAgICAgICAgICAgLy8gY3VzdG9tIGRpcnMgbWF5IHVzZSBiZWZvcmVVcGRhdGUgc28gdGhleSBuZWVkIHRvIGZvcmNlIGJsb2Nrc1xuICAgICAgICAgICAgICAgIC8vIHRvIGVuc3VyZSBiZWZvcmUtdXBkYXRlIGdldHMgY2FsbGVkIGJlZm9yZSBjaGlsZHJlbiB1cGRhdGVcbiAgICAgICAgICAgICAgICBpZiAoaGFzQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkVXNlQmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgcHJvcHNFeHByZXNzaW9uID0gdW5kZWZpbmVkO1xuICAgIC8vIGhhcyB2LWJpbmQ9XCJvYmplY3RcIiBvciB2LW9uPVwib2JqZWN0XCIsIHdyYXAgd2l0aCBtZXJnZVByb3BzXG4gICAgaWYgKG1lcmdlQXJncy5sZW5ndGgpIHtcbiAgICAgICAgLy8gY2xvc2UgdXAgYW55IG5vdC15ZXQtbWVyZ2VkIHByb3BzXG4gICAgICAgIHB1c2hNZXJnZUFyZygpO1xuICAgICAgICBpZiAobWVyZ2VBcmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHByb3BzRXhwcmVzc2lvbiA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKE1FUkdFX1BST1BTKSwgbWVyZ2VBcmdzLCBlbGVtZW50TG9jKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNpbmdsZSB2LWJpbmQgd2l0aCBub3RoaW5nIGVsc2UgLSBubyBuZWVkIGZvciBhIG1lcmdlUHJvcHMgY2FsbFxuICAgICAgICAgICAgcHJvcHNFeHByZXNzaW9uID0gbWVyZ2VBcmdzWzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICAgIHByb3BzRXhwcmVzc2lvbiA9IGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oZGVkdXBlUHJvcGVydGllcyhwcm9wZXJ0aWVzKSwgZWxlbWVudExvYyk7XG4gICAgfVxuICAgIC8vIHBhdGNoRmxhZyBhbmFseXNpc1xuICAgIGlmIChoYXNEeW5hbWljS2V5cykge1xuICAgICAgICBwYXRjaEZsYWcgfD0gMTYgLyogUGF0Y2hGbGFncy5GVUxMX1BST1BTICovO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGhhc0NsYXNzQmluZGluZyAmJiAhaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHBhdGNoRmxhZyB8PSAyIC8qIFBhdGNoRmxhZ3MuQ0xBU1MgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc1N0eWxlQmluZGluZyAmJiAhaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHBhdGNoRmxhZyB8PSA0IC8qIFBhdGNoRmxhZ3MuU1RZTEUgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGR5bmFtaWNQcm9wTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBwYXRjaEZsYWcgfD0gOCAvKiBQYXRjaEZsYWdzLlBST1BTICovO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNIeWRyYXRpb25FdmVudEJpbmRpbmcpIHtcbiAgICAgICAgICAgIHBhdGNoRmxhZyB8PSAzMiAvKiBQYXRjaEZsYWdzLkhZRFJBVEVfRVZFTlRTICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghc2hvdWxkVXNlQmxvY2sgJiZcbiAgICAgICAgKHBhdGNoRmxhZyA9PT0gMCB8fCBwYXRjaEZsYWcgPT09IDMyIC8qIFBhdGNoRmxhZ3MuSFlEUkFURV9FVkVOVFMgKi8pICYmXG4gICAgICAgIChoYXNSZWYgfHwgaGFzVm5vZGVIb29rIHx8IHJ1bnRpbWVEaXJlY3RpdmVzLmxlbmd0aCA+IDApKSB7XG4gICAgICAgIHBhdGNoRmxhZyB8PSA1MTIgLyogUGF0Y2hGbGFncy5ORUVEX1BBVENIICovO1xuICAgIH1cbiAgICAvLyBwcmUtbm9ybWFsaXplIHByb3BzLCBTU1IgaXMgc2tpcHBlZCBmb3Igbm93XG4gICAgaWYgKCFjb250ZXh0LmluU1NSICYmIHByb3BzRXhwcmVzc2lvbikge1xuICAgICAgICBzd2l0Y2ggKHByb3BzRXhwcmVzc2lvbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDE1IC8qIE5vZGVUeXBlcy5KU19PQkpFQ1RfRVhQUkVTU0lPTiAqLzpcbiAgICAgICAgICAgICAgICAvLyBtZWFucyB0aGF0IHRoZXJlIGlzIG5vIHYtYmluZCxcbiAgICAgICAgICAgICAgICAvLyBidXQgc3RpbGwgbmVlZCB0byBkZWFsIHdpdGggZHluYW1pYyBrZXkgYmluZGluZ1xuICAgICAgICAgICAgICAgIGxldCBjbGFzc0tleUluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlS2V5SW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICBsZXQgaGFzRHluYW1pY0tleSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHNFeHByZXNzaW9uLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcHJvcHNFeHByZXNzaW9uLnByb3BlcnRpZXNbaV0ua2V5O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdGF0aWNFeHAoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5jb250ZW50ID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NLZXlJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXkuY29udGVudCA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlS2V5SW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFrZXkuaXNIYW5kbGVyS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNEeW5hbWljS2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjbGFzc1Byb3AgPSBwcm9wc0V4cHJlc3Npb24ucHJvcGVydGllc1tjbGFzc0tleUluZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZVByb3AgPSBwcm9wc0V4cHJlc3Npb24ucHJvcGVydGllc1tzdHlsZUtleUluZGV4XTtcbiAgICAgICAgICAgICAgICAvLyBubyBkeW5hbWljIGtleVxuICAgICAgICAgICAgICAgIGlmICghaGFzRHluYW1pY0tleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3NQcm9wICYmICFpc1N0YXRpY0V4cChjbGFzc1Byb3AudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc1Byb3AudmFsdWUgPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihOT1JNQUxJWkVfQ0xBU1MpLCBbY2xhc3NQcm9wLnZhbHVlXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlUHJvcCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHN0YXRpYyBzdHlsZSBpcyBjb21waWxlZCBpbnRvIGFuIG9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIHVzZSBgaGFzU3R5bGVCaW5kaW5nYCB0byBlbnN1cmUgdGhhdCBpdCBpcyBhIGR5bmFtaWMgc3R5bGUgYmluZGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgKGhhc1N0eWxlQmluZGluZyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzdHlsZVByb3AudmFsdWUudHlwZSA9PT0gNCAvKiBOb2RlVHlwZXMuU0lNUExFX0VYUFJFU1NJT04gKi8gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVQcm9wLnZhbHVlLmNvbnRlbnQudHJpbSgpWzBdID09PSBgW2ApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdi1iaW5kOnN0eWxlIGFuZCBzdHlsZSBib3RoIGV4aXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHYtYmluZDpzdHlsZSB3aXRoIHN0YXRpYyBsaXRlcmFsIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlUHJvcC52YWx1ZS50eXBlID09PSAxNyAvKiBOb2RlVHlwZXMuSlNfQVJSQVlfRVhQUkVTU0lPTiAqLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlUHJvcC52YWx1ZSA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKE5PUk1BTElaRV9TVFlMRSksIFtzdHlsZVByb3AudmFsdWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZHluYW1pYyBrZXkgYmluZGluZywgd3JhcCB3aXRoIGBub3JtYWxpemVQcm9wc2BcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNFeHByZXNzaW9uID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoTk9STUFMSVpFX1BST1BTKSwgW3Byb3BzRXhwcmVzc2lvbl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTQgLyogTm9kZVR5cGVzLkpTX0NBTExfRVhQUkVTU0lPTiAqLzpcbiAgICAgICAgICAgICAgICAvLyBtZXJnZVByb3BzIGNhbGwsIGRvIG5vdGhpbmdcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gc2luZ2xlIHYtYmluZFxuICAgICAgICAgICAgICAgIHByb3BzRXhwcmVzc2lvbiA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKE5PUk1BTElaRV9QUk9QUyksIFtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoR1VBUkRfUkVBQ1RJVkVfUFJPUFMpLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc0V4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczogcHJvcHNFeHByZXNzaW9uLFxuICAgICAgICBkaXJlY3RpdmVzOiBydW50aW1lRGlyZWN0aXZlcyxcbiAgICAgICAgcGF0Y2hGbGFnLFxuICAgICAgICBkeW5hbWljUHJvcE5hbWVzLFxuICAgICAgICBzaG91bGRVc2VCbG9ja1xuICAgIH07XG59XG4vLyBEZWR1cGUgcHJvcHMgaW4gYW4gb2JqZWN0IGxpdGVyYWwuXG4vLyBMaXRlcmFsIGR1cGxpY2F0ZWQgYXR0cmlidXRlcyB3b3VsZCBoYXZlIGJlZW4gd2FybmVkIGR1cmluZyB0aGUgcGFyc2UgcGhhc2UsXG4vLyBob3dldmVyLCBpdCdzIHBvc3NpYmxlIHRvIGVuY291bnRlciBkdXBsaWNhdGVkIGBvblhYWGAgaGFuZGxlcnMgd2l0aCBkaWZmZXJlbnRcbi8vIG1vZGlmaWVycy4gV2UgYWxzbyBuZWVkIHRvIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBjbGFzcyAvIHN0eWxlIGF0dHJpYnV0ZXMuXG4vLyAtIG9uWFhYIGhhbmRsZXJzIC8gc3R5bGU6IG1lcmdlIGludG8gYXJyYXlcbi8vIC0gY2xhc3M6IG1lcmdlIGludG8gc2luZ2xlIGV4cHJlc3Npb24gd2l0aCBjb25jYXRlbmF0aW9uXG5mdW5jdGlvbiBkZWR1cGVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpIHtcbiAgICBjb25zdCBrbm93blByb3BzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGRlZHVwZWQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJvcCA9IHByb3BlcnRpZXNbaV07XG4gICAgICAgIC8vIGR5bmFtaWMga2V5cyBhcmUgYWx3YXlzIGFsbG93ZWRcbiAgICAgICAgaWYgKHByb3Aua2V5LnR5cGUgPT09IDggLyogTm9kZVR5cGVzLkNPTVBPVU5EX0VYUFJFU1NJT04gKi8gfHwgIXByb3Aua2V5LmlzU3RhdGljKSB7XG4gICAgICAgICAgICBkZWR1cGVkLnB1c2gocHJvcCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gcHJvcC5rZXkuY29udGVudDtcbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBrbm93blByb3BzLmdldChuYW1lKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3N0eWxlJyB8fCBuYW1lID09PSAnY2xhc3MnIHx8IGlzT24obmFtZSkpIHtcbiAgICAgICAgICAgICAgICBtZXJnZUFzQXJyYXkoZXhpc3RpbmcsIHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdW5leHBlY3RlZCBkdXBsaWNhdGUsIHNob3VsZCBoYXZlIGVtaXR0ZWQgZXJyb3IgZHVyaW5nIHBhcnNlXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBrbm93blByb3BzLnNldChuYW1lLCBwcm9wKTtcbiAgICAgICAgICAgIGRlZHVwZWQucHVzaChwcm9wKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVkdXBlZDtcbn1cbmZ1bmN0aW9uIG1lcmdlQXNBcnJheShleGlzdGluZywgaW5jb21pbmcpIHtcbiAgICBpZiAoZXhpc3RpbmcudmFsdWUudHlwZSA9PT0gMTcgLyogTm9kZVR5cGVzLkpTX0FSUkFZX0VYUFJFU1NJT04gKi8pIHtcbiAgICAgICAgZXhpc3RpbmcudmFsdWUuZWxlbWVudHMucHVzaChpbmNvbWluZy52YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBleGlzdGluZy52YWx1ZSA9IGNyZWF0ZUFycmF5RXhwcmVzc2lvbihbZXhpc3RpbmcudmFsdWUsIGluY29taW5nLnZhbHVlXSwgZXhpc3RpbmcubG9jKTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZERpcmVjdGl2ZUFyZ3MoZGlyLCBjb250ZXh0KSB7XG4gICAgY29uc3QgZGlyQXJncyA9IFtdO1xuICAgIGNvbnN0IHJ1bnRpbWUgPSBkaXJlY3RpdmVJbXBvcnRNYXAuZ2V0KGRpcik7XG4gICAgaWYgKHJ1bnRpbWUpIHtcbiAgICAgICAgLy8gYnVpbHQtaW4gZGlyZWN0aXZlIHdpdGggcnVudGltZVxuICAgICAgICBkaXJBcmdzLnB1c2goY29udGV4dC5oZWxwZXJTdHJpbmcocnVudGltZSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gaW5qZWN0IHN0YXRlbWVudCBmb3IgcmVzb2x2aW5nIGRpcmVjdGl2ZVxuICAgICAgICAgICAgY29udGV4dC5oZWxwZXIoUkVTT0xWRV9ESVJFQ1RJVkUpO1xuICAgICAgICAgICAgY29udGV4dC5kaXJlY3RpdmVzLmFkZChkaXIubmFtZSk7XG4gICAgICAgICAgICBkaXJBcmdzLnB1c2godG9WYWxpZEFzc2V0SWQoZGlyLm5hbWUsIGBkaXJlY3RpdmVgKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeyBsb2MgfSA9IGRpcjtcbiAgICBpZiAoZGlyLmV4cClcbiAgICAgICAgZGlyQXJncy5wdXNoKGRpci5leHApO1xuICAgIGlmIChkaXIuYXJnKSB7XG4gICAgICAgIGlmICghZGlyLmV4cCkge1xuICAgICAgICAgICAgZGlyQXJncy5wdXNoKGB2b2lkIDBgKTtcbiAgICAgICAgfVxuICAgICAgICBkaXJBcmdzLnB1c2goZGlyLmFyZyk7XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzKS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFkaXIuYXJnKSB7XG4gICAgICAgICAgICBpZiAoIWRpci5leHApIHtcbiAgICAgICAgICAgICAgICBkaXJBcmdzLnB1c2goYHZvaWQgMGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlyQXJncy5wdXNoKGB2b2lkIDBgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cnVlRXhwcmVzc2lvbiA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYHRydWVgLCBmYWxzZSwgbG9jKTtcbiAgICAgICAgZGlyQXJncy5wdXNoKGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oZGlyLm1vZGlmaWVycy5tYXAobW9kaWZpZXIgPT4gY3JlYXRlT2JqZWN0UHJvcGVydHkobW9kaWZpZXIsIHRydWVFeHByZXNzaW9uKSksIGxvYykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQXJyYXlFeHByZXNzaW9uKGRpckFyZ3MsIGRpci5sb2MpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5RHluYW1pY1Byb3BOYW1lcyhwcm9wcykge1xuICAgIGxldCBwcm9wc05hbWVzU3RyaW5nID0gYFtgO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gcHJvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHByb3BzTmFtZXNTdHJpbmcgKz0gSlNPTi5zdHJpbmdpZnkocHJvcHNbaV0pO1xuICAgICAgICBpZiAoaSA8IGwgLSAxKVxuICAgICAgICAgICAgcHJvcHNOYW1lc1N0cmluZyArPSAnLCAnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcHNOYW1lc1N0cmluZyArIGBdYDtcbn1cbmZ1bmN0aW9uIGlzQ29tcG9uZW50VGFnKHRhZykge1xuICAgIHJldHVybiB0YWcgPT09ICdjb21wb25lbnQnIHx8IHRhZyA9PT0gJ0NvbXBvbmVudCc7XG59XG5cbihwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxuICAgID8gT2JqZWN0LmZyZWV6ZSh7fSlcbiAgICA6IHt9O1xuKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gT2JqZWN0LmZyZWV6ZShbXSkgOiBbXTtcbmNvbnN0IGNhY2hlU3RyaW5nRnVuY3Rpb24gPSAoZm4pID0+IHtcbiAgICBjb25zdCBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgcmV0dXJuICgoc3RyKSA9PiB7XG4gICAgICAgIGNvbnN0IGhpdCA9IGNhY2hlW3N0cl07XG4gICAgICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKTtcbiAgICB9KTtcbn07XG5jb25zdCBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBjYW1lbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4ge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCAoXywgYykgPT4gKGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJykpO1xufSk7XG5cbmNvbnN0IHRyYW5zZm9ybVNsb3RPdXRsZXQgPSAobm9kZSwgY29udGV4dCkgPT4ge1xuICAgIGlmIChpc1Nsb3RPdXRsZXQobm9kZSkpIHtcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbiwgbG9jIH0gPSBub2RlO1xuICAgICAgICBjb25zdCB7IHNsb3ROYW1lLCBzbG90UHJvcHMgfSA9IHByb2Nlc3NTbG90T3V0bGV0KG5vZGUsIGNvbnRleHQpO1xuICAgICAgICBjb25zdCBzbG90QXJncyA9IFtcbiAgICAgICAgICAgIGNvbnRleHQucHJlZml4SWRlbnRpZmllcnMgPyBgX2N0eC4kc2xvdHNgIDogYCRzbG90c2AsXG4gICAgICAgICAgICBzbG90TmFtZSxcbiAgICAgICAgICAgICd7fScsXG4gICAgICAgICAgICAndW5kZWZpbmVkJyxcbiAgICAgICAgICAgICd0cnVlJ1xuICAgICAgICBdO1xuICAgICAgICBsZXQgZXhwZWN0ZWRMZW4gPSAyO1xuICAgICAgICBpZiAoc2xvdFByb3BzKSB7XG4gICAgICAgICAgICBzbG90QXJnc1syXSA9IHNsb3RQcm9wcztcbiAgICAgICAgICAgIGV4cGVjdGVkTGVuID0gMztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICBzbG90QXJnc1szXSA9IGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbihbXSwgY2hpbGRyZW4sIGZhbHNlLCBmYWxzZSwgbG9jKTtcbiAgICAgICAgICAgIGV4cGVjdGVkTGVuID0gNDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGV4dC5zY29wZUlkICYmICFjb250ZXh0LnNsb3R0ZWQpIHtcbiAgICAgICAgICAgIGV4cGVjdGVkTGVuID0gNTtcbiAgICAgICAgfVxuICAgICAgICBzbG90QXJncy5zcGxpY2UoZXhwZWN0ZWRMZW4pOyAvLyByZW1vdmUgdW51c2VkIGFyZ3VtZW50c1xuICAgICAgICBub2RlLmNvZGVnZW5Ob2RlID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoUkVOREVSX1NMT1QpLCBzbG90QXJncywgbG9jKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gcHJvY2Vzc1Nsb3RPdXRsZXQobm9kZSwgY29udGV4dCkge1xuICAgIGxldCBzbG90TmFtZSA9IGBcImRlZmF1bHRcImA7XG4gICAgbGV0IHNsb3RQcm9wcyA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBub25OYW1lUHJvcHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUucHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcCA9IG5vZGUucHJvcHNbaV07XG4gICAgICAgIGlmIChwLnR5cGUgPT09IDYgLyogTm9kZVR5cGVzLkFUVFJJQlVURSAqLykge1xuICAgICAgICAgICAgaWYgKHAudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAocC5uYW1lID09PSAnbmFtZScpIHtcbiAgICAgICAgICAgICAgICAgICAgc2xvdE5hbWUgPSBKU09OLnN0cmluZ2lmeShwLnZhbHVlLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcC5uYW1lID0gY2FtZWxpemUocC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgbm9uTmFtZVByb3BzLnB1c2gocCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHAubmFtZSA9PT0gJ2JpbmQnICYmIGlzU3RhdGljQXJnT2YocC5hcmcsICduYW1lJykpIHtcbiAgICAgICAgICAgICAgICBpZiAocC5leHApXG4gICAgICAgICAgICAgICAgICAgIHNsb3ROYW1lID0gcC5leHA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocC5uYW1lID09PSAnYmluZCcgJiYgcC5hcmcgJiYgaXNTdGF0aWNFeHAocC5hcmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHAuYXJnLmNvbnRlbnQgPSBjYW1lbGl6ZShwLmFyZy5jb250ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9uTmFtZVByb3BzLnB1c2gocCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vbk5hbWVQcm9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIGRpcmVjdGl2ZXMgfSA9IGJ1aWxkUHJvcHMobm9kZSwgY29udGV4dCwgbm9uTmFtZVByb3BzLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICBzbG90UHJvcHMgPSBwcm9wcztcbiAgICAgICAgaWYgKGRpcmVjdGl2ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzNiAvKiBFcnJvckNvZGVzLlhfVl9TTE9UX1VORVhQRUNURURfRElSRUNUSVZFX09OX1NMT1RfT1VUTEVUICovLCBkaXJlY3RpdmVzWzBdLmxvYykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNsb3ROYW1lLFxuICAgICAgICBzbG90UHJvcHNcbiAgICB9O1xufVxuXG5jb25zdCBmbkV4cFJFID0gL15cXHMqKFtcXHckX10rfChhc3luY1xccyopP1xcKFteKV0qP1xcKSlcXHMqKDpbXj1dKyk/PT58XlxccyooYXN5bmNcXHMrKT9mdW5jdGlvbig/OlxccytbXFx3JF0rKT9cXHMqXFwoLztcbmNvbnN0IHRyYW5zZm9ybU9uID0gKGRpciwgbm9kZSwgY29udGV4dCwgYXVnbWVudG9yKSA9PiB7XG4gICAgY29uc3QgeyBsb2MsIG1vZGlmaWVycywgYXJnIH0gPSBkaXI7XG4gICAgaWYgKCFkaXIuZXhwICYmICFtb2RpZmllcnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDM1IC8qIEVycm9yQ29kZXMuWF9WX09OX05PX0VYUFJFU1NJT04gKi8sIGxvYykpO1xuICAgIH1cbiAgICBsZXQgZXZlbnROYW1lO1xuICAgIGlmIChhcmcudHlwZSA9PT0gNCAvKiBOb2RlVHlwZXMuU0lNUExFX0VYUFJFU1NJT04gKi8pIHtcbiAgICAgICAgaWYgKGFyZy5pc1N0YXRpYykge1xuICAgICAgICAgICAgbGV0IHJhd05hbWUgPSBhcmcuY29udGVudDtcbiAgICAgICAgICAgIC8vIFRPRE8gZGVwcmVjYXRlIEB2bm9kZVhYWCB1c2FnZVxuICAgICAgICAgICAgaWYgKHJhd05hbWUuc3RhcnRzV2l0aCgndnVlOicpKSB7XG4gICAgICAgICAgICAgICAgcmF3TmFtZSA9IGB2bm9kZS0ke3Jhd05hbWUuc2xpY2UoNCl9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGV2ZW50U3RyaW5nID0gbm9kZS50YWdUeXBlICE9PSAwIC8qIEVsZW1lbnRUeXBlcy5FTEVNRU5UICovIHx8XG4gICAgICAgICAgICAgICAgcmF3TmFtZS5zdGFydHNXaXRoKCd2bm9kZScpIHx8XG4gICAgICAgICAgICAgICAgIS9bQS1aXS8udGVzdChyYXdOYW1lKVxuICAgICAgICAgICAgICAgID8gLy8gZm9yIG5vbi1lbGVtZW50IGFuZCB2bm9kZSBsaWZlY3ljbGUgZXZlbnQgbGlzdGVuZXJzLCBhdXRvIGNvbnZlcnRcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgdG8gY2FtZWxDYXNlLiBTZWUgaXNzdWUgIzIyNDlcbiAgICAgICAgICAgICAgICAgICAgdG9IYW5kbGVyS2V5KGNhbWVsaXplJDEocmF3TmFtZSkpXG4gICAgICAgICAgICAgICAgOiAvLyBwcmVzZXJ2ZSBjYXNlIGZvciBwbGFpbiBlbGVtZW50IGxpc3RlbmVycyB0aGF0IGhhdmUgdXBwZXJjYXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIGxldHRlcnMsIGFzIHRoZXNlIG1heSBiZSBjdXN0b20gZWxlbWVudHMnIGN1c3RvbSBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgYG9uOiR7cmF3TmFtZX1gO1xuICAgICAgICAgICAgZXZlbnROYW1lID0gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihldmVudFN0cmluZywgdHJ1ZSwgYXJnLmxvYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyAjMjM4OFxuICAgICAgICAgICAgZXZlbnROYW1lID0gY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtcbiAgICAgICAgICAgICAgICBgJHtjb250ZXh0LmhlbHBlclN0cmluZyhUT19IQU5ETEVSX0tFWSl9KGAsXG4gICAgICAgICAgICAgICAgYXJnLFxuICAgICAgICAgICAgICAgIGApYFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGFscmVhZHkgYSBjb21wb3VuZCBleHByZXNzaW9uLlxuICAgICAgICBldmVudE5hbWUgPSBhcmc7XG4gICAgICAgIGV2ZW50TmFtZS5jaGlsZHJlbi51bnNoaWZ0KGAke2NvbnRleHQuaGVscGVyU3RyaW5nKFRPX0hBTkRMRVJfS0VZKX0oYCk7XG4gICAgICAgIGV2ZW50TmFtZS5jaGlsZHJlbi5wdXNoKGApYCk7XG4gICAgfVxuICAgIC8vIGhhbmRsZXIgcHJvY2Vzc2luZ1xuICAgIGxldCBleHAgPSBkaXIuZXhwO1xuICAgIGlmIChleHAgJiYgIWV4cC5jb250ZW50LnRyaW0oKSkge1xuICAgICAgICBleHAgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGxldCBzaG91bGRDYWNoZSA9IGNvbnRleHQuY2FjaGVIYW5kbGVycyAmJiAhZXhwICYmICFjb250ZXh0LmluVk9uY2U7XG4gICAgaWYgKGV4cCkge1xuICAgICAgICBjb25zdCBpc01lbWJlckV4cCA9IGlzTWVtYmVyRXhwcmVzc2lvbihleHAuY29udGVudCk7XG4gICAgICAgIGNvbnN0IGlzSW5saW5lU3RhdGVtZW50ID0gIShpc01lbWJlckV4cCB8fCBmbkV4cFJFLnRlc3QoZXhwLmNvbnRlbnQpKTtcbiAgICAgICAgY29uc3QgaGFzTXVsdGlwbGVTdGF0ZW1lbnRzID0gZXhwLmNvbnRlbnQuaW5jbHVkZXMoYDtgKTtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB0cnVlKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKGV4cCwgY29udGV4dCwgZmFsc2UsIGhhc011bHRpcGxlU3RhdGVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSW5saW5lU3RhdGVtZW50IHx8IChzaG91bGRDYWNoZSAmJiBpc01lbWJlckV4cCkpIHtcbiAgICAgICAgICAgIC8vIHdyYXAgaW5saW5lIHN0YXRlbWVudCBpbiBhIGZ1bmN0aW9uIGV4cHJlc3Npb25cbiAgICAgICAgICAgIGV4cCA9IGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbXG4gICAgICAgICAgICAgICAgYCR7aXNJbmxpbmVTdGF0ZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgPyBgJGV2ZW50YFxuICAgICAgICAgICAgICAgICAgICA6IGAke2BgfSguLi5hcmdzKWB9ID0+ICR7aGFzTXVsdGlwbGVTdGF0ZW1lbnRzID8gYHtgIDogYChgfWAsXG4gICAgICAgICAgICAgICAgZXhwLFxuICAgICAgICAgICAgICAgIGhhc011bHRpcGxlU3RhdGVtZW50cyA/IGB9YCA6IGApYFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHJldCA9IHtcbiAgICAgICAgcHJvcHM6IFtcbiAgICAgICAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KGV2ZW50TmFtZSwgZXhwIHx8IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYCgpID0+IHt9YCwgZmFsc2UsIGxvYykpXG4gICAgICAgIF1cbiAgICB9O1xuICAgIC8vIGFwcGx5IGV4dGVuZGVkIGNvbXBpbGVyIGF1Z21lbnRvclxuICAgIGlmIChhdWdtZW50b3IpIHtcbiAgICAgICAgcmV0ID0gYXVnbWVudG9yKHJldCk7XG4gICAgfVxuICAgIGlmIChzaG91bGRDYWNoZSkge1xuICAgICAgICAvLyBjYWNoZSBoYW5kbGVycyBzbyB0aGF0IGl0J3MgYWx3YXlzIHRoZSBzYW1lIGhhbmRsZXIgYmVpbmcgcGFzc2VkIGRvd24uXG4gICAgICAgIC8vIHRoaXMgYXZvaWRzIHVubmVjZXNzYXJ5IHJlLXJlbmRlcnMgd2hlbiB1c2VycyB1c2UgaW5saW5lIGhhbmRsZXJzIG9uXG4gICAgICAgIC8vIGNvbXBvbmVudHMuXG4gICAgICAgIHJldC5wcm9wc1swXS52YWx1ZSA9IGNvbnRleHQuY2FjaGUocmV0LnByb3BzWzBdLnZhbHVlKTtcbiAgICB9XG4gICAgLy8gbWFyayB0aGUga2V5IGFzIGhhbmRsZXIgZm9yIHByb3BzIG5vcm1hbGl6YXRpb24gY2hlY2tcbiAgICByZXQucHJvcHMuZm9yRWFjaChwID0+IChwLmtleS5pc0hhbmRsZXJLZXkgPSB0cnVlKSk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbi8vIHYtYmluZCB3aXRob3V0IGFyZyBpcyBoYW5kbGVkIGRpcmVjdGx5IGluIC4vdHJhbnNmb3JtRWxlbWVudHMudHMgZHVlIHRvIGl0IGFmZmVjdGluZ1xuLy8gY29kZWdlbiBmb3IgdGhlIGVudGlyZSBwcm9wcyBvYmplY3QuIFRoaXMgdHJhbnNmb3JtIGhlcmUgaXMgb25seSBmb3Igdi1iaW5kXG4vLyAqd2l0aCogYXJncy5cbmNvbnN0IHRyYW5zZm9ybUJpbmQgPSAoZGlyLCBfbm9kZSwgY29udGV4dCkgPT4ge1xuICAgIGNvbnN0IHsgZXhwLCBtb2RpZmllcnMsIGxvYyB9ID0gZGlyO1xuICAgIGNvbnN0IGFyZyA9IGRpci5hcmc7XG4gICAgaWYgKGFyZy50eXBlICE9PSA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLykge1xuICAgICAgICBhcmcuY2hpbGRyZW4udW5zaGlmdChgKGApO1xuICAgICAgICBhcmcuY2hpbGRyZW4ucHVzaChgKSB8fCBcIlwiYCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFhcmcuaXNTdGF0aWMpIHtcbiAgICAgICAgYXJnLmNvbnRlbnQgPSBgJHthcmcuY29udGVudH0gfHwgXCJcImA7XG4gICAgfVxuICAgIC8vIC5zeW5jIGlzIHJlcGxhY2VkIGJ5IHYtbW9kZWw6YXJnXG4gICAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcygnY2FtZWwnKSkge1xuICAgICAgICBpZiAoYXJnLnR5cGUgPT09IDQgLyogTm9kZVR5cGVzLlNJTVBMRV9FWFBSRVNTSU9OICovKSB7XG4gICAgICAgICAgICBpZiAoYXJnLmlzU3RhdGljKSB7XG4gICAgICAgICAgICAgICAgYXJnLmNvbnRlbnQgPSBjYW1lbGl6ZSQxKGFyZy5jb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFyZy5jb250ZW50ID0gYCR7Y29udGV4dC5oZWxwZXJTdHJpbmcoQ0FNRUxJWkUpfSgke2FyZy5jb250ZW50fSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXJnLmNoaWxkcmVuLnVuc2hpZnQoYCR7Y29udGV4dC5oZWxwZXJTdHJpbmcoQ0FNRUxJWkUpfShgKTtcbiAgICAgICAgICAgIGFyZy5jaGlsZHJlbi5wdXNoKGApYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjb250ZXh0LmluU1NSKSB7XG4gICAgICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoJ3Byb3AnKSkge1xuICAgICAgICAgICAgaW5qZWN0UHJlZml4KGFyZywgJy4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKCdhdHRyJykpIHtcbiAgICAgICAgICAgIGluamVjdFByZWZpeChhcmcsICdeJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFleHAgfHxcbiAgICAgICAgKGV4cC50eXBlID09PSA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLyAmJiAhZXhwLmNvbnRlbnQudHJpbSgpKSkge1xuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzNCAvKiBFcnJvckNvZGVzLlhfVl9CSU5EX05PX0VYUFJFU1NJT04gKi8sIGxvYykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJvcHM6IFtjcmVhdGVPYmplY3RQcm9wZXJ0eShhcmcsIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oJycsIHRydWUsIGxvYykpXVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczogW2NyZWF0ZU9iamVjdFByb3BlcnR5KGFyZywgZXhwKV1cbiAgICB9O1xufTtcbmNvbnN0IGluamVjdFByZWZpeCA9IChhcmcsIHByZWZpeCkgPT4ge1xuICAgIGlmIChhcmcudHlwZSA9PT0gNCAvKiBOb2RlVHlwZXMuU0lNUExFX0VYUFJFU1NJT04gKi8pIHtcbiAgICAgICAgaWYgKGFyZy5pc1N0YXRpYykge1xuICAgICAgICAgICAgYXJnLmNvbnRlbnQgPSBwcmVmaXggKyBhcmcuY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFyZy5jb250ZW50ID0gYFxcYCR7cHJlZml4fVxcJHske2FyZy5jb250ZW50fX1cXGBgO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhcmcuY2hpbGRyZW4udW5zaGlmdChgJyR7cHJlZml4fScgKyAoYCk7XG4gICAgICAgIGFyZy5jaGlsZHJlbi5wdXNoKGApYCk7XG4gICAgfVxufTtcblxuLy8gTWVyZ2UgYWRqYWNlbnQgdGV4dCBub2RlcyBhbmQgZXhwcmVzc2lvbnMgaW50byBhIHNpbmdsZSBleHByZXNzaW9uXG4vLyBlLmcuIDxkaXY+YWJjIHt7IGQgfX0ge3sgZSB9fTwvZGl2PiBzaG91bGQgaGF2ZSBhIHNpbmdsZSBleHByZXNzaW9uIG5vZGUgYXMgY2hpbGQuXG5jb25zdCB0cmFuc2Zvcm1UZXh0ID0gKG5vZGUsIGNvbnRleHQpID0+IHtcbiAgICBpZiAobm9kZS50eXBlID09PSAwIC8qIE5vZGVUeXBlcy5ST09UICovIHx8XG4gICAgICAgIG5vZGUudHlwZSA9PT0gMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLyB8fFxuICAgICAgICBub2RlLnR5cGUgPT09IDExIC8qIE5vZGVUeXBlcy5GT1IgKi8gfHxcbiAgICAgICAgbm9kZS50eXBlID09PSAxMCAvKiBOb2RlVHlwZXMuSUZfQlJBTkNIICovKSB7XG4gICAgICAgIC8vIHBlcmZvcm0gdGhlIHRyYW5zZm9ybSBvbiBub2RlIGV4aXQgc28gdGhhdCBhbGwgZXhwcmVzc2lvbnMgaGF2ZSBhbHJlYWR5XG4gICAgICAgIC8vIGJlZW4gcHJvY2Vzc2VkLlxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRDb250YWluZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsZXQgaGFzVGV4dCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGlzVGV4dChjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzVGV4dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gY2hpbGRyZW5bal07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNUZXh0KG5leHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50Q29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250YWluZXIgPSBjaGlsZHJlbltpXSA9IGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbY2hpbGRdLCBjaGlsZC5sb2MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGUgaW50byBjdXJyZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRhaW5lci5jaGlsZHJlbi5wdXNoKGAgKyBgLCBuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRhaW5lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGFzVGV4dCB8fFxuICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBwbGFpbiBlbGVtZW50IHdpdGggYSBzaW5nbGUgdGV4dCBjaGlsZCwgbGVhdmUgaXRcbiAgICAgICAgICAgICAgICAvLyBhcy1pcyBzaW5jZSB0aGUgcnVudGltZSBoYXMgZGVkaWNhdGVkIGZhc3QgcGF0aCBmb3IgdGhpcyBieSBkaXJlY3RseVxuICAgICAgICAgICAgICAgIC8vIHNldHRpbmcgdGV4dENvbnRlbnQgb2YgdGhlIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgLy8gZm9yIGNvbXBvbmVudCByb290IGl0J3MgYWx3YXlzIG5vcm1hbGl6ZWQgYW55d2F5LlxuICAgICAgICAgICAgICAgIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgKG5vZGUudHlwZSA9PT0gMCAvKiBOb2RlVHlwZXMuUk9PVCAqLyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKG5vZGUudHlwZSA9PT0gMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudGFnVHlwZSA9PT0gMCAvKiBFbGVtZW50VHlwZXMuRUxFTUVOVCAqLyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICMzNzU2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3VzdG9tIGRpcmVjdGl2ZXMgY2FuIHBvdGVudGlhbGx5IGFkZCBET00gZWxlbWVudHMgYXJiaXRyYXJpbHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBhdm9pZCBzZXR0aW5nIHRleHRDb250ZW50IG9mIHRoZSBlbGVtZW50IGF0IHJ1bnRpbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCBhY2NpZGVudGFsbHkgb3ZlcndyaXRpbmcgdGhlIERPTSBlbGVtZW50cyBhZGRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ5IHRoZSB1c2VyIHRocm91Z2ggY3VzdG9tIGRpcmVjdGl2ZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIW5vZGUucHJvcHMuZmluZChwID0+IHAudHlwZSA9PT0gNyAvKiBOb2RlVHlwZXMuRElSRUNUSVZFICovICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFjb250ZXh0LmRpcmVjdGl2ZVRyYW5zZm9ybXNbcC5uYW1lXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiBjb21wYXQgbW9kZSwgPHRlbXBsYXRlPiB0YWdzIHdpdGggbm8gc3BlY2lhbCBkaXJlY3RpdmVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCBiZSByZW5kZXJlZCBhcyBhIGZyYWdtZW50IHNvIGl0cyBjaGlsZHJlbiBtdXN0IGJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydGVkIGludG8gdm5vZGVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICEobm9kZS50YWcgPT09ICd0ZW1wbGF0ZScpKSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcHJlLWNvbnZlcnQgdGV4dCBub2RlcyBpbnRvIGNyZWF0ZVRleHRWTm9kZSh0ZXh0KSBjYWxscyB0byBhdm9pZFxuICAgICAgICAgICAgLy8gcnVudGltZSBub3JtYWxpemF0aW9uLlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGlzVGV4dChjaGlsZCkgfHwgY2hpbGQudHlwZSA9PT0gOCAvKiBOb2RlVHlwZXMuQ09NUE9VTkRfRVhQUkVTU0lPTiAqLykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsQXJncyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGVUZXh0Vk5vZGUgZGVmYXVsdHMgdG8gc2luZ2xlIHdoaXRlc3BhY2UsIHNvIGlmIGl0IGlzIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIHNwYWNlIHRoZSBjb2RlIGNvdWxkIGJlIGFuIGVtcHR5IGNhbGwgdG8gc2F2ZSBieXRlcy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT09IDIgLyogTm9kZVR5cGVzLlRFWFQgKi8gfHwgY2hpbGQuY29udGVudCAhPT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsQXJncy5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBtYXJrIGR5bmFtaWMgdGV4dCB3aXRoIGZsYWcgc28gaXQgZ2V0cyBwYXRjaGVkIGluc2lkZSBhIGJsb2NrXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udGV4dC5zc3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbnN0YW50VHlwZShjaGlsZCwgY29udGV4dCkgPT09IDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxBcmdzLnB1c2goMSAvKiBQYXRjaEZsYWdzLlRFWFQgKi8gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgIC8qICR7UGF0Y2hGbGFnTmFtZXNbMSAvKiBQYXRjaEZsYWdzLlRFWFQgKi9dfSAqL2AgOiBgYCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogMTIgLyogTm9kZVR5cGVzLlRFWFRfQ0FMTCAqLyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNoaWxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jOiBjaGlsZC5sb2MsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlZ2VuTm9kZTogY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoQ1JFQVRFX1RFWFQpLCBjYWxsQXJncylcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufTtcblxuY29uc3Qgc2VlbiA9IG5ldyBXZWFrU2V0KCk7XG5jb25zdCB0cmFuc2Zvcm1PbmNlID0gKG5vZGUsIGNvbnRleHQpID0+IHtcbiAgICBpZiAobm9kZS50eXBlID09PSAxIC8qIE5vZGVUeXBlcy5FTEVNRU5UICovICYmIGZpbmREaXIobm9kZSwgJ29uY2UnLCB0cnVlKSkge1xuICAgICAgICBpZiAoc2Vlbi5oYXMobm9kZSkgfHwgY29udGV4dC5pblZPbmNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2Vlbi5hZGQobm9kZSk7XG4gICAgICAgIGNvbnRleHQuaW5WT25jZSA9IHRydWU7XG4gICAgICAgIGNvbnRleHQuaGVscGVyKFNFVF9CTE9DS19UUkFDS0lORyk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb250ZXh0LmluVk9uY2UgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGN1ciA9IGNvbnRleHQuY3VycmVudE5vZGU7XG4gICAgICAgICAgICBpZiAoY3VyLmNvZGVnZW5Ob2RlKSB7XG4gICAgICAgICAgICAgICAgY3VyLmNvZGVnZW5Ob2RlID0gY29udGV4dC5jYWNoZShjdXIuY29kZWdlbk5vZGUsIHRydWUgLyogaXNWTm9kZSAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufTtcblxuY29uc3QgdHJhbnNmb3JtTW9kZWwgPSAoZGlyLCBub2RlLCBjb250ZXh0KSA9PiB7XG4gICAgY29uc3QgeyBleHAsIGFyZyB9ID0gZGlyO1xuICAgIGlmICghZXhwKSB7XG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDQxIC8qIEVycm9yQ29kZXMuWF9WX01PREVMX05PX0VYUFJFU1NJT04gKi8sIGRpci5sb2MpKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRyYW5zZm9ybVByb3BzKCk7XG4gICAgfVxuICAgIGNvbnN0IHJhd0V4cCA9IGV4cC5sb2Muc291cmNlO1xuICAgIGNvbnN0IGV4cFN0cmluZyA9IGV4cC50eXBlID09PSA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLyA/IGV4cC5jb250ZW50IDogcmF3RXhwO1xuICAgIC8vIGltIFNGQyA8c2NyaXB0IHNldHVwPiBpbmxpbmUgbW9kZSwgdGhlIGV4cCBtYXkgaGF2ZSBiZWVuIHRyYW5zZm9ybWVkIGludG9cbiAgICAvLyBfdW5yZWYoZXhwKVxuICAgIGNvbnN0IGJpbmRpbmdUeXBlID0gY29udGV4dC5iaW5kaW5nTWV0YWRhdGFbcmF3RXhwXTtcbiAgICAvLyBjaGVjayBwcm9wc1xuICAgIGlmIChiaW5kaW5nVHlwZSA9PT0gXCJwcm9wc1wiIC8qIEJpbmRpbmdUeXBlcy5QUk9QUyAqLyB8fFxuICAgICAgICBiaW5kaW5nVHlwZSA9PT0gXCJwcm9wcy1hbGlhc2VkXCIgLyogQmluZGluZ1R5cGVzLlBST1BTX0FMSUFTRUQgKi8pIHtcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDQgLyogRXJyb3JDb2Rlcy5YX1ZfTU9ERUxfT05fUFJPUFMgKi8sIGV4cC5sb2MpKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRyYW5zZm9ybVByb3BzKCk7XG4gICAgfVxuICAgIGNvbnN0IG1heWJlUmVmID0gIXRydWUgIDtcbiAgICBpZiAoIWV4cFN0cmluZy50cmltKCkgfHxcbiAgICAgICAgKCFpc01lbWJlckV4cHJlc3Npb24oZXhwU3RyaW5nKSAmJiAhbWF5YmVSZWYpKSB7XG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDQyIC8qIEVycm9yQ29kZXMuWF9WX01PREVMX01BTEZPUk1FRF9FWFBSRVNTSU9OICovLCBleHAubG9jKSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVUcmFuc2Zvcm1Qcm9wcygpO1xuICAgIH1cbiAgICBjb25zdCBwcm9wTmFtZSA9IGFyZyA/IGFyZyA6IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oJ21vZGVsVmFsdWUnLCB0cnVlKTtcbiAgICBjb25zdCBldmVudE5hbWUgPSBhcmdcbiAgICAgICAgPyBpc1N0YXRpY0V4cChhcmcpXG4gICAgICAgICAgICA/IGBvblVwZGF0ZToke2FyZy5jb250ZW50fWBcbiAgICAgICAgICAgIDogY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFsnXCJvblVwZGF0ZTpcIiArICcsIGFyZ10pXG4gICAgICAgIDogYG9uVXBkYXRlOm1vZGVsVmFsdWVgO1xuICAgIGxldCBhc3NpZ25tZW50RXhwO1xuICAgIGNvbnN0IGV2ZW50QXJnID0gY29udGV4dC5pc1RTID8gYCgkZXZlbnQ6IGFueSlgIDogYCRldmVudGA7XG4gICAge1xuICAgICAgICBhc3NpZ25tZW50RXhwID0gY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtcbiAgICAgICAgICAgIGAke2V2ZW50QXJnfSA9PiAoKGAsXG4gICAgICAgICAgICBleHAsXG4gICAgICAgICAgICBgKSA9ICRldmVudClgXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjb25zdCBwcm9wcyA9IFtcbiAgICAgICAgLy8gbW9kZWxWYWx1ZTogZm9vXG4gICAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KHByb3BOYW1lLCBkaXIuZXhwKSxcbiAgICAgICAgLy8gXCJvblVwZGF0ZTptb2RlbFZhbHVlXCI6ICRldmVudCA9PiAoZm9vID0gJGV2ZW50KVxuICAgICAgICBjcmVhdGVPYmplY3RQcm9wZXJ0eShldmVudE5hbWUsIGFzc2lnbm1lbnRFeHApXG4gICAgXTtcbiAgICAvLyBtb2RlbE1vZGlmaWVyczogeyBmb286IHRydWUsIFwiYmFyLWJhelwiOiB0cnVlIH1cbiAgICBpZiAoZGlyLm1vZGlmaWVycy5sZW5ndGggJiYgbm9kZS50YWdUeXBlID09PSAxIC8qIEVsZW1lbnRUeXBlcy5DT01QT05FTlQgKi8pIHtcbiAgICAgICAgY29uc3QgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVyc1xuICAgICAgICAgICAgLm1hcChtID0+IChpc1NpbXBsZUlkZW50aWZpZXIobSkgPyBtIDogSlNPTi5zdHJpbmdpZnkobSkpICsgYDogdHJ1ZWApXG4gICAgICAgICAgICAuam9pbihgLCBgKTtcbiAgICAgICAgY29uc3QgbW9kaWZpZXJzS2V5ID0gYXJnXG4gICAgICAgICAgICA/IGlzU3RhdGljRXhwKGFyZylcbiAgICAgICAgICAgICAgICA/IGAke2FyZy5jb250ZW50fU1vZGlmaWVyc2BcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbYXJnLCAnICsgXCJNb2RpZmllcnNcIiddKVxuICAgICAgICAgICAgOiBgbW9kZWxNb2RpZmllcnNgO1xuICAgICAgICBwcm9wcy5wdXNoKGNyZWF0ZU9iamVjdFByb3BlcnR5KG1vZGlmaWVyc0tleSwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgeyAke21vZGlmaWVyc30gfWAsIGZhbHNlLCBkaXIubG9jLCAyIC8qIENvbnN0YW50VHlwZXMuQ0FOX0hPSVNUICovKSkpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlVHJhbnNmb3JtUHJvcHMocHJvcHMpO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zZm9ybVByb3BzKHByb3BzID0gW10pIHtcbiAgICByZXR1cm4geyBwcm9wcyB9O1xufVxuXG5jb25zdCB2YWxpZERpdmlzaW9uQ2hhclJFID0gL1tcXHcpLitcXC1fJFxcXV0vO1xuY29uc3QgdHJhbnNmb3JtRmlsdGVyID0gKG5vZGUsIGNvbnRleHQpID0+IHtcbiAgICBpZiAoIWlzQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX0ZJTFRFUlwiIC8qIENvbXBpbGVyRGVwcmVjYXRpb25UeXBlcy5DT01QSUxFUl9GSUxURVJTICovLCBjb250ZXh0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChub2RlLnR5cGUgPT09IDUgLyogTm9kZVR5cGVzLklOVEVSUE9MQVRJT04gKi8pIHtcbiAgICAgICAgLy8gZmlsdGVyIHJld3JpdGUgaXMgYXBwbGllZCBiZWZvcmUgZXhwcmVzc2lvbiB0cmFuc2Zvcm0gc28gb25seVxuICAgICAgICAvLyBzaW1wbGUgZXhwcmVzc2lvbnMgYXJlIHBvc3NpYmxlIGF0IHRoaXMgc3RhZ2VcbiAgICAgICAgcmV3cml0ZUZpbHRlcihub2RlLmNvbnRlbnQsIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAobm9kZS50eXBlID09PSAxIC8qIE5vZGVUeXBlcy5FTEVNRU5UICovKSB7XG4gICAgICAgIG5vZGUucHJvcHMuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICAgICAgaWYgKHByb3AudHlwZSA9PT0gNyAvKiBOb2RlVHlwZXMuRElSRUNUSVZFICovICYmXG4gICAgICAgICAgICAgICAgcHJvcC5uYW1lICE9PSAnZm9yJyAmJlxuICAgICAgICAgICAgICAgIHByb3AuZXhwKSB7XG4gICAgICAgICAgICAgICAgcmV3cml0ZUZpbHRlcihwcm9wLmV4cCwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5mdW5jdGlvbiByZXdyaXRlRmlsdGVyKG5vZGUsIGNvbnRleHQpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLykge1xuICAgICAgICBwYXJzZUZpbHRlcihub2RlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZCAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gNCAvKiBOb2RlVHlwZXMuU0lNUExFX0VYUFJFU1NJT04gKi8pIHtcbiAgICAgICAgICAgICAgICBwYXJzZUZpbHRlcihjaGlsZCwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZC50eXBlID09PSA4IC8qIE5vZGVUeXBlcy5DT01QT1VORF9FWFBSRVNTSU9OICovKSB7XG4gICAgICAgICAgICAgICAgcmV3cml0ZUZpbHRlcihub2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkLnR5cGUgPT09IDUgLyogTm9kZVR5cGVzLklOVEVSUE9MQVRJT04gKi8pIHtcbiAgICAgICAgICAgICAgICByZXdyaXRlRmlsdGVyKGNoaWxkLmNvbnRlbnQsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VGaWx0ZXIobm9kZSwgY29udGV4dCkge1xuICAgIGNvbnN0IGV4cCA9IG5vZGUuY29udGVudDtcbiAgICBsZXQgaW5TaW5nbGUgPSBmYWxzZTtcbiAgICBsZXQgaW5Eb3VibGUgPSBmYWxzZTtcbiAgICBsZXQgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICAgIGxldCBpblJlZ2V4ID0gZmFsc2U7XG4gICAgbGV0IGN1cmx5ID0gMDtcbiAgICBsZXQgc3F1YXJlID0gMDtcbiAgICBsZXQgcGFyZW4gPSAwO1xuICAgIGxldCBsYXN0RmlsdGVySW5kZXggPSAwO1xuICAgIGxldCBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IGV4cC5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcmV2ID0gYztcbiAgICAgICAgYyA9IGV4cC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoaW5TaW5nbGUpIHtcbiAgICAgICAgICAgIGlmIChjID09PSAweDI3ICYmIHByZXYgIT09IDB4NWMpXG4gICAgICAgICAgICAgICAgaW5TaW5nbGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbkRvdWJsZSkge1xuICAgICAgICAgICAgaWYgKGMgPT09IDB4MjIgJiYgcHJldiAhPT0gMHg1YylcbiAgICAgICAgICAgICAgICBpbkRvdWJsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluVGVtcGxhdGVTdHJpbmcpIHtcbiAgICAgICAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NWMpXG4gICAgICAgICAgICAgICAgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluUmVnZXgpIHtcbiAgICAgICAgICAgIGlmIChjID09PSAweDJmICYmIHByZXYgIT09IDB4NWMpXG4gICAgICAgICAgICAgICAgaW5SZWdleCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IDB4N2MgJiYgLy8gcGlwZVxuICAgICAgICAgICAgZXhwLmNoYXJDb2RlQXQoaSArIDEpICE9PSAweDdjICYmXG4gICAgICAgICAgICBleHAuY2hhckNvZGVBdChpIC0gMSkgIT09IDB4N2MgJiZcbiAgICAgICAgICAgICFjdXJseSAmJlxuICAgICAgICAgICAgIXNxdWFyZSAmJlxuICAgICAgICAgICAgIXBhcmVuKSB7XG4gICAgICAgICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gZmlyc3QgZmlsdGVyLCBlbmQgb2YgZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHVzaEZpbHRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAweDIyOlxuICAgICAgICAgICAgICAgICAgICBpbkRvdWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBcIlxuICAgICAgICAgICAgICAgIGNhc2UgMHgyNzpcbiAgICAgICAgICAgICAgICAgICAgaW5TaW5nbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gJ1xuICAgICAgICAgICAgICAgIGNhc2UgMHg2MDpcbiAgICAgICAgICAgICAgICAgICAgaW5UZW1wbGF0ZVN0cmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBgXG4gICAgICAgICAgICAgICAgY2FzZSAweDI4OlxuICAgICAgICAgICAgICAgICAgICBwYXJlbisrO1xuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gKFxuICAgICAgICAgICAgICAgIGNhc2UgMHgyOTpcbiAgICAgICAgICAgICAgICAgICAgcGFyZW4tLTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIClcbiAgICAgICAgICAgICAgICBjYXNlIDB4NWI6XG4gICAgICAgICAgICAgICAgICAgIHNxdWFyZSsrO1xuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gW1xuICAgICAgICAgICAgICAgIGNhc2UgMHg1ZDpcbiAgICAgICAgICAgICAgICAgICAgc3F1YXJlLS07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBdXG4gICAgICAgICAgICAgICAgY2FzZSAweDdiOlxuICAgICAgICAgICAgICAgICAgICBjdXJseSsrO1xuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8ge1xuICAgICAgICAgICAgICAgIGNhc2UgMHg3ZDpcbiAgICAgICAgICAgICAgICAgICAgY3VybHktLTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID09PSAweDJmKSB7XG4gICAgICAgICAgICAgICAgLy8gL1xuICAgICAgICAgICAgICAgIGxldCBqID0gaSAtIDE7XG4gICAgICAgICAgICAgICAgbGV0IHA7XG4gICAgICAgICAgICAgICAgLy8gZmluZCBmaXJzdCBub24td2hpdGVzcGFjZSBwcmV2IGNoYXJcbiAgICAgICAgICAgICAgICBmb3IgKDsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwICE9PSAnICcpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5SZWdleCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxhc3RGaWx0ZXJJbmRleCAhPT0gMCkge1xuICAgICAgICBwdXNoRmlsdGVyKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hGaWx0ZXIoKSB7XG4gICAgICAgIGZpbHRlcnMucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgICB9XG4gICAgaWYgKGZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgd2FybkRlcHJlY2F0aW9uKFwiQ09NUElMRVJfRklMVEVSXCIgLyogQ29tcGlsZXJEZXByZWNhdGlvblR5cGVzLkNPTVBJTEVSX0ZJTFRFUlMgKi8sIGNvbnRleHQsIG5vZGUubG9jKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSB3cmFwRmlsdGVyKGV4cHJlc3Npb24sIGZpbHRlcnNbaV0sIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuY29udGVudCA9IGV4cHJlc3Npb247XG4gICAgfVxufVxuZnVuY3Rpb24gd3JhcEZpbHRlcihleHAsIGZpbHRlciwgY29udGV4dCkge1xuICAgIGNvbnRleHQuaGVscGVyKFJFU09MVkVfRklMVEVSKTtcbiAgICBjb25zdCBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcbiAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgY29udGV4dC5maWx0ZXJzLmFkZChmaWx0ZXIpO1xuICAgICAgICByZXR1cm4gYCR7dG9WYWxpZEFzc2V0SWQoZmlsdGVyLCAnZmlsdGVyJyl9KCR7ZXhwfSlgO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcbiAgICAgICAgY29uc3QgYXJncyA9IGZpbHRlci5zbGljZShpICsgMSk7XG4gICAgICAgIGNvbnRleHQuZmlsdGVycy5hZGQobmFtZSk7XG4gICAgICAgIHJldHVybiBgJHt0b1ZhbGlkQXNzZXRJZChuYW1lLCAnZmlsdGVyJyl9KCR7ZXhwfSR7YXJncyAhPT0gJyknID8gJywnICsgYXJncyA6IGFyZ3N9YDtcbiAgICB9XG59XG5cbmNvbnN0IHNlZW4kMSA9IG5ldyBXZWFrU2V0KCk7XG5jb25zdCB0cmFuc2Zvcm1NZW1vID0gKG5vZGUsIGNvbnRleHQpID0+IHtcbiAgICBpZiAobm9kZS50eXBlID09PSAxIC8qIE5vZGVUeXBlcy5FTEVNRU5UICovKSB7XG4gICAgICAgIGNvbnN0IGRpciA9IGZpbmREaXIobm9kZSwgJ21lbW8nKTtcbiAgICAgICAgaWYgKCFkaXIgfHwgc2VlbiQxLmhhcyhub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNlZW4kMS5hZGQobm9kZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb2RlZ2VuTm9kZSA9IG5vZGUuY29kZWdlbk5vZGUgfHxcbiAgICAgICAgICAgICAgICBjb250ZXh0LmN1cnJlbnROb2RlLmNvZGVnZW5Ob2RlO1xuICAgICAgICAgICAgaWYgKGNvZGVnZW5Ob2RlICYmIGNvZGVnZW5Ob2RlLnR5cGUgPT09IDEzIC8qIE5vZGVUeXBlcy5WTk9ERV9DQUxMICovKSB7XG4gICAgICAgICAgICAgICAgLy8gbm9uLWNvbXBvbmVudCBzdWIgdHJlZSBzaG91bGQgYmUgdHVybmVkIGludG8gYSBibG9ja1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnRhZ1R5cGUgIT09IDEgLyogRWxlbWVudFR5cGVzLkNPTVBPTkVOVCAqLykge1xuICAgICAgICAgICAgICAgICAgICBtYWtlQmxvY2soY29kZWdlbk5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLmNvZGVnZW5Ob2RlID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoV0lUSF9NRU1PKSwgW1xuICAgICAgICAgICAgICAgICAgICBkaXIuZXhwLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24odW5kZWZpbmVkLCBjb2RlZ2VuTm9kZSksXG4gICAgICAgICAgICAgICAgICAgIGBfY2FjaGVgLFxuICAgICAgICAgICAgICAgICAgICBTdHJpbmcoY29udGV4dC5jYWNoZWQrKylcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBnZXRCYXNlVHJhbnNmb3JtUHJlc2V0KHByZWZpeElkZW50aWZpZXJzKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgW1xuICAgICAgICAgICAgdHJhbnNmb3JtT25jZSxcbiAgICAgICAgICAgIHRyYW5zZm9ybUlmLFxuICAgICAgICAgICAgdHJhbnNmb3JtTWVtbyxcbiAgICAgICAgICAgIHRyYW5zZm9ybUZvcixcbiAgICAgICAgICAgIC4uLihbdHJhbnNmb3JtRmlsdGVyXSApLFxuICAgICAgICAgICAgLi4uKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICA/IFt0cmFuc2Zvcm1FeHByZXNzaW9uXVxuICAgICAgICAgICAgICAgICAgICA6IFtdKSxcbiAgICAgICAgICAgIHRyYW5zZm9ybVNsb3RPdXRsZXQsXG4gICAgICAgICAgICB0cmFuc2Zvcm1FbGVtZW50LFxuICAgICAgICAgICAgdHJhY2tTbG90U2NvcGVzLFxuICAgICAgICAgICAgdHJhbnNmb3JtVGV4dFxuICAgICAgICBdLFxuICAgICAgICB7XG4gICAgICAgICAgICBvbjogdHJhbnNmb3JtT24sXG4gICAgICAgICAgICBiaW5kOiB0cmFuc2Zvcm1CaW5kLFxuICAgICAgICAgICAgbW9kZWw6IHRyYW5zZm9ybU1vZGVsXG4gICAgICAgIH1cbiAgICBdO1xufVxuLy8gd2UgbmFtZSBpdCBgYmFzZUNvbXBpbGVgIHNvIHRoYXQgaGlnaGVyIG9yZGVyIGNvbXBpbGVycyBsaWtlXG4vLyBAdnVlL2NvbXBpbGVyLWRvbSBjYW4gZXhwb3J0IGBjb21waWxlYCB3aGlsZSByZS1leHBvcnRpbmcgZXZlcnl0aGluZyBlbHNlLlxuZnVuY3Rpb24gYmFzZUNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IG9uRXJyb3IgPSBvcHRpb25zLm9uRXJyb3IgfHwgZGVmYXVsdE9uRXJyb3I7XG4gICAgY29uc3QgaXNNb2R1bGVNb2RlID0gb3B0aW9ucy5tb2RlID09PSAnbW9kdWxlJztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICB7XG4gICAgICAgIGlmIChvcHRpb25zLnByZWZpeElkZW50aWZpZXJzID09PSB0cnVlKSB7XG4gICAgICAgICAgICBvbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDcgLyogRXJyb3JDb2Rlcy5YX1BSRUZJWF9JRF9OT1RfU1VQUE9SVEVEICovKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNNb2R1bGVNb2RlKSB7XG4gICAgICAgICAgICBvbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDggLyogRXJyb3JDb2Rlcy5YX01PRFVMRV9NT0RFX05PVF9TVVBQT1JURUQgKi8pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwcmVmaXhJZGVudGlmaWVycyA9ICF0cnVlIDtcbiAgICBpZiAob3B0aW9ucy5jYWNoZUhhbmRsZXJzKSB7XG4gICAgICAgIG9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig0OSAvKiBFcnJvckNvZGVzLlhfQ0FDSEVfSEFORExFUl9OT1RfU1VQUE9SVEVEICovKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnNjb3BlSWQgJiYgIWlzTW9kdWxlTW9kZSkge1xuICAgICAgICBvbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNTAgLyogRXJyb3JDb2Rlcy5YX1NDT1BFX0lEX05PVF9TVVBQT1JURUQgKi8pKTtcbiAgICB9XG4gICAgY29uc3QgYXN0ID0gaXNTdHJpbmcodGVtcGxhdGUpID8gYmFzZVBhcnNlKHRlbXBsYXRlLCBvcHRpb25zKSA6IHRlbXBsYXRlO1xuICAgIGNvbnN0IFtub2RlVHJhbnNmb3JtcywgZGlyZWN0aXZlVHJhbnNmb3Jtc10gPSBnZXRCYXNlVHJhbnNmb3JtUHJlc2V0KCk7XG4gICAgdHJhbnNmb3JtKGFzdCwgZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIHByZWZpeElkZW50aWZpZXJzLFxuICAgICAgICBub2RlVHJhbnNmb3JtczogW1xuICAgICAgICAgICAgLi4ubm9kZVRyYW5zZm9ybXMsXG4gICAgICAgICAgICAuLi4ob3B0aW9ucy5ub2RlVHJhbnNmb3JtcyB8fCBbXSkgLy8gdXNlciB0cmFuc2Zvcm1zXG4gICAgICAgIF0sXG4gICAgICAgIGRpcmVjdGl2ZVRyYW5zZm9ybXM6IGV4dGVuZCh7fSwgZGlyZWN0aXZlVHJhbnNmb3Jtcywgb3B0aW9ucy5kaXJlY3RpdmVUcmFuc2Zvcm1zIHx8IHt9IC8vIHVzZXIgdHJhbnNmb3Jtc1xuICAgICAgICApXG4gICAgfSkpO1xuICAgIHJldHVybiBnZW5lcmF0ZShhc3QsIGV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgICBwcmVmaXhJZGVudGlmaWVyc1xuICAgIH0pKTtcbn1cblxuY29uc3Qgbm9vcERpcmVjdGl2ZVRyYW5zZm9ybSA9ICgpID0+ICh7IHByb3BzOiBbXSB9KTtcblxuZXhwb3J0IHsgQkFTRV9UUkFOU0lUSU9OLCBDQU1FTElaRSwgQ0FQSVRBTElaRSwgQ1JFQVRFX0JMT0NLLCBDUkVBVEVfQ09NTUVOVCwgQ1JFQVRFX0VMRU1FTlRfQkxPQ0ssIENSRUFURV9FTEVNRU5UX1ZOT0RFLCBDUkVBVEVfU0xPVFMsIENSRUFURV9TVEFUSUMsIENSRUFURV9URVhULCBDUkVBVEVfVk5PREUsIEZSQUdNRU5ULCBHVUFSRF9SRUFDVElWRV9QUk9QUywgSVNfTUVNT19TQU1FLCBJU19SRUYsIEtFRVBfQUxJVkUsIE1FUkdFX1BST1BTLCBOT1JNQUxJWkVfQ0xBU1MsIE5PUk1BTElaRV9QUk9QUywgTk9STUFMSVpFX1NUWUxFLCBPUEVOX0JMT0NLLCBQT1BfU0NPUEVfSUQsIFBVU0hfU0NPUEVfSUQsIFJFTkRFUl9MSVNULCBSRU5ERVJfU0xPVCwgUkVTT0xWRV9DT01QT05FTlQsIFJFU09MVkVfRElSRUNUSVZFLCBSRVNPTFZFX0RZTkFNSUNfQ09NUE9ORU5ULCBSRVNPTFZFX0ZJTFRFUiwgU0VUX0JMT0NLX1RSQUNLSU5HLCBTVVNQRU5TRSwgVEVMRVBPUlQsIFRPX0RJU1BMQVlfU1RSSU5HLCBUT19IQU5ETEVSUywgVE9fSEFORExFUl9LRVksIFVOUkVGLCBXSVRIX0NUWCwgV0lUSF9ESVJFQ1RJVkVTLCBXSVRIX01FTU8sIGFkdmFuY2VQb3NpdGlvbldpdGhDbG9uZSwgYWR2YW5jZVBvc2l0aW9uV2l0aE11dGF0aW9uLCBhc3NlcnQsIGJhc2VDb21waWxlLCBiYXNlUGFyc2UsIGJ1aWxkRGlyZWN0aXZlQXJncywgYnVpbGRQcm9wcywgYnVpbGRTbG90cywgY2hlY2tDb21wYXRFbmFibGVkLCBjcmVhdGVBcnJheUV4cHJlc3Npb24sIGNyZWF0ZUFzc2lnbm1lbnRFeHByZXNzaW9uLCBjcmVhdGVCbG9ja1N0YXRlbWVudCwgY3JlYXRlQ2FjaGVFeHByZXNzaW9uLCBjcmVhdGVDYWxsRXhwcmVzc2lvbiwgY3JlYXRlQ29tcGlsZXJFcnJvciwgY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uLCBjcmVhdGVDb25kaXRpb25hbEV4cHJlc3Npb24sIGNyZWF0ZUZvckxvb3BQYXJhbXMsIGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbiwgY3JlYXRlSWZTdGF0ZW1lbnQsIGNyZWF0ZUludGVycG9sYXRpb24sIGNyZWF0ZU9iamVjdEV4cHJlc3Npb24sIGNyZWF0ZU9iamVjdFByb3BlcnR5LCBjcmVhdGVSZXR1cm5TdGF0ZW1lbnQsIGNyZWF0ZVJvb3QsIGNyZWF0ZVNlcXVlbmNlRXhwcmVzc2lvbiwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbiwgY3JlYXRlU3RydWN0dXJhbERpcmVjdGl2ZVRyYW5zZm9ybSwgY3JlYXRlVGVtcGxhdGVMaXRlcmFsLCBjcmVhdGVUcmFuc2Zvcm1Db250ZXh0LCBjcmVhdGVWTm9kZUNhbGwsIGV4dHJhY3RJZGVudGlmaWVycywgZmluZERpciwgZmluZFByb3AsIGdlbmVyYXRlLCBnZXRCYXNlVHJhbnNmb3JtUHJlc2V0LCBnZXRDb25zdGFudFR5cGUsIGdldElubmVyUmFuZ2UsIGdldE1lbW9lZFZOb2RlQ2FsbCwgZ2V0Vk5vZGVCbG9ja0hlbHBlciwgZ2V0Vk5vZGVIZWxwZXIsIGhhc0R5bmFtaWNLZXlWQmluZCwgaGFzU2NvcGVSZWYsIGhlbHBlck5hbWVNYXAsIGluamVjdFByb3AsIGlzQnVpbHRJblR5cGUsIGlzQ29yZUNvbXBvbmVudCwgaXNGdW5jdGlvblR5cGUsIGlzSW5EZXN0cnVjdHVyZUFzc2lnbm1lbnQsIGlzTWVtYmVyRXhwcmVzc2lvbiwgaXNNZW1iZXJFeHByZXNzaW9uQnJvd3NlciwgaXNNZW1iZXJFeHByZXNzaW9uTm9kZSwgaXNSZWZlcmVuY2VkSWRlbnRpZmllciwgaXNTaW1wbGVJZGVudGlmaWVyLCBpc1Nsb3RPdXRsZXQsIGlzU3RhdGljQXJnT2YsIGlzU3RhdGljRXhwLCBpc1N0YXRpY1Byb3BlcnR5LCBpc1N0YXRpY1Byb3BlcnR5S2V5LCBpc1RlbXBsYXRlTm9kZSwgaXNUZXh0LCBpc1ZTbG90LCBsb2NTdHViLCBtYWtlQmxvY2ssIG5vb3BEaXJlY3RpdmVUcmFuc2Zvcm0sIHByb2Nlc3NFeHByZXNzaW9uLCBwcm9jZXNzRm9yLCBwcm9jZXNzSWYsIHByb2Nlc3NTbG90T3V0bGV0LCByZWdpc3RlclJ1bnRpbWVIZWxwZXJzLCByZXNvbHZlQ29tcG9uZW50VHlwZSwgc3RyaW5naWZ5RXhwcmVzc2lvbiwgdG9WYWxpZEFzc2V0SWQsIHRyYWNrU2xvdFNjb3BlcywgdHJhY2tWRm9yU2xvdFNjb3BlcywgdHJhbnNmb3JtLCB0cmFuc2Zvcm1CaW5kLCB0cmFuc2Zvcm1FbGVtZW50LCB0cmFuc2Zvcm1FeHByZXNzaW9uLCB0cmFuc2Zvcm1Nb2RlbCwgdHJhbnNmb3JtT24sIHRyYXZlcnNlTm9kZSwgd2Fsa0Jsb2NrRGVjbGFyYXRpb25zLCB3YWxrRnVuY3Rpb25QYXJhbXMsIHdhbGtJZGVudGlmaWVycywgd2FybkRlcHJlY2F0aW9uIH07XG4iLCJpbXBvcnQgeyByZWdpc3RlclJ1bnRpbWVIZWxwZXJzLCBpc0J1aWx0SW5UeXBlLCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uLCBjcmVhdGVDb21waWxlckVycm9yLCBjcmVhdGVPYmplY3RQcm9wZXJ0eSwgZ2V0Q29uc3RhbnRUeXBlLCBjcmVhdGVDYWxsRXhwcmVzc2lvbiwgVE9fRElTUExBWV9TVFJJTkcsIHRyYW5zZm9ybU1vZGVsIGFzIHRyYW5zZm9ybU1vZGVsJDEsIGZpbmRQcm9wLCBoYXNEeW5hbWljS2V5VkJpbmQsIHRyYW5zZm9ybU9uIGFzIHRyYW5zZm9ybU9uJDEsIGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbiwgaXNTdGF0aWNFeHAsIGNoZWNrQ29tcGF0RW5hYmxlZCwgbm9vcERpcmVjdGl2ZVRyYW5zZm9ybSwgYmFzZUNvbXBpbGUsIGJhc2VQYXJzZSB9IGZyb20gJ0B2dWUvY29tcGlsZXItY29yZSc7XG5leHBvcnQgKiBmcm9tICdAdnVlL2NvbXBpbGVyLWNvcmUnO1xuaW1wb3J0IHsgaXNWb2lkVGFnLCBpc0hUTUxUYWcsIGlzU1ZHVGFnLCBtYWtlTWFwLCBwYXJzZVN0cmluZ1N0eWxlLCBjYXBpdGFsaXplLCBleHRlbmQgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmNvbnN0IFZfTU9ERUxfUkFESU8gPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHZNb2RlbFJhZGlvYCA6IGBgKTtcbmNvbnN0IFZfTU9ERUxfQ0hFQ0tCT1ggPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHZNb2RlbENoZWNrYm94YCA6IGBgKTtcbmNvbnN0IFZfTU9ERUxfVEVYVCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdk1vZGVsVGV4dGAgOiBgYCk7XG5jb25zdCBWX01PREVMX1NFTEVDVCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdk1vZGVsU2VsZWN0YCA6IGBgKTtcbmNvbnN0IFZfTU9ERUxfRFlOQU1JQyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdk1vZGVsRHluYW1pY2AgOiBgYCk7XG5jb25zdCBWX09OX1dJVEhfTU9ESUZJRVJTID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB2T25Nb2RpZmllcnNHdWFyZGAgOiBgYCk7XG5jb25zdCBWX09OX1dJVEhfS0VZUyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdk9uS2V5c0d1YXJkYCA6IGBgKTtcbmNvbnN0IFZfU0hPVyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdlNob3dgIDogYGApO1xuY29uc3QgVFJBTlNJVElPTiA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgVHJhbnNpdGlvbmAgOiBgYCk7XG5jb25zdCBUUkFOU0lUSU9OX0dST1VQID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBUcmFuc2l0aW9uR3JvdXBgIDogYGApO1xucmVnaXN0ZXJSdW50aW1lSGVscGVycyh7XG4gICAgW1ZfTU9ERUxfUkFESU9dOiBgdk1vZGVsUmFkaW9gLFxuICAgIFtWX01PREVMX0NIRUNLQk9YXTogYHZNb2RlbENoZWNrYm94YCxcbiAgICBbVl9NT0RFTF9URVhUXTogYHZNb2RlbFRleHRgLFxuICAgIFtWX01PREVMX1NFTEVDVF06IGB2TW9kZWxTZWxlY3RgLFxuICAgIFtWX01PREVMX0RZTkFNSUNdOiBgdk1vZGVsRHluYW1pY2AsXG4gICAgW1ZfT05fV0lUSF9NT0RJRklFUlNdOiBgd2l0aE1vZGlmaWVyc2AsXG4gICAgW1ZfT05fV0lUSF9LRVlTXTogYHdpdGhLZXlzYCxcbiAgICBbVl9TSE9XXTogYHZTaG93YCxcbiAgICBbVFJBTlNJVElPTl06IGBUcmFuc2l0aW9uYCxcbiAgICBbVFJBTlNJVElPTl9HUk9VUF06IGBUcmFuc2l0aW9uR3JvdXBgXG59KTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXG5sZXQgZGVjb2RlcjtcbmZ1bmN0aW9uIGRlY29kZUh0bWxCcm93c2VyKHJhdywgYXNBdHRyID0gZmFsc2UpIHtcbiAgICBpZiAoIWRlY29kZXIpIHtcbiAgICAgICAgZGVjb2RlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIH1cbiAgICBpZiAoYXNBdHRyKSB7XG4gICAgICAgIGRlY29kZXIuaW5uZXJIVE1MID0gYDxkaXYgZm9vPVwiJHtyYXcucmVwbGFjZSgvXCIvZywgJyZxdW90OycpfVwiPmA7XG4gICAgICAgIHJldHVybiBkZWNvZGVyLmNoaWxkcmVuWzBdLmdldEF0dHJpYnV0ZSgnZm9vJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkZWNvZGVyLmlubmVySFRNTCA9IHJhdztcbiAgICAgICAgcmV0dXJuIGRlY29kZXIudGV4dENvbnRlbnQ7XG4gICAgfVxufVxuXG5jb25zdCBpc1Jhd1RleHRDb250YWluZXIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoJ3N0eWxlLGlmcmFtZSxzY3JpcHQsbm9zY3JpcHQnLCB0cnVlKTtcbmNvbnN0IHBhcnNlck9wdGlvbnMgPSB7XG4gICAgaXNWb2lkVGFnLFxuICAgIGlzTmF0aXZlVGFnOiB0YWcgPT4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkdUYWcodGFnKSxcbiAgICBpc1ByZVRhZzogdGFnID0+IHRhZyA9PT0gJ3ByZScsXG4gICAgZGVjb2RlRW50aXRpZXM6IGRlY29kZUh0bWxCcm93c2VyICxcbiAgICBpc0J1aWx0SW5Db21wb25lbnQ6ICh0YWcpID0+IHtcbiAgICAgICAgaWYgKGlzQnVpbHRJblR5cGUodGFnLCBgVHJhbnNpdGlvbmApKSB7XG4gICAgICAgICAgICByZXR1cm4gVFJBTlNJVElPTjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0J1aWx0SW5UeXBlKHRhZywgYFRyYW5zaXRpb25Hcm91cGApKSB7XG4gICAgICAgICAgICByZXR1cm4gVFJBTlNJVElPTl9HUk9VUDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvcGFyc2luZy5odG1sI3RyZWUtY29uc3RydWN0aW9uLWRpc3BhdGNoZXJcbiAgICBnZXROYW1lc3BhY2UodGFnLCBwYXJlbnQpIHtcbiAgICAgICAgbGV0IG5zID0gcGFyZW50ID8gcGFyZW50Lm5zIDogMCAvKiBET01OYW1lc3BhY2VzLkhUTUwgKi87XG4gICAgICAgIGlmIChwYXJlbnQgJiYgbnMgPT09IDIgLyogRE9NTmFtZXNwYWNlcy5NQVRIX01MICovKSB7XG4gICAgICAgICAgICBpZiAocGFyZW50LnRhZyA9PT0gJ2Fubm90YXRpb24teG1sJykge1xuICAgICAgICAgICAgICAgIGlmICh0YWcgPT09ICdzdmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIERPTU5hbWVzcGFjZXMuU1ZHICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyZW50LnByb3BzLnNvbWUoYSA9PiBhLnR5cGUgPT09IDYgLyogTm9kZVR5cGVzLkFUVFJJQlVURSAqLyAmJlxuICAgICAgICAgICAgICAgICAgICBhLm5hbWUgPT09ICdlbmNvZGluZycgJiZcbiAgICAgICAgICAgICAgICAgICAgYS52YWx1ZSAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIChhLnZhbHVlLmNvbnRlbnQgPT09ICd0ZXh0L2h0bWwnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBhLnZhbHVlLmNvbnRlbnQgPT09ICdhcHBsaWNhdGlvbi94aHRtbCt4bWwnKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbnMgPSAwIC8qIERPTU5hbWVzcGFjZXMuSFRNTCAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgvXm0oPzpbaW9uc118dGV4dCkkLy50ZXN0KHBhcmVudC50YWcpICYmXG4gICAgICAgICAgICAgICAgdGFnICE9PSAnbWdseXBoJyAmJlxuICAgICAgICAgICAgICAgIHRhZyAhPT0gJ21hbGlnbm1hcmsnKSB7XG4gICAgICAgICAgICAgICAgbnMgPSAwIC8qIERPTU5hbWVzcGFjZXMuSFRNTCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJlbnQgJiYgbnMgPT09IDEgLyogRE9NTmFtZXNwYWNlcy5TVkcgKi8pIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQudGFnID09PSAnZm9yZWlnbk9iamVjdCcgfHxcbiAgICAgICAgICAgICAgICBwYXJlbnQudGFnID09PSAnZGVzYycgfHxcbiAgICAgICAgICAgICAgICBwYXJlbnQudGFnID09PSAndGl0bGUnKSB7XG4gICAgICAgICAgICAgICAgbnMgPSAwIC8qIERPTU5hbWVzcGFjZXMuSFRNTCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobnMgPT09IDAgLyogRE9NTmFtZXNwYWNlcy5IVE1MICovKSB7XG4gICAgICAgICAgICBpZiAodGFnID09PSAnc3ZnJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIERPTU5hbWVzcGFjZXMuU1ZHICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDIgLyogRE9NTmFtZXNwYWNlcy5NQVRIX01MICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBucztcbiAgICB9LFxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCNwYXJzaW5nLWh0bWwtZnJhZ21lbnRzXG4gICAgZ2V0VGV4dE1vZGUoeyB0YWcsIG5zIH0pIHtcbiAgICAgICAgaWYgKG5zID09PSAwIC8qIERPTU5hbWVzcGFjZXMuSFRNTCAqLykge1xuICAgICAgICAgICAgaWYgKHRhZyA9PT0gJ3RleHRhcmVhJyB8fCB0YWcgPT09ICd0aXRsZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBUZXh0TW9kZXMuUkNEQVRBICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUmF3VGV4dENvbnRhaW5lcih0YWcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDIgLyogVGV4dE1vZGVzLlJBV1RFWFQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDAgLyogVGV4dE1vZGVzLkRBVEEgKi87XG4gICAgfVxufTtcblxuLy8gUGFyc2UgaW5saW5lIENTUyBzdHJpbmdzIGZvciBzdGF0aWMgc3R5bGUgYXR0cmlidXRlcyBpbnRvIGFuIG9iamVjdC5cbi8vIFRoaXMgaXMgYSBOb2RlVHJhbnNmb3JtIHNpbmNlIGl0IHdvcmtzIG9uIHRoZSBzdGF0aWMgYHN0eWxlYCBhdHRyaWJ1dGUgYW5kXG4vLyBjb252ZXJ0cyBpdCBpbnRvIGEgZHluYW1pYyBlcXVpdmFsZW50OlxuLy8gc3R5bGU9XCJjb2xvcjogcmVkXCIgLT4gOnN0eWxlPSd7IFwiY29sb3JcIjogXCJyZWRcIiB9J1xuLy8gSXQgaXMgdGhlbiBwcm9jZXNzZWQgYnkgYHRyYW5zZm9ybUVsZW1lbnRgIGFuZCBpbmNsdWRlZCBpbiB0aGUgZ2VuZXJhdGVkXG4vLyBwcm9wcy5cbmNvbnN0IHRyYW5zZm9ybVN0eWxlID0gbm9kZSA9PiB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLykge1xuICAgICAgICBub2RlLnByb3BzLmZvckVhY2goKHAsIGkpID0+IHtcbiAgICAgICAgICAgIGlmIChwLnR5cGUgPT09IDYgLyogTm9kZVR5cGVzLkFUVFJJQlVURSAqLyAmJiBwLm5hbWUgPT09ICdzdHlsZScgJiYgcC52YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgcCB3aXRoIGFuIGV4cHJlc3Npb24gbm9kZVxuICAgICAgICAgICAgICAgIG5vZGUucHJvcHNbaV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IDcgLyogTm9kZVR5cGVzLkRJUkVDVElWRSAqLyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogYGJpbmRgLFxuICAgICAgICAgICAgICAgICAgICBhcmc6IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYHN0eWxlYCwgdHJ1ZSwgcC5sb2MpLFxuICAgICAgICAgICAgICAgICAgICBleHA6IHBhcnNlSW5saW5lQ1NTKHAudmFsdWUuY29udGVudCwgcC5sb2MpLFxuICAgICAgICAgICAgICAgICAgICBtb2RpZmllcnM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBsb2M6IHAubG9jXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcbmNvbnN0IHBhcnNlSW5saW5lQ1NTID0gKGNzc1RleHQsIGxvYykgPT4ge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBwYXJzZVN0cmluZ1N0eWxlKGNzc1RleHQpO1xuICAgIHJldHVybiBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKEpTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZWQpLCBmYWxzZSwgbG9jLCAzIC8qIENvbnN0YW50VHlwZXMuQ0FOX1NUUklOR0lGWSAqLyk7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVET01Db21waWxlckVycm9yKGNvZGUsIGxvYykge1xuICAgIHJldHVybiBjcmVhdGVDb21waWxlckVycm9yKGNvZGUsIGxvYywgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICF0cnVlID8gRE9NRXJyb3JNZXNzYWdlcyA6IHVuZGVmaW5lZCk7XG59XG5jb25zdCBET01FcnJvck1lc3NhZ2VzID0ge1xuICAgIFs1MSAvKiBET01FcnJvckNvZGVzLlhfVl9IVE1MX05PX0VYUFJFU1NJT04gKi9dOiBgdi1odG1sIGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxuICAgIFs1MiAvKiBET01FcnJvckNvZGVzLlhfVl9IVE1MX1dJVEhfQ0hJTERSRU4gKi9dOiBgdi1odG1sIHdpbGwgb3ZlcnJpZGUgZWxlbWVudCBjaGlsZHJlbi5gLFxuICAgIFs1MyAvKiBET01FcnJvckNvZGVzLlhfVl9URVhUX05PX0VYUFJFU1NJT04gKi9dOiBgdi10ZXh0IGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxuICAgIFs1NCAvKiBET01FcnJvckNvZGVzLlhfVl9URVhUX1dJVEhfQ0hJTERSRU4gKi9dOiBgdi10ZXh0IHdpbGwgb3ZlcnJpZGUgZWxlbWVudCBjaGlsZHJlbi5gLFxuICAgIFs1NSAvKiBET01FcnJvckNvZGVzLlhfVl9NT0RFTF9PTl9JTlZBTElEX0VMRU1FTlQgKi9dOiBgdi1tb2RlbCBjYW4gb25seSBiZSB1c2VkIG9uIDxpbnB1dD4sIDx0ZXh0YXJlYT4gYW5kIDxzZWxlY3Q+IGVsZW1lbnRzLmAsXG4gICAgWzU2IC8qIERPTUVycm9yQ29kZXMuWF9WX01PREVMX0FSR19PTl9FTEVNRU5UICovXTogYHYtbW9kZWwgYXJndW1lbnQgaXMgbm90IHN1cHBvcnRlZCBvbiBwbGFpbiBlbGVtZW50cy5gLFxuICAgIFs1NyAvKiBET01FcnJvckNvZGVzLlhfVl9NT0RFTF9PTl9GSUxFX0lOUFVUX0VMRU1FTlQgKi9dOiBgdi1tb2RlbCBjYW5ub3QgYmUgdXNlZCBvbiBmaWxlIGlucHV0cyBzaW5jZSB0aGV5IGFyZSByZWFkLW9ubHkuIFVzZSBhIHYtb246Y2hhbmdlIGxpc3RlbmVyIGluc3RlYWQuYCxcbiAgICBbNTggLyogRE9NRXJyb3JDb2Rlcy5YX1ZfTU9ERUxfVU5ORUNFU1NBUllfVkFMVUUgKi9dOiBgVW5uZWNlc3NhcnkgdmFsdWUgYmluZGluZyB1c2VkIGFsb25nc2lkZSB2LW1vZGVsLiBJdCB3aWxsIGludGVyZmVyZSB3aXRoIHYtbW9kZWwncyBiZWhhdmlvci5gLFxuICAgIFs1OSAvKiBET01FcnJvckNvZGVzLlhfVl9TSE9XX05PX0VYUFJFU1NJT04gKi9dOiBgdi1zaG93IGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxuICAgIFs2MCAvKiBET01FcnJvckNvZGVzLlhfVFJBTlNJVElPTl9JTlZBTElEX0NISUxEUkVOICovXTogYDxUcmFuc2l0aW9uPiBleHBlY3RzIGV4YWN0bHkgb25lIGNoaWxkIGVsZW1lbnQgb3IgY29tcG9uZW50LmAsXG4gICAgWzYxIC8qIERPTUVycm9yQ29kZXMuWF9JR05PUkVEX1NJREVfRUZGRUNUX1RBRyAqL106IGBUYWdzIHdpdGggc2lkZSBlZmZlY3QgKDxzY3JpcHQ+IGFuZCA8c3R5bGU+KSBhcmUgaWdub3JlZCBpbiBjbGllbnQgY29tcG9uZW50IHRlbXBsYXRlcy5gXG59O1xuXG5jb25zdCB0cmFuc2Zvcm1WSHRtbCA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcbiAgICBjb25zdCB7IGV4cCwgbG9jIH0gPSBkaXI7XG4gICAgaWYgKCFleHApIHtcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTEgLyogRE9NRXJyb3JDb2Rlcy5YX1ZfSFRNTF9OT19FWFBSRVNTSU9OICovLCBsb2MpKTtcbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVET01Db21waWxlckVycm9yKDUyIC8qIERPTUVycm9yQ29kZXMuWF9WX0hUTUxfV0lUSF9DSElMRFJFTiAqLywgbG9jKSk7XG4gICAgICAgIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IFtcbiAgICAgICAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYGlubmVySFRNTGAsIHRydWUsIGxvYyksIGV4cCB8fCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKCcnLCB0cnVlKSlcbiAgICAgICAgXVxuICAgIH07XG59O1xuXG5jb25zdCB0cmFuc2Zvcm1WVGV4dCA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcbiAgICBjb25zdCB7IGV4cCwgbG9jIH0gPSBkaXI7XG4gICAgaWYgKCFleHApIHtcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTMgLyogRE9NRXJyb3JDb2Rlcy5YX1ZfVEVYVF9OT19FWFBSRVNTSU9OICovLCBsb2MpKTtcbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVET01Db21waWxlckVycm9yKDU0IC8qIERPTUVycm9yQ29kZXMuWF9WX1RFWFRfV0lUSF9DSElMRFJFTiAqLywgbG9jKSk7XG4gICAgICAgIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IFtcbiAgICAgICAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYHRleHRDb250ZW50YCwgdHJ1ZSksIGV4cFxuICAgICAgICAgICAgICAgID8gZ2V0Q29uc3RhbnRUeXBlKGV4cCwgY29udGV4dCkgPiAwXG4gICAgICAgICAgICAgICAgICAgID8gZXhwXG4gICAgICAgICAgICAgICAgICAgIDogY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXJTdHJpbmcoVE9fRElTUExBWV9TVFJJTkcpLCBbZXhwXSwgbG9jKVxuICAgICAgICAgICAgICAgIDogY3JlYXRlU2ltcGxlRXhwcmVzc2lvbignJywgdHJ1ZSkpXG4gICAgICAgIF1cbiAgICB9O1xufTtcblxuY29uc3QgdHJhbnNmb3JtTW9kZWwgPSAoZGlyLCBub2RlLCBjb250ZXh0KSA9PiB7XG4gICAgY29uc3QgYmFzZVJlc3VsdCA9IHRyYW5zZm9ybU1vZGVsJDEoZGlyLCBub2RlLCBjb250ZXh0KTtcbiAgICAvLyBiYXNlIHRyYW5zZm9ybSBoYXMgZXJyb3JzIE9SIGNvbXBvbmVudCB2LW1vZGVsIChvbmx5IG5lZWQgcHJvcHMpXG4gICAgaWYgKCFiYXNlUmVzdWx0LnByb3BzLmxlbmd0aCB8fCBub2RlLnRhZ1R5cGUgPT09IDEgLyogRWxlbWVudFR5cGVzLkNPTVBPTkVOVCAqLykge1xuICAgICAgICByZXR1cm4gYmFzZVJlc3VsdDtcbiAgICB9XG4gICAgaWYgKGRpci5hcmcpIHtcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTYgLyogRE9NRXJyb3JDb2Rlcy5YX1ZfTU9ERUxfQVJHX09OX0VMRU1FTlQgKi8sIGRpci5hcmcubG9jKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrRHVwbGljYXRlZFZhbHVlKCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGZpbmRQcm9wKG5vZGUsICd2YWx1ZScpO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVET01Db21waWxlckVycm9yKDU4IC8qIERPTUVycm9yQ29kZXMuWF9WX01PREVMX1VOTkVDRVNTQVJZX1ZBTFVFICovLCB2YWx1ZS5sb2MpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7IHRhZyB9ID0gbm9kZTtcbiAgICBjb25zdCBpc0N1c3RvbUVsZW1lbnQgPSBjb250ZXh0LmlzQ3VzdG9tRWxlbWVudCh0YWcpO1xuICAgIGlmICh0YWcgPT09ICdpbnB1dCcgfHxcbiAgICAgICAgdGFnID09PSAndGV4dGFyZWEnIHx8XG4gICAgICAgIHRhZyA9PT0gJ3NlbGVjdCcgfHxcbiAgICAgICAgaXNDdXN0b21FbGVtZW50KSB7XG4gICAgICAgIGxldCBkaXJlY3RpdmVUb1VzZSA9IFZfTU9ERUxfVEVYVDtcbiAgICAgICAgbGV0IGlzSW52YWxpZFR5cGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fCBpc0N1c3RvbUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBmaW5kUHJvcChub2RlLCBgdHlwZWApO1xuICAgICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZS50eXBlID09PSA3IC8qIE5vZGVUeXBlcy5ESVJFQ1RJVkUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gOnR5cGU9XCJmb29cIlxuICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmVUb1VzZSA9IFZfTU9ERUxfRFlOQU1JQztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUudmFsdWUuY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmFkaW8nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZVRvVXNlID0gVl9NT0RFTF9SQURJTztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmVUb1VzZSA9IFZfTU9ERUxfQ0hFQ0tCT1g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmaWxlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0ludmFsaWRUeXBlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1NyAvKiBET01FcnJvckNvZGVzLlhfVl9NT0RFTF9PTl9GSUxFX0lOUFVUX0VMRU1FTlQgKi8sIGRpci5sb2MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGV4dCB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNoZWNrRHVwbGljYXRlZFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXNEeW5hbWljS2V5VkJpbmQobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50IGhhcyBiaW5kaW5ncyB3aXRoIGR5bmFtaWMga2V5cywgd2hpY2ggY2FuIHBvc3NpYmx5IGNvbnRhaW5cbiAgICAgICAgICAgICAgICAvLyBcInR5cGVcIi5cbiAgICAgICAgICAgICAgICBkaXJlY3RpdmVUb1VzZSA9IFZfTU9ERUxfRFlOQU1JQztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRleHQgdHlwZVxuICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjaGVja0R1cGxpY2F0ZWRWYWx1ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgICAgIGRpcmVjdGl2ZVRvVXNlID0gVl9NT0RFTF9TRUxFQ1Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB0ZXh0YXJlYVxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNoZWNrRHVwbGljYXRlZFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW5qZWN0IHJ1bnRpbWUgZGlyZWN0aXZlXG4gICAgICAgIC8vIGJ5IHJldHVybmluZyB0aGUgaGVscGVyIHN5bWJvbCB2aWEgbmVlZFJ1bnRpbWVcbiAgICAgICAgLy8gdGhlIGltcG9ydCB3aWxsIHJlcGxhY2VkIGEgcmVzb2x2ZURpcmVjdGl2ZSBjYWxsLlxuICAgICAgICBpZiAoIWlzSW52YWxpZFR5cGUpIHtcbiAgICAgICAgICAgIGJhc2VSZXN1bHQubmVlZFJ1bnRpbWUgPSBjb250ZXh0LmhlbHBlcihkaXJlY3RpdmVUb1VzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVET01Db21waWxlckVycm9yKDU1IC8qIERPTUVycm9yQ29kZXMuWF9WX01PREVMX09OX0lOVkFMSURfRUxFTUVOVCAqLywgZGlyLmxvYykpO1xuICAgIH1cbiAgICAvLyBuYXRpdmUgdm1vZGVsIGRvZXNuJ3QgbmVlZCB0aGUgYG1vZGVsVmFsdWVgIHByb3BzIHNpbmNlIHRoZXkgYXJlIGFsc29cbiAgICAvLyBwYXNzZWQgdG8gdGhlIHJ1bnRpbWUgYXMgYGJpbmRpbmcudmFsdWVgLiByZW1vdmluZyBpdCByZWR1Y2VzIGNvZGUgc2l6ZS5cbiAgICBiYXNlUmVzdWx0LnByb3BzID0gYmFzZVJlc3VsdC5wcm9wcy5maWx0ZXIocCA9PiAhKHAua2V5LnR5cGUgPT09IDQgLyogTm9kZVR5cGVzLlNJTVBMRV9FWFBSRVNTSU9OICovICYmXG4gICAgICAgIHAua2V5LmNvbnRlbnQgPT09ICdtb2RlbFZhbHVlJykpO1xuICAgIHJldHVybiBiYXNlUmVzdWx0O1xufTtcblxuY29uc3QgaXNFdmVudE9wdGlvbk1vZGlmaWVyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGBwYXNzaXZlLG9uY2UsY2FwdHVyZWApO1xuY29uc3QgaXNOb25LZXlNb2RpZmllciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChcbi8vIGV2ZW50IHByb3BhZ2F0aW9uIG1hbmFnZW1lbnRcbmBzdG9wLHByZXZlbnQsc2VsZixgICtcbiAgICAvLyBzeXN0ZW0gbW9kaWZpZXJzICsgZXhhY3RcbiAgICBgY3RybCxzaGlmdCxhbHQsbWV0YSxleGFjdCxgICtcbiAgICAvLyBtb3VzZVxuICAgIGBtaWRkbGVgKTtcbi8vIGxlZnQgJiByaWdodCBjb3VsZCBiZSBtb3VzZSBvciBrZXkgbW9kaWZpZXJzIGJhc2VkIG9uIGV2ZW50IHR5cGVcbmNvbnN0IG1heWJlS2V5TW9kaWZpZXIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoJ2xlZnQscmlnaHQnKTtcbmNvbnN0IGlzS2V5Ym9hcmRFdmVudCA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChgb25rZXl1cCxvbmtleWRvd24sb25rZXlwcmVzc2AsIHRydWUpO1xuY29uc3QgcmVzb2x2ZU1vZGlmaWVycyA9IChrZXksIG1vZGlmaWVycywgY29udGV4dCwgbG9jKSA9PiB7XG4gICAgY29uc3Qga2V5TW9kaWZpZXJzID0gW107XG4gICAgY29uc3Qgbm9uS2V5TW9kaWZpZXJzID0gW107XG4gICAgY29uc3QgZXZlbnRPcHRpb25Nb2RpZmllcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBtb2RpZmllciA9IG1vZGlmaWVyc1tpXTtcbiAgICAgICAgaWYgKG1vZGlmaWVyID09PSAnbmF0aXZlJyAmJlxuICAgICAgICAgICAgY2hlY2tDb21wYXRFbmFibGVkKFwiQ09NUElMRVJfVl9PTl9OQVRJVkVcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfVl9PTl9OQVRJVkUgKi8sIGNvbnRleHQsIGxvYykpIHtcbiAgICAgICAgICAgIGV2ZW50T3B0aW9uTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRXZlbnRPcHRpb25Nb2RpZmllcihtb2RpZmllcikpIHtcbiAgICAgICAgICAgIC8vIGV2ZW50T3B0aW9uTW9kaWZpZXJzOiBtb2RpZmllcnMgZm9yIGFkZEV2ZW50TGlzdGVuZXIoKSBvcHRpb25zLFxuICAgICAgICAgICAgLy8gZS5nLiAucGFzc2l2ZSAmIC5jYXB0dXJlXG4gICAgICAgICAgICBldmVudE9wdGlvbk1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJ1bnRpbWVNb2RpZmllcnM6IG1vZGlmaWVycyB0aGF0IG5lZWRzIHJ1bnRpbWUgZ3VhcmRzXG4gICAgICAgICAgICBpZiAobWF5YmVLZXlNb2RpZmllcihtb2RpZmllcikpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNTdGF0aWNFeHAoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNLZXlib2FyZEV2ZW50KGtleS5jb250ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5TW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9uS2V5TW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBrZXlNb2RpZmllcnMucHVzaChtb2RpZmllcik7XG4gICAgICAgICAgICAgICAgICAgIG5vbktleU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOb25LZXlNb2RpZmllcihtb2RpZmllcikpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9uS2V5TW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAga2V5TW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBrZXlNb2RpZmllcnMsXG4gICAgICAgIG5vbktleU1vZGlmaWVycyxcbiAgICAgICAgZXZlbnRPcHRpb25Nb2RpZmllcnNcbiAgICB9O1xufTtcbmNvbnN0IHRyYW5zZm9ybUNsaWNrID0gKGtleSwgZXZlbnQpID0+IHtcbiAgICBjb25zdCBpc1N0YXRpY0NsaWNrID0gaXNTdGF0aWNFeHAoa2V5KSAmJiBrZXkuY29udGVudC50b0xvd2VyQ2FzZSgpID09PSAnb25jbGljayc7XG4gICAgcmV0dXJuIGlzU3RhdGljQ2xpY2tcbiAgICAgICAgPyBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGV2ZW50LCB0cnVlKVxuICAgICAgICA6IGtleS50eXBlICE9PSA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqL1xuICAgICAgICAgICAgPyBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oW1xuICAgICAgICAgICAgICAgIGAoYCxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgYCkgPT09IFwib25DbGlja1wiID8gXCIke2V2ZW50fVwiIDogKGAsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIGApYFxuICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIDoga2V5O1xufTtcbmNvbnN0IHRyYW5zZm9ybU9uID0gKGRpciwgbm9kZSwgY29udGV4dCkgPT4ge1xuICAgIHJldHVybiB0cmFuc2Zvcm1PbiQxKGRpciwgbm9kZSwgY29udGV4dCwgYmFzZVJlc3VsdCA9PiB7XG4gICAgICAgIGNvbnN0IHsgbW9kaWZpZXJzIH0gPSBkaXI7XG4gICAgICAgIGlmICghbW9kaWZpZXJzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBiYXNlUmVzdWx0O1xuICAgICAgICBsZXQgeyBrZXksIHZhbHVlOiBoYW5kbGVyRXhwIH0gPSBiYXNlUmVzdWx0LnByb3BzWzBdO1xuICAgICAgICBjb25zdCB7IGtleU1vZGlmaWVycywgbm9uS2V5TW9kaWZpZXJzLCBldmVudE9wdGlvbk1vZGlmaWVycyB9ID0gcmVzb2x2ZU1vZGlmaWVycyhrZXksIG1vZGlmaWVycywgY29udGV4dCwgZGlyLmxvYyk7XG4gICAgICAgIC8vIG5vcm1hbGl6ZSBjbGljay5yaWdodCBhbmQgY2xpY2subWlkZGxlIHNpbmNlIHRoZXkgZG9uJ3QgYWN0dWFsbHkgZmlyZVxuICAgICAgICBpZiAobm9uS2V5TW9kaWZpZXJzLmluY2x1ZGVzKCdyaWdodCcpKSB7XG4gICAgICAgICAgICBrZXkgPSB0cmFuc2Zvcm1DbGljayhrZXksIGBvbkNvbnRleHRtZW51YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vbktleU1vZGlmaWVycy5pbmNsdWRlcygnbWlkZGxlJykpIHtcbiAgICAgICAgICAgIGtleSA9IHRyYW5zZm9ybUNsaWNrKGtleSwgYG9uTW91c2V1cGApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub25LZXlNb2RpZmllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBoYW5kbGVyRXhwID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoVl9PTl9XSVRIX01PRElGSUVSUyksIFtcbiAgICAgICAgICAgICAgICBoYW5kbGVyRXhwLFxuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG5vbktleU1vZGlmaWVycylcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXlNb2RpZmllcnMubGVuZ3RoICYmXG4gICAgICAgICAgICAvLyBpZiBldmVudCBuYW1lIGlzIGR5bmFtaWMsIGFsd2F5cyB3cmFwIHdpdGgga2V5cyBndWFyZFxuICAgICAgICAgICAgKCFpc1N0YXRpY0V4cChrZXkpIHx8IGlzS2V5Ym9hcmRFdmVudChrZXkuY29udGVudCkpKSB7XG4gICAgICAgICAgICBoYW5kbGVyRXhwID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoVl9PTl9XSVRIX0tFWVMpLCBbXG4gICAgICAgICAgICAgICAgaGFuZGxlckV4cCxcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShrZXlNb2RpZmllcnMpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnRPcHRpb25Nb2RpZmllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBtb2RpZmllclBvc3RmaXggPSBldmVudE9wdGlvbk1vZGlmaWVycy5tYXAoY2FwaXRhbGl6ZSkuam9pbignJyk7XG4gICAgICAgICAgICBrZXkgPSBpc1N0YXRpY0V4cChrZXkpXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGAke2tleS5jb250ZW50fSR7bW9kaWZpZXJQb3N0Zml4fWAsIHRydWUpXG4gICAgICAgICAgICAgICAgOiBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oW2AoYCwga2V5LCBgKSArIFwiJHttb2RpZmllclBvc3RmaXh9XCJgXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByb3BzOiBbY3JlYXRlT2JqZWN0UHJvcGVydHkoa2V5LCBoYW5kbGVyRXhwKV1cbiAgICAgICAgfTtcbiAgICB9KTtcbn07XG5cbmNvbnN0IHRyYW5zZm9ybVNob3cgPSAoZGlyLCBub2RlLCBjb250ZXh0KSA9PiB7XG4gICAgY29uc3QgeyBleHAsIGxvYyB9ID0gZGlyO1xuICAgIGlmICghZXhwKSB7XG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVET01Db21waWxlckVycm9yKDU5IC8qIERPTUVycm9yQ29kZXMuWF9WX1NIT1dfTk9fRVhQUkVTU0lPTiAqLywgbG9jKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiBbXSxcbiAgICAgICAgbmVlZFJ1bnRpbWU6IGNvbnRleHQuaGVscGVyKFZfU0hPVylcbiAgICB9O1xufTtcblxuY29uc3QgdHJhbnNmb3JtVHJhbnNpdGlvbiA9IChub2RlLCBjb250ZXh0KSA9PiB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLyAmJlxuICAgICAgICBub2RlLnRhZ1R5cGUgPT09IDEgLyogRWxlbWVudFR5cGVzLkNPTVBPTkVOVCAqLykge1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSBjb250ZXh0LmlzQnVpbHRJbkNvbXBvbmVudChub2RlLnRhZyk7XG4gICAgICAgIGlmIChjb21wb25lbnQgPT09IFRSQU5TSVRJT04pIHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHdhcm4gbXVsdGlwbGUgdHJhbnNpdGlvbiBjaGlsZHJlblxuICAgICAgICAgICAgICAgIGlmIChoYXNNdWx0aXBsZUNoaWxkcmVuKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVET01Db21waWxlckVycm9yKDYwIC8qIERPTUVycm9yQ29kZXMuWF9UUkFOU0lUSU9OX0lOVkFMSURfQ0hJTERSRU4gKi8sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBub2RlLmNoaWxkcmVuWzBdLmxvYy5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogbm9kZS5jaGlsZHJlbltub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDFdLmxvYy5lbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6ICcnXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgaXQncyBzIHNpbmdsZSBjaGlsZCB3LyB2LXNob3dcbiAgICAgICAgICAgICAgICAvLyBpZiB5ZXMsIGluamVjdCBcInBlcnNpc3RlZDogdHJ1ZVwiIHRvIHRoZSB0cmFuc2l0aW9uIHByb3BzXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSAxIC8qIE5vZGVUeXBlcy5FTEVNRU5UICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcCBvZiBjaGlsZC5wcm9wcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAudHlwZSA9PT0gNyAvKiBOb2RlVHlwZXMuRElSRUNUSVZFICovICYmIHAubmFtZSA9PT0gJ3Nob3cnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wcm9wcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogNiAvKiBOb2RlVHlwZXMuQVRUUklCVVRFICovLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncGVyc2lzdGVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jOiBub2RlLmxvY1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5mdW5jdGlvbiBoYXNNdWx0aXBsZUNoaWxkcmVuKG5vZGUpIHtcbiAgICAvLyAjMTM1MiBmaWx0ZXIgb3V0IHBvdGVudGlhbCBjb21tZW50IG5vZGVzLlxuICAgIGNvbnN0IGNoaWxkcmVuID0gKG5vZGUuY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLmZpbHRlcihjID0+IGMudHlwZSAhPT0gMyAvKiBOb2RlVHlwZXMuQ09NTUVOVCAqLyAmJlxuICAgICAgICAhKGMudHlwZSA9PT0gMiAvKiBOb2RlVHlwZXMuVEVYVCAqLyAmJiAhYy5jb250ZW50LnRyaW0oKSkpKTtcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuWzBdO1xuICAgIHJldHVybiAoY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8XG4gICAgICAgIGNoaWxkLnR5cGUgPT09IDExIC8qIE5vZGVUeXBlcy5GT1IgKi8gfHxcbiAgICAgICAgKGNoaWxkLnR5cGUgPT09IDkgLyogTm9kZVR5cGVzLklGICovICYmIGNoaWxkLmJyYW5jaGVzLnNvbWUoaGFzTXVsdGlwbGVDaGlsZHJlbikpKTtcbn1cblxuY29uc3QgaWdub3JlU2lkZUVmZmVjdFRhZ3MgPSAobm9kZSwgY29udGV4dCkgPT4ge1xuICAgIGlmIChub2RlLnR5cGUgPT09IDEgLyogTm9kZVR5cGVzLkVMRU1FTlQgKi8gJiZcbiAgICAgICAgbm9kZS50YWdUeXBlID09PSAwIC8qIEVsZW1lbnRUeXBlcy5FTEVNRU5UICovICYmXG4gICAgICAgIChub2RlLnRhZyA9PT0gJ3NjcmlwdCcgfHwgbm9kZS50YWcgPT09ICdzdHlsZScpKSB7XG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVET01Db21waWxlckVycm9yKDYxIC8qIERPTUVycm9yQ29kZXMuWF9JR05PUkVEX1NJREVfRUZGRUNUX1RBRyAqLywgbm9kZS5sb2MpKTtcbiAgICAgICAgY29udGV4dC5yZW1vdmVOb2RlKCk7XG4gICAgfVxufTtcblxuY29uc3QgRE9NTm9kZVRyYW5zZm9ybXMgPSBbXG4gICAgdHJhbnNmb3JtU3R5bGUsXG4gICAgLi4uKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IFt0cmFuc2Zvcm1UcmFuc2l0aW9uXSA6IFtdKVxuXTtcbmNvbnN0IERPTURpcmVjdGl2ZVRyYW5zZm9ybXMgPSB7XG4gICAgY2xvYWs6IG5vb3BEaXJlY3RpdmVUcmFuc2Zvcm0sXG4gICAgaHRtbDogdHJhbnNmb3JtVkh0bWwsXG4gICAgdGV4dDogdHJhbnNmb3JtVlRleHQsXG4gICAgbW9kZWw6IHRyYW5zZm9ybU1vZGVsLFxuICAgIG9uOiB0cmFuc2Zvcm1PbixcbiAgICBzaG93OiB0cmFuc2Zvcm1TaG93XG59O1xuZnVuY3Rpb24gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIGJhc2VDb21waWxlKHRlbXBsYXRlLCBleHRlbmQoe30sIHBhcnNlck9wdGlvbnMsIG9wdGlvbnMsIHtcbiAgICAgICAgbm9kZVRyYW5zZm9ybXM6IFtcbiAgICAgICAgICAgIC8vIGlnbm9yZSA8c2NyaXB0PiBhbmQgPHRhZz5cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHB1dCBpbnNpZGUgRE9NTm9kZVRyYW5zZm9ybXMgYmVjYXVzZSB0aGF0IGxpc3QgaXMgdXNlZFxuICAgICAgICAgICAgLy8gYnkgY29tcGlsZXItc3NyIHRvIGdlbmVyYXRlIHZub2RlIGZhbGxiYWNrIGJyYW5jaGVzXG4gICAgICAgICAgICBpZ25vcmVTaWRlRWZmZWN0VGFncyxcbiAgICAgICAgICAgIC4uLkRPTU5vZGVUcmFuc2Zvcm1zLFxuICAgICAgICAgICAgLi4uKG9wdGlvbnMubm9kZVRyYW5zZm9ybXMgfHwgW10pXG4gICAgICAgIF0sXG4gICAgICAgIGRpcmVjdGl2ZVRyYW5zZm9ybXM6IGV4dGVuZCh7fSwgRE9NRGlyZWN0aXZlVHJhbnNmb3Jtcywgb3B0aW9ucy5kaXJlY3RpdmVUcmFuc2Zvcm1zIHx8IHt9KSxcbiAgICAgICAgdHJhbnNmb3JtSG9pc3Q6IG51bGwgXG4gICAgfSkpO1xufVxuZnVuY3Rpb24gcGFyc2UodGVtcGxhdGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBiYXNlUGFyc2UodGVtcGxhdGUsIGV4dGVuZCh7fSwgcGFyc2VyT3B0aW9ucywgb3B0aW9ucykpO1xufVxuXG5leHBvcnQgeyBET01EaXJlY3RpdmVUcmFuc2Zvcm1zLCBET01Ob2RlVHJhbnNmb3JtcywgVFJBTlNJVElPTiwgVFJBTlNJVElPTl9HUk9VUCwgVl9NT0RFTF9DSEVDS0JPWCwgVl9NT0RFTF9EWU5BTUlDLCBWX01PREVMX1JBRElPLCBWX01PREVMX1NFTEVDVCwgVl9NT0RFTF9URVhULCBWX09OX1dJVEhfS0VZUywgVl9PTl9XSVRIX01PRElGSUVSUywgVl9TSE9XLCBjb21waWxlLCBjcmVhdGVET01Db21waWxlckVycm9yLCBwYXJzZSwgcGFyc2VyT3B0aW9ucywgdHJhbnNmb3JtU3R5bGUgfTtcbiIsImltcG9ydCB7IGV4dGVuZCwgaXNBcnJheSwgdG9OdW1iZXIsIGlzTWFwLCBpc0ludGVnZXJLZXksIGhhc093biwgaXNTeW1ib2wsIGlzT2JqZWN0LCBoYXNDaGFuZ2VkLCBtYWtlTWFwLCBjYXBpdGFsaXplLCB0b1Jhd1R5cGUsIGRlZiwgaXNGdW5jdGlvbiwgTk9PUCB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuZnVuY3Rpb24gd2Fybihtc2csIC4uLmFyZ3MpIHtcbiAgICBjb25zb2xlLndhcm4oYFtWdWUgd2Fybl0gJHttc2d9YCwgLi4uYXJncyk7XG59XG5cbmxldCBhY3RpdmVFZmZlY3RTY29wZTtcbmNsYXNzIEVmZmVjdFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihkZXRhY2hlZCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZGV0YWNoZWQgPSBkZXRhY2hlZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVmZmVjdHMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGVhbnVwcyA9IFtdO1xuICAgICAgICB0aGlzLnBhcmVudCA9IGFjdGl2ZUVmZmVjdFNjb3BlO1xuICAgICAgICBpZiAoIWRldGFjaGVkICYmIGFjdGl2ZUVmZmVjdFNjb3BlKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID1cbiAgICAgICAgICAgICAgICAoYWN0aXZlRWZmZWN0U2NvcGUuc2NvcGVzIHx8IChhY3RpdmVFZmZlY3RTY29wZS5zY29wZXMgPSBbXSkpLnB1c2godGhpcykgLSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJ1bihmbikge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRFZmZlY3RTY29wZSA9IGFjdGl2ZUVmZmVjdFNjb3BlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IGN1cnJlbnRFZmZlY3RTY29wZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgIHdhcm4oYGNhbm5vdCBydW4gYW4gaW5hY3RpdmUgZWZmZWN0IHNjb3BlLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIG5vbi1kZXRhY2hlZCBzY29wZXNcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBvbigpIHtcbiAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgPSB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBub24tZGV0YWNoZWQgc2NvcGVzXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgb2ZmKCkge1xuICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IHRoaXMucGFyZW50O1xuICAgIH1cbiAgICBzdG9wKGZyb21QYXJlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICBsZXQgaSwgbDtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmVmZmVjdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lZmZlY3RzW2ldLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNsZWFudXBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYW51cHNbaV0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnNjb3Blcykge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLnNjb3Blcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY29wZXNbaV0uc3RvcCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBuZXN0ZWQgc2NvcGUsIGRlcmVmZXJlbmNlIGZyb20gcGFyZW50IHRvIGF2b2lkIG1lbW9yeSBsZWFrc1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRldGFjaGVkICYmIHRoaXMucGFyZW50ICYmICFmcm9tUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gb3B0aW1pemVkIE8oMSkgcmVtb3ZhbFxuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzLnBhcmVudC5zY29wZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QgJiYgbGFzdCAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5zY29wZXNbdGhpcy5pbmRleF0gPSBsYXN0O1xuICAgICAgICAgICAgICAgICAgICBsYXN0LmluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBlZmZlY3RTY29wZShkZXRhY2hlZCkge1xuICAgIHJldHVybiBuZXcgRWZmZWN0U2NvcGUoZGV0YWNoZWQpO1xufVxuZnVuY3Rpb24gcmVjb3JkRWZmZWN0U2NvcGUoZWZmZWN0LCBzY29wZSA9IGFjdGl2ZUVmZmVjdFNjb3BlKSB7XG4gICAgaWYgKHNjb3BlICYmIHNjb3BlLmFjdGl2ZSkge1xuICAgICAgICBzY29wZS5lZmZlY3RzLnB1c2goZWZmZWN0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50U2NvcGUoKSB7XG4gICAgcmV0dXJuIGFjdGl2ZUVmZmVjdFNjb3BlO1xufVxuZnVuY3Rpb24gb25TY29wZURpc3Bvc2UoZm4pIHtcbiAgICBpZiAoYWN0aXZlRWZmZWN0U2NvcGUpIHtcbiAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUuY2xlYW51cHMucHVzaChmbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICB3YXJuKGBvblNjb3BlRGlzcG9zZSgpIGlzIGNhbGxlZCB3aGVuIHRoZXJlIGlzIG5vIGFjdGl2ZSBlZmZlY3Qgc2NvcGVgICtcbiAgICAgICAgICAgIGAgdG8gYmUgYXNzb2NpYXRlZCB3aXRoLmApO1xuICAgIH1cbn1cblxuY29uc3QgY3JlYXRlRGVwID0gKGVmZmVjdHMpID0+IHtcbiAgICBjb25zdCBkZXAgPSBuZXcgU2V0KGVmZmVjdHMpO1xuICAgIGRlcC53ID0gMDtcbiAgICBkZXAubiA9IDA7XG4gICAgcmV0dXJuIGRlcDtcbn07XG5jb25zdCB3YXNUcmFja2VkID0gKGRlcCkgPT4gKGRlcC53ICYgdHJhY2tPcEJpdCkgPiAwO1xuY29uc3QgbmV3VHJhY2tlZCA9IChkZXApID0+IChkZXAubiAmIHRyYWNrT3BCaXQpID4gMDtcbmNvbnN0IGluaXREZXBNYXJrZXJzID0gKHsgZGVwcyB9KSA9PiB7XG4gICAgaWYgKGRlcHMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGVwc1tpXS53IHw9IHRyYWNrT3BCaXQ7IC8vIHNldCB3YXMgdHJhY2tlZFxuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGZpbmFsaXplRGVwTWFya2VycyA9IChlZmZlY3QpID0+IHtcbiAgICBjb25zdCB7IGRlcHMgfSA9IGVmZmVjdDtcbiAgICBpZiAoZGVwcy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IHB0ciA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZGVwID0gZGVwc1tpXTtcbiAgICAgICAgICAgIGlmICh3YXNUcmFja2VkKGRlcCkgJiYgIW5ld1RyYWNrZWQoZGVwKSkge1xuICAgICAgICAgICAgICAgIGRlcC5kZWxldGUoZWZmZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlcHNbcHRyKytdID0gZGVwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2xlYXIgYml0c1xuICAgICAgICAgICAgZGVwLncgJj0gfnRyYWNrT3BCaXQ7XG4gICAgICAgICAgICBkZXAubiAmPSB+dHJhY2tPcEJpdDtcbiAgICAgICAgfVxuICAgICAgICBkZXBzLmxlbmd0aCA9IHB0cjtcbiAgICB9XG59O1xuXG5jb25zdCB0YXJnZXRNYXAgPSBuZXcgV2Vha01hcCgpO1xuLy8gVGhlIG51bWJlciBvZiBlZmZlY3RzIGN1cnJlbnRseSBiZWluZyB0cmFja2VkIHJlY3Vyc2l2ZWx5LlxubGV0IGVmZmVjdFRyYWNrRGVwdGggPSAwO1xubGV0IHRyYWNrT3BCaXQgPSAxO1xuLyoqXG4gKiBUaGUgYml0d2lzZSB0cmFjayBtYXJrZXJzIHN1cHBvcnQgYXQgbW9zdCAzMCBsZXZlbHMgb2YgcmVjdXJzaW9uLlxuICogVGhpcyB2YWx1ZSBpcyBjaG9zZW4gdG8gZW5hYmxlIG1vZGVybiBKUyBlbmdpbmVzIHRvIHVzZSBhIFNNSSBvbiBhbGwgcGxhdGZvcm1zLlxuICogV2hlbiByZWN1cnNpb24gZGVwdGggaXMgZ3JlYXRlciwgZmFsbCBiYWNrIHRvIHVzaW5nIGEgZnVsbCBjbGVhbnVwLlxuICovXG5jb25zdCBtYXhNYXJrZXJCaXRzID0gMzA7XG5sZXQgYWN0aXZlRWZmZWN0O1xuY29uc3QgSVRFUkFURV9LRVkgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ2l0ZXJhdGUnIDogJycpO1xuY29uc3QgTUFQX0tFWV9JVEVSQVRFX0tFWSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnTWFwIGtleSBpdGVyYXRlJyA6ICcnKTtcbmNsYXNzIFJlYWN0aXZlRWZmZWN0IHtcbiAgICBjb25zdHJ1Y3Rvcihmbiwgc2NoZWR1bGVyID0gbnVsbCwgc2NvcGUpIHtcbiAgICAgICAgdGhpcy5mbiA9IGZuO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLmRlcHMgPSBbXTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJlY29yZEVmZmVjdFNjb3BlKHRoaXMsIHNjb3BlKTtcbiAgICB9XG4gICAgcnVuKCkge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mbigpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJlbnQgPSBhY3RpdmVFZmZlY3Q7XG4gICAgICAgIGxldCBsYXN0U2hvdWxkVHJhY2sgPSBzaG91bGRUcmFjaztcbiAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudCA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gYWN0aXZlRWZmZWN0O1xuICAgICAgICAgICAgYWN0aXZlRWZmZWN0ID0gdGhpcztcbiAgICAgICAgICAgIHNob3VsZFRyYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIHRyYWNrT3BCaXQgPSAxIDw8ICsrZWZmZWN0VHJhY2tEZXB0aDtcbiAgICAgICAgICAgIGlmIChlZmZlY3RUcmFja0RlcHRoIDw9IG1heE1hcmtlckJpdHMpIHtcbiAgICAgICAgICAgICAgICBpbml0RGVwTWFya2Vycyh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsZWFudXBFZmZlY3QodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mbigpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGVmZmVjdFRyYWNrRGVwdGggPD0gbWF4TWFya2VyQml0cykge1xuICAgICAgICAgICAgICAgIGZpbmFsaXplRGVwTWFya2Vycyh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNrT3BCaXQgPSAxIDw8IC0tZWZmZWN0VHJhY2tEZXB0aDtcbiAgICAgICAgICAgIGFjdGl2ZUVmZmVjdCA9IHRoaXMucGFyZW50O1xuICAgICAgICAgICAgc2hvdWxkVHJhY2sgPSBsYXN0U2hvdWxkVHJhY2s7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlZmVyU3RvcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIC8vIHN0b3BwZWQgd2hpbGUgcnVubmluZyBpdHNlbGYgLSBkZWZlciB0aGUgY2xlYW51cFxuICAgICAgICBpZiAoYWN0aXZlRWZmZWN0ID09PSB0aGlzKSB7XG4gICAgICAgICAgICB0aGlzLmRlZmVyU3RvcCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgIGNsZWFudXBFZmZlY3QodGhpcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5vblN0b3ApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uU3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNsZWFudXBFZmZlY3QoZWZmZWN0KSB7XG4gICAgY29uc3QgeyBkZXBzIH0gPSBlZmZlY3Q7XG4gICAgaWYgKGRlcHMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGVwc1tpXS5kZWxldGUoZWZmZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBkZXBzLmxlbmd0aCA9IDA7XG4gICAgfVxufVxuZnVuY3Rpb24gZWZmZWN0KGZuLCBvcHRpb25zKSB7XG4gICAgaWYgKGZuLmVmZmVjdCkge1xuICAgICAgICBmbiA9IGZuLmVmZmVjdC5mbjtcbiAgICB9XG4gICAgY29uc3QgX2VmZmVjdCA9IG5ldyBSZWFjdGl2ZUVmZmVjdChmbik7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKF9lZmZlY3QsIG9wdGlvbnMpO1xuICAgICAgICBpZiAob3B0aW9ucy5zY29wZSlcbiAgICAgICAgICAgIHJlY29yZEVmZmVjdFNjb3BlKF9lZmZlY3QsIG9wdGlvbnMuc2NvcGUpO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMubGF6eSkge1xuICAgICAgICBfZWZmZWN0LnJ1bigpO1xuICAgIH1cbiAgICBjb25zdCBydW5uZXIgPSBfZWZmZWN0LnJ1bi5iaW5kKF9lZmZlY3QpO1xuICAgIHJ1bm5lci5lZmZlY3QgPSBfZWZmZWN0O1xuICAgIHJldHVybiBydW5uZXI7XG59XG5mdW5jdGlvbiBzdG9wKHJ1bm5lcikge1xuICAgIHJ1bm5lci5lZmZlY3Quc3RvcCgpO1xufVxubGV0IHNob3VsZFRyYWNrID0gdHJ1ZTtcbmNvbnN0IHRyYWNrU3RhY2sgPSBbXTtcbmZ1bmN0aW9uIHBhdXNlVHJhY2tpbmcoKSB7XG4gICAgdHJhY2tTdGFjay5wdXNoKHNob3VsZFRyYWNrKTtcbiAgICBzaG91bGRUcmFjayA9IGZhbHNlO1xufVxuZnVuY3Rpb24gZW5hYmxlVHJhY2tpbmcoKSB7XG4gICAgdHJhY2tTdGFjay5wdXNoKHNob3VsZFRyYWNrKTtcbiAgICBzaG91bGRUcmFjayA9IHRydWU7XG59XG5mdW5jdGlvbiByZXNldFRyYWNraW5nKCkge1xuICAgIGNvbnN0IGxhc3QgPSB0cmFja1N0YWNrLnBvcCgpO1xuICAgIHNob3VsZFRyYWNrID0gbGFzdCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGxhc3Q7XG59XG5mdW5jdGlvbiB0cmFjayh0YXJnZXQsIHR5cGUsIGtleSkge1xuICAgIGlmIChzaG91bGRUcmFjayAmJiBhY3RpdmVFZmZlY3QpIHtcbiAgICAgICAgbGV0IGRlcHNNYXAgPSB0YXJnZXRNYXAuZ2V0KHRhcmdldCk7XG4gICAgICAgIGlmICghZGVwc01hcCkge1xuICAgICAgICAgICAgdGFyZ2V0TWFwLnNldCh0YXJnZXQsIChkZXBzTWFwID0gbmV3IE1hcCgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlcCA9IGRlcHNNYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghZGVwKSB7XG4gICAgICAgICAgICBkZXBzTWFwLnNldChrZXksIChkZXAgPSBjcmVhdGVEZXAoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV2ZW50SW5mbyA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxuICAgICAgICAgICAgPyB7IGVmZmVjdDogYWN0aXZlRWZmZWN0LCB0YXJnZXQsIHR5cGUsIGtleSB9XG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgdHJhY2tFZmZlY3RzKGRlcCwgZXZlbnRJbmZvKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0cmFja0VmZmVjdHMoZGVwLCBkZWJ1Z2dlckV2ZW50RXh0cmFJbmZvKSB7XG4gICAgbGV0IHNob3VsZFRyYWNrID0gZmFsc2U7XG4gICAgaWYgKGVmZmVjdFRyYWNrRGVwdGggPD0gbWF4TWFya2VyQml0cykge1xuICAgICAgICBpZiAoIW5ld1RyYWNrZWQoZGVwKSkge1xuICAgICAgICAgICAgZGVwLm4gfD0gdHJhY2tPcEJpdDsgLy8gc2V0IG5ld2x5IHRyYWNrZWRcbiAgICAgICAgICAgIHNob3VsZFRyYWNrID0gIXdhc1RyYWNrZWQoZGVwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gRnVsbCBjbGVhbnVwIG1vZGUuXG4gICAgICAgIHNob3VsZFRyYWNrID0gIWRlcC5oYXMoYWN0aXZlRWZmZWN0KTtcbiAgICB9XG4gICAgaWYgKHNob3VsZFRyYWNrKSB7XG4gICAgICAgIGRlcC5hZGQoYWN0aXZlRWZmZWN0KTtcbiAgICAgICAgYWN0aXZlRWZmZWN0LmRlcHMucHVzaChkZXApO1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGFjdGl2ZUVmZmVjdC5vblRyYWNrKSB7XG4gICAgICAgICAgICBhY3RpdmVFZmZlY3Qub25UcmFjayhPYmplY3QuYXNzaWduKHsgZWZmZWN0OiBhY3RpdmVFZmZlY3QgfSwgZGVidWdnZXJFdmVudEV4dHJhSW5mbykpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdHJpZ2dlcih0YXJnZXQsIHR5cGUsIGtleSwgbmV3VmFsdWUsIG9sZFZhbHVlLCBvbGRUYXJnZXQpIHtcbiAgICBjb25zdCBkZXBzTWFwID0gdGFyZ2V0TWFwLmdldCh0YXJnZXQpO1xuICAgIGlmICghZGVwc01hcCkge1xuICAgICAgICAvLyBuZXZlciBiZWVuIHRyYWNrZWRcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgZGVwcyA9IFtdO1xuICAgIGlmICh0eXBlID09PSBcImNsZWFyXCIgLyogVHJpZ2dlck9wVHlwZXMuQ0xFQVIgKi8pIHtcbiAgICAgICAgLy8gY29sbGVjdGlvbiBiZWluZyBjbGVhcmVkXG4gICAgICAgIC8vIHRyaWdnZXIgYWxsIGVmZmVjdHMgZm9yIHRhcmdldFxuICAgICAgICBkZXBzID0gWy4uLmRlcHNNYXAudmFsdWVzKCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXkgPT09ICdsZW5ndGgnICYmIGlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICBjb25zdCBuZXdMZW5ndGggPSB0b051bWJlcihuZXdWYWx1ZSk7XG4gICAgICAgIGRlcHNNYXAuZm9yRWFjaCgoZGVwLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdsZW5ndGgnIHx8IGtleSA+PSBuZXdMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkZXBzLnB1c2goZGVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBzY2hlZHVsZSBydW5zIGZvciBTRVQgfCBBREQgfCBERUxFVEVcbiAgICAgICAgaWYgKGtleSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBkZXBzLnB1c2goZGVwc01hcC5nZXQoa2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWxzbyBydW4gZm9yIGl0ZXJhdGlvbiBrZXkgb24gQUREIHwgREVMRVRFIHwgTWFwLlNFVFxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhZGRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5BREQgKi86XG4gICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBzLnB1c2goZGVwc01hcC5nZXQoTUFQX0tFWV9JVEVSQVRFX0tFWSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzSW50ZWdlcktleShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5ldyBpbmRleCBhZGRlZCB0byBhcnJheSAtPiBsZW5ndGggY2hhbmdlc1xuICAgICAgICAgICAgICAgICAgICBkZXBzLnB1c2goZGVwc01hcC5nZXQoJ2xlbmd0aCcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZGVsZXRlXCIgLyogVHJpZ2dlck9wVHlwZXMuREVMRVRFICovOlxuICAgICAgICAgICAgICAgIGlmICghaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KE1BUF9LRVlfSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzZXRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5TRVQgKi86XG4gICAgICAgICAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50SW5mbyA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxuICAgICAgICA/IHsgdGFyZ2V0LCB0eXBlLCBrZXksIG5ld1ZhbHVlLCBvbGRWYWx1ZSwgb2xkVGFyZ2V0IH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgaWYgKGRlcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmIChkZXBzWzBdKSB7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckVmZmVjdHMoZGVwc1swXSwgZXZlbnRJbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyaWdnZXJFZmZlY3RzKGRlcHNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBlZmZlY3RzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZGVwIG9mIGRlcHMpIHtcbiAgICAgICAgICAgIGlmIChkZXApIHtcbiAgICAgICAgICAgICAgICBlZmZlY3RzLnB1c2goLi4uZGVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICB0cmlnZ2VyRWZmZWN0cyhjcmVhdGVEZXAoZWZmZWN0cyksIGV2ZW50SW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cmlnZ2VyRWZmZWN0cyhjcmVhdGVEZXAoZWZmZWN0cykpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdHJpZ2dlckVmZmVjdHMoZGVwLCBkZWJ1Z2dlckV2ZW50RXh0cmFJbmZvKSB7XG4gICAgLy8gc3ByZWFkIGludG8gYXJyYXkgZm9yIHN0YWJpbGl6YXRpb25cbiAgICBjb25zdCBlZmZlY3RzID0gaXNBcnJheShkZXApID8gZGVwIDogWy4uLmRlcF07XG4gICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICBpZiAoZWZmZWN0LmNvbXB1dGVkKSB7XG4gICAgICAgICAgICB0cmlnZ2VyRWZmZWN0KGVmZmVjdCwgZGVidWdnZXJFdmVudEV4dHJhSW5mbyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICBpZiAoIWVmZmVjdC5jb21wdXRlZCkge1xuICAgICAgICAgICAgdHJpZ2dlckVmZmVjdChlZmZlY3QsIGRlYnVnZ2VyRXZlbnRFeHRyYUluZm8pO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdHJpZ2dlckVmZmVjdChlZmZlY3QsIGRlYnVnZ2VyRXZlbnRFeHRyYUluZm8pIHtcbiAgICBpZiAoZWZmZWN0ICE9PSBhY3RpdmVFZmZlY3QgfHwgZWZmZWN0LmFsbG93UmVjdXJzZSkge1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGVmZmVjdC5vblRyaWdnZXIpIHtcbiAgICAgICAgICAgIGVmZmVjdC5vblRyaWdnZXIoZXh0ZW5kKHsgZWZmZWN0IH0sIGRlYnVnZ2VyRXZlbnRFeHRyYUluZm8pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWZmZWN0LnNjaGVkdWxlcikge1xuICAgICAgICAgICAgZWZmZWN0LnNjaGVkdWxlcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWZmZWN0LnJ1bigpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBpc05vblRyYWNrYWJsZUtleXMgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoYF9fcHJvdG9fXyxfX3ZfaXNSZWYsX19pc1Z1ZWApO1xuY29uc3QgYnVpbHRJblN5bWJvbHMgPSBuZXcgU2V0KFxuLyojX19QVVJFX18qL1xuT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoU3ltYm9sKVxuICAgIC8vIGlvczEwLnggT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoU3ltYm9sKSBjYW4gZW51bWVyYXRlICdhcmd1bWVudHMnIGFuZCAnY2FsbGVyJ1xuICAgIC8vIGJ1dCBhY2Nlc3NpbmcgdGhlbSBvbiBTeW1ib2wgbGVhZHMgdG8gVHlwZUVycm9yIGJlY2F1c2UgU3ltYm9sIGlzIGEgc3RyaWN0IG1vZGVcbiAgICAvLyBmdW5jdGlvblxuICAgIC5maWx0ZXIoa2V5ID0+IGtleSAhPT0gJ2FyZ3VtZW50cycgJiYga2V5ICE9PSAnY2FsbGVyJylcbiAgICAubWFwKGtleSA9PiBTeW1ib2xba2V5XSlcbiAgICAuZmlsdGVyKGlzU3ltYm9sKSk7XG5jb25zdCBnZXQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZUdldHRlcigpO1xuY29uc3Qgc2hhbGxvd0dldCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlR2V0dGVyKGZhbHNlLCB0cnVlKTtcbmNvbnN0IHJlYWRvbmx5R2V0ID0gLyojX19QVVJFX18qLyBjcmVhdGVHZXR0ZXIodHJ1ZSk7XG5jb25zdCBzaGFsbG93UmVhZG9ubHlHZXQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZUdldHRlcih0cnVlLCB0cnVlKTtcbmNvbnN0IGFycmF5SW5zdHJ1bWVudGF0aW9ucyA9IC8qI19fUFVSRV9fKi8gY3JlYXRlQXJyYXlJbnN0cnVtZW50YXRpb25zKCk7XG5mdW5jdGlvbiBjcmVhdGVBcnJheUluc3RydW1lbnRhdGlvbnMoKSB7XG4gICAgY29uc3QgaW5zdHJ1bWVudGF0aW9ucyA9IHt9O1xuICAgIFsnaW5jbHVkZXMnLCAnaW5kZXhPZicsICdsYXN0SW5kZXhPZiddLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgaW5zdHJ1bWVudGF0aW9uc1trZXldID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGFyciA9IHRvUmF3KHRoaXMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHRyYWNrKGFyciwgXCJnZXRcIiAvKiBUcmFja09wVHlwZXMuR0VUICovLCBpICsgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd2UgcnVuIHRoZSBtZXRob2QgdXNpbmcgdGhlIG9yaWdpbmFsIGFyZ3MgZmlyc3QgKHdoaWNoIG1heSBiZSByZWFjdGl2ZSlcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGFycltrZXldKC4uLmFyZ3MpO1xuICAgICAgICAgICAgaWYgKHJlcyA9PT0gLTEgfHwgcmVzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoYXQgZGlkbid0IHdvcmssIHJ1biBpdCBhZ2FpbiB1c2luZyByYXcgdmFsdWVzLlxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJba2V5XSguLi5hcmdzLm1hcCh0b1JhdykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBbJ3B1c2gnLCAncG9wJywgJ3NoaWZ0JywgJ3Vuc2hpZnQnLCAnc3BsaWNlJ10uZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBpbnN0cnVtZW50YXRpb25zW2tleV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgcGF1c2VUcmFja2luZygpO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gdG9SYXcodGhpcylba2V5XS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGluc3RydW1lbnRhdGlvbnM7XG59XG5mdW5jdGlvbiBjcmVhdGVHZXR0ZXIoaXNSZWFkb25seSA9IGZhbHNlLCBzaGFsbG93ID0gZmFsc2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcikge1xuICAgICAgICBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWN0aXZlXCIgLyogUmVhY3RpdmVGbGFncy5JU19SRUFDVElWRSAqLykge1xuICAgICAgICAgICAgcmV0dXJuICFpc1JlYWRvbmx5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiIC8qIFJlYWN0aXZlRmxhZ3MuSVNfUkVBRE9OTFkgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBpc1JlYWRvbmx5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNTaGFsbG93XCIgLyogUmVhY3RpdmVGbGFncy5JU19TSEFMTE9XICovKSB7XG4gICAgICAgICAgICByZXR1cm4gc2hhbGxvdztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiX192X3Jhd1wiIC8qIFJlYWN0aXZlRmxhZ3MuUkFXICovICYmXG4gICAgICAgICAgICByZWNlaXZlciA9PT1cbiAgICAgICAgICAgICAgICAoaXNSZWFkb25seVxuICAgICAgICAgICAgICAgICAgICA/IHNoYWxsb3dcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2hhbGxvd1JlYWRvbmx5TWFwXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHJlYWRvbmx5TWFwXG4gICAgICAgICAgICAgICAgICAgIDogc2hhbGxvd1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBzaGFsbG93UmVhY3RpdmVNYXBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcmVhY3RpdmVNYXApLmdldCh0YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldElzQXJyYXkgPSBpc0FycmF5KHRhcmdldCk7XG4gICAgICAgIGlmICghaXNSZWFkb25seSAmJiB0YXJnZXRJc0FycmF5ICYmIGhhc093bihhcnJheUluc3RydW1lbnRhdGlvbnMsIGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldChhcnJheUluc3RydW1lbnRhdGlvbnMsIGtleSwgcmVjZWl2ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcik7XG4gICAgICAgIGlmIChpc1N5bWJvbChrZXkpID8gYnVpbHRJblN5bWJvbHMuaGFzKGtleSkgOiBpc05vblRyYWNrYWJsZUtleXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzUmVhZG9ubHkpIHtcbiAgICAgICAgICAgIHRyYWNrKHRhcmdldCwgXCJnZXRcIiAvKiBUcmFja09wVHlwZXMuR0VUICovLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaGFsbG93KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1JlZihyZXMpKSB7XG4gICAgICAgICAgICAvLyByZWYgdW53cmFwcGluZyAtIHNraXAgdW53cmFwIGZvciBBcnJheSArIGludGVnZXIga2V5LlxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldElzQXJyYXkgJiYgaXNJbnRlZ2VyS2V5KGtleSkgPyByZXMgOiByZXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgcmV0dXJuZWQgdmFsdWUgaW50byBhIHByb3h5IGFzIHdlbGwuIHdlIGRvIHRoZSBpc09iamVjdCBjaGVja1xuICAgICAgICAgICAgLy8gaGVyZSB0byBhdm9pZCBpbnZhbGlkIHZhbHVlIHdhcm5pbmcuIEFsc28gbmVlZCB0byBsYXp5IGFjY2VzcyByZWFkb25seVxuICAgICAgICAgICAgLy8gYW5kIHJlYWN0aXZlIGhlcmUgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICAgICAgICAgIHJldHVybiBpc1JlYWRvbmx5ID8gcmVhZG9ubHkocmVzKSA6IHJlYWN0aXZlKHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xufVxuY29uc3Qgc2V0ID0gLyojX19QVVJFX18qLyBjcmVhdGVTZXR0ZXIoKTtcbmNvbnN0IHNoYWxsb3dTZXQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZVNldHRlcih0cnVlKTtcbmZ1bmN0aW9uIGNyZWF0ZVNldHRlcihzaGFsbG93ID0gZmFsc2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gc2V0KHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgbGV0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgICAgIGlmIChpc1JlYWRvbmx5KG9sZFZhbHVlKSAmJiBpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2hhbGxvdykge1xuICAgICAgICAgICAgaWYgKCFpc1NoYWxsb3codmFsdWUpICYmICFpc1JlYWRvbmx5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gdG9SYXcob2xkVmFsdWUpO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0FycmF5KHRhcmdldCkgJiYgaXNSZWYob2xkVmFsdWUpICYmICFpc1JlZih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhZEtleSA9IGlzQXJyYXkodGFyZ2V0KSAmJiBpc0ludGVnZXJLZXkoa2V5KVxuICAgICAgICAgICAgPyBOdW1iZXIoa2V5KSA8IHRhcmdldC5sZW5ndGhcbiAgICAgICAgICAgIDogaGFzT3duKHRhcmdldCwga2V5KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5zZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcik7XG4gICAgICAgIC8vIGRvbid0IHRyaWdnZXIgaWYgdGFyZ2V0IGlzIHNvbWV0aGluZyB1cCBpbiB0aGUgcHJvdG90eXBlIGNoYWluIG9mIG9yaWdpbmFsXG4gICAgICAgIGlmICh0YXJnZXQgPT09IHRvUmF3KHJlY2VpdmVyKSkge1xuICAgICAgICAgICAgaWYgKCFoYWRLZXkpIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5BREQgKi8sIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzQ2hhbmdlZCh2YWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwic2V0XCIgLyogVHJpZ2dlck9wVHlwZXMuU0VUICovLCBrZXksIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufVxuZnVuY3Rpb24gZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcbiAgICBjb25zdCBoYWRLZXkgPSBoYXNPd24odGFyZ2V0LCBrZXkpO1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSk7XG4gICAgaWYgKHJlc3VsdCAmJiBoYWRLZXkpIHtcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiZGVsZXRlXCIgLyogVHJpZ2dlck9wVHlwZXMuREVMRVRFICovLCBrZXksIHVuZGVmaW5lZCwgb2xkVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaGFzKHRhcmdldCwga2V5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5oYXModGFyZ2V0LCBrZXkpO1xuICAgIGlmICghaXNTeW1ib2woa2V5KSB8fCAhYnVpbHRJblN5bWJvbHMuaGFzKGtleSkpIHtcbiAgICAgICAgdHJhY2sodGFyZ2V0LCBcImhhc1wiIC8qIFRyYWNrT3BUeXBlcy5IQVMgKi8sIGtleSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBvd25LZXlzKHRhcmdldCkge1xuICAgIHRyYWNrKHRhcmdldCwgXCJpdGVyYXRlXCIgLyogVHJhY2tPcFR5cGVzLklURVJBVEUgKi8sIGlzQXJyYXkodGFyZ2V0KSA/ICdsZW5ndGgnIDogSVRFUkFURV9LRVkpO1xuICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcbn1cbmNvbnN0IG11dGFibGVIYW5kbGVycyA9IHtcbiAgICBnZXQsXG4gICAgc2V0LFxuICAgIGRlbGV0ZVByb3BlcnR5LFxuICAgIGhhcyxcbiAgICBvd25LZXlzXG59O1xuY29uc3QgcmVhZG9ubHlIYW5kbGVycyA9IHtcbiAgICBnZXQ6IHJlYWRvbmx5R2V0LFxuICAgIHNldCh0YXJnZXQsIGtleSkge1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICB3YXJuKGBTZXQgb3BlcmF0aW9uIG9uIGtleSBcIiR7U3RyaW5nKGtleSl9XCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KSB7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgIHdhcm4oYERlbGV0ZSBvcGVyYXRpb24gb24ga2V5IFwiJHtTdHJpbmcoa2V5KX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn07XG5jb25zdCBzaGFsbG93UmVhY3RpdmVIYW5kbGVycyA9IC8qI19fUFVSRV9fKi8gZXh0ZW5kKHt9LCBtdXRhYmxlSGFuZGxlcnMsIHtcbiAgICBnZXQ6IHNoYWxsb3dHZXQsXG4gICAgc2V0OiBzaGFsbG93U2V0XG59KTtcbi8vIFByb3BzIGhhbmRsZXJzIGFyZSBzcGVjaWFsIGluIHRoZSBzZW5zZSB0aGF0IGl0IHNob3VsZCBub3QgdW53cmFwIHRvcC1sZXZlbFxuLy8gcmVmcyAoaW4gb3JkZXIgdG8gYWxsb3cgcmVmcyB0byBiZSBleHBsaWNpdGx5IHBhc3NlZCBkb3duKSwgYnV0IHNob3VsZFxuLy8gcmV0YWluIHRoZSByZWFjdGl2aXR5IG9mIHRoZSBub3JtYWwgcmVhZG9ubHkgb2JqZWN0LlxuY29uc3Qgc2hhbGxvd1JlYWRvbmx5SGFuZGxlcnMgPSAvKiNfX1BVUkVfXyovIGV4dGVuZCh7fSwgcmVhZG9ubHlIYW5kbGVycywge1xuICAgIGdldDogc2hhbGxvd1JlYWRvbmx5R2V0XG59KTtcblxuY29uc3QgdG9TaGFsbG93ID0gKHZhbHVlKSA9PiB2YWx1ZTtcbmNvbnN0IGdldFByb3RvID0gKHYpID0+IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2Yodik7XG5mdW5jdGlvbiBnZXQkMSh0YXJnZXQsIGtleSwgaXNSZWFkb25seSA9IGZhbHNlLCBpc1NoYWxsb3cgPSBmYWxzZSkge1xuICAgIC8vICMxNzcyOiByZWFkb25seShyZWFjdGl2ZShNYXApKSBzaG91bGQgcmV0dXJuIHJlYWRvbmx5ICsgcmVhY3RpdmUgdmVyc2lvblxuICAgIC8vIG9mIHRoZSB2YWx1ZVxuICAgIHRhcmdldCA9IHRhcmdldFtcIl9fdl9yYXdcIiAvKiBSZWFjdGl2ZUZsYWdzLlJBVyAqL107XG4gICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcbiAgICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xuICAgIGlmICghaXNSZWFkb25seSkge1xuICAgICAgICBpZiAoa2V5ICE9PSByYXdLZXkpIHtcbiAgICAgICAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJnZXRcIiAvKiBUcmFja09wVHlwZXMuR0VUICovLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJnZXRcIiAvKiBUcmFja09wVHlwZXMuR0VUICovLCByYXdLZXkpO1xuICAgIH1cbiAgICBjb25zdCB7IGhhcyB9ID0gZ2V0UHJvdG8ocmF3VGFyZ2V0KTtcbiAgICBjb25zdCB3cmFwID0gaXNTaGFsbG93ID8gdG9TaGFsbG93IDogaXNSZWFkb25seSA/IHRvUmVhZG9ubHkgOiB0b1JlYWN0aXZlO1xuICAgIGlmIChoYXMuY2FsbChyYXdUYXJnZXQsIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIHdyYXAodGFyZ2V0LmdldChrZXkpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaGFzLmNhbGwocmF3VGFyZ2V0LCByYXdLZXkpKSB7XG4gICAgICAgIHJldHVybiB3cmFwKHRhcmdldC5nZXQocmF3S2V5KSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRhcmdldCAhPT0gcmF3VGFyZ2V0KSB7XG4gICAgICAgIC8vICMzNjAyIHJlYWRvbmx5KHJlYWN0aXZlKE1hcCkpXG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IHRoZSBuZXN0ZWQgcmVhY3RpdmUgYE1hcGAgY2FuIGRvIHRyYWNraW5nIGZvciBpdHNlbGZcbiAgICAgICAgdGFyZ2V0LmdldChrZXkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhcyQxKGtleSwgaXNSZWFkb25seSA9IGZhbHNlKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpc1tcIl9fdl9yYXdcIiAvKiBSZWFjdGl2ZUZsYWdzLlJBVyAqL107XG4gICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcbiAgICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xuICAgIGlmICghaXNSZWFkb25seSkge1xuICAgICAgICBpZiAoa2V5ICE9PSByYXdLZXkpIHtcbiAgICAgICAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJoYXNcIiAvKiBUcmFja09wVHlwZXMuSEFTICovLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJoYXNcIiAvKiBUcmFja09wVHlwZXMuSEFTICovLCByYXdLZXkpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5ID09PSByYXdLZXlcbiAgICAgICAgPyB0YXJnZXQuaGFzKGtleSlcbiAgICAgICAgOiB0YXJnZXQuaGFzKGtleSkgfHwgdGFyZ2V0LmhhcyhyYXdLZXkpO1xufVxuZnVuY3Rpb24gc2l6ZSh0YXJnZXQsIGlzUmVhZG9ubHkgPSBmYWxzZSkge1xuICAgIHRhcmdldCA9IHRhcmdldFtcIl9fdl9yYXdcIiAvKiBSZWFjdGl2ZUZsYWdzLlJBVyAqL107XG4gICAgIWlzUmVhZG9ubHkgJiYgdHJhY2sodG9SYXcodGFyZ2V0KSwgXCJpdGVyYXRlXCIgLyogVHJhY2tPcFR5cGVzLklURVJBVEUgKi8sIElURVJBVEVfS0VZKTtcbiAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCAnc2l6ZScsIHRhcmdldCk7XG59XG5mdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcbiAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcbiAgICBjb25zdCBwcm90byA9IGdldFByb3RvKHRhcmdldCk7XG4gICAgY29uc3QgaGFkS2V5ID0gcHJvdG8uaGFzLmNhbGwodGFyZ2V0LCB2YWx1ZSk7XG4gICAgaWYgKCFoYWRLZXkpIHtcbiAgICAgICAgdGFyZ2V0LmFkZCh2YWx1ZSk7XG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiIC8qIFRyaWdnZXJPcFR5cGVzLkFERCAqLywgdmFsdWUsIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiBzZXQkMShrZXksIHZhbHVlKSB7XG4gICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XG4gICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XG4gICAgY29uc3QgeyBoYXMsIGdldCB9ID0gZ2V0UHJvdG8odGFyZ2V0KTtcbiAgICBsZXQgaGFkS2V5ID0gaGFzLmNhbGwodGFyZ2V0LCBrZXkpO1xuICAgIGlmICghaGFkS2V5KSB7XG4gICAgICAgIGtleSA9IHRvUmF3KGtleSk7XG4gICAgICAgIGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzLCBrZXkpO1xuICAgIH1cbiAgICBjb25zdCBvbGRWYWx1ZSA9IGdldC5jYWxsKHRhcmdldCwga2V5KTtcbiAgICB0YXJnZXQuc2V0KGtleSwgdmFsdWUpO1xuICAgIGlmICghaGFkS2V5KSB7XG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiIC8qIFRyaWdnZXJPcFR5cGVzLkFERCAqLywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhhc0NoYW5nZWQodmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJzZXRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5TRVQgKi8sIGtleSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiBkZWxldGVFbnRyeShrZXkpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcbiAgICBjb25zdCB7IGhhcywgZ2V0IH0gPSBnZXRQcm90byh0YXJnZXQpO1xuICAgIGxldCBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XG4gICAgaWYgKCFoYWRLZXkpIHtcbiAgICAgICAga2V5ID0gdG9SYXcoa2V5KTtcbiAgICAgICAgaGFkS2V5ID0gaGFzLmNhbGwodGFyZ2V0LCBrZXkpO1xuICAgIH1cbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMsIGtleSk7XG4gICAgfVxuICAgIGNvbnN0IG9sZFZhbHVlID0gZ2V0ID8gZ2V0LmNhbGwodGFyZ2V0LCBrZXkpIDogdW5kZWZpbmVkO1xuICAgIC8vIGZvcndhcmQgdGhlIG9wZXJhdGlvbiBiZWZvcmUgcXVldWVpbmcgcmVhY3Rpb25zXG4gICAgY29uc3QgcmVzdWx0ID0gdGFyZ2V0LmRlbGV0ZShrZXkpO1xuICAgIGlmIChoYWRLZXkpIHtcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiZGVsZXRlXCIgLyogVHJpZ2dlck9wVHlwZXMuREVMRVRFICovLCBrZXksIHVuZGVmaW5lZCwgb2xkVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XG4gICAgY29uc3QgaGFkSXRlbXMgPSB0YXJnZXQuc2l6ZSAhPT0gMDtcbiAgICBjb25zdCBvbGRUYXJnZXQgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcbiAgICAgICAgPyBpc01hcCh0YXJnZXQpXG4gICAgICAgICAgICA/IG5ldyBNYXAodGFyZ2V0KVxuICAgICAgICAgICAgOiBuZXcgU2V0KHRhcmdldClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgLy8gZm9yd2FyZCB0aGUgb3BlcmF0aW9uIGJlZm9yZSBxdWV1ZWluZyByZWFjdGlvbnNcbiAgICBjb25zdCByZXN1bHQgPSB0YXJnZXQuY2xlYXIoKTtcbiAgICBpZiAoaGFkSXRlbXMpIHtcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiY2xlYXJcIiAvKiBUcmlnZ2VyT3BUeXBlcy5DTEVBUiAqLywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG9sZFRhcmdldCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjcmVhdGVGb3JFYWNoKGlzUmVhZG9ubHksIGlzU2hhbGxvdykge1xuICAgIHJldHVybiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgIGNvbnN0IG9ic2VydmVkID0gdGhpcztcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gb2JzZXJ2ZWRbXCJfX3ZfcmF3XCIgLyogUmVhY3RpdmVGbGFncy5SQVcgKi9dO1xuICAgICAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xuICAgICAgICBjb25zdCB3cmFwID0gaXNTaGFsbG93ID8gdG9TaGFsbG93IDogaXNSZWFkb25seSA/IHRvUmVhZG9ubHkgOiB0b1JlYWN0aXZlO1xuICAgICAgICAhaXNSZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiaXRlcmF0ZVwiIC8qIFRyYWNrT3BUeXBlcy5JVEVSQVRFICovLCBJVEVSQVRFX0tFWSk7XG4gICAgICAgIHJldHVybiB0YXJnZXQuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgLy8gaW1wb3J0YW50OiBtYWtlIHN1cmUgdGhlIGNhbGxiYWNrIGlzXG4gICAgICAgICAgICAvLyAxLiBpbnZva2VkIHdpdGggdGhlIHJlYWN0aXZlIG1hcCBhcyBgdGhpc2AgYW5kIDNyZCBhcmdcbiAgICAgICAgICAgIC8vIDIuIHRoZSB2YWx1ZSByZWNlaXZlZCBzaG91bGQgYmUgYSBjb3JyZXNwb25kaW5nIHJlYWN0aXZlL3JlYWRvbmx5LlxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgd3JhcCh2YWx1ZSksIHdyYXAoa2V5KSwgb2JzZXJ2ZWQpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCBpc1JlYWRvbmx5LCBpc1NoYWxsb3cpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpc1tcIl9fdl9yYXdcIiAvKiBSZWFjdGl2ZUZsYWdzLlJBVyAqL107XG4gICAgICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XG4gICAgICAgIGNvbnN0IHRhcmdldElzTWFwID0gaXNNYXAocmF3VGFyZ2V0KTtcbiAgICAgICAgY29uc3QgaXNQYWlyID0gbWV0aG9kID09PSAnZW50cmllcycgfHwgKG1ldGhvZCA9PT0gU3ltYm9sLml0ZXJhdG9yICYmIHRhcmdldElzTWFwKTtcbiAgICAgICAgY29uc3QgaXNLZXlPbmx5ID0gbWV0aG9kID09PSAna2V5cycgJiYgdGFyZ2V0SXNNYXA7XG4gICAgICAgIGNvbnN0IGlubmVySXRlcmF0b3IgPSB0YXJnZXRbbWV0aG9kXSguLi5hcmdzKTtcbiAgICAgICAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdyA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcbiAgICAgICAgIWlzUmVhZG9ubHkgJiZcbiAgICAgICAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJpdGVyYXRlXCIgLyogVHJhY2tPcFR5cGVzLklURVJBVEUgKi8sIGlzS2V5T25seSA/IE1BUF9LRVlfSVRFUkFURV9LRVkgOiBJVEVSQVRFX0tFWSk7XG4gICAgICAgIC8vIHJldHVybiBhIHdyYXBwZWQgaXRlcmF0b3Igd2hpY2ggcmV0dXJucyBvYnNlcnZlZCB2ZXJzaW9ucyBvZiB0aGVcbiAgICAgICAgLy8gdmFsdWVzIGVtaXR0ZWQgZnJvbSB0aGUgcmVhbCBpdGVyYXRvclxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gaXRlcmF0b3IgcHJvdG9jb2xcbiAgICAgICAgICAgIG5leHQoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gaW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgPyB7IHZhbHVlLCBkb25lIH1cbiAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaXNQYWlyID8gW3dyYXAodmFsdWVbMF0pLCB3cmFwKHZhbHVlWzFdKV0gOiB3cmFwKHZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBpdGVyYWJsZSBwcm90b2NvbFxuICAgICAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlYWRvbmx5TWV0aG9kKHR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYXJnc1swXSA/IGBvbiBrZXkgXCIke2FyZ3NbMF19XCIgYCA6IGBgO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGAke2NhcGl0YWxpemUodHlwZSl9IG9wZXJhdGlvbiAke2tleX1mYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLCB0b1Jhdyh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGUgPT09IFwiZGVsZXRlXCIgLyogVHJpZ2dlck9wVHlwZXMuREVMRVRFICovID8gZmFsc2UgOiB0aGlzO1xuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVJbnN0cnVtZW50YXRpb25zKCkge1xuICAgIGNvbnN0IG11dGFibGVJbnN0cnVtZW50YXRpb25zID0ge1xuICAgICAgICBnZXQoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEodGhpcywga2V5KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2l6ZSh0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzOiBoYXMkMSxcbiAgICAgICAgYWRkLFxuICAgICAgICBzZXQ6IHNldCQxLFxuICAgICAgICBkZWxldGU6IGRlbGV0ZUVudHJ5LFxuICAgICAgICBjbGVhcixcbiAgICAgICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaChmYWxzZSwgZmFsc2UpXG4gICAgfTtcbiAgICBjb25zdCBzaGFsbG93SW5zdHJ1bWVudGF0aW9ucyA9IHtcbiAgICAgICAgZ2V0KGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldCQxKHRoaXMsIGtleSwgZmFsc2UsIHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBzaXplKHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBoYXM6IGhhcyQxLFxuICAgICAgICBhZGQsXG4gICAgICAgIHNldDogc2V0JDEsXG4gICAgICAgIGRlbGV0ZTogZGVsZXRlRW50cnksXG4gICAgICAgIGNsZWFyLFxuICAgICAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKGZhbHNlLCB0cnVlKVxuICAgIH07XG4gICAgY29uc3QgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zID0ge1xuICAgICAgICBnZXQoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEodGhpcywga2V5LCB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2l6ZSh0aGlzLCB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGhhcyQxLmNhbGwodGhpcywga2V5LCB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImFkZFwiIC8qIFRyaWdnZXJPcFR5cGVzLkFERCAqLyksXG4gICAgICAgIHNldDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJzZXRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5TRVQgKi8pLFxuICAgICAgICBkZWxldGU6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiZGVsZXRlXCIgLyogVHJpZ2dlck9wVHlwZXMuREVMRVRFICovKSxcbiAgICAgICAgY2xlYXI6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiY2xlYXJcIiAvKiBUcmlnZ2VyT3BUeXBlcy5DTEVBUiAqLyksXG4gICAgICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2godHJ1ZSwgZmFsc2UpXG4gICAgfTtcbiAgICBjb25zdCBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zID0ge1xuICAgICAgICBnZXQoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEodGhpcywga2V5LCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2l6ZSh0aGlzLCB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGhhcyQxLmNhbGwodGhpcywga2V5LCB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImFkZFwiIC8qIFRyaWdnZXJPcFR5cGVzLkFERCAqLyksXG4gICAgICAgIHNldDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJzZXRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5TRVQgKi8pLFxuICAgICAgICBkZWxldGU6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiZGVsZXRlXCIgLyogVHJpZ2dlck9wVHlwZXMuREVMRVRFICovKSxcbiAgICAgICAgY2xlYXI6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiY2xlYXJcIiAvKiBUcmlnZ2VyT3BUeXBlcy5DTEVBUiAqLyksXG4gICAgICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2godHJ1ZSwgdHJ1ZSlcbiAgICB9O1xuICAgIGNvbnN0IGl0ZXJhdG9yTWV0aG9kcyA9IFsna2V5cycsICd2YWx1ZXMnLCAnZW50cmllcycsIFN5bWJvbC5pdGVyYXRvcl07XG4gICAgaXRlcmF0b3JNZXRob2RzLmZvckVhY2gobWV0aG9kID0+IHtcbiAgICAgICAgbXV0YWJsZUluc3RydW1lbnRhdGlvbnNbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgc2hhbGxvd0luc3RydW1lbnRhdGlvbnNbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgZmFsc2UsIHRydWUpO1xuICAgICAgICBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIHRydWUsIHRydWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIG11dGFibGVJbnN0cnVtZW50YXRpb25zLFxuICAgICAgICByZWFkb25seUluc3RydW1lbnRhdGlvbnMsXG4gICAgICAgIHNoYWxsb3dJbnN0cnVtZW50YXRpb25zLFxuICAgICAgICBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zXG4gICAgXTtcbn1cbmNvbnN0IFttdXRhYmxlSW5zdHJ1bWVudGF0aW9ucywgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zLCBzaGFsbG93SW5zdHJ1bWVudGF0aW9ucywgc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc10gPSAvKiAjX19QVVJFX18qLyBjcmVhdGVJbnN0cnVtZW50YXRpb25zKCk7XG5mdW5jdGlvbiBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoaXNSZWFkb25seSwgc2hhbGxvdykge1xuICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbnMgPSBzaGFsbG93XG4gICAgICAgID8gaXNSZWFkb25seVxuICAgICAgICAgICAgPyBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zXG4gICAgICAgICAgICA6IHNoYWxsb3dJbnN0cnVtZW50YXRpb25zXG4gICAgICAgIDogaXNSZWFkb25seVxuICAgICAgICAgICAgPyByZWFkb25seUluc3RydW1lbnRhdGlvbnNcbiAgICAgICAgICAgIDogbXV0YWJsZUluc3RydW1lbnRhdGlvbnM7XG4gICAgcmV0dXJuICh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpID0+IHtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFjdGl2ZVwiIC8qIFJlYWN0aXZlRmxhZ3MuSVNfUkVBQ1RJVkUgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiAhaXNSZWFkb25seTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzUmVhZG9ubHlcIiAvKiBSZWFjdGl2ZUZsYWdzLklTX1JFQURPTkxZICovKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNSZWFkb25seTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiX192X3Jhd1wiIC8qIFJlYWN0aXZlRmxhZ3MuUkFXICovKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZWZsZWN0LmdldChoYXNPd24oaW5zdHJ1bWVudGF0aW9ucywga2V5KSAmJiBrZXkgaW4gdGFyZ2V0XG4gICAgICAgICAgICA/IGluc3RydW1lbnRhdGlvbnNcbiAgICAgICAgICAgIDogdGFyZ2V0LCBrZXksIHJlY2VpdmVyKTtcbiAgICB9O1xufVxuY29uc3QgbXV0YWJsZUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcbiAgICBnZXQ6IC8qI19fUFVSRV9fKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGZhbHNlLCBmYWxzZSlcbn07XG5jb25zdCBzaGFsbG93Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xuICAgIGdldDogLyojX19QVVJFX18qLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoZmFsc2UsIHRydWUpXG59O1xuY29uc3QgcmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XG4gICAgZ2V0OiAvKiNfX1BVUkVfXyovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcih0cnVlLCBmYWxzZSlcbn07XG5jb25zdCBzaGFsbG93UmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XG4gICAgZ2V0OiAvKiNfX1BVUkVfXyovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcih0cnVlLCB0cnVlKVxufTtcbmZ1bmN0aW9uIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzLCBrZXkpIHtcbiAgICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xuICAgIGlmIChyYXdLZXkgIT09IGtleSAmJiBoYXMuY2FsbCh0YXJnZXQsIHJhd0tleSkpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHRvUmF3VHlwZSh0YXJnZXQpO1xuICAgICAgICBjb25zb2xlLndhcm4oYFJlYWN0aXZlICR7dHlwZX0gY29udGFpbnMgYm90aCB0aGUgcmF3IGFuZCByZWFjdGl2ZSBgICtcbiAgICAgICAgICAgIGB2ZXJzaW9ucyBvZiB0aGUgc2FtZSBvYmplY3Qke3R5cGUgPT09IGBNYXBgID8gYCBhcyBrZXlzYCA6IGBgfSwgYCArXG4gICAgICAgICAgICBgd2hpY2ggY2FuIGxlYWQgdG8gaW5jb25zaXN0ZW5jaWVzLiBgICtcbiAgICAgICAgICAgIGBBdm9pZCBkaWZmZXJlbnRpYXRpbmcgYmV0d2VlbiB0aGUgcmF3IGFuZCByZWFjdGl2ZSB2ZXJzaW9ucyBgICtcbiAgICAgICAgICAgIGBvZiBhbiBvYmplY3QgYW5kIG9ubHkgdXNlIHRoZSByZWFjdGl2ZSB2ZXJzaW9uIGlmIHBvc3NpYmxlLmApO1xuICAgIH1cbn1cblxuY29uc3QgcmVhY3RpdmVNYXAgPSBuZXcgV2Vha01hcCgpO1xuY29uc3Qgc2hhbGxvd1JlYWN0aXZlTWFwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHJlYWRvbmx5TWFwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHNoYWxsb3dSZWFkb25seU1hcCA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiB0YXJnZXRUeXBlTWFwKHJhd1R5cGUpIHtcbiAgICBzd2l0Y2ggKHJhd1R5cGUpIHtcbiAgICAgICAgY2FzZSAnT2JqZWN0JzpcbiAgICAgICAgY2FzZSAnQXJyYXknOlxuICAgICAgICAgICAgcmV0dXJuIDEgLyogVGFyZ2V0VHlwZS5DT01NT04gKi87XG4gICAgICAgIGNhc2UgJ01hcCc6XG4gICAgICAgIGNhc2UgJ1NldCc6XG4gICAgICAgIGNhc2UgJ1dlYWtNYXAnOlxuICAgICAgICBjYXNlICdXZWFrU2V0JzpcbiAgICAgICAgICAgIHJldHVybiAyIC8qIFRhcmdldFR5cGUuQ09MTEVDVElPTiAqLztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAwIC8qIFRhcmdldFR5cGUuSU5WQUxJRCAqLztcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRUYXJnZXRUeXBlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlW1wiX192X3NraXBcIiAvKiBSZWFjdGl2ZUZsYWdzLlNLSVAgKi9dIHx8ICFPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKVxuICAgICAgICA/IDAgLyogVGFyZ2V0VHlwZS5JTlZBTElEICovXG4gICAgICAgIDogdGFyZ2V0VHlwZU1hcCh0b1Jhd1R5cGUodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIHJlYWN0aXZlKHRhcmdldCkge1xuICAgIC8vIGlmIHRyeWluZyB0byBvYnNlcnZlIGEgcmVhZG9ubHkgcHJveHksIHJldHVybiB0aGUgcmVhZG9ubHkgdmVyc2lvbi5cbiAgICBpZiAoaXNSZWFkb25seSh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIGZhbHNlLCBtdXRhYmxlSGFuZGxlcnMsIG11dGFibGVDb2xsZWN0aW9uSGFuZGxlcnMsIHJlYWN0aXZlTWFwKTtcbn1cbi8qKlxuICogUmV0dXJuIGEgc2hhbGxvd2x5LXJlYWN0aXZlIGNvcHkgb2YgdGhlIG9yaWdpbmFsIG9iamVjdCwgd2hlcmUgb25seSB0aGUgcm9vdFxuICogbGV2ZWwgcHJvcGVydGllcyBhcmUgcmVhY3RpdmUuIEl0IGFsc28gZG9lcyBub3QgYXV0by11bndyYXAgcmVmcyAoZXZlbiBhdCB0aGVcbiAqIHJvb3QgbGV2ZWwpLlxuICovXG5mdW5jdGlvbiBzaGFsbG93UmVhY3RpdmUodGFyZ2V0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgZmFsc2UsIHNoYWxsb3dSZWFjdGl2ZUhhbmRsZXJzLCBzaGFsbG93Q29sbGVjdGlvbkhhbmRsZXJzLCBzaGFsbG93UmVhY3RpdmVNYXApO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgcmVhZG9ubHkgY29weSBvZiB0aGUgb3JpZ2luYWwgb2JqZWN0LiBOb3RlIHRoZSByZXR1cm5lZCBjb3B5IGlzIG5vdFxuICogbWFkZSByZWFjdGl2ZSwgYnV0IGByZWFkb25seWAgY2FuIGJlIGNhbGxlZCBvbiBhbiBhbHJlYWR5IHJlYWN0aXZlIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVhZG9ubHkodGFyZ2V0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgdHJ1ZSwgcmVhZG9ubHlIYW5kbGVycywgcmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMsIHJlYWRvbmx5TWFwKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHJlYWN0aXZlLWNvcHkgb2YgdGhlIG9yaWdpbmFsIG9iamVjdCwgd2hlcmUgb25seSB0aGUgcm9vdCBsZXZlbFxuICogcHJvcGVydGllcyBhcmUgcmVhZG9ubHksIGFuZCBkb2VzIE5PVCB1bndyYXAgcmVmcyBub3IgcmVjdXJzaXZlbHkgY29udmVydFxuICogcmV0dXJuZWQgcHJvcGVydGllcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgY3JlYXRpbmcgdGhlIHByb3BzIHByb3h5IG9iamVjdCBmb3Igc3RhdGVmdWwgY29tcG9uZW50cy5cbiAqL1xuZnVuY3Rpb24gc2hhbGxvd1JlYWRvbmx5KHRhcmdldCkge1xuICAgIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIHRydWUsIHNoYWxsb3dSZWFkb25seUhhbmRsZXJzLCBzaGFsbG93UmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMsIHNoYWxsb3dSZWFkb25seU1hcCk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIGlzUmVhZG9ubHksIGJhc2VIYW5kbGVycywgY29sbGVjdGlvbkhhbmRsZXJzLCBwcm94eU1hcCkge1xuICAgIGlmICghaXNPYmplY3QodGFyZ2V0KSkge1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYHZhbHVlIGNhbm5vdCBiZSBtYWRlIHJlYWN0aXZlOiAke1N0cmluZyh0YXJnZXQpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIC8vIHRhcmdldCBpcyBhbHJlYWR5IGEgUHJveHksIHJldHVybiBpdC5cbiAgICAvLyBleGNlcHRpb246IGNhbGxpbmcgcmVhZG9ubHkoKSBvbiBhIHJlYWN0aXZlIG9iamVjdFxuICAgIGlmICh0YXJnZXRbXCJfX3ZfcmF3XCIgLyogUmVhY3RpdmVGbGFncy5SQVcgKi9dICYmXG4gICAgICAgICEoaXNSZWFkb25seSAmJiB0YXJnZXRbXCJfX3ZfaXNSZWFjdGl2ZVwiIC8qIFJlYWN0aXZlRmxhZ3MuSVNfUkVBQ1RJVkUgKi9dKSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICAvLyB0YXJnZXQgYWxyZWFkeSBoYXMgY29ycmVzcG9uZGluZyBQcm94eVxuICAgIGNvbnN0IGV4aXN0aW5nUHJveHkgPSBwcm94eU1hcC5nZXQodGFyZ2V0KTtcbiAgICBpZiAoZXhpc3RpbmdQcm94eSkge1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdQcm94eTtcbiAgICB9XG4gICAgLy8gb25seSBzcGVjaWZpYyB2YWx1ZSB0eXBlcyBjYW4gYmUgb2JzZXJ2ZWQuXG4gICAgY29uc3QgdGFyZ2V0VHlwZSA9IGdldFRhcmdldFR5cGUodGFyZ2V0KTtcbiAgICBpZiAodGFyZ2V0VHlwZSA9PT0gMCAvKiBUYXJnZXRUeXBlLklOVkFMSUQgKi8pIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkodGFyZ2V0LCB0YXJnZXRUeXBlID09PSAyIC8qIFRhcmdldFR5cGUuQ09MTEVDVElPTiAqLyA/IGNvbGxlY3Rpb25IYW5kbGVycyA6IGJhc2VIYW5kbGVycyk7XG4gICAgcHJveHlNYXAuc2V0KHRhcmdldCwgcHJveHkpO1xuICAgIHJldHVybiBwcm94eTtcbn1cbmZ1bmN0aW9uIGlzUmVhY3RpdmUodmFsdWUpIHtcbiAgICBpZiAoaXNSZWFkb25seSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGlzUmVhY3RpdmUodmFsdWVbXCJfX3ZfcmF3XCIgLyogUmVhY3RpdmVGbGFncy5SQVcgKi9dKTtcbiAgICB9XG4gICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzUmVhY3RpdmVcIiAvKiBSZWFjdGl2ZUZsYWdzLklTX1JFQUNUSVZFICovXSk7XG59XG5mdW5jdGlvbiBpc1JlYWRvbmx5KHZhbHVlKSB7XG4gICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzUmVhZG9ubHlcIiAvKiBSZWFjdGl2ZUZsYWdzLklTX1JFQURPTkxZICovXSk7XG59XG5mdW5jdGlvbiBpc1NoYWxsb3codmFsdWUpIHtcbiAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNTaGFsbG93XCIgLyogUmVhY3RpdmVGbGFncy5JU19TSEFMTE9XICovXSk7XG59XG5mdW5jdGlvbiBpc1Byb3h5KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUmVhY3RpdmUodmFsdWUpIHx8IGlzUmVhZG9ubHkodmFsdWUpO1xufVxuZnVuY3Rpb24gdG9SYXcob2JzZXJ2ZWQpIHtcbiAgICBjb25zdCByYXcgPSBvYnNlcnZlZCAmJiBvYnNlcnZlZFtcIl9fdl9yYXdcIiAvKiBSZWFjdGl2ZUZsYWdzLlJBVyAqL107XG4gICAgcmV0dXJuIHJhdyA/IHRvUmF3KHJhdykgOiBvYnNlcnZlZDtcbn1cbmZ1bmN0aW9uIG1hcmtSYXcodmFsdWUpIHtcbiAgICBkZWYodmFsdWUsIFwiX192X3NraXBcIiAvKiBSZWFjdGl2ZUZsYWdzLlNLSVAgKi8sIHRydWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmNvbnN0IHRvUmVhY3RpdmUgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSA/IHJlYWN0aXZlKHZhbHVlKSA6IHZhbHVlO1xuY29uc3QgdG9SZWFkb25seSA9ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpID8gcmVhZG9ubHkodmFsdWUpIDogdmFsdWU7XG5cbmZ1bmN0aW9uIHRyYWNrUmVmVmFsdWUocmVmKSB7XG4gICAgaWYgKHNob3VsZFRyYWNrICYmIGFjdGl2ZUVmZmVjdCkge1xuICAgICAgICByZWYgPSB0b1JhdyhyZWYpO1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICB0cmFja0VmZmVjdHMocmVmLmRlcCB8fCAocmVmLmRlcCA9IGNyZWF0ZURlcCgpKSwge1xuICAgICAgICAgICAgICAgIHRhcmdldDogcmVmLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiZ2V0XCIgLyogVHJhY2tPcFR5cGVzLkdFVCAqLyxcbiAgICAgICAgICAgICAgICBrZXk6ICd2YWx1ZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJhY2tFZmZlY3RzKHJlZi5kZXAgfHwgKHJlZi5kZXAgPSBjcmVhdGVEZXAoKSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdHJpZ2dlclJlZlZhbHVlKHJlZiwgbmV3VmFsKSB7XG4gICAgcmVmID0gdG9SYXcocmVmKTtcbiAgICBpZiAocmVmLmRlcCkge1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICB0cmlnZ2VyRWZmZWN0cyhyZWYuZGVwLCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiByZWYsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzZXRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5TRVQgKi8sXG4gICAgICAgICAgICAgICAga2V5OiAndmFsdWUnLFxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJpZ2dlckVmZmVjdHMocmVmLmRlcCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpc1JlZihyKSB7XG4gICAgcmV0dXJuICEhKHIgJiYgci5fX3ZfaXNSZWYgPT09IHRydWUpO1xufVxuZnVuY3Rpb24gcmVmKHZhbHVlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVJlZih2YWx1ZSwgZmFsc2UpO1xufVxuZnVuY3Rpb24gc2hhbGxvd1JlZih2YWx1ZSkge1xuICAgIHJldHVybiBjcmVhdGVSZWYodmFsdWUsIHRydWUpO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVmKHJhd1ZhbHVlLCBzaGFsbG93KSB7XG4gICAgaWYgKGlzUmVmKHJhd1ZhbHVlKSkge1xuICAgICAgICByZXR1cm4gcmF3VmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVmSW1wbChyYXdWYWx1ZSwgc2hhbGxvdyk7XG59XG5jbGFzcyBSZWZJbXBsIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgX192X2lzU2hhbGxvdykge1xuICAgICAgICB0aGlzLl9fdl9pc1NoYWxsb3cgPSBfX3ZfaXNTaGFsbG93O1xuICAgICAgICB0aGlzLmRlcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xuICAgICAgICB0aGlzLl9yYXdWYWx1ZSA9IF9fdl9pc1NoYWxsb3cgPyB2YWx1ZSA6IHRvUmF3KHZhbHVlKTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBfX3ZfaXNTaGFsbG93ID8gdmFsdWUgOiB0b1JlYWN0aXZlKHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICB0cmFja1JlZlZhbHVlKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuICAgIHNldCB2YWx1ZShuZXdWYWwpIHtcbiAgICAgICAgY29uc3QgdXNlRGlyZWN0VmFsdWUgPSB0aGlzLl9fdl9pc1NoYWxsb3cgfHwgaXNTaGFsbG93KG5ld1ZhbCkgfHwgaXNSZWFkb25seShuZXdWYWwpO1xuICAgICAgICBuZXdWYWwgPSB1c2VEaXJlY3RWYWx1ZSA/IG5ld1ZhbCA6IHRvUmF3KG5ld1ZhbCk7XG4gICAgICAgIGlmIChoYXNDaGFuZ2VkKG5ld1ZhbCwgdGhpcy5fcmF3VmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9yYXdWYWx1ZSA9IG5ld1ZhbDtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdXNlRGlyZWN0VmFsdWUgPyBuZXdWYWwgOiB0b1JlYWN0aXZlKG5ld1ZhbCk7XG4gICAgICAgICAgICB0cmlnZ2VyUmVmVmFsdWUodGhpcywgbmV3VmFsKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXJSZWYocmVmKSB7XG4gICAgdHJpZ2dlclJlZlZhbHVlKHJlZiwgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gcmVmLnZhbHVlIDogdm9pZCAwKTtcbn1cbmZ1bmN0aW9uIHVucmVmKHJlZikge1xuICAgIHJldHVybiBpc1JlZihyZWYpID8gcmVmLnZhbHVlIDogcmVmO1xufVxuY29uc3Qgc2hhbGxvd1Vud3JhcEhhbmRsZXJzID0ge1xuICAgIGdldDogKHRhcmdldCwga2V5LCByZWNlaXZlcikgPT4gdW5yZWYoUmVmbGVjdC5nZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSksXG4gICAgc2V0OiAodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcikgPT4ge1xuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xuICAgICAgICBpZiAoaXNSZWYob2xkVmFsdWUpICYmICFpc1JlZih2YWx1ZSkpIHtcbiAgICAgICAgICAgIG9sZFZhbHVlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LnNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5mdW5jdGlvbiBwcm94eVJlZnMob2JqZWN0V2l0aFJlZnMpIHtcbiAgICByZXR1cm4gaXNSZWFjdGl2ZShvYmplY3RXaXRoUmVmcylcbiAgICAgICAgPyBvYmplY3RXaXRoUmVmc1xuICAgICAgICA6IG5ldyBQcm94eShvYmplY3RXaXRoUmVmcywgc2hhbGxvd1Vud3JhcEhhbmRsZXJzKTtcbn1cbmNsYXNzIEN1c3RvbVJlZkltcGwge1xuICAgIGNvbnN0cnVjdG9yKGZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy5kZXAgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBnZXQsIHNldCB9ID0gZmFjdG9yeSgoKSA9PiB0cmFja1JlZlZhbHVlKHRoaXMpLCAoKSA9PiB0cmlnZ2VyUmVmVmFsdWUodGhpcykpO1xuICAgICAgICB0aGlzLl9nZXQgPSBnZXQ7XG4gICAgICAgIHRoaXMuX3NldCA9IHNldDtcbiAgICB9XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0KCk7XG4gICAgfVxuICAgIHNldCB2YWx1ZShuZXdWYWwpIHtcbiAgICAgICAgdGhpcy5fc2V0KG5ld1ZhbCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3VzdG9tUmVmKGZhY3RvcnkpIHtcbiAgICByZXR1cm4gbmV3IEN1c3RvbVJlZkltcGwoZmFjdG9yeSk7XG59XG5mdW5jdGlvbiB0b1JlZnMob2JqZWN0KSB7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNQcm94eShvYmplY3QpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgdG9SZWZzKCkgZXhwZWN0cyBhIHJlYWN0aXZlIG9iamVjdCBidXQgcmVjZWl2ZWQgYSBwbGFpbiBvbmUuYCk7XG4gICAgfVxuICAgIGNvbnN0IHJldCA9IGlzQXJyYXkob2JqZWN0KSA/IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKSA6IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgICAgICByZXRba2V5XSA9IHRvUmVmKG9iamVjdCwga2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbmNsYXNzIE9iamVjdFJlZkltcGwge1xuICAgIGNvbnN0cnVjdG9yKF9vYmplY3QsIF9rZXksIF9kZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgdGhpcy5fb2JqZWN0ID0gX29iamVjdDtcbiAgICAgICAgdGhpcy5fa2V5ID0gX2tleTtcbiAgICAgICAgdGhpcy5fZGVmYXVsdFZhbHVlID0gX2RlZmF1bHRWYWx1ZTtcbiAgICAgICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHRoaXMuX29iamVjdFt0aGlzLl9rZXldO1xuICAgICAgICByZXR1cm4gdmFsID09PSB1bmRlZmluZWQgPyB0aGlzLl9kZWZhdWx0VmFsdWUgOiB2YWw7XG4gICAgfVxuICAgIHNldCB2YWx1ZShuZXdWYWwpIHtcbiAgICAgICAgdGhpcy5fb2JqZWN0W3RoaXMuX2tleV0gPSBuZXdWYWw7XG4gICAgfVxufVxuZnVuY3Rpb24gdG9SZWYob2JqZWN0LCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgIGNvbnN0IHZhbCA9IG9iamVjdFtrZXldO1xuICAgIHJldHVybiBpc1JlZih2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogbmV3IE9iamVjdFJlZkltcGwob2JqZWN0LCBrZXksIGRlZmF1bHRWYWx1ZSk7XG59XG5cbnZhciBfYTtcbmNsYXNzIENvbXB1dGVkUmVmSW1wbCB7XG4gICAgY29uc3RydWN0b3IoZ2V0dGVyLCBfc2V0dGVyLCBpc1JlYWRvbmx5LCBpc1NTUikge1xuICAgICAgICB0aGlzLl9zZXR0ZXIgPSBfc2V0dGVyO1xuICAgICAgICB0aGlzLmRlcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xuICAgICAgICB0aGlzW19hXSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMuZWZmZWN0ID0gbmV3IFJlYWN0aXZlRWZmZWN0KGdldHRlciwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9kaXJ0eSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyUmVmVmFsdWUodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVmZmVjdC5jb21wdXRlZCA9IHRoaXM7XG4gICAgICAgIHRoaXMuZWZmZWN0LmFjdGl2ZSA9IHRoaXMuX2NhY2hlYWJsZSA9ICFpc1NTUjtcbiAgICAgICAgdGhpc1tcIl9fdl9pc1JlYWRvbmx5XCIgLyogUmVhY3RpdmVGbGFncy5JU19SRUFET05MWSAqL10gPSBpc1JlYWRvbmx5O1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIC8vIHRoZSBjb21wdXRlZCByZWYgbWF5IGdldCB3cmFwcGVkIGJ5IG90aGVyIHByb3hpZXMgZS5nLiByZWFkb25seSgpICMzMzc2XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0b1Jhdyh0aGlzKTtcbiAgICAgICAgdHJhY2tSZWZWYWx1ZShzZWxmKTtcbiAgICAgICAgaWYgKHNlbGYuX2RpcnR5IHx8ICFzZWxmLl9jYWNoZWFibGUpIHtcbiAgICAgICAgICAgIHNlbGYuX2RpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICBzZWxmLl92YWx1ZSA9IHNlbGYuZWZmZWN0LnJ1bigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmLl92YWx1ZTtcbiAgICB9XG4gICAgc2V0IHZhbHVlKG5ld1ZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3NldHRlcihuZXdWYWx1ZSk7XG4gICAgfVxufVxuX2EgPSBcIl9fdl9pc1JlYWRvbmx5XCIgLyogUmVhY3RpdmVGbGFncy5JU19SRUFET05MWSAqLztcbmZ1bmN0aW9uIGNvbXB1dGVkKGdldHRlck9yT3B0aW9ucywgZGVidWdPcHRpb25zLCBpc1NTUiA9IGZhbHNlKSB7XG4gICAgbGV0IGdldHRlcjtcbiAgICBsZXQgc2V0dGVyO1xuICAgIGNvbnN0IG9ubHlHZXR0ZXIgPSBpc0Z1bmN0aW9uKGdldHRlck9yT3B0aW9ucyk7XG4gICAgaWYgKG9ubHlHZXR0ZXIpIHtcbiAgICAgICAgZ2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zO1xuICAgICAgICBzZXR0ZXIgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcbiAgICAgICAgICAgID8gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignV3JpdGUgb3BlcmF0aW9uIGZhaWxlZDogY29tcHV0ZWQgdmFsdWUgaXMgcmVhZG9ubHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogTk9PUDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdldHRlciA9IGdldHRlck9yT3B0aW9ucy5nZXQ7XG4gICAgICAgIHNldHRlciA9IGdldHRlck9yT3B0aW9ucy5zZXQ7XG4gICAgfVxuICAgIGNvbnN0IGNSZWYgPSBuZXcgQ29tcHV0ZWRSZWZJbXBsKGdldHRlciwgc2V0dGVyLCBvbmx5R2V0dGVyIHx8ICFzZXR0ZXIsIGlzU1NSKTtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGRlYnVnT3B0aW9ucyAmJiAhaXNTU1IpIHtcbiAgICAgICAgY1JlZi5lZmZlY3Qub25UcmFjayA9IGRlYnVnT3B0aW9ucy5vblRyYWNrO1xuICAgICAgICBjUmVmLmVmZmVjdC5vblRyaWdnZXIgPSBkZWJ1Z09wdGlvbnMub25UcmlnZ2VyO1xuICAgIH1cbiAgICByZXR1cm4gY1JlZjtcbn1cblxudmFyIF9hJDE7XG5jb25zdCB0aWNrID0gLyojX19QVVJFX18qLyBQcm9taXNlLnJlc29sdmUoKTtcbmNvbnN0IHF1ZXVlID0gW107XG5sZXQgcXVldWVkID0gZmFsc2U7XG5jb25zdCBzY2hlZHVsZXIgPSAoZm4pID0+IHtcbiAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICBpZiAoIXF1ZXVlZCkge1xuICAgICAgICBxdWV1ZWQgPSB0cnVlO1xuICAgICAgICB0aWNrLnRoZW4oZmx1c2gpO1xuICAgIH1cbn07XG5jb25zdCBmbHVzaCA9ICgpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHF1ZXVlW2ldKCk7XG4gICAgfVxuICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgcXVldWVkID0gZmFsc2U7XG59O1xuY2xhc3MgRGVmZXJyZWRDb21wdXRlZFJlZkltcGwge1xuICAgIGNvbnN0cnVjdG9yKGdldHRlcikge1xuICAgICAgICB0aGlzLmRlcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XG4gICAgICAgIHRoaXNbX2EkMV0gPSB0cnVlO1xuICAgICAgICBsZXQgY29tcGFyZVRhcmdldDtcbiAgICAgICAgbGV0IGhhc0NvbXBhcmVUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVmZmVjdCA9IG5ldyBSZWFjdGl2ZUVmZmVjdChnZXR0ZXIsIChjb21wdXRlZFRyaWdnZXIpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlcCkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wdXRlZFRyaWdnZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGFyZVRhcmdldCA9IHRoaXMuX3ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBoYXNDb21wYXJlVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNjaGVkdWxlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZVRvQ29tcGFyZSA9IGhhc0NvbXBhcmVUYXJnZXQgPyBjb21wYXJlVGFyZ2V0IDogdGhpcy5fdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGhhc0NvbXBhcmVUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmVmZmVjdC5hY3RpdmUgJiYgdGhpcy5fZ2V0KCkgIT09IHZhbHVlVG9Db21wYXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlclJlZlZhbHVlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjaGFpbmVkIHVwc3RyZWFtIGNvbXB1dGVkcyBhcmUgbm90aWZpZWQgc3luY2hyb25vdXNseSB0byBlbnN1cmVcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZSBpbnZhbGlkYXRpb24gaW4gY2FzZSBvZiBzeW5jIGFjY2Vzczsgbm9ybWFsIGVmZmVjdHMgYXJlXG4gICAgICAgICAgICAgICAgLy8gZGVmZXJyZWQgdG8gYmUgdHJpZ2dlcmVkIGluIHNjaGVkdWxlci5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgdGhpcy5kZXApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuY29tcHV0ZWQgaW5zdGFuY2VvZiBEZWZlcnJlZENvbXB1dGVkUmVmSW1wbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zY2hlZHVsZXIodHJ1ZSAvKiBjb21wdXRlZFRyaWdnZXIgKi8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lZmZlY3QuY29tcHV0ZWQgPSB0aGlzO1xuICAgIH1cbiAgICBfZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5fZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuX3ZhbHVlID0gdGhpcy5lZmZlY3QucnVuKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICB0cmFja1JlZlZhbHVlKHRoaXMpO1xuICAgICAgICAvLyB0aGUgY29tcHV0ZWQgcmVmIG1heSBnZXQgd3JhcHBlZCBieSBvdGhlciBwcm94aWVzIGUuZy4gcmVhZG9ubHkoKSAjMzM3NlxuICAgICAgICByZXR1cm4gdG9SYXcodGhpcykuX2dldCgpO1xuICAgIH1cbn1cbl9hJDEgPSBcIl9fdl9pc1JlYWRvbmx5XCIgLyogUmVhY3RpdmVGbGFncy5JU19SRUFET05MWSAqLztcbmZ1bmN0aW9uIGRlZmVycmVkQ29tcHV0ZWQoZ2V0dGVyKSB7XG4gICAgcmV0dXJuIG5ldyBEZWZlcnJlZENvbXB1dGVkUmVmSW1wbChnZXR0ZXIpO1xufVxuXG5leHBvcnQgeyBFZmZlY3RTY29wZSwgSVRFUkFURV9LRVksIFJlYWN0aXZlRWZmZWN0LCBjb21wdXRlZCwgY3VzdG9tUmVmLCBkZWZlcnJlZENvbXB1dGVkLCBlZmZlY3QsIGVmZmVjdFNjb3BlLCBlbmFibGVUcmFja2luZywgZ2V0Q3VycmVudFNjb3BlLCBpc1Byb3h5LCBpc1JlYWN0aXZlLCBpc1JlYWRvbmx5LCBpc1JlZiwgaXNTaGFsbG93LCBtYXJrUmF3LCBvblNjb3BlRGlzcG9zZSwgcGF1c2VUcmFja2luZywgcHJveHlSZWZzLCByZWFjdGl2ZSwgcmVhZG9ubHksIHJlZiwgcmVzZXRUcmFja2luZywgc2hhbGxvd1JlYWN0aXZlLCBzaGFsbG93UmVhZG9ubHksIHNoYWxsb3dSZWYsIHN0b3AsIHRvUmF3LCB0b1JlZiwgdG9SZWZzLCB0cmFjaywgdHJpZ2dlciwgdHJpZ2dlclJlZiwgdW5yZWYgfTtcbiIsImltcG9ydCB7IHBhdXNlVHJhY2tpbmcsIHJlc2V0VHJhY2tpbmcsIGlzUmVmLCB0b1JhdywgaXNTaGFsbG93IGFzIGlzU2hhbGxvdyQxLCBpc1JlYWN0aXZlLCBSZWFjdGl2ZUVmZmVjdCwgcmVmLCBzaGFsbG93UmVhZG9ubHksIHRyYWNrLCByZWFjdGl2ZSwgc2hhbGxvd1JlYWN0aXZlLCB0cmlnZ2VyLCBpc1Byb3h5LCBFZmZlY3RTY29wZSwgbWFya1JhdywgcHJveHlSZWZzLCBjb21wdXRlZCBhcyBjb21wdXRlZCQxLCBpc1JlYWRvbmx5IH0gZnJvbSAnQHZ1ZS9yZWFjdGl2aXR5JztcbmV4cG9ydCB7IEVmZmVjdFNjb3BlLCBSZWFjdGl2ZUVmZmVjdCwgY3VzdG9tUmVmLCBlZmZlY3QsIGVmZmVjdFNjb3BlLCBnZXRDdXJyZW50U2NvcGUsIGlzUHJveHksIGlzUmVhY3RpdmUsIGlzUmVhZG9ubHksIGlzUmVmLCBpc1NoYWxsb3csIG1hcmtSYXcsIG9uU2NvcGVEaXNwb3NlLCBwcm94eVJlZnMsIHJlYWN0aXZlLCByZWFkb25seSwgcmVmLCBzaGFsbG93UmVhY3RpdmUsIHNoYWxsb3dSZWFkb25seSwgc2hhbGxvd1JlZiwgc3RvcCwgdG9SYXcsIHRvUmVmLCB0b1JlZnMsIHRyaWdnZXJSZWYsIHVucmVmIH0gZnJvbSAnQHZ1ZS9yZWFjdGl2aXR5JztcbmltcG9ydCB7IGlzU3RyaW5nLCBpc0Z1bmN0aW9uLCBpc1Byb21pc2UsIGlzQXJyYXksIE5PT1AsIGdldEdsb2JhbFRoaXMsIGV4dGVuZCwgRU1QVFlfT0JKLCB0b0hhbmRsZXJLZXksIHRvTnVtYmVyLCBoeXBoZW5hdGUsIGNhbWVsaXplLCBpc09iamVjdCwgaXNPbiwgaGFzT3duLCBpc01vZGVsTGlzdGVuZXIsIGhhc0NoYW5nZWQsIHJlbW92ZSwgaXNTZXQsIGlzTWFwLCBpc1BsYWluT2JqZWN0LCBpbnZva2VBcnJheUZucywgaXNCdWlsdEluRGlyZWN0aXZlLCBjYXBpdGFsaXplLCBpc0dsb2JhbGx5V2hpdGVsaXN0ZWQsIGRlZiwgaXNSZXNlcnZlZFByb3AsIEVNUFRZX0FSUiwgdG9SYXdUeXBlLCBtYWtlTWFwLCBOTywgbm9ybWFsaXplQ2xhc3MsIG5vcm1hbGl6ZVN0eWxlIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuZXhwb3J0IHsgY2FtZWxpemUsIGNhcGl0YWxpemUsIG5vcm1hbGl6ZUNsYXNzLCBub3JtYWxpemVQcm9wcywgbm9ybWFsaXplU3R5bGUsIHRvRGlzcGxheVN0cmluZywgdG9IYW5kbGVyS2V5IH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5jb25zdCBzdGFjayA9IFtdO1xuZnVuY3Rpb24gcHVzaFdhcm5pbmdDb250ZXh0KHZub2RlKSB7XG4gICAgc3RhY2sucHVzaCh2bm9kZSk7XG59XG5mdW5jdGlvbiBwb3BXYXJuaW5nQ29udGV4dCgpIHtcbiAgICBzdGFjay5wb3AoKTtcbn1cbmZ1bmN0aW9uIHdhcm4obXNnLCAuLi5hcmdzKSB7XG4gICAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBhdm9pZCBwcm9wcyBmb3JtYXR0aW5nIG9yIHdhcm4gaGFuZGxlciB0cmFja2luZyBkZXBzIHRoYXQgbWlnaHQgYmUgbXV0YXRlZFxuICAgIC8vIGR1cmluZyBwYXRjaCwgbGVhZGluZyB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gICAgcGF1c2VUcmFja2luZygpO1xuICAgIGNvbnN0IGluc3RhbmNlID0gc3RhY2subGVuZ3RoID8gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0uY29tcG9uZW50IDogbnVsbDtcbiAgICBjb25zdCBhcHBXYXJuSGFuZGxlciA9IGluc3RhbmNlICYmIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLndhcm5IYW5kbGVyO1xuICAgIGNvbnN0IHRyYWNlID0gZ2V0Q29tcG9uZW50VHJhY2UoKTtcbiAgICBpZiAoYXBwV2FybkhhbmRsZXIpIHtcbiAgICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKGFwcFdhcm5IYW5kbGVyLCBpbnN0YW5jZSwgMTEgLyogRXJyb3JDb2Rlcy5BUFBfV0FSTl9IQU5ETEVSICovLCBbXG4gICAgICAgICAgICBtc2cgKyBhcmdzLmpvaW4oJycpLFxuICAgICAgICAgICAgaW5zdGFuY2UgJiYgaW5zdGFuY2UucHJveHksXG4gICAgICAgICAgICB0cmFjZVxuICAgICAgICAgICAgICAgIC5tYXAoKHsgdm5vZGUgfSkgPT4gYGF0IDwke2Zvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIHZub2RlLnR5cGUpfT5gKVxuICAgICAgICAgICAgICAgIC5qb2luKCdcXG4nKSxcbiAgICAgICAgICAgIHRyYWNlXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgd2FybkFyZ3MgPSBbYFtWdWUgd2Fybl06ICR7bXNnfWAsIC4uLmFyZ3NdO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHRyYWNlLmxlbmd0aCAmJlxuICAgICAgICAgICAgLy8gYXZvaWQgc3BhbW1pbmcgY29uc29sZSBkdXJpbmcgdGVzdHNcbiAgICAgICAgICAgICFmYWxzZSkge1xuICAgICAgICAgICAgd2FybkFyZ3MucHVzaChgXFxuYCwgLi4uZm9ybWF0VHJhY2UodHJhY2UpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLndhcm4oLi4ud2FybkFyZ3MpO1xuICAgIH1cbiAgICByZXNldFRyYWNraW5nKCk7XG59XG5mdW5jdGlvbiBnZXRDb21wb25lbnRUcmFjZSgpIHtcbiAgICBsZXQgY3VycmVudFZOb2RlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgaWYgKCFjdXJyZW50Vk5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICAvLyB3ZSBjYW4ndCBqdXN0IHVzZSB0aGUgc3RhY2sgYmVjYXVzZSBpdCB3aWxsIGJlIGluY29tcGxldGUgZHVyaW5nIHVwZGF0ZXNcbiAgICAvLyB0aGF0IGRpZCBub3Qgc3RhcnQgZnJvbSB0aGUgcm9vdC4gUmUtY29uc3RydWN0IHRoZSBwYXJlbnQgY2hhaW4gdXNpbmdcbiAgICAvLyBpbnN0YW5jZSBwYXJlbnQgcG9pbnRlcnMuXG4gICAgY29uc3Qgbm9ybWFsaXplZFN0YWNrID0gW107XG4gICAgd2hpbGUgKGN1cnJlbnRWTm9kZSkge1xuICAgICAgICBjb25zdCBsYXN0ID0gbm9ybWFsaXplZFN0YWNrWzBdO1xuICAgICAgICBpZiAobGFzdCAmJiBsYXN0LnZub2RlID09PSBjdXJyZW50Vk5vZGUpIHtcbiAgICAgICAgICAgIGxhc3QucmVjdXJzZUNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub3JtYWxpemVkU3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgdm5vZGU6IGN1cnJlbnRWTm9kZSxcbiAgICAgICAgICAgICAgICByZWN1cnNlQ291bnQ6IDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudEluc3RhbmNlID0gY3VycmVudFZOb2RlLmNvbXBvbmVudCAmJiBjdXJyZW50Vk5vZGUuY29tcG9uZW50LnBhcmVudDtcbiAgICAgICAgY3VycmVudFZOb2RlID0gcGFyZW50SW5zdGFuY2UgJiYgcGFyZW50SW5zdGFuY2Uudm5vZGU7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVkU3RhY2s7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gZm9ybWF0VHJhY2UodHJhY2UpIHtcbiAgICBjb25zdCBsb2dzID0gW107XG4gICAgdHJhY2UuZm9yRWFjaCgoZW50cnksIGkpID0+IHtcbiAgICAgICAgbG9ncy5wdXNoKC4uLihpID09PSAwID8gW10gOiBbYFxcbmBdKSwgLi4uZm9ybWF0VHJhY2VFbnRyeShlbnRyeSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBsb2dzO1xufVxuZnVuY3Rpb24gZm9ybWF0VHJhY2VFbnRyeSh7IHZub2RlLCByZWN1cnNlQ291bnQgfSkge1xuICAgIGNvbnN0IHBvc3RmaXggPSByZWN1cnNlQ291bnQgPiAwID8gYC4uLiAoJHtyZWN1cnNlQ291bnR9IHJlY3Vyc2l2ZSBjYWxscylgIDogYGA7XG4gICAgY29uc3QgaXNSb290ID0gdm5vZGUuY29tcG9uZW50ID8gdm5vZGUuY29tcG9uZW50LnBhcmVudCA9PSBudWxsIDogZmFsc2U7XG4gICAgY29uc3Qgb3BlbiA9IGAgYXQgPCR7Zm9ybWF0Q29tcG9uZW50TmFtZSh2bm9kZS5jb21wb25lbnQsIHZub2RlLnR5cGUsIGlzUm9vdCl9YDtcbiAgICBjb25zdCBjbG9zZSA9IGA+YCArIHBvc3RmaXg7XG4gICAgcmV0dXJuIHZub2RlLnByb3BzXG4gICAgICAgID8gW29wZW4sIC4uLmZvcm1hdFByb3BzKHZub2RlLnByb3BzKSwgY2xvc2VdXG4gICAgICAgIDogW29wZW4gKyBjbG9zZV07XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gZm9ybWF0UHJvcHMocHJvcHMpIHtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvcHMpO1xuICAgIGtleXMuc2xpY2UoMCwgMykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICByZXMucHVzaCguLi5mb3JtYXRQcm9wKGtleSwgcHJvcHNba2V5XSkpO1xuICAgIH0pO1xuICAgIGlmIChrZXlzLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgcmVzLnB1c2goYCAuLi5gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBmb3JtYXRQcm9wKGtleSwgdmFsdWUsIHJhdykge1xuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PSR7dmFsdWV9YF07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT0ke3ZhbHVlfWBdO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1JlZih2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSBmb3JtYXRQcm9wKGtleSwgdG9SYXcodmFsdWUudmFsdWUpLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09UmVmPGAsIHZhbHVlLCBgPmBdO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gW2Ake2tleX09Zm4ke3ZhbHVlLm5hbWUgPyBgPCR7dmFsdWUubmFtZX0+YCA6IGBgfWBdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XG4gICAgICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PWAsIHZhbHVlXTtcbiAgICB9XG59XG5cbmNvbnN0IEVycm9yVHlwZVN0cmluZ3MgPSB7XG4gICAgW1wic3BcIiAvKiBMaWZlY3ljbGVIb29rcy5TRVJWRVJfUFJFRkVUQ0ggKi9dOiAnc2VydmVyUHJlZmV0Y2ggaG9vaycsXG4gICAgW1wiYmNcIiAvKiBMaWZlY3ljbGVIb29rcy5CRUZPUkVfQ1JFQVRFICovXTogJ2JlZm9yZUNyZWF0ZSBob29rJyxcbiAgICBbXCJjXCIgLyogTGlmZWN5Y2xlSG9va3MuQ1JFQVRFRCAqL106ICdjcmVhdGVkIGhvb2snLFxuICAgIFtcImJtXCIgLyogTGlmZWN5Y2xlSG9va3MuQkVGT1JFX01PVU5UICovXTogJ2JlZm9yZU1vdW50IGhvb2snLFxuICAgIFtcIm1cIiAvKiBMaWZlY3ljbGVIb29rcy5NT1VOVEVEICovXTogJ21vdW50ZWQgaG9vaycsXG4gICAgW1wiYnVcIiAvKiBMaWZlY3ljbGVIb29rcy5CRUZPUkVfVVBEQVRFICovXTogJ2JlZm9yZVVwZGF0ZSBob29rJyxcbiAgICBbXCJ1XCIgLyogTGlmZWN5Y2xlSG9va3MuVVBEQVRFRCAqL106ICd1cGRhdGVkJyxcbiAgICBbXCJidW1cIiAvKiBMaWZlY3ljbGVIb29rcy5CRUZPUkVfVU5NT1VOVCAqL106ICdiZWZvcmVVbm1vdW50IGhvb2snLFxuICAgIFtcInVtXCIgLyogTGlmZWN5Y2xlSG9va3MuVU5NT1VOVEVEICovXTogJ3VubW91bnRlZCBob29rJyxcbiAgICBbXCJhXCIgLyogTGlmZWN5Y2xlSG9va3MuQUNUSVZBVEVEICovXTogJ2FjdGl2YXRlZCBob29rJyxcbiAgICBbXCJkYVwiIC8qIExpZmVjeWNsZUhvb2tzLkRFQUNUSVZBVEVEICovXTogJ2RlYWN0aXZhdGVkIGhvb2snLFxuICAgIFtcImVjXCIgLyogTGlmZWN5Y2xlSG9va3MuRVJST1JfQ0FQVFVSRUQgKi9dOiAnZXJyb3JDYXB0dXJlZCBob29rJyxcbiAgICBbXCJydGNcIiAvKiBMaWZlY3ljbGVIb29rcy5SRU5ERVJfVFJBQ0tFRCAqL106ICdyZW5kZXJUcmFja2VkIGhvb2snLFxuICAgIFtcInJ0Z1wiIC8qIExpZmVjeWNsZUhvb2tzLlJFTkRFUl9UUklHR0VSRUQgKi9dOiAncmVuZGVyVHJpZ2dlcmVkIGhvb2snLFxuICAgIFswIC8qIEVycm9yQ29kZXMuU0VUVVBfRlVOQ1RJT04gKi9dOiAnc2V0dXAgZnVuY3Rpb24nLFxuICAgIFsxIC8qIEVycm9yQ29kZXMuUkVOREVSX0ZVTkNUSU9OICovXTogJ3JlbmRlciBmdW5jdGlvbicsXG4gICAgWzIgLyogRXJyb3JDb2Rlcy5XQVRDSF9HRVRURVIgKi9dOiAnd2F0Y2hlciBnZXR0ZXInLFxuICAgIFszIC8qIEVycm9yQ29kZXMuV0FUQ0hfQ0FMTEJBQ0sgKi9dOiAnd2F0Y2hlciBjYWxsYmFjaycsXG4gICAgWzQgLyogRXJyb3JDb2Rlcy5XQVRDSF9DTEVBTlVQICovXTogJ3dhdGNoZXIgY2xlYW51cCBmdW5jdGlvbicsXG4gICAgWzUgLyogRXJyb3JDb2Rlcy5OQVRJVkVfRVZFTlRfSEFORExFUiAqL106ICduYXRpdmUgZXZlbnQgaGFuZGxlcicsXG4gICAgWzYgLyogRXJyb3JDb2Rlcy5DT01QT05FTlRfRVZFTlRfSEFORExFUiAqL106ICdjb21wb25lbnQgZXZlbnQgaGFuZGxlcicsXG4gICAgWzcgLyogRXJyb3JDb2Rlcy5WTk9ERV9IT09LICovXTogJ3Zub2RlIGhvb2snLFxuICAgIFs4IC8qIEVycm9yQ29kZXMuRElSRUNUSVZFX0hPT0sgKi9dOiAnZGlyZWN0aXZlIGhvb2snLFxuICAgIFs5IC8qIEVycm9yQ29kZXMuVFJBTlNJVElPTl9IT09LICovXTogJ3RyYW5zaXRpb24gaG9vaycsXG4gICAgWzEwIC8qIEVycm9yQ29kZXMuQVBQX0VSUk9SX0hBTkRMRVIgKi9dOiAnYXBwIGVycm9ySGFuZGxlcicsXG4gICAgWzExIC8qIEVycm9yQ29kZXMuQVBQX1dBUk5fSEFORExFUiAqL106ICdhcHAgd2FybkhhbmRsZXInLFxuICAgIFsxMiAvKiBFcnJvckNvZGVzLkZVTkNUSU9OX1JFRiAqL106ICdyZWYgZnVuY3Rpb24nLFxuICAgIFsxMyAvKiBFcnJvckNvZGVzLkFTWU5DX0NPTVBPTkVOVF9MT0FERVIgKi9dOiAnYXN5bmMgY29tcG9uZW50IGxvYWRlcicsXG4gICAgWzE0IC8qIEVycm9yQ29kZXMuU0NIRURVTEVSICovXTogJ3NjaGVkdWxlciBmbHVzaC4gVGhpcyBpcyBsaWtlbHkgYSBWdWUgaW50ZXJuYWxzIGJ1Zy4gJyArXG4gICAgICAgICdQbGVhc2Ugb3BlbiBhbiBpc3N1ZSBhdCBodHRwczovL25ldy1pc3N1ZS52dWVqcy5vcmcvP3JlcG89dnVlanMvY29yZSdcbn07XG5mdW5jdGlvbiBjYWxsV2l0aEVycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKSB7XG4gICAgbGV0IHJlcztcbiAgICB0cnkge1xuICAgICAgICByZXMgPSBhcmdzID8gZm4oLi4uYXJncykgOiBmbigpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oZm4pKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGNhbGxXaXRoRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpO1xuICAgICAgICBpZiAocmVzICYmIGlzUHJvbWlzZShyZXMpKSB7XG4gICAgICAgICAgICByZXMuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCB0eXBlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWVzLnB1c2goY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoZm5baV0sIGluc3RhbmNlLCB0eXBlLCBhcmdzKSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG59XG5mdW5jdGlvbiBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCB0eXBlLCB0aHJvd0luRGV2ID0gdHJ1ZSkge1xuICAgIGNvbnN0IGNvbnRleHRWTm9kZSA9IGluc3RhbmNlID8gaW5zdGFuY2Uudm5vZGUgOiBudWxsO1xuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICBsZXQgY3VyID0gaW5zdGFuY2UucGFyZW50O1xuICAgICAgICAvLyB0aGUgZXhwb3NlZCBpbnN0YW5jZSBpcyB0aGUgcmVuZGVyIHByb3h5IHRvIGtlZXAgaXQgY29uc2lzdGVudCB3aXRoIDIueFxuICAgICAgICBjb25zdCBleHBvc2VkSW5zdGFuY2UgPSBpbnN0YW5jZS5wcm94eTtcbiAgICAgICAgLy8gaW4gcHJvZHVjdGlvbiB0aGUgaG9vayByZWNlaXZlcyBvbmx5IHRoZSBlcnJvciBjb2RlXG4gICAgICAgIGNvbnN0IGVycm9ySW5mbyA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IEVycm9yVHlwZVN0cmluZ3NbdHlwZV0gOiB0eXBlO1xuICAgICAgICB3aGlsZSAoY3VyKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvckNhcHR1cmVkSG9va3MgPSBjdXIuZWM7XG4gICAgICAgICAgICBpZiAoZXJyb3JDYXB0dXJlZEhvb2tzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlcnJvckNhcHR1cmVkSG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yQ2FwdHVyZWRIb29rc1tpXShlcnIsIGV4cG9zZWRJbnN0YW5jZSwgZXJyb3JJbmZvKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXBwLWxldmVsIGhhbmRsaW5nXG4gICAgICAgIGNvbnN0IGFwcEVycm9ySGFuZGxlciA9IGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLmVycm9ySGFuZGxlcjtcbiAgICAgICAgaWYgKGFwcEVycm9ySGFuZGxlcikge1xuICAgICAgICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKGFwcEVycm9ySGFuZGxlciwgbnVsbCwgMTAgLyogRXJyb3JDb2Rlcy5BUFBfRVJST1JfSEFORExFUiAqLywgW2VyciwgZXhwb3NlZEluc3RhbmNlLCBlcnJvckluZm9dKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsb2dFcnJvcihlcnIsIHR5cGUsIGNvbnRleHRWTm9kZSwgdGhyb3dJbkRldik7XG59XG5mdW5jdGlvbiBsb2dFcnJvcihlcnIsIHR5cGUsIGNvbnRleHRWTm9kZSwgdGhyb3dJbkRldiA9IHRydWUpIHtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIGNvbnN0IGluZm8gPSBFcnJvclR5cGVTdHJpbmdzW3R5cGVdO1xuICAgICAgICBpZiAoY29udGV4dFZOb2RlKSB7XG4gICAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQoY29udGV4dFZOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICB3YXJuKGBVbmhhbmRsZWQgZXJyb3Ike2luZm8gPyBgIGR1cmluZyBleGVjdXRpb24gb2YgJHtpbmZvfWAgOiBgYH1gKTtcbiAgICAgICAgaWYgKGNvbnRleHRWTm9kZSkge1xuICAgICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjcmFzaCBpbiBkZXYgYnkgZGVmYXVsdCBzbyBpdCdzIG1vcmUgbm90aWNlYWJsZVxuICAgICAgICBpZiAodGhyb3dJbkRldikge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyByZWNvdmVyIGluIHByb2QgdG8gcmVkdWNlIHRoZSBpbXBhY3Qgb24gZW5kLXVzZXJcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIH1cbn1cblxubGV0IGlzRmx1c2hpbmcgPSBmYWxzZTtcbmxldCBpc0ZsdXNoUGVuZGluZyA9IGZhbHNlO1xuY29uc3QgcXVldWUgPSBbXTtcbmxldCBmbHVzaEluZGV4ID0gMDtcbmNvbnN0IHBlbmRpbmdQb3N0Rmx1c2hDYnMgPSBbXTtcbmxldCBhY3RpdmVQb3N0Rmx1c2hDYnMgPSBudWxsO1xubGV0IHBvc3RGbHVzaEluZGV4ID0gMDtcbmNvbnN0IHJlc29sdmVkUHJvbWlzZSA9IC8qI19fUFVSRV9fKi8gUHJvbWlzZS5yZXNvbHZlKCk7XG5sZXQgY3VycmVudEZsdXNoUHJvbWlzZSA9IG51bGw7XG5jb25zdCBSRUNVUlNJT05fTElNSVQgPSAxMDA7XG5mdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgIGNvbnN0IHAgPSBjdXJyZW50Rmx1c2hQcm9taXNlIHx8IHJlc29sdmVkUHJvbWlzZTtcbiAgICByZXR1cm4gZm4gPyBwLnRoZW4odGhpcyA/IGZuLmJpbmQodGhpcykgOiBmbikgOiBwO1xufVxuLy8gIzI3Njhcbi8vIFVzZSBiaW5hcnktc2VhcmNoIHRvIGZpbmQgYSBzdWl0YWJsZSBwb3NpdGlvbiBpbiB0aGUgcXVldWUsXG4vLyBzbyB0aGF0IHRoZSBxdWV1ZSBtYWludGFpbnMgdGhlIGluY3JlYXNpbmcgb3JkZXIgb2Ygam9iJ3MgaWQsXG4vLyB3aGljaCBjYW4gcHJldmVudCB0aGUgam9iIGZyb20gYmVpbmcgc2tpcHBlZCBhbmQgYWxzbyBjYW4gYXZvaWQgcmVwZWF0ZWQgcGF0Y2hpbmcuXG5mdW5jdGlvbiBmaW5kSW5zZXJ0aW9uSW5kZXgoaWQpIHtcbiAgICAvLyB0aGUgc3RhcnQgaW5kZXggc2hvdWxkIGJlIGBmbHVzaEluZGV4ICsgMWBcbiAgICBsZXQgc3RhcnQgPSBmbHVzaEluZGV4ICsgMTtcbiAgICBsZXQgZW5kID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xuICAgICAgICBjb25zdCBtaWRkbGUgPSAoc3RhcnQgKyBlbmQpID4+PiAxO1xuICAgICAgICBjb25zdCBtaWRkbGVKb2JJZCA9IGdldElkKHF1ZXVlW21pZGRsZV0pO1xuICAgICAgICBtaWRkbGVKb2JJZCA8IGlkID8gKHN0YXJ0ID0gbWlkZGxlICsgMSkgOiAoZW5kID0gbWlkZGxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXJ0O1xufVxuZnVuY3Rpb24gcXVldWVKb2Ioam9iKSB7XG4gICAgLy8gdGhlIGRlZHVwZSBzZWFyY2ggdXNlcyB0aGUgc3RhcnRJbmRleCBhcmd1bWVudCBvZiBBcnJheS5pbmNsdWRlcygpXG4gICAgLy8gYnkgZGVmYXVsdCB0aGUgc2VhcmNoIGluZGV4IGluY2x1ZGVzIHRoZSBjdXJyZW50IGpvYiB0aGF0IGlzIGJlaW5nIHJ1blxuICAgIC8vIHNvIGl0IGNhbm5vdCByZWN1cnNpdmVseSB0cmlnZ2VyIGl0c2VsZiBhZ2Fpbi5cbiAgICAvLyBpZiB0aGUgam9iIGlzIGEgd2F0Y2goKSBjYWxsYmFjaywgdGhlIHNlYXJjaCB3aWxsIHN0YXJ0IHdpdGggYSArMSBpbmRleCB0b1xuICAgIC8vIGFsbG93IGl0IHJlY3Vyc2l2ZWx5IHRyaWdnZXIgaXRzZWxmIC0gaXQgaXMgdGhlIHVzZXIncyByZXNwb25zaWJpbGl0eSB0b1xuICAgIC8vIGVuc3VyZSBpdCBkb2Vzbid0IGVuZCB1cCBpbiBhbiBpbmZpbml0ZSBsb29wLlxuICAgIGlmICghcXVldWUubGVuZ3RoIHx8XG4gICAgICAgICFxdWV1ZS5pbmNsdWRlcyhqb2IsIGlzRmx1c2hpbmcgJiYgam9iLmFsbG93UmVjdXJzZSA/IGZsdXNoSW5kZXggKyAxIDogZmx1c2hJbmRleCkpIHtcbiAgICAgICAgaWYgKGpvYi5pZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGpvYik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBxdWV1ZS5zcGxpY2UoZmluZEluc2VydGlvbkluZGV4KGpvYi5pZCksIDAsIGpvYik7XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVGbHVzaCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHF1ZXVlRmx1c2goKSB7XG4gICAgaWYgKCFpc0ZsdXNoaW5nICYmICFpc0ZsdXNoUGVuZGluZykge1xuICAgICAgICBpc0ZsdXNoUGVuZGluZyA9IHRydWU7XG4gICAgICAgIGN1cnJlbnRGbHVzaFByb21pc2UgPSByZXNvbHZlZFByb21pc2UudGhlbihmbHVzaEpvYnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGludmFsaWRhdGVKb2Ioam9iKSB7XG4gICAgY29uc3QgaSA9IHF1ZXVlLmluZGV4T2Yoam9iKTtcbiAgICBpZiAoaSA+IGZsdXNoSW5kZXgpIHtcbiAgICAgICAgcXVldWUuc3BsaWNlKGksIDEpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHF1ZXVlUG9zdEZsdXNoQ2IoY2IpIHtcbiAgICBpZiAoIWlzQXJyYXkoY2IpKSB7XG4gICAgICAgIGlmICghYWN0aXZlUG9zdEZsdXNoQ2JzIHx8XG4gICAgICAgICAgICAhYWN0aXZlUG9zdEZsdXNoQ2JzLmluY2x1ZGVzKGNiLCBjYi5hbGxvd1JlY3Vyc2UgPyBwb3N0Rmx1c2hJbmRleCArIDEgOiBwb3N0Rmx1c2hJbmRleCkpIHtcbiAgICAgICAgICAgIHBlbmRpbmdQb3N0Rmx1c2hDYnMucHVzaChjYik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGlmIGNiIGlzIGFuIGFycmF5LCBpdCBpcyBhIGNvbXBvbmVudCBsaWZlY3ljbGUgaG9vayB3aGljaCBjYW4gb25seSBiZVxuICAgICAgICAvLyB0cmlnZ2VyZWQgYnkgYSBqb2IsIHdoaWNoIGlzIGFscmVhZHkgZGVkdXBlZCBpbiB0aGUgbWFpbiBxdWV1ZSwgc29cbiAgICAgICAgLy8gd2UgY2FuIHNraXAgZHVwbGljYXRlIGNoZWNrIGhlcmUgdG8gaW1wcm92ZSBwZXJmXG4gICAgICAgIHBlbmRpbmdQb3N0Rmx1c2hDYnMucHVzaCguLi5jYik7XG4gICAgfVxuICAgIHF1ZXVlRmx1c2goKTtcbn1cbmZ1bmN0aW9uIGZsdXNoUHJlRmx1c2hDYnMoc2VlbiwgXG4vLyBpZiBjdXJyZW50bHkgZmx1c2hpbmcsIHNraXAgdGhlIGN1cnJlbnQgam9iIGl0c2VsZlxuaSA9IGlzRmx1c2hpbmcgPyBmbHVzaEluZGV4ICsgMSA6IDApIHtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIHNlZW4gPSBzZWVuIHx8IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgZm9yICg7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjYiA9IHF1ZXVlW2ldO1xuICAgICAgICBpZiAoY2IgJiYgY2IucHJlKSB7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBjYikpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHF1ZXVlLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBmbHVzaFBvc3RGbHVzaENicyhzZWVuKSB7XG4gICAgaWYgKHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGRlZHVwZWQgPSBbLi4ubmV3IFNldChwZW5kaW5nUG9zdEZsdXNoQ2JzKV07XG4gICAgICAgIHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoID0gMDtcbiAgICAgICAgLy8gIzE5NDcgYWxyZWFkeSBoYXMgYWN0aXZlIHF1ZXVlLCBuZXN0ZWQgZmx1c2hQb3N0Rmx1c2hDYnMgY2FsbFxuICAgICAgICBpZiAoYWN0aXZlUG9zdEZsdXNoQ2JzKSB7XG4gICAgICAgICAgICBhY3RpdmVQb3N0Rmx1c2hDYnMucHVzaCguLi5kZWR1cGVkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhY3RpdmVQb3N0Rmx1c2hDYnMgPSBkZWR1cGVkO1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICBzZWVuID0gc2VlbiB8fCBuZXcgTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzLnNvcnQoKGEsIGIpID0+IGdldElkKGEpIC0gZ2V0SWQoYikpO1xuICAgICAgICBmb3IgKHBvc3RGbHVzaEluZGV4ID0gMDsgcG9zdEZsdXNoSW5kZXggPCBhY3RpdmVQb3N0Rmx1c2hDYnMubGVuZ3RoOyBwb3N0Rmx1c2hJbmRleCsrKSB7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICAgICAgY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGFjdGl2ZVBvc3RGbHVzaENic1twb3N0Rmx1c2hJbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY3RpdmVQb3N0Rmx1c2hDYnNbcG9zdEZsdXNoSW5kZXhdKCk7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzID0gbnVsbDtcbiAgICAgICAgcG9zdEZsdXNoSW5kZXggPSAwO1xuICAgIH1cbn1cbmNvbnN0IGdldElkID0gKGpvYikgPT4gam9iLmlkID09IG51bGwgPyBJbmZpbml0eSA6IGpvYi5pZDtcbmNvbnN0IGNvbXBhcmF0b3IgPSAoYSwgYikgPT4ge1xuICAgIGNvbnN0IGRpZmYgPSBnZXRJZChhKSAtIGdldElkKGIpO1xuICAgIGlmIChkaWZmID09PSAwKSB7XG4gICAgICAgIGlmIChhLnByZSAmJiAhYi5wcmUpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGlmIChiLnByZSAmJiAhYS5wcmUpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIGRpZmY7XG59O1xuZnVuY3Rpb24gZmx1c2hKb2JzKHNlZW4pIHtcbiAgICBpc0ZsdXNoUGVuZGluZyA9IGZhbHNlO1xuICAgIGlzRmx1c2hpbmcgPSB0cnVlO1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgc2VlbiA9IHNlZW4gfHwgbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cbiAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gICAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkIHNvIGl0cyByZW5kZXIgZWZmZWN0IHdpbGwgaGF2ZSBzbWFsbGVyXG4gICAgLy8gICAgcHJpb3JpdHkgbnVtYmVyKVxuICAgIC8vIDIuIElmIGEgY29tcG9uZW50IGlzIHVubW91bnRlZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3MgdXBkYXRlLFxuICAgIC8vICAgIGl0cyB1cGRhdGUgY2FuIGJlIHNraXBwZWQuXG4gICAgcXVldWUuc29ydChjb21wYXJhdG9yKTtcbiAgICAvLyBjb25kaXRpb25hbCB1c2FnZSBvZiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZSBtdXN0IGJlIGRldGVybWluZWQgb3V0IG9mXG4gICAgLy8gdHJ5IC4uLiBjYXRjaCBibG9jayBzaW5jZSBSb2xsdXAgYnkgZGVmYXVsdCBkZS1vcHRpbWl6ZXMgdHJlZXNoYWtpbmdcbiAgICAvLyBpbnNpZGUgdHJ5LWNhdGNoLiBUaGlzIGNhbiBsZWF2ZSBhbGwgd2FybmluZyBjb2RlIHVuc2hha2VkLiBBbHRob3VnaFxuICAgIC8vIHRoZXkgd291bGQgZ2V0IGV2ZW50dWFsbHkgc2hha2VuIGJ5IGEgbWluaWZpZXIgbGlrZSB0ZXJzZXIsIHNvbWUgbWluaWZpZXJzXG4gICAgLy8gd291bGQgZmFpbCB0byBkbyB0aGF0IChlLmcuIGh0dHBzOi8vZ2l0aHViLmNvbS9ldmFudy9lc2J1aWxkL2lzc3Vlcy8xNjEwKVxuICAgIGNvbnN0IGNoZWNrID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXG4gICAgICAgID8gKGpvYikgPT4gY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGpvYilcbiAgICAgICAgOiBOT09QO1xuICAgIHRyeSB7XG4gICAgICAgIGZvciAoZmx1c2hJbmRleCA9IDA7IGZsdXNoSW5kZXggPCBxdWV1ZS5sZW5ndGg7IGZsdXNoSW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3Qgam9iID0gcXVldWVbZmx1c2hJbmRleF07XG4gICAgICAgICAgICBpZiAoam9iICYmIGpvYi5hY3RpdmUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjaGVjayhqb2IpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgcnVubmluZzpgLCBqb2IuaWQpXG4gICAgICAgICAgICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKGpvYiwgbnVsbCwgMTQgLyogRXJyb3JDb2Rlcy5TQ0hFRFVMRVIgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBmbHVzaEluZGV4ID0gMDtcbiAgICAgICAgcXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgZmx1c2hQb3N0Rmx1c2hDYnMoc2Vlbik7XG4gICAgICAgIGlzRmx1c2hpbmcgPSBmYWxzZTtcbiAgICAgICAgY3VycmVudEZsdXNoUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIC8vIHNvbWUgcG9zdEZsdXNoQ2IgcXVldWVkIGpvYnMhXG4gICAgICAgIC8vIGtlZXAgZmx1c2hpbmcgdW50aWwgaXQgZHJhaW5zLlxuICAgICAgICBpZiAocXVldWUubGVuZ3RoIHx8IHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBmbHVzaEpvYnMoc2Vlbik7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2VlbiwgZm4pIHtcbiAgICBpZiAoIXNlZW4uaGFzKGZuKSkge1xuICAgICAgICBzZWVuLnNldChmbiwgMSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBjb3VudCA9IHNlZW4uZ2V0KGZuKTtcbiAgICAgICAgaWYgKGNvdW50ID4gUkVDVVJTSU9OX0xJTUlUKSB7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGZuLm93bmVySW5zdGFuY2U7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnROYW1lID0gaW5zdGFuY2UgJiYgZ2V0Q29tcG9uZW50TmFtZShpbnN0YW5jZS50eXBlKTtcbiAgICAgICAgICAgIHdhcm4oYE1heGltdW0gcmVjdXJzaXZlIHVwZGF0ZXMgZXhjZWVkZWQke2NvbXBvbmVudE5hbWUgPyBgIGluIGNvbXBvbmVudCA8JHtjb21wb25lbnROYW1lfT5gIDogYGB9LiBgICtcbiAgICAgICAgICAgICAgICBgVGhpcyBtZWFucyB5b3UgaGF2ZSBhIHJlYWN0aXZlIGVmZmVjdCB0aGF0IGlzIG11dGF0aW5nIGl0cyBvd24gYCArXG4gICAgICAgICAgICAgICAgYGRlcGVuZGVuY2llcyBhbmQgdGh1cyByZWN1cnNpdmVseSB0cmlnZ2VyaW5nIGl0c2VsZi4gUG9zc2libGUgc291cmNlcyBgICtcbiAgICAgICAgICAgICAgICBgaW5jbHVkZSBjb21wb25lbnQgdGVtcGxhdGUsIHJlbmRlciBmdW5jdGlvbiwgdXBkYXRlZCBob29rIG9yIGAgK1xuICAgICAgICAgICAgICAgIGB3YXRjaGVyIHNvdXJjZSBmdW5jdGlvbi5gKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2Vlbi5zZXQoZm4sIGNvdW50ICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xubGV0IGlzSG1yVXBkYXRpbmcgPSBmYWxzZTtcbmNvbnN0IGhtckRpcnR5Q29tcG9uZW50cyA9IG5ldyBTZXQoKTtcbi8vIEV4cG9zZSB0aGUgSE1SIHJ1bnRpbWUgb24gdGhlIGdsb2JhbCBvYmplY3Rcbi8vIFRoaXMgbWFrZXMgaXQgZW50aXJlbHkgdHJlZS1zaGFrYWJsZSB3aXRob3V0IHBvbGx1dGluZyB0aGUgZXhwb3J0cyBhbmQgbWFrZXNcbi8vIGl0IGVhc2llciB0byBiZSB1c2VkIGluIHRvb2xpbmdzIGxpa2UgdnVlLWxvYWRlclxuLy8gTm90ZTogZm9yIGEgY29tcG9uZW50IHRvIGJlIGVsaWdpYmxlIGZvciBITVIgaXQgYWxzbyBuZWVkcyB0aGUgX19obXJJZCBvcHRpb25cbi8vIHRvIGJlIHNldCBzbyB0aGF0IGl0cyBpbnN0YW5jZXMgY2FuIGJlIHJlZ2lzdGVyZWQgLyByZW1vdmVkLlxuaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9ITVJfUlVOVElNRV9fID0ge1xuICAgICAgICBjcmVhdGVSZWNvcmQ6IHRyeVdyYXAoY3JlYXRlUmVjb3JkKSxcbiAgICAgICAgcmVyZW5kZXI6IHRyeVdyYXAocmVyZW5kZXIpLFxuICAgICAgICByZWxvYWQ6IHRyeVdyYXAocmVsb2FkKVxuICAgIH07XG59XG5jb25zdCBtYXAgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiByZWdpc3RlckhNUihpbnN0YW5jZSkge1xuICAgIGNvbnN0IGlkID0gaW5zdGFuY2UudHlwZS5fX2htcklkO1xuICAgIGxldCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcbiAgICBpZiAoIXJlY29yZCkge1xuICAgICAgICBjcmVhdGVSZWNvcmQoaWQsIGluc3RhbmNlLnR5cGUpO1xuICAgICAgICByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcbiAgICB9XG4gICAgcmVjb3JkLmluc3RhbmNlcy5hZGQoaW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gdW5yZWdpc3RlckhNUihpbnN0YW5jZSkge1xuICAgIG1hcC5nZXQoaW5zdGFuY2UudHlwZS5fX2htcklkKS5pbnN0YW5jZXMuZGVsZXRlKGluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlY29yZChpZCwgaW5pdGlhbERlZikge1xuICAgIGlmIChtYXAuaGFzKGlkKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG1hcC5zZXQoaWQsIHtcbiAgICAgICAgaW5pdGlhbERlZjogbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoaW5pdGlhbERlZiksXG4gICAgICAgIGluc3RhbmNlczogbmV3IFNldCgpXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDbGFzc0NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICByZXR1cm4gaXNDbGFzc0NvbXBvbmVudChjb21wb25lbnQpID8gY29tcG9uZW50Ll9fdmNjT3B0cyA6IGNvbXBvbmVudDtcbn1cbmZ1bmN0aW9uIHJlcmVuZGVyKGlkLCBuZXdSZW5kZXIpIHtcbiAgICBjb25zdCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcbiAgICBpZiAoIXJlY29yZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHVwZGF0ZSBpbml0aWFsIHJlY29yZCAoZm9yIG5vdC15ZXQtcmVuZGVyZWQgY29tcG9uZW50KVxuICAgIHJlY29yZC5pbml0aWFsRGVmLnJlbmRlciA9IG5ld1JlbmRlcjtcbiAgICBbLi4ucmVjb3JkLmluc3RhbmNlc10uZm9yRWFjaChpbnN0YW5jZSA9PiB7XG4gICAgICAgIGlmIChuZXdSZW5kZXIpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnJlbmRlciA9IG5ld1JlbmRlcjtcbiAgICAgICAgICAgIG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGluc3RhbmNlLnR5cGUpLnJlbmRlciA9IG5ld1JlbmRlcjtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5yZW5kZXJDYWNoZSA9IFtdO1xuICAgICAgICAvLyB0aGlzIGZsYWcgZm9yY2VzIGNoaWxkIGNvbXBvbmVudHMgd2l0aCBzbG90IGNvbnRlbnQgdG8gdXBkYXRlXG4gICAgICAgIGlzSG1yVXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgICAgaXNIbXJVcGRhdGluZyA9IGZhbHNlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcmVsb2FkKGlkLCBuZXdDb21wKSB7XG4gICAgY29uc3QgcmVjb3JkID0gbWFwLmdldChpZCk7XG4gICAgaWYgKCFyZWNvcmQpXG4gICAgICAgIHJldHVybjtcbiAgICBuZXdDb21wID0gbm9ybWFsaXplQ2xhc3NDb21wb25lbnQobmV3Q29tcCk7XG4gICAgLy8gdXBkYXRlIGluaXRpYWwgZGVmIChmb3Igbm90LXlldC1yZW5kZXJlZCBjb21wb25lbnRzKVxuICAgIHVwZGF0ZUNvbXBvbmVudERlZihyZWNvcmQuaW5pdGlhbERlZiwgbmV3Q29tcCk7XG4gICAgLy8gY3JlYXRlIGEgc25hcHNob3Qgd2hpY2ggYXZvaWRzIHRoZSBzZXQgYmVpbmcgbXV0YXRlZCBkdXJpbmcgdXBkYXRlc1xuICAgIGNvbnN0IGluc3RhbmNlcyA9IFsuLi5yZWNvcmQuaW5zdGFuY2VzXTtcbiAgICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIGluc3RhbmNlcykge1xuICAgICAgICBjb25zdCBvbGRDb21wID0gbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoaW5zdGFuY2UudHlwZSk7XG4gICAgICAgIGlmICghaG1yRGlydHlDb21wb25lbnRzLmhhcyhvbGRDb21wKSkge1xuICAgICAgICAgICAgLy8gMS4gVXBkYXRlIGV4aXN0aW5nIGNvbXAgZGVmaW5pdGlvbiB0byBtYXRjaCBuZXcgb25lXG4gICAgICAgICAgICBpZiAob2xkQ29tcCAhPT0gcmVjb3JkLmluaXRpYWxEZWYpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVDb21wb25lbnREZWYob2xkQ29tcCwgbmV3Q29tcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAyLiBtYXJrIGRlZmluaXRpb24gZGlydHkuIFRoaXMgZm9yY2VzIHRoZSByZW5kZXJlciB0byByZXBsYWNlIHRoZVxuICAgICAgICAgICAgLy8gY29tcG9uZW50IG9uIHBhdGNoLlxuICAgICAgICAgICAgaG1yRGlydHlDb21wb25lbnRzLmFkZChvbGRDb21wKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAzLiBpbnZhbGlkYXRlIG9wdGlvbnMgcmVzb2x1dGlvbiBjYWNoZVxuICAgICAgICBpbnN0YW5jZS5hcHBDb250ZXh0Lm9wdGlvbnNDYWNoZS5kZWxldGUoaW5zdGFuY2UudHlwZSk7XG4gICAgICAgIC8vIDQuIGFjdHVhbGx5IHVwZGF0ZVxuICAgICAgICBpZiAoaW5zdGFuY2UuY2VSZWxvYWQpIHtcbiAgICAgICAgICAgIC8vIGN1c3RvbSBlbGVtZW50XG4gICAgICAgICAgICBobXJEaXJ0eUNvbXBvbmVudHMuYWRkKG9sZENvbXApO1xuICAgICAgICAgICAgaW5zdGFuY2UuY2VSZWxvYWQobmV3Q29tcC5zdHlsZXMpO1xuICAgICAgICAgICAgaG1yRGlydHlDb21wb25lbnRzLmRlbGV0ZShvbGRDb21wKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnN0YW5jZS5wYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIDQuIEZvcmNlIHRoZSBwYXJlbnQgaW5zdGFuY2UgdG8gcmUtcmVuZGVyLiBUaGlzIHdpbGwgY2F1c2UgYWxsIHVwZGF0ZWRcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudHMgdG8gYmUgdW5tb3VudGVkIGFuZCByZS1tb3VudGVkLiBRdWV1ZSB0aGUgdXBkYXRlIHNvIHRoYXQgd2VcbiAgICAgICAgICAgIC8vIGRvbid0IGVuZCB1cCBmb3JjaW5nIHRoZSBzYW1lIHBhcmVudCB0byByZS1yZW5kZXIgbXVsdGlwbGUgdGltZXMuXG4gICAgICAgICAgICBxdWV1ZUpvYihpbnN0YW5jZS5wYXJlbnQudXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnN0YW5jZS5hcHBDb250ZXh0LnJlbG9hZCkge1xuICAgICAgICAgICAgLy8gcm9vdCBpbnN0YW5jZSBtb3VudGVkIHZpYSBjcmVhdGVBcHAoKSBoYXMgYSByZWxvYWQgbWV0aG9kXG4gICAgICAgICAgICBpbnN0YW5jZS5hcHBDb250ZXh0LnJlbG9hZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyByb290IGluc3RhbmNlIGluc2lkZSB0cmVlIGNyZWF0ZWQgdmlhIHJhdyByZW5kZXIoKS4gRm9yY2UgcmVsb2FkLlxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdbSE1SXSBSb290IG9yIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UgbW9kaWZpZWQuIEZ1bGwgcmVsb2FkIHJlcXVpcmVkLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIDUuIG1ha2Ugc3VyZSB0byBjbGVhbnVwIGRpcnR5IGhtciBjb21wb25lbnRzIGFmdGVyIHVwZGF0ZVxuICAgIHF1ZXVlUG9zdEZsdXNoQ2IoKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIGluc3RhbmNlcykge1xuICAgICAgICAgICAgaG1yRGlydHlDb21wb25lbnRzLmRlbGV0ZShub3JtYWxpemVDbGFzc0NvbXBvbmVudChpbnN0YW5jZS50eXBlKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudERlZihvbGRDb21wLCBuZXdDb21wKSB7XG4gICAgZXh0ZW5kKG9sZENvbXAsIG5ld0NvbXApO1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9sZENvbXApIHtcbiAgICAgICAgaWYgKGtleSAhPT0gJ19fZmlsZScgJiYgIShrZXkgaW4gbmV3Q29tcCkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvbGRDb21wW2tleV07XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB0cnlXcmFwKGZuKSB7XG4gICAgcmV0dXJuIChpZCwgYXJnKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4oaWQsIGFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFtITVJdIFNvbWV0aGluZyB3ZW50IHdyb25nIGR1cmluZyBWdWUgY29tcG9uZW50IGhvdC1yZWxvYWQuIGAgK1xuICAgICAgICAgICAgICAgIGBGdWxsIHJlbG9hZCByZXF1aXJlZC5gKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmxldCBkZXZ0b29scztcbmxldCBidWZmZXIgPSBbXTtcbmxldCBkZXZ0b29sc05vdEluc3RhbGxlZCA9IGZhbHNlO1xuZnVuY3Rpb24gZW1pdChldmVudCwgLi4uYXJncykge1xuICAgIGlmIChkZXZ0b29scykge1xuICAgICAgICBkZXZ0b29scy5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWRldnRvb2xzTm90SW5zdGFsbGVkKSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKHsgZXZlbnQsIGFyZ3MgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0RGV2dG9vbHNIb29rKGhvb2ssIHRhcmdldCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgZGV2dG9vbHMgPSBob29rO1xuICAgIGlmIChkZXZ0b29scykge1xuICAgICAgICBkZXZ0b29scy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgYnVmZmVyLmZvckVhY2goKHsgZXZlbnQsIGFyZ3MgfSkgPT4gZGV2dG9vbHMuZW1pdChldmVudCwgLi4uYXJncykpO1xuICAgICAgICBidWZmZXIgPSBbXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoXG4gICAgLy8gaGFuZGxlIGxhdGUgZGV2dG9vbHMgaW5qZWN0aW9uIC0gb25seSBkbyB0aGlzIGlmIHdlIGFyZSBpbiBhbiBhY3R1YWxcbiAgICAvLyBicm93c2VyIGVudmlyb25tZW50IHRvIGF2b2lkIHRoZSB0aW1lciBoYW5kbGUgc3RhbGxpbmcgdGVzdCBydW5uZXIgZXhpdFxuICAgIC8vICgjNDgxNSlcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAvLyBzb21lIGVudnMgbW9jayB3aW5kb3cgYnV0IG5vdCBmdWxseVxuICAgICAgICB3aW5kb3cuSFRNTEVsZW1lbnQgJiZcbiAgICAgICAgLy8gYWxzbyBleGNsdWRlIGpzZG9tXG4gICAgICAgICEoKF9iID0gKF9hID0gd2luZG93Lm5hdmlnYXRvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVzZXJBZ2VudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmluY2x1ZGVzKCdqc2RvbScpKSkge1xuICAgICAgICBjb25zdCByZXBsYXkgPSAodGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18gPVxuICAgICAgICAgICAgdGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18gfHwgW10pO1xuICAgICAgICByZXBsYXkucHVzaCgobmV3SG9vaykgPT4ge1xuICAgICAgICAgICAgc2V0RGV2dG9vbHNIb29rKG5ld0hvb2ssIHRhcmdldCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBjbGVhciBidWZmZXIgYWZ0ZXIgM3MgLSB0aGUgdXNlciBwcm9iYWJseSBkb2Vzbid0IGhhdmUgZGV2dG9vbHMgaW5zdGFsbGVkXG4gICAgICAgIC8vIGF0IGFsbCwgYW5kIGtlZXBpbmcgdGhlIGJ1ZmZlciB3aWxsIGNhdXNlIG1lbW9yeSBsZWFrcyAoIzQ3MzgpXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFkZXZ0b29scykge1xuICAgICAgICAgICAgICAgIHRhcmdldC5fX1ZVRV9ERVZUT09MU19IT09LX1JFUExBWV9fID0gbnVsbDtcbiAgICAgICAgICAgICAgICBkZXZ0b29sc05vdEluc3RhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnVmZmVyID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDMwMDApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gbm9uLWJyb3dzZXIgZW52LCBhc3N1bWUgbm90IGluc3RhbGxlZFxuICAgICAgICBkZXZ0b29sc05vdEluc3RhbGxlZCA9IHRydWU7XG4gICAgICAgIGJ1ZmZlciA9IFtdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRldnRvb2xzSW5pdEFwcChhcHAsIHZlcnNpb24pIHtcbiAgICBlbWl0KFwiYXBwOmluaXRcIiAvKiBEZXZ0b29sc0hvb2tzLkFQUF9JTklUICovLCBhcHAsIHZlcnNpb24sIHtcbiAgICAgICAgRnJhZ21lbnQsXG4gICAgICAgIFRleHQsXG4gICAgICAgIENvbW1lbnQsXG4gICAgICAgIFN0YXRpY1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZGV2dG9vbHNVbm1vdW50QXBwKGFwcCkge1xuICAgIGVtaXQoXCJhcHA6dW5tb3VudFwiIC8qIERldnRvb2xzSG9va3MuQVBQX1VOTU9VTlQgKi8sIGFwcCk7XG59XG5jb25zdCBkZXZ0b29sc0NvbXBvbmVudEFkZGVkID0gLyojX19QVVJFX18qLyBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soXCJjb21wb25lbnQ6YWRkZWRcIiAvKiBEZXZ0b29sc0hvb2tzLkNPTVBPTkVOVF9BRERFRCAqLyk7XG5jb25zdCBkZXZ0b29sc0NvbXBvbmVudFVwZGF0ZWQgPSBcbi8qI19fUFVSRV9fKi8gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKFwiY29tcG9uZW50OnVwZGF0ZWRcIiAvKiBEZXZ0b29sc0hvb2tzLkNPTVBPTkVOVF9VUERBVEVEICovKTtcbmNvbnN0IF9kZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcImNvbXBvbmVudDpyZW1vdmVkXCIgLyogRGV2dG9vbHNIb29rcy5DT01QT05FTlRfUkVNT1ZFRCAqLyk7XG5jb25zdCBkZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQgPSAoY29tcG9uZW50KSA9PiB7XG4gICAgaWYgKGRldnRvb2xzICYmXG4gICAgICAgIHR5cGVvZiBkZXZ0b29scy5jbGVhbnVwQnVmZmVyID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgY29tcG9uZW50IGlmIGl0IHdhc24ndCBidWZmZXJlZFxuICAgICAgICAhZGV2dG9vbHMuY2xlYW51cEJ1ZmZlcihjb21wb25lbnQpKSB7XG4gICAgICAgIF9kZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQoY29tcG9uZW50KTtcbiAgICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKGhvb2spIHtcbiAgICByZXR1cm4gKGNvbXBvbmVudCkgPT4ge1xuICAgICAgICBlbWl0KGhvb2ssIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCwgY29tcG9uZW50LnVpZCwgY29tcG9uZW50LnBhcmVudCA/IGNvbXBvbmVudC5wYXJlbnQudWlkIDogdW5kZWZpbmVkLCBjb21wb25lbnQpO1xuICAgIH07XG59XG5jb25zdCBkZXZ0b29sc1BlcmZTdGFydCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlRGV2dG9vbHNQZXJmb3JtYW5jZUhvb2soXCJwZXJmOnN0YXJ0XCIgLyogRGV2dG9vbHNIb29rcy5QRVJGT1JNQU5DRV9TVEFSVCAqLyk7XG5jb25zdCBkZXZ0b29sc1BlcmZFbmQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZURldnRvb2xzUGVyZm9ybWFuY2VIb29rKFwicGVyZjplbmRcIiAvKiBEZXZ0b29sc0hvb2tzLlBFUkZPUk1BTkNFX0VORCAqLyk7XG5mdW5jdGlvbiBjcmVhdGVEZXZ0b29sc1BlcmZvcm1hbmNlSG9vayhob29rKSB7XG4gICAgcmV0dXJuIChjb21wb25lbnQsIHR5cGUsIHRpbWUpID0+IHtcbiAgICAgICAgZW1pdChob29rLCBjb21wb25lbnQuYXBwQ29udGV4dC5hcHAsIGNvbXBvbmVudC51aWQsIGNvbXBvbmVudCwgdHlwZSwgdGltZSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGRldnRvb2xzQ29tcG9uZW50RW1pdChjb21wb25lbnQsIGV2ZW50LCBwYXJhbXMpIHtcbiAgICBlbWl0KFwiY29tcG9uZW50OmVtaXRcIiAvKiBEZXZ0b29sc0hvb2tzLkNPTVBPTkVOVF9FTUlUICovLCBjb21wb25lbnQuYXBwQ29udGV4dC5hcHAsIGNvbXBvbmVudCwgZXZlbnQsIHBhcmFtcyk7XG59XG5cbmZ1bmN0aW9uIGVtaXQkMShpbnN0YW5jZSwgZXZlbnQsIC4uLnJhd0FyZ3MpIHtcbiAgICBpZiAoaW5zdGFuY2UuaXNVbm1vdW50ZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBwcm9wcyA9IGluc3RhbmNlLnZub2RlLnByb3BzIHx8IEVNUFRZX09CSjtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIGNvbnN0IHsgZW1pdHNPcHRpb25zLCBwcm9wc09wdGlvbnM6IFtwcm9wc09wdGlvbnNdIH0gPSBpbnN0YW5jZTtcbiAgICAgICAgaWYgKGVtaXRzT3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCEoZXZlbnQgaW4gZW1pdHNPcHRpb25zKSAmJlxuICAgICAgICAgICAgICAgICEoZmFsc2UgKSkge1xuICAgICAgICAgICAgICAgIGlmICghcHJvcHNPcHRpb25zIHx8ICEodG9IYW5kbGVyS2V5KGV2ZW50KSBpbiBwcm9wc09wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYENvbXBvbmVudCBlbWl0dGVkIGV2ZW50IFwiJHtldmVudH1cIiBidXQgaXQgaXMgbmVpdGhlciBkZWNsYXJlZCBpbiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGB0aGUgZW1pdHMgb3B0aW9uIG5vciBhcyBhbiBcIiR7dG9IYW5kbGVyS2V5KGV2ZW50KX1cIiBwcm9wLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IGVtaXRzT3B0aW9uc1tldmVudF07XG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsaWRhdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gdmFsaWRhdG9yKC4uLnJhd0FyZ3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEludmFsaWQgZXZlbnQgYXJndW1lbnRzOiBldmVudCB2YWxpZGF0aW9uIGZhaWxlZCBmb3IgZXZlbnQgXCIke2V2ZW50fVwiLmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBhcmdzID0gcmF3QXJncztcbiAgICBjb25zdCBpc01vZGVsTGlzdGVuZXIgPSBldmVudC5zdGFydHNXaXRoKCd1cGRhdGU6Jyk7XG4gICAgLy8gZm9yIHYtbW9kZWwgdXBkYXRlOnh4eCBldmVudHMsIGFwcGx5IG1vZGlmaWVycyBvbiBhcmdzXG4gICAgY29uc3QgbW9kZWxBcmcgPSBpc01vZGVsTGlzdGVuZXIgJiYgZXZlbnQuc2xpY2UoNyk7XG4gICAgaWYgKG1vZGVsQXJnICYmIG1vZGVsQXJnIGluIHByb3BzKSB7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVyc0tleSA9IGAke21vZGVsQXJnID09PSAnbW9kZWxWYWx1ZScgPyAnbW9kZWwnIDogbW9kZWxBcmd9TW9kaWZpZXJzYDtcbiAgICAgICAgY29uc3QgeyBudW1iZXIsIHRyaW0gfSA9IHByb3BzW21vZGlmaWVyc0tleV0gfHwgRU1QVFlfT0JKO1xuICAgICAgICBpZiAodHJpbSkge1xuICAgICAgICAgICAgYXJncyA9IHJhd0FyZ3MubWFwKGEgPT4gKGlzU3RyaW5nKGEpID8gYS50cmltKCkgOiBhKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bWJlcikge1xuICAgICAgICAgICAgYXJncyA9IHJhd0FyZ3MubWFwKHRvTnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEVtaXQoaW5zdGFuY2UsIGV2ZW50LCBhcmdzKTtcbiAgICB9XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICBjb25zdCBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgcHJvcHNbdG9IYW5kbGVyS2V5KGxvd2VyQ2FzZUV2ZW50KV0pIHtcbiAgICAgICAgICAgIHdhcm4oYEV2ZW50IFwiJHtsb3dlckNhc2VFdmVudH1cIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBgICtcbiAgICAgICAgICAgICAgICBgJHtmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCBpbnN0YW5jZS50eXBlKX0gYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFwiJHtldmVudH1cIi4gYCArXG4gICAgICAgICAgICAgICAgYE5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIGAgK1xuICAgICAgICAgICAgICAgIGB2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gYCArXG4gICAgICAgICAgICAgICAgYFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFwiJHtoeXBoZW5hdGUoZXZlbnQpfVwiIGluc3RlYWQgb2YgXCIke2V2ZW50fVwiLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBoYW5kbGVyTmFtZTtcbiAgICBsZXQgaGFuZGxlciA9IHByb3BzWyhoYW5kbGVyTmFtZSA9IHRvSGFuZGxlcktleShldmVudCkpXSB8fFxuICAgICAgICAvLyBhbHNvIHRyeSBjYW1lbENhc2UgZXZlbnQgaGFuZGxlciAoIzIyNDkpXG4gICAgICAgIHByb3BzWyhoYW5kbGVyTmFtZSA9IHRvSGFuZGxlcktleShjYW1lbGl6ZShldmVudCkpKV07XG4gICAgLy8gZm9yIHYtbW9kZWwgdXBkYXRlOnh4eCBldmVudHMsIGFsc28gdHJpZ2dlciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRcbiAgICAvLyBmb3IgcHJvcHMgcGFzc2VkIHZpYSBrZWJhYi1jYXNlXG4gICAgaWYgKCFoYW5kbGVyICYmIGlzTW9kZWxMaXN0ZW5lcikge1xuICAgICAgICBoYW5kbGVyID0gcHJvcHNbKGhhbmRsZXJOYW1lID0gdG9IYW5kbGVyS2V5KGh5cGhlbmF0ZShldmVudCkpKV07XG4gICAgfVxuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhhbmRsZXIsIGluc3RhbmNlLCA2IC8qIEVycm9yQ29kZXMuQ09NUE9ORU5UX0VWRU5UX0hBTkRMRVIgKi8sIGFyZ3MpO1xuICAgIH1cbiAgICBjb25zdCBvbmNlSGFuZGxlciA9IHByb3BzW2hhbmRsZXJOYW1lICsgYE9uY2VgXTtcbiAgICBpZiAob25jZUhhbmRsZXIpIHtcbiAgICAgICAgaWYgKCFpbnN0YW5jZS5lbWl0dGVkKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5lbWl0dGVkID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5zdGFuY2UuZW1pdHRlZFtoYW5kbGVyTmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5lbWl0dGVkW2hhbmRsZXJOYW1lXSA9IHRydWU7XG4gICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKG9uY2VIYW5kbGVyLCBpbnN0YW5jZSwgNiAvKiBFcnJvckNvZGVzLkNPTVBPTkVOVF9FVkVOVF9IQU5ETEVSICovLCBhcmdzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVFbWl0c09wdGlvbnMoY29tcCwgYXBwQ29udGV4dCwgYXNNaXhpbiA9IGZhbHNlKSB7XG4gICAgY29uc3QgY2FjaGUgPSBhcHBDb250ZXh0LmVtaXRzQ2FjaGU7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGNvbXApO1xuICAgIGlmIChjYWNoZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cbiAgICBjb25zdCByYXcgPSBjb21wLmVtaXRzO1xuICAgIGxldCBub3JtYWxpemVkID0ge307XG4gICAgLy8gYXBwbHkgbWl4aW4vZXh0ZW5kcyBwcm9wc1xuICAgIGxldCBoYXNFeHRlbmRzID0gZmFsc2U7XG4gICAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18gJiYgIWlzRnVuY3Rpb24oY29tcCkpIHtcbiAgICAgICAgY29uc3QgZXh0ZW5kRW1pdHMgPSAocmF3KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkRnJvbUV4dGVuZCA9IG5vcm1hbGl6ZUVtaXRzT3B0aW9ucyhyYXcsIGFwcENvbnRleHQsIHRydWUpO1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRGcm9tRXh0ZW5kKSB7XG4gICAgICAgICAgICAgICAgaGFzRXh0ZW5kcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXh0ZW5kKG5vcm1hbGl6ZWQsIG5vcm1hbGl6ZWRGcm9tRXh0ZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFhc01peGluICYmIGFwcENvbnRleHQubWl4aW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgYXBwQ29udGV4dC5taXhpbnMuZm9yRWFjaChleHRlbmRFbWl0cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXAuZXh0ZW5kcykge1xuICAgICAgICAgICAgZXh0ZW5kRW1pdHMoY29tcC5leHRlbmRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcC5taXhpbnMpIHtcbiAgICAgICAgICAgIGNvbXAubWl4aW5zLmZvckVhY2goZXh0ZW5kRW1pdHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghcmF3ICYmICFoYXNFeHRlbmRzKSB7XG4gICAgICAgIGlmIChpc09iamVjdChjb21wKSkge1xuICAgICAgICAgICAgY2FjaGUuc2V0KGNvbXAsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoaXNBcnJheShyYXcpKSB7XG4gICAgICAgIHJhdy5mb3JFYWNoKGtleSA9PiAobm9ybWFsaXplZFtrZXldID0gbnVsbCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZXh0ZW5kKG5vcm1hbGl6ZWQsIHJhdyk7XG4gICAgfVxuICAgIGlmIChpc09iamVjdChjb21wKSkge1xuICAgICAgICBjYWNoZS5zZXQoY29tcCwgbm9ybWFsaXplZCk7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVkO1xufVxuLy8gQ2hlY2sgaWYgYW4gaW5jb21pbmcgcHJvcCBrZXkgaXMgYSBkZWNsYXJlZCBlbWl0IGV2ZW50IGxpc3RlbmVyLlxuLy8gZS5nLiBXaXRoIGBlbWl0czogeyBjbGljazogbnVsbCB9YCwgcHJvcHMgbmFtZWQgYG9uQ2xpY2tgIGFuZCBgb25jbGlja2AgYXJlXG4vLyBib3RoIGNvbnNpZGVyZWQgbWF0Y2hlZCBsaXN0ZW5lcnMuXG5mdW5jdGlvbiBpc0VtaXRMaXN0ZW5lcihvcHRpb25zLCBrZXkpIHtcbiAgICBpZiAoIW9wdGlvbnMgfHwgIWlzT24oa2V5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGtleSA9IGtleS5zbGljZSgyKS5yZXBsYWNlKC9PbmNlJC8sICcnKTtcbiAgICByZXR1cm4gKGhhc093bihvcHRpb25zLCBrZXlbMF0udG9Mb3dlckNhc2UoKSArIGtleS5zbGljZSgxKSkgfHxcbiAgICAgICAgaGFzT3duKG9wdGlvbnMsIGh5cGhlbmF0ZShrZXkpKSB8fFxuICAgICAgICBoYXNPd24ob3B0aW9ucywga2V5KSk7XG59XG5cbi8qKlxuICogbWFyayB0aGUgY3VycmVudCByZW5kZXJpbmcgaW5zdGFuY2UgZm9yIGFzc2V0IHJlc29sdXRpb24gKGUuZy5cbiAqIHJlc29sdmVDb21wb25lbnQsIHJlc29sdmVEaXJlY3RpdmUpIGR1cmluZyByZW5kZXJcbiAqL1xubGV0IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XG5sZXQgY3VycmVudFNjb3BlSWQgPSBudWxsO1xuLyoqXG4gKiBOb3RlOiByZW5kZXJpbmcgY2FsbHMgbWF5YmUgbmVzdGVkLiBUaGUgZnVuY3Rpb24gcmV0dXJucyB0aGUgcGFyZW50IHJlbmRlcmluZ1xuICogaW5zdGFuY2UgaWYgcHJlc2VudCwgd2hpY2ggc2hvdWxkIGJlIHJlc3RvcmVkIGFmdGVyIHRoZSByZW5kZXIgaXMgZG9uZTpcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgcHJldiA9IHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShpKVxuICogLy8gLi4ucmVuZGVyXG4gKiBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UocHJldilcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgICBjb25zdCBwcmV2ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgIGN1cnJlbnRTY29wZUlkID0gKGluc3RhbmNlICYmIGluc3RhbmNlLnR5cGUuX19zY29wZUlkKSB8fCBudWxsO1xuICAgIHJldHVybiBwcmV2O1xufVxuLyoqXG4gKiBTZXQgc2NvcGUgaWQgd2hlbiBjcmVhdGluZyBob2lzdGVkIHZub2Rlcy5cbiAqIEBwcml2YXRlIGNvbXBpbGVyIGhlbHBlclxuICovXG5mdW5jdGlvbiBwdXNoU2NvcGVJZChpZCkge1xuICAgIGN1cnJlbnRTY29wZUlkID0gaWQ7XG59XG4vKipcbiAqIFRlY2huaWNhbGx5IHdlIG5vIGxvbmdlciBuZWVkIHRoaXMgYWZ0ZXIgMy4wLjggYnV0IHdlIG5lZWQgdG8ga2VlcCB0aGUgc2FtZVxuICogQVBJIGZvciBiYWNrd2FyZHMgY29tcGF0IHcvIGNvZGUgZ2VuZXJhdGVkIGJ5IGNvbXBpbGVycy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHBvcFNjb3BlSWQoKSB7XG4gICAgY3VycmVudFNjb3BlSWQgPSBudWxsO1xufVxuLyoqXG4gKiBPbmx5IGZvciBiYWNrd2FyZHMgY29tcGF0XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCB3aXRoU2NvcGVJZCA9IChfaWQpID0+IHdpdGhDdHg7XG4vKipcbiAqIFdyYXAgYSBzbG90IGZ1bmN0aW9uIHRvIG1lbW9pemUgY3VycmVudCByZW5kZXJpbmcgaW5zdGFuY2VcbiAqIEBwcml2YXRlIGNvbXBpbGVyIGhlbHBlclxuICovXG5mdW5jdGlvbiB3aXRoQ3R4KGZuLCBjdHggPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UsIGlzTm9uU2NvcGVkU2xvdCAvLyBmYWxzZSBvbmx5XG4pIHtcbiAgICBpZiAoIWN0eClcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgIC8vIGFscmVhZHkgbm9ybWFsaXplZFxuICAgIGlmIChmbi5fbikge1xuICAgICAgICByZXR1cm4gZm47XG4gICAgfVxuICAgIGNvbnN0IHJlbmRlckZuV2l0aENvbnRleHQgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAvLyBJZiBhIHVzZXIgY2FsbHMgYSBjb21waWxlZCBzbG90IGluc2lkZSBhIHRlbXBsYXRlIGV4cHJlc3Npb24gKCMxNzQ1KSwgaXRcbiAgICAgICAgLy8gY2FuIG1lc3MgdXAgYmxvY2sgdHJhY2tpbmcsIHNvIGJ5IGRlZmF1bHQgd2UgZGlzYWJsZSBibG9jayB0cmFja2luZyBhbmRcbiAgICAgICAgLy8gZm9yY2UgYmFpbCBvdXQgd2hlbiBpbnZva2luZyBhIGNvbXBpbGVkIHNsb3QgKGluZGljYXRlZCBieSB0aGUgLl9kIGZsYWcpLlxuICAgICAgICAvLyBUaGlzIGlzbid0IG5lY2Vzc2FyeSBpZiByZW5kZXJpbmcgYSBjb21waWxlZCBgPHNsb3Q+YCwgc28gd2UgZmxpcCB0aGVcbiAgICAgICAgLy8gLl9kIGZsYWcgb2ZmIHdoZW4gaW52b2tpbmcgdGhlIHdyYXBwZWQgZm4gaW5zaWRlIGByZW5kZXJTbG90YC5cbiAgICAgICAgaWYgKHJlbmRlckZuV2l0aENvbnRleHQuX2QpIHtcbiAgICAgICAgICAgIHNldEJsb2NrVHJhY2tpbmcoLTEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZJbnN0YW5jZSA9IHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShjdHgpO1xuICAgICAgICBsZXQgcmVzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzID0gZm4oLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UocHJldkluc3RhbmNlKTtcbiAgICAgICAgICAgIGlmIChyZW5kZXJGbldpdGhDb250ZXh0Ll9kKSB7XG4gICAgICAgICAgICAgICAgc2V0QmxvY2tUcmFja2luZygxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRVcGRhdGVkKGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIC8vIG1hcmsgbm9ybWFsaXplZCB0byBhdm9pZCBkdXBsaWNhdGVkIHdyYXBwaW5nXG4gICAgcmVuZGVyRm5XaXRoQ29udGV4dC5fbiA9IHRydWU7XG4gICAgLy8gbWFyayB0aGlzIGFzIGNvbXBpbGVkIGJ5IGRlZmF1bHRcbiAgICAvLyB0aGlzIGlzIHVzZWQgaW4gdm5vZGUudHMgLT4gbm9ybWFsaXplQ2hpbGRyZW4oKSB0byBzZXQgdGhlIHNsb3RcbiAgICAvLyByZW5kZXJpbmcgZmxhZy5cbiAgICByZW5kZXJGbldpdGhDb250ZXh0Ll9jID0gdHJ1ZTtcbiAgICAvLyBkaXNhYmxlIGJsb2NrIHRyYWNraW5nIGJ5IGRlZmF1bHRcbiAgICByZW5kZXJGbldpdGhDb250ZXh0Ll9kID0gdHJ1ZTtcbiAgICByZXR1cm4gcmVuZGVyRm5XaXRoQ29udGV4dDtcbn1cblxuLyoqXG4gKiBkZXYgb25seSBmbGFnIHRvIHRyYWNrIHdoZXRoZXIgJGF0dHJzIHdhcyB1c2VkIGR1cmluZyByZW5kZXIuXG4gKiBJZiAkYXR0cnMgd2FzIHVzZWQgZHVyaW5nIHJlbmRlciB0aGVuIHRoZSB3YXJuaW5nIGZvciBmYWlsZWQgYXR0cnNcbiAqIGZhbGx0aHJvdWdoIGNhbiBiZSBzdXBwcmVzc2VkLlxuICovXG5sZXQgYWNjZXNzZWRBdHRycyA9IGZhbHNlO1xuZnVuY3Rpb24gbWFya0F0dHJzQWNjZXNzZWQoKSB7XG4gICAgYWNjZXNzZWRBdHRycyA9IHRydWU7XG59XG5mdW5jdGlvbiByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKSB7XG4gICAgY29uc3QgeyB0eXBlOiBDb21wb25lbnQsIHZub2RlLCBwcm94eSwgd2l0aFByb3h5LCBwcm9wcywgcHJvcHNPcHRpb25zOiBbcHJvcHNPcHRpb25zXSwgc2xvdHMsIGF0dHJzLCBlbWl0LCByZW5kZXIsIHJlbmRlckNhY2hlLCBkYXRhLCBzZXR1cFN0YXRlLCBjdHgsIGluaGVyaXRBdHRycyB9ID0gaW5zdGFuY2U7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBsZXQgZmFsbHRocm91Z2hBdHRycztcbiAgICBjb25zdCBwcmV2ID0gc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKGluc3RhbmNlKTtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIGFjY2Vzc2VkQXR0cnMgPSBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDQgLyogU2hhcGVGbGFncy5TVEFURUZVTF9DT01QT05FTlQgKi8pIHtcbiAgICAgICAgICAgIC8vIHdpdGhQcm94eSBpcyBhIHByb3h5IHdpdGggYSBkaWZmZXJlbnQgYGhhc2AgdHJhcCBvbmx5IGZvclxuICAgICAgICAgICAgLy8gcnVudGltZS1jb21waWxlZCByZW5kZXIgZnVuY3Rpb25zIHVzaW5nIGB3aXRoYCBibG9jay5cbiAgICAgICAgICAgIGNvbnN0IHByb3h5VG9Vc2UgPSB3aXRoUHJveHkgfHwgcHJveHk7XG4gICAgICAgICAgICByZXN1bHQgPSBub3JtYWxpemVWTm9kZShyZW5kZXIuY2FsbChwcm94eVRvVXNlLCBwcm94eVRvVXNlLCByZW5kZXJDYWNoZSwgcHJvcHMsIHNldHVwU3RhdGUsIGRhdGEsIGN0eCkpO1xuICAgICAgICAgICAgZmFsbHRocm91Z2hBdHRycyA9IGF0dHJzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZnVuY3Rpb25hbFxuICAgICAgICAgICAgY29uc3QgcmVuZGVyID0gQ29tcG9uZW50O1xuICAgICAgICAgICAgLy8gaW4gZGV2LCBtYXJrIGF0dHJzIGFjY2Vzc2VkIGlmIG9wdGlvbmFsIHByb3BzIChhdHRycyA9PT0gcHJvcHMpXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGF0dHJzID09PSBwcm9wcykge1xuICAgICAgICAgICAgICAgIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSBub3JtYWxpemVWTm9kZShyZW5kZXIubGVuZ3RoID4gMVxuICAgICAgICAgICAgICAgID8gcmVuZGVyKHByb3BzLCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgYXR0cnMoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya0F0dHJzQWNjZXNzZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiB7IGF0dHJzLCBzbG90cywgZW1pdCB9KVxuICAgICAgICAgICAgICAgIDogcmVuZGVyKHByb3BzLCBudWxsIC8qIHdlIGtub3cgaXQgZG9lc24ndCBuZWVkIGl0ICovKSk7XG4gICAgICAgICAgICBmYWxsdGhyb3VnaEF0dHJzID0gQ29tcG9uZW50LnByb3BzXG4gICAgICAgICAgICAgICAgPyBhdHRyc1xuICAgICAgICAgICAgICAgIDogZ2V0RnVuY3Rpb25hbEZhbGx0aHJvdWdoKGF0dHJzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGJsb2NrU3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgMSAvKiBFcnJvckNvZGVzLlJFTkRFUl9GVU5DVElPTiAqLyk7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xuICAgIH1cbiAgICAvLyBhdHRyIG1lcmdpbmdcbiAgICAvLyBpbiBkZXYgbW9kZSwgY29tbWVudHMgYXJlIHByZXNlcnZlZCwgYW5kIGl0J3MgcG9zc2libGUgZm9yIGEgdGVtcGxhdGVcbiAgICAvLyB0byBoYXZlIGNvbW1lbnRzIGFsb25nIHNpZGUgdGhlIHJvb3QgZWxlbWVudCB3aGljaCBtYWtlcyBpdCBhIGZyYWdtZW50XG4gICAgbGV0IHJvb3QgPSByZXN1bHQ7XG4gICAgbGV0IHNldFJvb3QgPSB1bmRlZmluZWQ7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICByZXN1bHQucGF0Y2hGbGFnID4gMCAmJlxuICAgICAgICByZXN1bHQucGF0Y2hGbGFnICYgMjA0OCAvKiBQYXRjaEZsYWdzLkRFVl9ST09UX0ZSQUdNRU5UICovKSB7XG4gICAgICAgIFtyb290LCBzZXRSb290XSA9IGdldENoaWxkUm9vdChyZXN1bHQpO1xuICAgIH1cbiAgICBpZiAoZmFsbHRocm91Z2hBdHRycyAmJiBpbmhlcml0QXR0cnMgIT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhmYWxsdGhyb3VnaEF0dHJzKTtcbiAgICAgICAgY29uc3QgeyBzaGFwZUZsYWcgfSA9IHJvb3Q7XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmICgxIC8qIFNoYXBlRmxhZ3MuRUxFTUVOVCAqLyB8IDYgLyogU2hhcGVGbGFncy5DT01QT05FTlQgKi8pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzT3B0aW9ucyAmJiBrZXlzLnNvbWUoaXNNb2RlbExpc3RlbmVyKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIHYtbW9kZWwgbGlzdGVuZXIgKG9uVXBkYXRlOnh4eCkgaGFzIGEgY29ycmVzcG9uZGluZyBkZWNsYXJlZFxuICAgICAgICAgICAgICAgICAgICAvLyBwcm9wLCBpdCBpbmRpY2F0ZXMgdGhpcyBjb21wb25lbnQgZXhwZWN0cyB0byBoYW5kbGUgdi1tb2RlbCBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgc2hvdWxkIG5vdCBmYWxsdGhyb3VnaC5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVsYXRlZDogIzE1NDMsICMxNjQzLCAjMTk4OVxuICAgICAgICAgICAgICAgICAgICBmYWxsdGhyb3VnaEF0dHJzID0gZmlsdGVyTW9kZWxMaXN0ZW5lcnMoZmFsbHRocm91Z2hBdHRycywgcHJvcHNPcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcm9vdCA9IGNsb25lVk5vZGUocm9vdCwgZmFsbHRocm91Z2hBdHRycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWFjY2Vzc2VkQXR0cnMgJiYgcm9vdC50eXBlICE9PSBDb21tZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxsQXR0cnMgPSBPYmplY3Qua2V5cyhhdHRycyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnRBdHRycyA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4dHJhQXR0cnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGFsbEF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBhbGxBdHRyc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzT24oa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIHYtbW9kZWwgaGFuZGxlcnMgd2hlbiB0aGV5IGZhaWwgdG8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNNb2RlbExpc3RlbmVyKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgYG9uYCwgbG93ZXJjYXNlIGZpcnN0IGxldHRlciB0byByZWZsZWN0IGV2ZW50IGNhc2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFjY3VyYXRlbHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudEF0dHJzLnB1c2goa2V5WzJdLnRvTG93ZXJDYXNlKCkgKyBrZXkuc2xpY2UoMykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFBdHRycy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhQXR0cnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEV4dHJhbmVvdXMgbm9uLXByb3BzIGF0dHJpYnV0ZXMgKGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCR7ZXh0cmFBdHRycy5qb2luKCcsICcpfSkgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgd2VyZSBwYXNzZWQgdG8gY29tcG9uZW50IGJ1dCBjb3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBpbmhlcml0ZWQgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgYmVjYXVzZSBjb21wb25lbnQgcmVuZGVycyBmcmFnbWVudCBvciB0ZXh0IHJvb3Qgbm9kZXMuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChldmVudEF0dHJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKGBFeHRyYW5lb3VzIG5vbi1lbWl0cyBldmVudCBsaXN0ZW5lcnMgKGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCR7ZXZlbnRBdHRycy5qb2luKCcsICcpfSkgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgd2VyZSBwYXNzZWQgdG8gY29tcG9uZW50IGJ1dCBjb3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBpbmhlcml0ZWQgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgYmVjYXVzZSBjb21wb25lbnQgcmVuZGVycyBmcmFnbWVudCBvciB0ZXh0IHJvb3Qgbm9kZXMuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYElmIHRoZSBsaXN0ZW5lciBpcyBpbnRlbmRlZCB0byBiZSBhIGNvbXBvbmVudCBjdXN0b20gZXZlbnQgbGlzdGVuZXIgb25seSwgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgZGVjbGFyZSBpdCB1c2luZyB0aGUgXCJlbWl0c1wiIG9wdGlvbi5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gaW5oZXJpdCBkaXJlY3RpdmVzXG4gICAgaWYgKHZub2RlLmRpcnMpIHtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNFbGVtZW50Um9vdChyb290KSkge1xuICAgICAgICAgICAgd2FybihgUnVudGltZSBkaXJlY3RpdmUgdXNlZCBvbiBjb21wb25lbnQgd2l0aCBub24tZWxlbWVudCByb290IG5vZGUuIGAgK1xuICAgICAgICAgICAgICAgIGBUaGUgZGlyZWN0aXZlcyB3aWxsIG5vdCBmdW5jdGlvbiBhcyBpbnRlbmRlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjbG9uZSBiZWZvcmUgbXV0YXRpbmcgc2luY2UgdGhlIHJvb3QgbWF5IGJlIGEgaG9pc3RlZCB2bm9kZVxuICAgICAgICByb290ID0gY2xvbmVWTm9kZShyb290KTtcbiAgICAgICAgcm9vdC5kaXJzID0gcm9vdC5kaXJzID8gcm9vdC5kaXJzLmNvbmNhdCh2bm9kZS5kaXJzKSA6IHZub2RlLmRpcnM7XG4gICAgfVxuICAgIC8vIGluaGVyaXQgdHJhbnNpdGlvbiBkYXRhXG4gICAgaWYgKHZub2RlLnRyYW5zaXRpb24pIHtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNFbGVtZW50Um9vdChyb290KSkge1xuICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IGluc2lkZSA8VHJhbnNpdGlvbj4gcmVuZGVycyBub24tZWxlbWVudCByb290IG5vZGUgYCArXG4gICAgICAgICAgICAgICAgYHRoYXQgY2Fubm90IGJlIGFuaW1hdGVkLmApO1xuICAgICAgICB9XG4gICAgICAgIHJvb3QudHJhbnNpdGlvbiA9IHZub2RlLnRyYW5zaXRpb247XG4gICAgfVxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgc2V0Um9vdCkge1xuICAgICAgICBzZXRSb290KHJvb3QpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gcm9vdDtcbiAgICB9XG4gICAgc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKHByZXYpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIGRldiBvbmx5XG4gKiBJbiBkZXYgbW9kZSwgdGVtcGxhdGUgcm9vdCBsZXZlbCBjb21tZW50cyBhcmUgcmVuZGVyZWQsIHdoaWNoIHR1cm5zIHRoZVxuICogdGVtcGxhdGUgaW50byBhIGZyYWdtZW50IHJvb3QsIGJ1dCB3ZSBuZWVkIHRvIGxvY2F0ZSB0aGUgc2luZ2xlIGVsZW1lbnRcbiAqIHJvb3QgZm9yIGF0dHJzIGFuZCBzY29wZSBpZCBwcm9jZXNzaW5nLlxuICovXG5jb25zdCBnZXRDaGlsZFJvb3QgPSAodm5vZGUpID0+IHtcbiAgICBjb25zdCByYXdDaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGNvbnN0IGR5bmFtaWNDaGlsZHJlbiA9IHZub2RlLmR5bmFtaWNDaGlsZHJlbjtcbiAgICBjb25zdCBjaGlsZFJvb3QgPSBmaWx0ZXJTaW5nbGVSb290KHJhd0NoaWxkcmVuKTtcbiAgICBpZiAoIWNoaWxkUm9vdCkge1xuICAgICAgICByZXR1cm4gW3Zub2RlLCB1bmRlZmluZWRdO1xuICAgIH1cbiAgICBjb25zdCBpbmRleCA9IHJhd0NoaWxkcmVuLmluZGV4T2YoY2hpbGRSb290KTtcbiAgICBjb25zdCBkeW5hbWljSW5kZXggPSBkeW5hbWljQ2hpbGRyZW4gPyBkeW5hbWljQ2hpbGRyZW4uaW5kZXhPZihjaGlsZFJvb3QpIDogLTE7XG4gICAgY29uc3Qgc2V0Um9vdCA9ICh1cGRhdGVkUm9vdCkgPT4ge1xuICAgICAgICByYXdDaGlsZHJlbltpbmRleF0gPSB1cGRhdGVkUm9vdDtcbiAgICAgICAgaWYgKGR5bmFtaWNDaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGR5bmFtaWNJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgZHluYW1pY0NoaWxkcmVuW2R5bmFtaWNJbmRleF0gPSB1cGRhdGVkUm9vdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVwZGF0ZWRSb290LnBhdGNoRmxhZyA+IDApIHtcbiAgICAgICAgICAgICAgICB2bm9kZS5keW5hbWljQ2hpbGRyZW4gPSBbLi4uZHluYW1pY0NoaWxkcmVuLCB1cGRhdGVkUm9vdF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBbbm9ybWFsaXplVk5vZGUoY2hpbGRSb290KSwgc2V0Um9vdF07XG59O1xuZnVuY3Rpb24gZmlsdGVyU2luZ2xlUm9vdChjaGlsZHJlbikge1xuICAgIGxldCBzaW5nbGVSb290O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKGlzVk5vZGUoY2hpbGQpKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgdXNlciBjb21tZW50XG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gQ29tbWVudCB8fCBjaGlsZC5jaGlsZHJlbiA9PT0gJ3YtaWYnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZVJvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFzIG1vcmUgdGhhbiAxIG5vbi1jb21tZW50IGNoaWxkLCByZXR1cm4gbm93XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZVJvb3QgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNpbmdsZVJvb3Q7XG59XG5jb25zdCBnZXRGdW5jdGlvbmFsRmFsbHRocm91Z2ggPSAoYXR0cnMpID0+IHtcbiAgICBsZXQgcmVzO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XG4gICAgICAgIGlmIChrZXkgPT09ICdjbGFzcycgfHwga2V5ID09PSAnc3R5bGUnIHx8IGlzT24oa2V5KSkge1xuICAgICAgICAgICAgKHJlcyB8fCAocmVzID0ge30pKVtrZXldID0gYXR0cnNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcbmNvbnN0IGZpbHRlck1vZGVsTGlzdGVuZXJzID0gKGF0dHJzLCBwcm9wcykgPT4ge1xuICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XG4gICAgICAgIGlmICghaXNNb2RlbExpc3RlbmVyKGtleSkgfHwgIShrZXkuc2xpY2UoOSkgaW4gcHJvcHMpKSB7XG4gICAgICAgICAgICByZXNba2V5XSA9IGF0dHJzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn07XG5jb25zdCBpc0VsZW1lbnRSb290ID0gKHZub2RlKSA9PiB7XG4gICAgcmV0dXJuICh2bm9kZS5zaGFwZUZsYWcgJiAoNiAvKiBTaGFwZUZsYWdzLkNPTVBPTkVOVCAqLyB8IDEgLyogU2hhcGVGbGFncy5FTEVNRU5UICovKSB8fFxuICAgICAgICB2bm9kZS50eXBlID09PSBDb21tZW50IC8vIHBvdGVudGlhbCB2LWlmIGJyYW5jaCBzd2l0Y2hcbiAgICApO1xufTtcbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZUNvbXBvbmVudChwcmV2Vk5vZGUsIG5leHRWTm9kZSwgb3B0aW1pemVkKSB7XG4gICAgY29uc3QgeyBwcm9wczogcHJldlByb3BzLCBjaGlsZHJlbjogcHJldkNoaWxkcmVuLCBjb21wb25lbnQgfSA9IHByZXZWTm9kZTtcbiAgICBjb25zdCB7IHByb3BzOiBuZXh0UHJvcHMsIGNoaWxkcmVuOiBuZXh0Q2hpbGRyZW4sIHBhdGNoRmxhZyB9ID0gbmV4dFZOb2RlO1xuICAgIGNvbnN0IGVtaXRzID0gY29tcG9uZW50LmVtaXRzT3B0aW9ucztcbiAgICAvLyBQYXJlbnQgY29tcG9uZW50J3MgcmVuZGVyIGZ1bmN0aW9uIHdhcyBob3QtdXBkYXRlZC4gU2luY2UgdGhpcyBtYXkgaGF2ZVxuICAgIC8vIGNhdXNlZCB0aGUgY2hpbGQgY29tcG9uZW50J3Mgc2xvdHMgY29udGVudCB0byBoYXZlIGNoYW5nZWQsIHdlIG5lZWQgdG9cbiAgICAvLyBmb3JjZSB0aGUgY2hpbGQgdG8gdXBkYXRlIGFzIHdlbGwuXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAocHJldkNoaWxkcmVuIHx8IG5leHRDaGlsZHJlbikgJiYgaXNIbXJVcGRhdGluZykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gZm9yY2UgY2hpbGQgdXBkYXRlIGZvciBydW50aW1lIGRpcmVjdGl2ZSBvciB0cmFuc2l0aW9uIG9uIGNvbXBvbmVudCB2bm9kZS5cbiAgICBpZiAobmV4dFZOb2RlLmRpcnMgfHwgbmV4dFZOb2RlLnRyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChvcHRpbWl6ZWQgJiYgcGF0Y2hGbGFnID49IDApIHtcbiAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDEwMjQgLyogUGF0Y2hGbGFncy5EWU5BTUlDX1NMT1RTICovKSB7XG4gICAgICAgICAgICAvLyBzbG90IGNvbnRlbnQgdGhhdCByZWZlcmVuY2VzIHZhbHVlcyB0aGF0IG1pZ2h0IGhhdmUgY2hhbmdlZCxcbiAgICAgICAgICAgIC8vIGUuZy4gaW4gYSB2LWZvclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDE2IC8qIFBhdGNoRmxhZ3MuRlVMTF9QUk9QUyAqLykge1xuICAgICAgICAgICAgaWYgKCFwcmV2UHJvcHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFuZXh0UHJvcHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwcmVzZW5jZSBvZiB0aGlzIGZsYWcgaW5kaWNhdGVzIHByb3BzIGFyZSBhbHdheXMgbm9uLW51bGxcbiAgICAgICAgICAgIHJldHVybiBoYXNQcm9wc0NoYW5nZWQocHJldlByb3BzLCBuZXh0UHJvcHMsIGVtaXRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXRjaEZsYWcgJiA4IC8qIFBhdGNoRmxhZ3MuUFJPUFMgKi8pIHtcbiAgICAgICAgICAgIGNvbnN0IGR5bmFtaWNQcm9wcyA9IG5leHRWTm9kZS5keW5hbWljUHJvcHM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGR5bmFtaWNQcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGR5bmFtaWNQcm9wc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFByb3BzW2tleV0gIT09IHByZXZQcm9wc1trZXldICYmXG4gICAgICAgICAgICAgICAgICAgICFpc0VtaXRMaXN0ZW5lcihlbWl0cywga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHRoaXMgcGF0aCBpcyBvbmx5IHRha2VuIGJ5IG1hbnVhbGx5IHdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9uc1xuICAgICAgICAvLyBzbyBwcmVzZW5jZSBvZiBhbnkgY2hpbGRyZW4gbGVhZHMgdG8gYSBmb3JjZWQgdXBkYXRlXG4gICAgICAgIGlmIChwcmV2Q2hpbGRyZW4gfHwgbmV4dENoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoIW5leHRDaGlsZHJlbiB8fCAhbmV4dENoaWxkcmVuLiRzdGFibGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldlByb3BzID09PSBuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXByZXZQcm9wcykge1xuICAgICAgICAgICAgcmV0dXJuICEhbmV4dFByb3BzO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbmV4dFByb3BzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0cyk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGhhc1Byb3BzQ2hhbmdlZChwcmV2UHJvcHMsIG5leHRQcm9wcywgZW1pdHNPcHRpb25zKSB7XG4gICAgY29uc3QgbmV4dEtleXMgPSBPYmplY3Qua2V5cyhuZXh0UHJvcHMpO1xuICAgIGlmIChuZXh0S2V5cy5sZW5ndGggIT09IE9iamVjdC5rZXlzKHByZXZQcm9wcykubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHRLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IG5leHRLZXlzW2ldO1xuICAgICAgICBpZiAobmV4dFByb3BzW2tleV0gIT09IHByZXZQcm9wc1trZXldICYmXG4gICAgICAgICAgICAhaXNFbWl0TGlzdGVuZXIoZW1pdHNPcHRpb25zLCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiB1cGRhdGVIT0NIb3N0RWwoeyB2bm9kZSwgcGFyZW50IH0sIGVsIC8vIEhvc3ROb2RlXG4pIHtcbiAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5zdWJUcmVlID09PSB2bm9kZSkge1xuICAgICAgICAodm5vZGUgPSBwYXJlbnQudm5vZGUpLmVsID0gZWw7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxufVxuXG5jb25zdCBpc1N1c3BlbnNlID0gKHR5cGUpID0+IHR5cGUuX19pc1N1c3BlbnNlO1xuLy8gU3VzcGVuc2UgZXhwb3NlcyBhIGNvbXBvbmVudC1saWtlIEFQSSwgYW5kIGlzIHRyZWF0ZWQgbGlrZSBhIGNvbXBvbmVudFxuLy8gaW4gdGhlIGNvbXBpbGVyLCBidXQgaW50ZXJuYWxseSBpdCdzIGEgc3BlY2lhbCBidWlsdC1pbiB0eXBlIHRoYXQgaG9va3Ncbi8vIGRpcmVjdGx5IGludG8gdGhlIHJlbmRlcmVyLlxuY29uc3QgU3VzcGVuc2VJbXBsID0ge1xuICAgIG5hbWU6ICdTdXNwZW5zZScsXG4gICAgLy8gSW4gb3JkZXIgdG8gbWFrZSBTdXNwZW5zZSB0cmVlLXNoYWthYmxlLCB3ZSBuZWVkIHRvIGF2b2lkIGltcG9ydGluZyBpdFxuICAgIC8vIGRpcmVjdGx5IGluIHRoZSByZW5kZXJlci4gVGhlIHJlbmRlcmVyIGNoZWNrcyBmb3IgdGhlIF9faXNTdXNwZW5zZSBmbGFnXG4gICAgLy8gb24gYSB2bm9kZSdzIHR5cGUgYW5kIGNhbGxzIHRoZSBgcHJvY2Vzc2AgbWV0aG9kLCBwYXNzaW5nIGluIHJlbmRlcmVyXG4gICAgLy8gaW50ZXJuYWxzLlxuICAgIF9faXNTdXNwZW5zZTogdHJ1ZSxcbiAgICBwcm9jZXNzKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgXG4gICAgLy8gcGxhdGZvcm0tc3BlY2lmaWMgaW1wbCBwYXNzZWQgZnJvbSByZW5kZXJlclxuICAgIHJlbmRlcmVySW50ZXJuYWxzKSB7XG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICAgICAgICBtb3VudFN1c3BlbnNlKG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXRjaFN1c3BlbnNlKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGh5ZHJhdGU6IGh5ZHJhdGVTdXNwZW5zZSxcbiAgICBjcmVhdGU6IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnksXG4gICAgbm9ybWFsaXplOiBub3JtYWxpemVTdXNwZW5zZUNoaWxkcmVuXG59O1xuLy8gRm9yY2UtY2FzdGVkIHB1YmxpYyB0eXBpbmcgZm9yIGggYW5kIFRTWCBwcm9wcyBpbmZlcmVuY2VcbmNvbnN0IFN1c3BlbnNlID0gKFN1c3BlbnNlSW1wbFxuICAgICk7XG5mdW5jdGlvbiB0cmlnZ2VyRXZlbnQodm5vZGUsIG5hbWUpIHtcbiAgICBjb25zdCBldmVudExpc3RlbmVyID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHNbbmFtZV07XG4gICAgaWYgKGlzRnVuY3Rpb24oZXZlbnRMaXN0ZW5lcikpIHtcbiAgICAgICAgZXZlbnRMaXN0ZW5lcigpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2Uodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKSB7XG4gICAgY29uc3QgeyBwOiBwYXRjaCwgbzogeyBjcmVhdGVFbGVtZW50IH0gfSA9IHJlbmRlcmVySW50ZXJuYWxzO1xuICAgIGNvbnN0IGhpZGRlbkNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnN0IHN1c3BlbnNlID0gKHZub2RlLnN1c3BlbnNlID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSh2bm9kZSwgcGFyZW50U3VzcGVuc2UsIHBhcmVudENvbXBvbmVudCwgY29udGFpbmVyLCBoaWRkZW5Db250YWluZXIsIGFuY2hvciwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscykpO1xuICAgIC8vIHN0YXJ0IG1vdW50aW5nIHRoZSBjb250ZW50IHN1YnRyZWUgaW4gYW4gb2ZmLWRvbSBjb250YWluZXJcbiAgICBwYXRjaChudWxsLCAoc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IHZub2RlLnNzQ29udGVudCksIGhpZGRlbkNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcyk7XG4gICAgLy8gbm93IGNoZWNrIGlmIHdlIGhhdmUgZW5jb3VudGVyZWQgYW55IGFzeW5jIGRlcHNcbiAgICBpZiAoc3VzcGVuc2UuZGVwcyA+IDApIHtcbiAgICAgICAgLy8gaGFzIGFzeW5jXG4gICAgICAgIC8vIGludm9rZSBAZmFsbGJhY2sgZXZlbnRcbiAgICAgICAgdHJpZ2dlckV2ZW50KHZub2RlLCAnb25QZW5kaW5nJyk7XG4gICAgICAgIHRyaWdnZXJFdmVudCh2bm9kZSwgJ29uRmFsbGJhY2snKTtcbiAgICAgICAgLy8gbW91bnQgdGhlIGZhbGxiYWNrIHRyZWVcbiAgICAgICAgcGF0Y2gobnVsbCwgdm5vZGUuc3NGYWxsYmFjaywgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgbnVsbCwgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcbiAgICAgICAgaXNTVkcsIHNsb3RTY29wZUlkcyk7XG4gICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgdm5vZGUuc3NGYWxsYmFjayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBTdXNwZW5zZSBoYXMgbm8gYXN5bmMgZGVwcy4gSnVzdCByZXNvbHZlLlxuICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGF0Y2hTdXNwZW5zZShuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgeyBwOiBwYXRjaCwgdW06IHVubW91bnQsIG86IHsgY3JlYXRlRWxlbWVudCB9IH0pIHtcbiAgICBjb25zdCBzdXNwZW5zZSA9IChuMi5zdXNwZW5zZSA9IG4xLnN1c3BlbnNlKTtcbiAgICBzdXNwZW5zZS52bm9kZSA9IG4yO1xuICAgIG4yLmVsID0gbjEuZWw7XG4gICAgY29uc3QgbmV3QnJhbmNoID0gbjIuc3NDb250ZW50O1xuICAgIGNvbnN0IG5ld0ZhbGxiYWNrID0gbjIuc3NGYWxsYmFjaztcbiAgICBjb25zdCB7IGFjdGl2ZUJyYW5jaCwgcGVuZGluZ0JyYW5jaCwgaXNJbkZhbGxiYWNrLCBpc0h5ZHJhdGluZyB9ID0gc3VzcGVuc2U7XG4gICAgaWYgKHBlbmRpbmdCcmFuY2gpIHtcbiAgICAgICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IG5ld0JyYW5jaDtcbiAgICAgICAgaWYgKGlzU2FtZVZOb2RlVHlwZShuZXdCcmFuY2gsIHBlbmRpbmdCcmFuY2gpKSB7XG4gICAgICAgICAgICAvLyBzYW1lIHJvb3QgdHlwZSBidXQgY29udGVudCBtYXkgaGF2ZSBjaGFuZ2VkLlxuICAgICAgICAgICAgcGF0Y2gocGVuZGluZ0JyYW5jaCwgbmV3QnJhbmNoLCBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNJbkZhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2goYWN0aXZlQnJhbmNoLCBuZXdGYWxsYmFjaywgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgbnVsbCwgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcbiAgICAgICAgICAgICAgICBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3RmFsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gdG9nZ2xlZCBiZWZvcmUgcGVuZGluZyB0cmVlIGlzIHJlc29sdmVkXG4gICAgICAgICAgICBzdXNwZW5zZS5wZW5kaW5nSWQrKztcbiAgICAgICAgICAgIGlmIChpc0h5ZHJhdGluZykge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRvZ2dsZWQgYmVmb3JlIGh5ZHJhdGlvbiBpcyBmaW5pc2hlZCwgdGhlIGN1cnJlbnQgRE9NIHRyZWUgaXNcbiAgICAgICAgICAgICAgICAvLyBubyBsb25nZXIgdmFsaWQuIHNldCBpdCBhcyB0aGUgYWN0aXZlIGJyYW5jaCBzbyBpdCB3aWxsIGJlIHVubW91bnRlZFxuICAgICAgICAgICAgICAgIC8vIHdoZW4gcmVzb2x2ZWRcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5pc0h5ZHJhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCA9IHBlbmRpbmdCcmFuY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1bm1vdW50KHBlbmRpbmdCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaW5jcmVtZW50IHBlbmRpbmcgSUQuIHRoaXMgaXMgdXNlZCB0byBpbnZhbGlkYXRlIGFzeW5jIGNhbGxiYWNrc1xuICAgICAgICAgICAgLy8gcmVzZXQgc3VzcGVuc2Ugc3RhdGVcbiAgICAgICAgICAgIHN1c3BlbnNlLmRlcHMgPSAwO1xuICAgICAgICAgICAgLy8gZGlzY2FyZCBlZmZlY3RzIGZyb20gcGVuZGluZyBicmFuY2hcbiAgICAgICAgICAgIHN1c3BlbnNlLmVmZmVjdHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIC8vIGRpc2NhcmQgcHJldmlvdXMgY29udGFpbmVyXG4gICAgICAgICAgICBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIgPSBjcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGlmIChpc0luRmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IGluIGZhbGxiYWNrIHN0YXRlXG4gICAgICAgICAgICAgICAgcGF0Y2gobnVsbCwgbmV3QnJhbmNoLCBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXRjaChhY3RpdmVCcmFuY2gsIG5ld0ZhbGxiYWNrLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBudWxsLCAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxuICAgICAgICAgICAgICAgICAgICBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIG5ld0ZhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY3RpdmVCcmFuY2ggJiYgaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgYWN0aXZlQnJhbmNoKSkge1xuICAgICAgICAgICAgICAgIC8vIHRvZ2dsZWQgXCJiYWNrXCIgdG8gY3VycmVudCBhY3RpdmUgYnJhbmNoXG4gICAgICAgICAgICAgICAgcGF0Y2goYWN0aXZlQnJhbmNoLCBuZXdCcmFuY2gsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgICAgIC8vIGZvcmNlIHJlc29sdmVcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc3dpdGNoZWQgdG8gYSAzcmQgYnJhbmNoXG4gICAgICAgICAgICAgICAgcGF0Y2gobnVsbCwgbmV3QnJhbmNoLCBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoYWN0aXZlQnJhbmNoICYmIGlzU2FtZVZOb2RlVHlwZShuZXdCcmFuY2gsIGFjdGl2ZUJyYW5jaCkpIHtcbiAgICAgICAgICAgIC8vIHJvb3QgZGlkIG5vdCBjaGFuZ2UsIGp1c3Qgbm9ybWFsIHBhdGNoXG4gICAgICAgICAgICBwYXRjaChhY3RpdmVCcmFuY2gsIG5ld0JyYW5jaCwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIG5ld0JyYW5jaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyByb290IG5vZGUgdG9nZ2xlZFxuICAgICAgICAgICAgLy8gaW52b2tlIEBwZW5kaW5nIGV2ZW50XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQobjIsICdvblBlbmRpbmcnKTtcbiAgICAgICAgICAgIC8vIG1vdW50IHBlbmRpbmcgYnJhbmNoIGluIG9mZi1kb20gY29udGFpbmVyXG4gICAgICAgICAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gbmV3QnJhbmNoO1xuICAgICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0lkKys7XG4gICAgICAgICAgICBwYXRjaChudWxsLCBuZXdCcmFuY2gsIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcbiAgICAgICAgICAgICAgICAvLyBpbmNvbWluZyBicmFuY2ggaGFzIG5vIGFzeW5jIGRlcHMsIHJlc29sdmUgbm93LlxuICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdGltZW91dCwgcGVuZGluZ0lkIH0gPSBzdXNwZW5zZTtcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VzcGVuc2UucGVuZGluZ0lkID09PSBwZW5kaW5nSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5mYWxsYmFjayhuZXdGYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aW1lb3V0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLmZhbGxiYWNrKG5ld0ZhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5sZXQgaGFzV2FybmVkID0gZmFsc2U7XG5mdW5jdGlvbiBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KHZub2RlLCBwYXJlbnQsIHBhcmVudENvbXBvbmVudCwgY29udGFpbmVyLCBoaWRkZW5Db250YWluZXIsIGFuY2hvciwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgaXNIeWRyYXRpbmcgPSBmYWxzZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWZhbHNlICYmICFoYXNXYXJuZWQpIHtcbiAgICAgICAgaGFzV2FybmVkID0gdHJ1ZTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBgY29uc29sZS5pbmZvYCBjYW5ub3QgYmUgbnVsbCBlcnJvclxuICAgICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShgPFN1c3BlbnNlPiBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZSBhbmQgaXRzIEFQSSB3aWxsIGxpa2VseSBjaGFuZ2UuYCk7XG4gICAgfVxuICAgIGNvbnN0IHsgcDogcGF0Y2gsIG06IG1vdmUsIHVtOiB1bm1vdW50LCBuOiBuZXh0LCBvOiB7IHBhcmVudE5vZGUsIHJlbW92ZSB9IH0gPSByZW5kZXJlckludGVybmFscztcbiAgICBjb25zdCB0aW1lb3V0ID0gdG9OdW1iZXIodm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudGltZW91dCk7XG4gICAgY29uc3Qgc3VzcGVuc2UgPSB7XG4gICAgICAgIHZub2RlLFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgaXNTVkcsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgaGlkZGVuQ29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIGRlcHM6IDAsXG4gICAgICAgIHBlbmRpbmdJZDogMCxcbiAgICAgICAgdGltZW91dDogdHlwZW9mIHRpbWVvdXQgPT09ICdudW1iZXInID8gdGltZW91dCA6IC0xLFxuICAgICAgICBhY3RpdmVCcmFuY2g6IG51bGwsXG4gICAgICAgIHBlbmRpbmdCcmFuY2g6IG51bGwsXG4gICAgICAgIGlzSW5GYWxsYmFjazogdHJ1ZSxcbiAgICAgICAgaXNIeWRyYXRpbmcsXG4gICAgICAgIGlzVW5tb3VudGVkOiBmYWxzZSxcbiAgICAgICAgZWZmZWN0czogW10sXG4gICAgICAgIHJlc29sdmUocmVzdW1lID0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VtZSAmJiAhc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN1c3BlbnNlLnJlc29sdmUoKSBpcyBjYWxsZWQgd2l0aG91dCBhIHBlbmRpbmcgYnJhbmNoLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3VzcGVuc2UuaXNVbm1vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdXNwZW5zZS5yZXNvbHZlKCkgaXMgY2FsbGVkIG9uIGFuIGFscmVhZHkgdW5tb3VudGVkIHN1c3BlbnNlIGJvdW5kYXJ5LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgdm5vZGUsIGFjdGl2ZUJyYW5jaCwgcGVuZGluZ0JyYW5jaCwgcGVuZGluZ0lkLCBlZmZlY3RzLCBwYXJlbnRDb21wb25lbnQsIGNvbnRhaW5lciB9ID0gc3VzcGVuc2U7XG4gICAgICAgICAgICBpZiAoc3VzcGVuc2UuaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5pc0h5ZHJhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXJlc3VtZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbGF5RW50ZXIgPSBhY3RpdmVCcmFuY2ggJiZcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0JyYW5jaC50cmFuc2l0aW9uICYmXG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdCcmFuY2gudHJhbnNpdGlvbi5tb2RlID09PSAnb3V0LWluJztcbiAgICAgICAgICAgICAgICBpZiAoZGVsYXlFbnRlcikge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVCcmFuY2gudHJhbnNpdGlvbi5hZnRlckxlYXZlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdJZCA9PT0gc3VzcGVuc2UucGVuZGluZ0lkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW92ZShwZW5kaW5nQnJhbmNoLCBjb250YWluZXIsIGFuY2hvciwgMCAvKiBNb3ZlVHlwZS5FTlRFUiAqLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgaW5pdGlhbCBhbmNob3Igb24gbW91bnRcbiAgICAgICAgICAgICAgICBsZXQgeyBhbmNob3IgfSA9IHN1c3BlbnNlO1xuICAgICAgICAgICAgICAgIC8vIHVubW91bnQgY3VycmVudCBhY3RpdmUgdHJlZVxuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVCcmFuY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGZhbGxiYWNrIHRyZWUgd2FzIG1vdW50ZWQsIGl0IG1heSBoYXZlIGJlZW4gbW92ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgcGFydCBvZiBhIHBhcmVudCBzdXNwZW5zZS4gZ2V0IHRoZSBsYXRlc3QgYW5jaG9yIGZvciBpbnNlcnRpb25cbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yID0gbmV4dChhY3RpdmVCcmFuY2gpO1xuICAgICAgICAgICAgICAgICAgICB1bm1vdW50KGFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZGVsYXlFbnRlcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIGNvbnRlbnQgZnJvbSBvZmYtZG9tIGNvbnRhaW5lciB0byBhY3R1YWwgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgIG1vdmUocGVuZGluZ0JyYW5jaCwgY29udGFpbmVyLCBhbmNob3IsIDAgLyogTW92ZVR5cGUuRU5URVIgKi8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgcGVuZGluZ0JyYW5jaCk7XG4gICAgICAgICAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gbnVsbDtcbiAgICAgICAgICAgIHN1c3BlbnNlLmlzSW5GYWxsYmFjayA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gZmx1c2ggYnVmZmVyZWQgZWZmZWN0c1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgaXMgYSBwZW5kaW5nIHBhcmVudCBzdXNwZW5zZVxuICAgICAgICAgICAgbGV0IHBhcmVudCA9IHN1c3BlbnNlLnBhcmVudDtcbiAgICAgICAgICAgIGxldCBoYXNVbnJlc29sdmVkQW5jZXN0b3IgPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50LnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZm91bmQgYSBwZW5kaW5nIHBhcmVudCBzdXNwZW5zZSwgbWVyZ2UgYnVmZmVyZWQgcG9zdCBqb2JzXG4gICAgICAgICAgICAgICAgICAgIC8vIGludG8gdGhhdCBwYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmVmZmVjdHMucHVzaCguLi5lZmZlY3RzKTtcbiAgICAgICAgICAgICAgICAgICAgaGFzVW5yZXNvbHZlZEFuY2VzdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBubyBwZW5kaW5nIHBhcmVudCBzdXNwZW5zZSwgZmx1c2ggYWxsIGpvYnNcbiAgICAgICAgICAgIGlmICghaGFzVW5yZXNvbHZlZEFuY2VzdG9yKSB7XG4gICAgICAgICAgICAgICAgcXVldWVQb3N0Rmx1c2hDYihlZmZlY3RzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1c3BlbnNlLmVmZmVjdHMgPSBbXTtcbiAgICAgICAgICAgIC8vIGludm9rZSBAcmVzb2x2ZSBldmVudFxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KHZub2RlLCAnb25SZXNvbHZlJyk7XG4gICAgICAgIH0sXG4gICAgICAgIGZhbGxiYWNrKGZhbGxiYWNrVk5vZGUpIHtcbiAgICAgICAgICAgIGlmICghc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgdm5vZGUsIGFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBjb250YWluZXIsIGlzU1ZHIH0gPSBzdXNwZW5zZTtcbiAgICAgICAgICAgIC8vIGludm9rZSBAZmFsbGJhY2sgZXZlbnRcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudCh2bm9kZSwgJ29uRmFsbGJhY2snKTtcbiAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IG5leHQoYWN0aXZlQnJhbmNoKTtcbiAgICAgICAgICAgIGNvbnN0IG1vdW50RmFsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdXNwZW5zZS5pc0luRmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBtb3VudCB0aGUgZmFsbGJhY2sgdHJlZVxuICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIGZhbGxiYWNrVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIG51bGwsIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XG4gICAgICAgICAgICAgICAgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIGZhbGxiYWNrVk5vZGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5RW50ZXIgPSBmYWxsYmFja1ZOb2RlLnRyYW5zaXRpb24gJiYgZmFsbGJhY2tWTm9kZS50cmFuc2l0aW9uLm1vZGUgPT09ICdvdXQtaW4nO1xuICAgICAgICAgICAgaWYgKGRlbGF5RW50ZXIpIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVCcmFuY2gudHJhbnNpdGlvbi5hZnRlckxlYXZlID0gbW91bnRGYWxsYmFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1c3BlbnNlLmlzSW5GYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgICAvLyB1bm1vdW50IGN1cnJlbnQgYWN0aXZlIGJyYW5jaFxuICAgICAgICAgICAgdW5tb3VudChhY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgbnVsbCwgLy8gbm8gc3VzcGVuc2Ugc28gdW5tb3VudCBob29rcyBmaXJlIG5vd1xuICAgICAgICAgICAgdHJ1ZSAvLyBzaG91bGRSZW1vdmVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoIWRlbGF5RW50ZXIpIHtcbiAgICAgICAgICAgICAgICBtb3VudEZhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1vdmUoY29udGFpbmVyLCBhbmNob3IsIHR5cGUpIHtcbiAgICAgICAgICAgIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCAmJlxuICAgICAgICAgICAgICAgIG1vdmUoc3VzcGVuc2UuYWN0aXZlQnJhbmNoLCBjb250YWluZXIsIGFuY2hvciwgdHlwZSk7XG4gICAgICAgICAgICBzdXNwZW5zZS5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIH0sXG4gICAgICAgIG5leHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VzcGVuc2UuYWN0aXZlQnJhbmNoICYmIG5leHQoc3VzcGVuc2UuYWN0aXZlQnJhbmNoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVnaXN0ZXJEZXAoaW5zdGFuY2UsIHNldHVwUmVuZGVyRWZmZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBpc0luUGVuZGluZ1N1c3BlbnNlID0gISFzdXNwZW5zZS5wZW5kaW5nQnJhbmNoO1xuICAgICAgICAgICAgaWYgKGlzSW5QZW5kaW5nU3VzcGVuc2UpIHtcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5kZXBzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoeWRyYXRlZEVsID0gaW5zdGFuY2Uudm5vZGUuZWw7XG4gICAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIC5hc3luY0RlcC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIDAgLyogRXJyb3JDb2Rlcy5TRVRVUF9GVU5DVElPTiAqLyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGFzeW5jU2V0dXBSZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHJldHJ5IHdoZW4gdGhlIHNldHVwKCkgcHJvbWlzZSByZXNvbHZlcy5cbiAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQgbWF5IGhhdmUgYmVlbiB1bm1vdW50ZWQgYmVmb3JlIHJlc29sdmUuXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmlzVW5tb3VudGVkIHx8XG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLmlzVW5tb3VudGVkIHx8XG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLnBlbmRpbmdJZCAhPT0gaW5zdGFuY2Uuc3VzcGVuc2VJZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHJldHJ5IGZyb20gdGhpcyBjb21wb25lbnRcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5hc3luY1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZub2RlIH0gPSBpbnN0YW5jZTtcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dCh2bm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBhc3luY1NldHVwUmVzdWx0LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKGh5ZHJhdGVkRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdm5vZGUgbWF5IGhhdmUgYmVlbiByZXBsYWNlZCBpZiBhbiB1cGRhdGUgaGFwcGVuZWQgYmVmb3JlIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBhc3luYyBkZXAgaXMgcmVzb2x2ZWQuXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLmVsID0gaHlkcmF0ZWRFbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSAhaHlkcmF0ZWRFbCAmJiBpbnN0YW5jZS5zdWJUcmVlLmVsO1xuICAgICAgICAgICAgICAgIHNldHVwUmVuZGVyRWZmZWN0KGluc3RhbmNlLCB2bm9kZSwgXG4gICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IG1heSBoYXZlIGJlZW4gbW92ZWQgYmVmb3JlIHJlc29sdmUuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBub3QgYSBoeWRyYXRpb24sIGluc3RhbmNlLnN1YlRyZWUgd2lsbCBiZSB0aGUgY29tbWVudFxuICAgICAgICAgICAgICAgIC8vIHBsYWNlaG9sZGVyLlxuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUoaHlkcmF0ZWRFbCB8fCBpbnN0YW5jZS5zdWJUcmVlLmVsKSwgXG4gICAgICAgICAgICAgICAgLy8gYW5jaG9yIHdpbGwgbm90IGJlIHVzZWQgaWYgdGhpcyBpcyBoeWRyYXRpb24sIHNvIG9ubHkgbmVlZCB0b1xuICAgICAgICAgICAgICAgIC8vIGNvbnNpZGVyIHRoZSBjb21tZW50IHBsYWNlaG9sZGVyIGNhc2UuXG4gICAgICAgICAgICAgICAgaHlkcmF0ZWRFbCA/IG51bGwgOiBuZXh0KGluc3RhbmNlLnN1YlRyZWUpLCBzdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZShwbGFjZWhvbGRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVwZGF0ZUhPQ0hvc3RFbChpbnN0YW5jZSwgdm5vZGUuZWwpO1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gb25seSBkZWNyZWFzZSBkZXBzIGNvdW50IGlmIHN1c3BlbnNlIGlzIG5vdCBhbHJlYWR5IHJlc29sdmVkXG4gICAgICAgICAgICAgICAgaWYgKGlzSW5QZW5kaW5nU3VzcGVuc2UgJiYgLS1zdXNwZW5zZS5kZXBzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5tb3VudChwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpIHtcbiAgICAgICAgICAgIHN1c3BlbnNlLmlzVW5tb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5hY3RpdmVCcmFuY2gpIHtcbiAgICAgICAgICAgICAgICB1bm1vdW50KHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgICAgICAgICAgICB1bm1vdW50KHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHN1c3BlbnNlO1xufVxuZnVuY3Rpb24gaHlkcmF0ZVN1c3BlbnNlKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBoeWRyYXRlTm9kZSkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xuICAgIGNvbnN0IHN1c3BlbnNlID0gKHZub2RlLnN1c3BlbnNlID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSh2bm9kZSwgcGFyZW50U3VzcGVuc2UsIHBhcmVudENvbXBvbmVudCwgbm9kZS5wYXJlbnROb2RlLCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgbnVsbCwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pKTtcbiAgICAvLyB0aGVyZSBhcmUgdHdvIHBvc3NpYmxlIHNjZW5hcmlvcyBmb3Igc2VydmVyLXJlbmRlcmVkIHN1c3BlbnNlOlxuICAgIC8vIC0gc3VjY2Vzczogc3NyIGNvbnRlbnQgc2hvdWxkIGJlIGZ1bGx5IHJlc29sdmVkXG4gICAgLy8gLSBmYWlsdXJlOiBzc3IgY29udGVudCBzaG91bGQgYmUgdGhlIGZhbGxiYWNrIGJyYW5jaC5cbiAgICAvLyBob3dldmVyLCBvbiB0aGUgY2xpZW50IHdlIGRvbid0IHJlYWxseSBrbm93IGlmIGl0IGhhcyBmYWlsZWQgb3Igbm90XG4gICAgLy8gYXR0ZW1wdCB0byBoeWRyYXRlIHRoZSBET00gYXNzdW1pbmcgaXQgaGFzIHN1Y2NlZWRlZCwgYnV0IHdlIHN0aWxsXG4gICAgLy8gbmVlZCB0byBjb25zdHJ1Y3QgYSBzdXNwZW5zZSBib3VuZGFyeSBmaXJzdFxuICAgIGNvbnN0IHJlc3VsdCA9IGh5ZHJhdGVOb2RlKG5vZGUsIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gdm5vZGUuc3NDb250ZW50KSwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgIGlmIChzdXNwZW5zZS5kZXBzID09PSAwKSB7XG4gICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU3VzcGVuc2VDaGlsZHJlbih2bm9kZSkge1xuICAgIGNvbnN0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiB9ID0gdm5vZGU7XG4gICAgY29uc3QgaXNTbG90Q2hpbGRyZW4gPSBzaGFwZUZsYWcgJiAzMiAvKiBTaGFwZUZsYWdzLlNMT1RTX0NISUxEUkVOICovO1xuICAgIHZub2RlLnNzQ29udGVudCA9IG5vcm1hbGl6ZVN1c3BlbnNlU2xvdChpc1Nsb3RDaGlsZHJlbiA/IGNoaWxkcmVuLmRlZmF1bHQgOiBjaGlsZHJlbik7XG4gICAgdm5vZGUuc3NGYWxsYmFjayA9IGlzU2xvdENoaWxkcmVuXG4gICAgICAgID8gbm9ybWFsaXplU3VzcGVuc2VTbG90KGNoaWxkcmVuLmZhbGxiYWNrKVxuICAgICAgICA6IGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU3VzcGVuc2VTbG90KHMpIHtcbiAgICBsZXQgYmxvY2s7XG4gICAgaWYgKGlzRnVuY3Rpb24ocykpIHtcbiAgICAgICAgY29uc3QgdHJhY2tCbG9jayA9IGlzQmxvY2tUcmVlRW5hYmxlZCAmJiBzLl9jO1xuICAgICAgICBpZiAodHJhY2tCbG9jaykge1xuICAgICAgICAgICAgLy8gZGlzYWJsZVRyYWNraW5nOiBmYWxzZVxuICAgICAgICAgICAgLy8gYWxsb3cgYmxvY2sgdHJhY2tpbmcgZm9yIGNvbXBpbGVkIHNsb3RzXG4gICAgICAgICAgICAvLyAoc2VlIC4vY29tcG9uZW50UmVuZGVyQ29udGV4dC50cylcbiAgICAgICAgICAgIHMuX2QgPSBmYWxzZTtcbiAgICAgICAgICAgIG9wZW5CbG9jaygpO1xuICAgICAgICB9XG4gICAgICAgIHMgPSBzKCk7XG4gICAgICAgIGlmICh0cmFja0Jsb2NrKSB7XG4gICAgICAgICAgICBzLl9kID0gdHJ1ZTtcbiAgICAgICAgICAgIGJsb2NrID0gY3VycmVudEJsb2NrO1xuICAgICAgICAgICAgY2xvc2VCbG9jaygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc0FycmF5KHMpKSB7XG4gICAgICAgIGNvbnN0IHNpbmdsZUNoaWxkID0gZmlsdGVyU2luZ2xlUm9vdChzKTtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhc2luZ2xlQ2hpbGQpIHtcbiAgICAgICAgICAgIHdhcm4oYDxTdXNwZW5zZT4gc2xvdHMgZXhwZWN0IGEgc2luZ2xlIHJvb3Qgbm9kZS5gKTtcbiAgICAgICAgfVxuICAgICAgICBzID0gc2luZ2xlQ2hpbGQ7XG4gICAgfVxuICAgIHMgPSBub3JtYWxpemVWTm9kZShzKTtcbiAgICBpZiAoYmxvY2sgJiYgIXMuZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICAgIHMuZHluYW1pY0NoaWxkcmVuID0gYmxvY2suZmlsdGVyKGMgPT4gYyAhPT0gcyk7XG4gICAgfVxuICAgIHJldHVybiBzO1xufVxuZnVuY3Rpb24gcXVldWVFZmZlY3RXaXRoU3VzcGVuc2UoZm4sIHN1c3BlbnNlKSB7XG4gICAgaWYgKHN1c3BlbnNlICYmIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgICAgaWYgKGlzQXJyYXkoZm4pKSB7XG4gICAgICAgICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goLi4uZm4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VzcGVuc2UuZWZmZWN0cy5wdXNoKGZuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcXVldWVQb3N0Rmx1c2hDYihmbik7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBicmFuY2gpIHtcbiAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggPSBicmFuY2g7XG4gICAgY29uc3QgeyB2bm9kZSwgcGFyZW50Q29tcG9uZW50IH0gPSBzdXNwZW5zZTtcbiAgICBjb25zdCBlbCA9ICh2bm9kZS5lbCA9IGJyYW5jaC5lbCk7XG4gICAgLy8gaW4gY2FzZSBzdXNwZW5zZSBpcyB0aGUgcm9vdCBub2RlIG9mIGEgY29tcG9uZW50LFxuICAgIC8vIHJlY3Vyc2l2ZWx5IHVwZGF0ZSB0aGUgSE9DIGVsXG4gICAgaWYgKHBhcmVudENvbXBvbmVudCAmJiBwYXJlbnRDb21wb25lbnQuc3ViVHJlZSA9PT0gdm5vZGUpIHtcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LnZub2RlLmVsID0gZWw7XG4gICAgICAgIHVwZGF0ZUhPQ0hvc3RFbChwYXJlbnRDb21wb25lbnQsIGVsKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHByb3ZpZGUoa2V5LCB2YWx1ZSkge1xuICAgIGlmICghY3VycmVudEluc3RhbmNlKSB7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgIHdhcm4oYHByb3ZpZGUoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBzZXR1cCgpLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgcHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucHJvdmlkZXM7XG4gICAgICAgIC8vIGJ5IGRlZmF1bHQgYW4gaW5zdGFuY2UgaW5oZXJpdHMgaXRzIHBhcmVudCdzIHByb3ZpZGVzIG9iamVjdFxuICAgICAgICAvLyBidXQgd2hlbiBpdCBuZWVkcyB0byBwcm92aWRlIHZhbHVlcyBvZiBpdHMgb3duLCBpdCBjcmVhdGVzIGl0c1xuICAgICAgICAvLyBvd24gcHJvdmlkZXMgb2JqZWN0IHVzaW5nIHBhcmVudCBwcm92aWRlcyBvYmplY3QgYXMgcHJvdG90eXBlLlxuICAgICAgICAvLyB0aGlzIHdheSBpbiBgaW5qZWN0YCB3ZSBjYW4gc2ltcGx5IGxvb2sgdXAgaW5qZWN0aW9ucyBmcm9tIGRpcmVjdFxuICAgICAgICAvLyBwYXJlbnQgYW5kIGxldCB0aGUgcHJvdG90eXBlIGNoYWluIGRvIHRoZSB3b3JrLlxuICAgICAgICBjb25zdCBwYXJlbnRQcm92aWRlcyA9IGN1cnJlbnRJbnN0YW5jZS5wYXJlbnQgJiYgY3VycmVudEluc3RhbmNlLnBhcmVudC5wcm92aWRlcztcbiAgICAgICAgaWYgKHBhcmVudFByb3ZpZGVzID09PSBwcm92aWRlcykge1xuICAgICAgICAgICAgcHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucHJvdmlkZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFByb3ZpZGVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUUyBkb2Vzbid0IGFsbG93IHN5bWJvbCBhcyBpbmRleCB0eXBlXG4gICAgICAgIHByb3ZpZGVzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbmplY3Qoa2V5LCBkZWZhdWx0VmFsdWUsIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSA9IGZhbHNlKSB7XG4gICAgLy8gZmFsbGJhY2sgdG8gYGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZWAgc28gdGhhdCB0aGlzIGNhbiBiZSBjYWxsZWQgaW5cbiAgICAvLyBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gICAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2UgfHwgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAvLyAjMjQwMFxuICAgICAgICAvLyB0byBzdXBwb3J0IGBhcHAudXNlYCBwbHVnaW5zLFxuICAgICAgICAvLyBmYWxsYmFjayB0byBhcHBDb250ZXh0J3MgYHByb3ZpZGVzYCBpZiB0aGUgaW5zdGFuY2UgaXMgYXQgcm9vdFxuICAgICAgICBjb25zdCBwcm92aWRlcyA9IGluc3RhbmNlLnBhcmVudCA9PSBudWxsXG4gICAgICAgICAgICA/IGluc3RhbmNlLnZub2RlLmFwcENvbnRleHQgJiYgaW5zdGFuY2Uudm5vZGUuYXBwQ29udGV4dC5wcm92aWRlc1xuICAgICAgICAgICAgOiBpbnN0YW5jZS5wYXJlbnQucHJvdmlkZXM7XG4gICAgICAgIGlmIChwcm92aWRlcyAmJiBrZXkgaW4gcHJvdmlkZXMpIHtcbiAgICAgICAgICAgIC8vIFRTIGRvZXNuJ3QgYWxsb3cgc3ltYm9sIGFzIGluZGV4IHR5cGVcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJlYXREZWZhdWx0QXNGYWN0b3J5ICYmIGlzRnVuY3Rpb24oZGVmYXVsdFZhbHVlKVxuICAgICAgICAgICAgICAgID8gZGVmYXVsdFZhbHVlLmNhbGwoaW5zdGFuY2UucHJveHkpXG4gICAgICAgICAgICAgICAgOiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICB3YXJuKGBpbmplY3Rpb24gXCIke1N0cmluZyhrZXkpfVwiIG5vdCBmb3VuZC5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgd2FybihgaW5qZWN0KCkgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgc2V0dXAoKSBvciBmdW5jdGlvbmFsIGNvbXBvbmVudHMuYCk7XG4gICAgfVxufVxuXG4vLyBTaW1wbGUgZWZmZWN0LlxuZnVuY3Rpb24gd2F0Y2hFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGRvV2F0Y2goZWZmZWN0LCBudWxsLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHdhdGNoUG9zdEVmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZG9XYXRjaChlZmZlY3QsIG51bGwsICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcbiAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGZsdXNoOiAncG9zdCcgfSkgOiB7IGZsdXNoOiAncG9zdCcgfSkpO1xufVxuZnVuY3Rpb24gd2F0Y2hTeW5jRWZmZWN0KGVmZmVjdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBkb1dhdGNoKGVmZmVjdCwgbnVsbCwgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxuICAgICAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgZmx1c2g6ICdzeW5jJyB9KSA6IHsgZmx1c2g6ICdzeW5jJyB9KSk7XG59XG4vLyBpbml0aWFsIHZhbHVlIGZvciB3YXRjaGVycyB0byB0cmlnZ2VyIG9uIHVuZGVmaW5lZCBpbml0aWFsIHZhbHVlc1xuY29uc3QgSU5JVElBTF9XQVRDSEVSX1ZBTFVFID0ge307XG4vLyBpbXBsZW1lbnRhdGlvblxuZnVuY3Rpb24gd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucykge1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzRnVuY3Rpb24oY2IpKSB7XG4gICAgICAgIHdhcm4oYFxcYHdhdGNoKGZuLCBvcHRpb25zPylcXGAgc2lnbmF0dXJlIGhhcyBiZWVuIG1vdmVkIHRvIGEgc2VwYXJhdGUgQVBJLiBgICtcbiAgICAgICAgICAgIGBVc2UgXFxgd2F0Y2hFZmZlY3QoZm4sIG9wdGlvbnM/KVxcYCBpbnN0ZWFkLiBcXGB3YXRjaFxcYCBub3cgb25seSBgICtcbiAgICAgICAgICAgIGBzdXBwb3J0cyBcXGB3YXRjaChzb3VyY2UsIGNiLCBvcHRpb25zPykgc2lnbmF0dXJlLmApO1xuICAgIH1cbiAgICByZXR1cm4gZG9XYXRjaChzb3VyY2UsIGNiLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGRvV2F0Y2goc291cmNlLCBjYiwgeyBpbW1lZGlhdGUsIGRlZXAsIGZsdXNoLCBvblRyYWNrLCBvblRyaWdnZXIgfSA9IEVNUFRZX09CSikge1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWNiKSB7XG4gICAgICAgIGlmIChpbW1lZGlhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd2Fybihgd2F0Y2goKSBcImltbWVkaWF0ZVwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSBgICtcbiAgICAgICAgICAgICAgICBgd2F0Y2goc291cmNlLCBjYWxsYmFjaywgb3B0aW9ucz8pIHNpZ25hdHVyZS5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVlcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3YXJuKGB3YXRjaCgpIFwiZGVlcFwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSBgICtcbiAgICAgICAgICAgICAgICBgd2F0Y2goc291cmNlLCBjYWxsYmFjaywgb3B0aW9ucz8pIHNpZ25hdHVyZS5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB3YXJuSW52YWxpZFNvdXJjZSA9IChzKSA9PiB7XG4gICAgICAgIHdhcm4oYEludmFsaWQgd2F0Y2ggc291cmNlOiBgLCBzLCBgQSB3YXRjaCBzb3VyY2UgY2FuIG9ubHkgYmUgYSBnZXR0ZXIvZWZmZWN0IGZ1bmN0aW9uLCBhIHJlZiwgYCArXG4gICAgICAgICAgICBgYSByZWFjdGl2ZSBvYmplY3QsIG9yIGFuIGFycmF5IG9mIHRoZXNlIHR5cGVzLmApO1xuICAgIH07XG4gICAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgbGV0IGdldHRlcjtcbiAgICBsZXQgZm9yY2VUcmlnZ2VyID0gZmFsc2U7XG4gICAgbGV0IGlzTXVsdGlTb3VyY2UgPSBmYWxzZTtcbiAgICBpZiAoaXNSZWYoc291cmNlKSkge1xuICAgICAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2UudmFsdWU7XG4gICAgICAgIGZvcmNlVHJpZ2dlciA9IGlzU2hhbGxvdyQxKHNvdXJjZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUmVhY3RpdmUoc291cmNlKSkge1xuICAgICAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2U7XG4gICAgICAgIGRlZXAgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgaXNNdWx0aVNvdXJjZSA9IHRydWU7XG4gICAgICAgIGZvcmNlVHJpZ2dlciA9IHNvdXJjZS5zb21lKHMgPT4gaXNSZWFjdGl2ZShzKSB8fCBpc1NoYWxsb3ckMShzKSk7XG4gICAgICAgIGdldHRlciA9ICgpID0+IHNvdXJjZS5tYXAocyA9PiB7XG4gICAgICAgICAgICBpZiAoaXNSZWYocykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcy52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVhY3RpdmUocykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhdmVyc2Uocyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhzLCBpbnN0YW5jZSwgMiAvKiBFcnJvckNvZGVzLldBVENIX0dFVFRFUiAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybkludmFsaWRTb3VyY2Uocyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHNvdXJjZSkpIHtcbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAvLyBnZXR0ZXIgd2l0aCBjYlxuICAgICAgICAgICAgZ2V0dGVyID0gKCkgPT4gY2FsbFdpdGhFcnJvckhhbmRsaW5nKHNvdXJjZSwgaW5zdGFuY2UsIDIgLyogRXJyb3JDb2Rlcy5XQVRDSF9HRVRURVIgKi8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbm8gY2IgLT4gc2ltcGxlIGVmZmVjdFxuICAgICAgICAgICAgZ2V0dGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5pc1VubW91bnRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjbGVhbnVwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKHNvdXJjZSwgaW5zdGFuY2UsIDMgLyogRXJyb3JDb2Rlcy5XQVRDSF9DQUxMQkFDSyAqLywgW29uQ2xlYW51cF0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2V0dGVyID0gTk9PUDtcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm5JbnZhbGlkU291cmNlKHNvdXJjZSk7XG4gICAgfVxuICAgIGlmIChjYiAmJiBkZWVwKSB7XG4gICAgICAgIGNvbnN0IGJhc2VHZXR0ZXIgPSBnZXR0ZXI7XG4gICAgICAgIGdldHRlciA9ICgpID0+IHRyYXZlcnNlKGJhc2VHZXR0ZXIoKSk7XG4gICAgfVxuICAgIGxldCBjbGVhbnVwO1xuICAgIGxldCBvbkNsZWFudXAgPSAoZm4pID0+IHtcbiAgICAgICAgY2xlYW51cCA9IGVmZmVjdC5vblN0b3AgPSAoKSA9PiB7XG4gICAgICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCA0IC8qIEVycm9yQ29kZXMuV0FUQ0hfQ0xFQU5VUCAqLyk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvLyBpbiBTU1IgdGhlcmUgaXMgbm8gbmVlZCB0byBzZXR1cCBhbiBhY3R1YWwgZWZmZWN0LCBhbmQgaXQgc2hvdWxkIGJlIG5vb3BcbiAgICAvLyB1bmxlc3MgaXQncyBlYWdlciBvciBzeW5jIGZsdXNoXG4gICAgbGV0IHNzckNsZWFudXA7XG4gICAgaWYgKGlzSW5TU1JDb21wb25lbnRTZXR1cCkge1xuICAgICAgICAvLyB3ZSB3aWxsIGFsc28gbm90IGNhbGwgdGhlIGludmFsaWRhdGUgY2FsbGJhY2sgKCsgcnVubmVyIGlzIG5vdCBzZXQgdXApXG4gICAgICAgIG9uQ2xlYW51cCA9IE5PT1A7XG4gICAgICAgIGlmICghY2IpIHtcbiAgICAgICAgICAgIGdldHRlcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGltbWVkaWF0ZSkge1xuICAgICAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoY2IsIGluc3RhbmNlLCAzIC8qIEVycm9yQ29kZXMuV0FUQ0hfQ0FMTEJBQ0sgKi8sIFtcbiAgICAgICAgICAgICAgICBnZXR0ZXIoKSxcbiAgICAgICAgICAgICAgICBpc011bHRpU291cmNlID8gW10gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgb25DbGVhbnVwXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmx1c2ggPT09ICdzeW5jJykge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdXNlU1NSQ29udGV4dCgpO1xuICAgICAgICAgICAgc3NyQ2xlYW51cCA9IGN0eC5fX3dhdGNoZXJIYW5kbGVzIHx8IChjdHguX193YXRjaGVySGFuZGxlcyA9IFtdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBOT09QO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBvbGRWYWx1ZSA9IGlzTXVsdGlTb3VyY2VcbiAgICAgICAgPyBuZXcgQXJyYXkoc291cmNlLmxlbmd0aCkuZmlsbChJTklUSUFMX1dBVENIRVJfVkFMVUUpXG4gICAgICAgIDogSU5JVElBTF9XQVRDSEVSX1ZBTFVFO1xuICAgIGNvbnN0IGpvYiA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFlZmZlY3QuYWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAvLyB3YXRjaChzb3VyY2UsIGNiKVxuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBlZmZlY3QucnVuKCk7XG4gICAgICAgICAgICBpZiAoZGVlcCB8fFxuICAgICAgICAgICAgICAgIGZvcmNlVHJpZ2dlciB8fFxuICAgICAgICAgICAgICAgIChpc011bHRpU291cmNlXG4gICAgICAgICAgICAgICAgICAgID8gbmV3VmFsdWUuc29tZSgodiwgaSkgPT4gaGFzQ2hhbmdlZCh2LCBvbGRWYWx1ZVtpXSkpXG4gICAgICAgICAgICAgICAgICAgIDogaGFzQ2hhbmdlZChuZXdWYWx1ZSwgb2xkVmFsdWUpKSB8fFxuICAgICAgICAgICAgICAgIChmYWxzZSAgKSkge1xuICAgICAgICAgICAgICAgIC8vIGNsZWFudXAgYmVmb3JlIHJ1bm5pbmcgY2IgYWdhaW5cbiAgICAgICAgICAgICAgICBpZiAoY2xlYW51cCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGNiLCBpbnN0YW5jZSwgMyAvKiBFcnJvckNvZGVzLldBVENIX0NBTExCQUNLICovLCBbXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAvLyBwYXNzIHVuZGVmaW5lZCBhcyB0aGUgb2xkIHZhbHVlIHdoZW4gaXQncyBjaGFuZ2VkIGZvciB0aGUgZmlyc3QgdGltZVxuICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9PT0gSU5JVElBTF9XQVRDSEVSX1ZBTFVFXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgOiAoaXNNdWx0aVNvdXJjZSAmJiBvbGRWYWx1ZVswXSA9PT0gSU5JVElBTF9XQVRDSEVSX1ZBTFVFKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gW11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG9sZFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBvbkNsZWFudXBcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gd2F0Y2hFZmZlY3RcbiAgICAgICAgICAgIGVmZmVjdC5ydW4oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gaW1wb3J0YW50OiBtYXJrIHRoZSBqb2IgYXMgYSB3YXRjaGVyIGNhbGxiYWNrIHNvIHRoYXQgc2NoZWR1bGVyIGtub3dzXG4gICAgLy8gaXQgaXMgYWxsb3dlZCB0byBzZWxmLXRyaWdnZXIgKCMxNzI3KVxuICAgIGpvYi5hbGxvd1JlY3Vyc2UgPSAhIWNiO1xuICAgIGxldCBzY2hlZHVsZXI7XG4gICAgaWYgKGZsdXNoID09PSAnc3luYycpIHtcbiAgICAgICAgc2NoZWR1bGVyID0gam9iOyAvLyB0aGUgc2NoZWR1bGVyIGZ1bmN0aW9uIGdldHMgY2FsbGVkIGRpcmVjdGx5XG4gICAgfVxuICAgIGVsc2UgaWYgKGZsdXNoID09PSAncG9zdCcpIHtcbiAgICAgICAgc2NoZWR1bGVyID0gKCkgPT4gcXVldWVQb3N0UmVuZGVyRWZmZWN0KGpvYiwgaW5zdGFuY2UgJiYgaW5zdGFuY2Uuc3VzcGVuc2UpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gZGVmYXVsdDogJ3ByZSdcbiAgICAgICAgam9iLnByZSA9IHRydWU7XG4gICAgICAgIGlmIChpbnN0YW5jZSlcbiAgICAgICAgICAgIGpvYi5pZCA9IGluc3RhbmNlLnVpZDtcbiAgICAgICAgc2NoZWR1bGVyID0gKCkgPT4gcXVldWVKb2Ioam9iKTtcbiAgICB9XG4gICAgY29uc3QgZWZmZWN0ID0gbmV3IFJlYWN0aXZlRWZmZWN0KGdldHRlciwgc2NoZWR1bGVyKTtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIGVmZmVjdC5vblRyYWNrID0gb25UcmFjaztcbiAgICAgICAgZWZmZWN0Lm9uVHJpZ2dlciA9IG9uVHJpZ2dlcjtcbiAgICB9XG4gICAgLy8gaW5pdGlhbCBydW5cbiAgICBpZiAoY2IpIHtcbiAgICAgICAgaWYgKGltbWVkaWF0ZSkge1xuICAgICAgICAgICAgam9iKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvbGRWYWx1ZSA9IGVmZmVjdC5ydW4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChmbHVzaCA9PT0gJ3Bvc3QnKSB7XG4gICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChlZmZlY3QucnVuLmJpbmQoZWZmZWN0KSwgaW5zdGFuY2UgJiYgaW5zdGFuY2Uuc3VzcGVuc2UpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZWZmZWN0LnJ1bigpO1xuICAgIH1cbiAgICBjb25zdCB1bndhdGNoID0gKCkgPT4ge1xuICAgICAgICBlZmZlY3Quc3RvcCgpO1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2Uuc2NvcGUpIHtcbiAgICAgICAgICAgIHJlbW92ZShpbnN0YW5jZS5zY29wZS5lZmZlY3RzLCBlZmZlY3QpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpZiAoc3NyQ2xlYW51cClcbiAgICAgICAgc3NyQ2xlYW51cC5wdXNoKHVud2F0Y2gpO1xuICAgIHJldHVybiB1bndhdGNoO1xufVxuLy8gdGhpcy4kd2F0Y2hcbmZ1bmN0aW9uIGluc3RhbmNlV2F0Y2goc291cmNlLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHB1YmxpY1RoaXMgPSB0aGlzLnByb3h5O1xuICAgIGNvbnN0IGdldHRlciA9IGlzU3RyaW5nKHNvdXJjZSlcbiAgICAgICAgPyBzb3VyY2UuaW5jbHVkZXMoJy4nKVxuICAgICAgICAgICAgPyBjcmVhdGVQYXRoR2V0dGVyKHB1YmxpY1RoaXMsIHNvdXJjZSlcbiAgICAgICAgICAgIDogKCkgPT4gcHVibGljVGhpc1tzb3VyY2VdXG4gICAgICAgIDogc291cmNlLmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcyk7XG4gICAgbGV0IGNiO1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICBjYiA9IHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2IgPSB2YWx1ZS5oYW5kbGVyO1xuICAgICAgICBvcHRpb25zID0gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IGN1ciA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgICBzZXRDdXJyZW50SW5zdGFuY2UodGhpcyk7XG4gICAgY29uc3QgcmVzID0gZG9XYXRjaChnZXR0ZXIsIGNiLmJpbmQocHVibGljVGhpcyksIG9wdGlvbnMpO1xuICAgIGlmIChjdXIpIHtcbiAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKGN1cik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB1bnNldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gY3JlYXRlUGF0aEdldHRlcihjdHgsIHBhdGgpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBsZXQgY3VyID0gY3R4O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aCAmJiBjdXI7IGkrKykge1xuICAgICAgICAgICAgY3VyID0gY3VyW3NlZ21lbnRzW2ldXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VyO1xuICAgIH07XG59XG5mdW5jdGlvbiB0cmF2ZXJzZSh2YWx1ZSwgc2Vlbikge1xuICAgIGlmICghaXNPYmplY3QodmFsdWUpIHx8IHZhbHVlW1wiX192X3NraXBcIiAvKiBSZWFjdGl2ZUZsYWdzLlNLSVAgKi9dKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2VlbiA9IHNlZW4gfHwgbmV3IFNldCgpO1xuICAgIGlmIChzZWVuLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZWVuLmFkZCh2YWx1ZSk7XG4gICAgaWYgKGlzUmVmKHZhbHVlKSkge1xuICAgICAgICB0cmF2ZXJzZSh2YWx1ZS52YWx1ZSwgc2Vlbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRyYXZlcnNlKHZhbHVlW2ldLCBzZWVuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc1NldCh2YWx1ZSkgfHwgaXNNYXAodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgICAgIHRyYXZlcnNlKHYsIHNlZW4pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIHRyYXZlcnNlKHZhbHVlW2tleV0sIHNlZW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdXNlVHJhbnNpdGlvblN0YXRlKCkge1xuICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICBpc01vdW50ZWQ6IGZhbHNlLFxuICAgICAgICBpc0xlYXZpbmc6IGZhbHNlLFxuICAgICAgICBpc1VubW91bnRpbmc6IGZhbHNlLFxuICAgICAgICBsZWF2aW5nVk5vZGVzOiBuZXcgTWFwKClcbiAgICB9O1xuICAgIG9uTW91bnRlZCgoKSA9PiB7XG4gICAgICAgIHN0YXRlLmlzTW91bnRlZCA9IHRydWU7XG4gICAgfSk7XG4gICAgb25CZWZvcmVVbm1vdW50KCgpID0+IHtcbiAgICAgICAgc3RhdGUuaXNVbm1vdW50aW5nID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gc3RhdGU7XG59XG5jb25zdCBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvciA9IFtGdW5jdGlvbiwgQXJyYXldO1xuY29uc3QgQmFzZVRyYW5zaXRpb25JbXBsID0ge1xuICAgIG5hbWU6IGBCYXNlVHJhbnNpdGlvbmAsXG4gICAgcHJvcHM6IHtcbiAgICAgICAgbW9kZTogU3RyaW5nLFxuICAgICAgICBhcHBlYXI6IEJvb2xlYW4sXG4gICAgICAgIHBlcnNpc3RlZDogQm9vbGVhbixcbiAgICAgICAgLy8gZW50ZXJcbiAgICAgICAgb25CZWZvcmVFbnRlcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gICAgICAgIG9uRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICAgICAgICBvbkFmdGVyRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICAgICAgICBvbkVudGVyQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgICAgICAgLy8gbGVhdmVcbiAgICAgICAgb25CZWZvcmVMZWF2ZTogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gICAgICAgIG9uTGVhdmU6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICAgICAgICBvbkFmdGVyTGVhdmU6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICAgICAgICBvbkxlYXZlQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgICAgICAgLy8gYXBwZWFyXG4gICAgICAgIG9uQmVmb3JlQXBwZWFyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgICAgICAgb25BcHBlYXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICAgICAgICBvbkFmdGVyQXBwZWFyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgICAgICAgb25BcHBlYXJDYW5jZWxsZWQ6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yXG4gICAgfSxcbiAgICBzZXR1cChwcm9wcywgeyBzbG90cyB9KSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdXNlVHJhbnNpdGlvblN0YXRlKCk7XG4gICAgICAgIGxldCBwcmV2VHJhbnNpdGlvbktleTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gc2xvdHMuZGVmYXVsdCAmJiBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oc2xvdHMuZGVmYXVsdCgpLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjaGlsZCA9IGNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgaGFzRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyBsb2NhdGUgZmlyc3Qgbm9uLWNvbW1lbnQgY2hpbGRcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGMgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBoYXNGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdhcm4gbW9yZSB0aGFuIG9uZSBub24tY29tbWVudCBjaGlsZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQgb3IgY29tcG9uZW50LiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1VzZSA8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGVyZSdzIG5vIG5lZWQgdG8gdHJhY2sgcmVhY3Rpdml0eSBmb3IgdGhlc2UgcHJvcHMgc28gdXNlIHRoZSByYXdcbiAgICAgICAgICAgIC8vIHByb3BzIGZvciBhIGJpdCBiZXR0ZXIgcGVyZlxuICAgICAgICAgICAgY29uc3QgcmF3UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XG4gICAgICAgICAgICBjb25zdCB7IG1vZGUgfSA9IHJhd1Byb3BzO1xuICAgICAgICAgICAgLy8gY2hlY2sgbW9kZVxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgICAgIG1vZGUgJiZcbiAgICAgICAgICAgICAgICBtb2RlICE9PSAnaW4tb3V0JyAmJlxuICAgICAgICAgICAgICAgIG1vZGUgIT09ICdvdXQtaW4nICYmXG4gICAgICAgICAgICAgICAgbW9kZSAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICAgICAgd2FybihgaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJHttb2RlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmlzTGVhdmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGluIHRoZSBjYXNlIG9mIDx0cmFuc2l0aW9uPjxrZWVwLWFsaXZlLz48L3RyYW5zaXRpb24+LCB3ZSBuZWVkIHRvXG4gICAgICAgICAgICAvLyBjb21wYXJlIHRoZSB0eXBlIG9mIHRoZSBrZXB0LWFsaXZlIGNoaWxkcmVuLlxuICAgICAgICAgICAgY29uc3QgaW5uZXJDaGlsZCA9IGdldEtlZXBBbGl2ZUNoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgIGlmICghaW5uZXJDaGlsZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVudGVySG9va3MgPSByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKGlubmVyQ2hpbGQsIHJhd1Byb3BzLCBzdGF0ZSwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKGlubmVyQ2hpbGQsIGVudGVySG9va3MpO1xuICAgICAgICAgICAgY29uc3Qgb2xkQ2hpbGQgPSBpbnN0YW5jZS5zdWJUcmVlO1xuICAgICAgICAgICAgY29uc3Qgb2xkSW5uZXJDaGlsZCA9IG9sZENoaWxkICYmIGdldEtlZXBBbGl2ZUNoaWxkKG9sZENoaWxkKTtcbiAgICAgICAgICAgIGxldCB0cmFuc2l0aW9uS2V5Q2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgeyBnZXRUcmFuc2l0aW9uS2V5IH0gPSBpbm5lckNoaWxkLnR5cGU7XG4gICAgICAgICAgICBpZiAoZ2V0VHJhbnNpdGlvbktleSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGdldFRyYW5zaXRpb25LZXkoKTtcbiAgICAgICAgICAgICAgICBpZiAocHJldlRyYW5zaXRpb25LZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2VHJhbnNpdGlvbktleSA9IGtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSBwcmV2VHJhbnNpdGlvbktleSkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2VHJhbnNpdGlvbktleSA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbktleUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhhbmRsZSBtb2RlXG4gICAgICAgICAgICBpZiAob2xkSW5uZXJDaGlsZCAmJlxuICAgICAgICAgICAgICAgIG9sZElubmVyQ2hpbGQudHlwZSAhPT0gQ29tbWVudCAmJlxuICAgICAgICAgICAgICAgICghaXNTYW1lVk5vZGVUeXBlKGlubmVyQ2hpbGQsIG9sZElubmVyQ2hpbGQpIHx8IHRyYW5zaXRpb25LZXlDaGFuZ2VkKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlYXZpbmdIb29rcyA9IHJlc29sdmVUcmFuc2l0aW9uSG9va3Mob2xkSW5uZXJDaGlsZCwgcmF3UHJvcHMsIHN0YXRlLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIG9sZCB0cmVlJ3MgaG9va3MgaW4gY2FzZSBvZiBkeW5hbWljIHRyYW5zaXRpb25cbiAgICAgICAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3Mob2xkSW5uZXJDaGlsZCwgbGVhdmluZ0hvb2tzKTtcbiAgICAgICAgICAgICAgICAvLyBzd2l0Y2hpbmcgYmV0d2VlbiBkaWZmZXJlbnQgdmlld3NcbiAgICAgICAgICAgICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXNMZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgICAgICAgICAgICAgIGxlYXZpbmdIb29rcy5hZnRlckxlYXZlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXNMZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAjNjgzNVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgYWxzbyBuZWVkcyB0byBiZSB1cGRhdGVkIHdoZW4gYWN0aXZlIGlzIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnVwZGF0ZS5hY3RpdmUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcgJiYgaW5uZXJDaGlsZC50eXBlICE9PSBDb21tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxlYXZpbmdIb29rcy5kZWxheUxlYXZlID0gKGVsLCBlYXJseVJlbW92ZSwgZGVsYXllZExlYXZlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKHN0YXRlLCBvbGRJbm5lckNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlYXZpbmdWTm9kZXNDYWNoZVtTdHJpbmcob2xkSW5uZXJDaGlsZC5rZXkpXSA9IG9sZElubmVyQ2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlYXJseSByZW1vdmFsIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5fbGVhdmVDYiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYXJseVJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLl9sZWF2ZUNiID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlbnRlckhvb2tzLmRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRlckhvb2tzLmRlbGF5ZWRMZWF2ZSA9IGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgIH07XG4gICAgfVxufTtcbi8vIGV4cG9ydCB0aGUgcHVibGljIHR5cGUgZm9yIGgvdHN4IGluZmVyZW5jZVxuLy8gYWxzbyB0byBhdm9pZCBpbmxpbmUgaW1wb3J0KCkgaW4gZ2VuZXJhdGVkIGQudHMgZmlsZXNcbmNvbnN0IEJhc2VUcmFuc2l0aW9uID0gQmFzZVRyYW5zaXRpb25JbXBsO1xuZnVuY3Rpb24gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShzdGF0ZSwgdm5vZGUpIHtcbiAgICBjb25zdCB7IGxlYXZpbmdWTm9kZXMgfSA9IHN0YXRlO1xuICAgIGxldCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBsZWF2aW5nVk5vZGVzLmdldCh2bm9kZS50eXBlKTtcbiAgICBpZiAoIWxlYXZpbmdWTm9kZXNDYWNoZSkge1xuICAgICAgICBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBsZWF2aW5nVk5vZGVzLnNldCh2bm9kZS50eXBlLCBsZWF2aW5nVk5vZGVzQ2FjaGUpO1xuICAgIH1cbiAgICByZXR1cm4gbGVhdmluZ1ZOb2Rlc0NhY2hlO1xufVxuLy8gVGhlIHRyYW5zaXRpb24gaG9va3MgYXJlIGF0dGFjaGVkIHRvIHRoZSB2bm9kZSBhcyB2bm9kZS50cmFuc2l0aW9uXG4vLyBhbmQgd2lsbCBiZSBjYWxsZWQgYXQgYXBwcm9wcmlhdGUgdGltaW5nIGluIHRoZSByZW5kZXJlci5cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uSG9va3Modm5vZGUsIHByb3BzLCBzdGF0ZSwgaW5zdGFuY2UpIHtcbiAgICBjb25zdCB7IGFwcGVhciwgbW9kZSwgcGVyc2lzdGVkID0gZmFsc2UsIG9uQmVmb3JlRW50ZXIsIG9uRW50ZXIsIG9uQWZ0ZXJFbnRlciwgb25FbnRlckNhbmNlbGxlZCwgb25CZWZvcmVMZWF2ZSwgb25MZWF2ZSwgb25BZnRlckxlYXZlLCBvbkxlYXZlQ2FuY2VsbGVkLCBvbkJlZm9yZUFwcGVhciwgb25BcHBlYXIsIG9uQWZ0ZXJBcHBlYXIsIG9uQXBwZWFyQ2FuY2VsbGVkIH0gPSBwcm9wcztcbiAgICBjb25zdCBrZXkgPSBTdHJpbmcodm5vZGUua2V5KTtcbiAgICBjb25zdCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKHN0YXRlLCB2bm9kZSk7XG4gICAgY29uc3QgY2FsbEhvb2sgPSAoaG9vaywgYXJncykgPT4ge1xuICAgICAgICBob29rICYmXG4gICAgICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCBpbnN0YW5jZSwgOSAvKiBFcnJvckNvZGVzLlRSQU5TSVRJT05fSE9PSyAqLywgYXJncyk7XG4gICAgfTtcbiAgICBjb25zdCBjYWxsQXN5bmNIb29rID0gKGhvb2ssIGFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgZG9uZSA9IGFyZ3NbMV07XG4gICAgICAgIGNhbGxIb29rKGhvb2ssIGFyZ3MpO1xuICAgICAgICBpZiAoaXNBcnJheShob29rKSkge1xuICAgICAgICAgICAgaWYgKGhvb2suZXZlcnkoaG9vayA9PiBob29rLmxlbmd0aCA8PSAxKSlcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaG9vay5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBob29rcyA9IHtcbiAgICAgICAgbW9kZSxcbiAgICAgICAgcGVyc2lzdGVkLFxuICAgICAgICBiZWZvcmVFbnRlcihlbCkge1xuICAgICAgICAgICAgbGV0IGhvb2sgPSBvbkJlZm9yZUVudGVyO1xuICAgICAgICAgICAgaWYgKCFzdGF0ZS5pc01vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXBwZWFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvb2sgPSBvbkJlZm9yZUFwcGVhciB8fCBvbkJlZm9yZUVudGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZvciBzYW1lIGVsZW1lbnQgKHYtc2hvdylcbiAgICAgICAgICAgIGlmIChlbC5fbGVhdmVDYikge1xuICAgICAgICAgICAgICAgIGVsLl9sZWF2ZUNiKHRydWUgLyogY2FuY2VsbGVkICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZvciB0b2dnbGVkIGVsZW1lbnQgd2l0aCBzYW1lIGtleSAodi1pZilcbiAgICAgICAgICAgIGNvbnN0IGxlYXZpbmdWTm9kZSA9IGxlYXZpbmdWTm9kZXNDYWNoZVtrZXldO1xuICAgICAgICAgICAgaWYgKGxlYXZpbmdWTm9kZSAmJlxuICAgICAgICAgICAgICAgIGlzU2FtZVZOb2RlVHlwZSh2bm9kZSwgbGVhdmluZ1ZOb2RlKSAmJlxuICAgICAgICAgICAgICAgIGxlYXZpbmdWTm9kZS5lbC5fbGVhdmVDYikge1xuICAgICAgICAgICAgICAgIC8vIGZvcmNlIGVhcmx5IHJlbW92YWwgKG5vdCBjYW5jZWxsZWQpXG4gICAgICAgICAgICAgICAgbGVhdmluZ1ZOb2RlLmVsLl9sZWF2ZUNiKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsSG9vayhob29rLCBbZWxdKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW50ZXIoZWwpIHtcbiAgICAgICAgICAgIGxldCBob29rID0gb25FbnRlcjtcbiAgICAgICAgICAgIGxldCBhZnRlckhvb2sgPSBvbkFmdGVyRW50ZXI7XG4gICAgICAgICAgICBsZXQgY2FuY2VsSG9vayA9IG9uRW50ZXJDYW5jZWxsZWQ7XG4gICAgICAgICAgICBpZiAoIXN0YXRlLmlzTW91bnRlZCkge1xuICAgICAgICAgICAgICAgIGlmIChhcHBlYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaG9vayA9IG9uQXBwZWFyIHx8IG9uRW50ZXI7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVySG9vayA9IG9uQWZ0ZXJBcHBlYXIgfHwgb25BZnRlckVudGVyO1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxIb29rID0gb25BcHBlYXJDYW5jZWxsZWQgfHwgb25FbnRlckNhbmNlbGxlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBkb25lID0gKGVsLl9lbnRlckNiID0gKGNhbmNlbGxlZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbEhvb2soY2FuY2VsSG9vaywgW2VsXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsSG9vayhhZnRlckhvb2ssIFtlbF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaG9va3MuZGVsYXllZExlYXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvb2tzLmRlbGF5ZWRMZWF2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbC5fZW50ZXJDYiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGhvb2spIHtcbiAgICAgICAgICAgICAgICBjYWxsQXN5bmNIb29rKGhvb2ssIFtlbCwgZG9uZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsZWF2ZShlbCwgcmVtb3ZlKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBTdHJpbmcodm5vZGUua2V5KTtcbiAgICAgICAgICAgIGlmIChlbC5fZW50ZXJDYikge1xuICAgICAgICAgICAgICAgIGVsLl9lbnRlckNiKHRydWUgLyogY2FuY2VsbGVkICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5pc1VubW91bnRpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsSG9vayhvbkJlZm9yZUxlYXZlLCBbZWxdKTtcbiAgICAgICAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGRvbmUgPSAoZWwuX2xlYXZlQ2IgPSAoY2FuY2VsbGVkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxlZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsSG9vayhvbkxlYXZlQ2FuY2VsbGVkLCBbZWxdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxIb29rKG9uQWZ0ZXJMZWF2ZSwgW2VsXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsLl9sZWF2ZUNiID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmIChsZWF2aW5nVk5vZGVzQ2FjaGVba2V5XSA9PT0gdm5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGxlYXZpbmdWTm9kZXNDYWNoZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGVhdmluZ1ZOb2Rlc0NhY2hlW2tleV0gPSB2bm9kZTtcbiAgICAgICAgICAgIGlmIChvbkxlYXZlKSB7XG4gICAgICAgICAgICAgICAgY2FsbEFzeW5jSG9vayhvbkxlYXZlLCBbZWwsIGRvbmVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2xvbmUodm5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKHZub2RlLCBwcm9wcywgc3RhdGUsIGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGhvb2tzO1xufVxuLy8gdGhlIHBsYWNlaG9sZGVyIHJlYWxseSBvbmx5IGhhbmRsZXMgb25lIHNwZWNpYWwgY2FzZTogS2VlcEFsaXZlXG4vLyBpbiB0aGUgY2FzZSBvZiBhIEtlZXBBbGl2ZSBpbiBhIGxlYXZlIHBoYXNlIHdlIG5lZWQgdG8gcmV0dXJuIGEgS2VlcEFsaXZlXG4vLyBwbGFjZWhvbGRlciB3aXRoIGVtcHR5IGNvbnRlbnQgdG8gYXZvaWQgdGhlIEtlZXBBbGl2ZSBpbnN0YW5jZSBmcm9tIGJlaW5nXG4vLyB1bm1vdW50ZWQuXG5mdW5jdGlvbiBlbXB0eVBsYWNlaG9sZGVyKHZub2RlKSB7XG4gICAgaWYgKGlzS2VlcEFsaXZlKHZub2RlKSkge1xuICAgICAgICB2bm9kZSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgICAgICB2bm9kZS5jaGlsZHJlbiA9IG51bGw7XG4gICAgICAgIHJldHVybiB2bm9kZTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRLZWVwQWxpdmVDaGlsZCh2bm9kZSkge1xuICAgIHJldHVybiBpc0tlZXBBbGl2ZSh2bm9kZSlcbiAgICAgICAgPyB2bm9kZS5jaGlsZHJlblxuICAgICAgICAgICAgPyB2bm9kZS5jaGlsZHJlblswXVxuICAgICAgICAgICAgOiB1bmRlZmluZWRcbiAgICAgICAgOiB2bm9kZTtcbn1cbmZ1bmN0aW9uIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZSwgaG9va3MpIHtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNiAvKiBTaGFwZUZsYWdzLkNPTVBPTkVOVCAqLyAmJiB2bm9kZS5jb21wb25lbnQpIHtcbiAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKHZub2RlLmNvbXBvbmVudC5zdWJUcmVlLCBob29rcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEyOCAvKiBTaGFwZUZsYWdzLlNVU1BFTlNFICovKSB7XG4gICAgICAgIHZub2RlLnNzQ29udGVudC50cmFuc2l0aW9uID0gaG9va3MuY2xvbmUodm5vZGUuc3NDb250ZW50KTtcbiAgICAgICAgdm5vZGUuc3NGYWxsYmFjay50cmFuc2l0aW9uID0gaG9va3MuY2xvbmUodm5vZGUuc3NGYWxsYmFjayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2bm9kZS50cmFuc2l0aW9uID0gaG9va3M7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKGNoaWxkcmVuLCBrZWVwQ29tbWVudCA9IGZhbHNlLCBwYXJlbnRLZXkpIHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgbGV0IGtleWVkRnJhZ21lbnRDb3VudCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgLy8gIzUzNjAgaW5oZXJpdCBwYXJlbnQga2V5IGluIGNhc2Ugb2YgPHRlbXBsYXRlIHYtZm9yPlxuICAgICAgICBjb25zdCBrZXkgPSBwYXJlbnRLZXkgPT0gbnVsbFxuICAgICAgICAgICAgPyBjaGlsZC5rZXlcbiAgICAgICAgICAgIDogU3RyaW5nKHBhcmVudEtleSkgKyBTdHJpbmcoY2hpbGQua2V5ICE9IG51bGwgPyBjaGlsZC5rZXkgOiBpKTtcbiAgICAgICAgLy8gaGFuZGxlIGZyYWdtZW50IGNoaWxkcmVuIGNhc2UsIGUuZy4gdi1mb3JcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IEZyYWdtZW50KSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQucGF0Y2hGbGFnICYgMTI4IC8qIFBhdGNoRmxhZ3MuS0VZRURfRlJBR01FTlQgKi8pXG4gICAgICAgICAgICAgICAga2V5ZWRGcmFnbWVudENvdW50Kys7XG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihjaGlsZC5jaGlsZHJlbiwga2VlcENvbW1lbnQsIGtleSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbW1lbnQgcGxhY2Vob2xkZXJzIHNob3VsZCBiZSBza2lwcGVkLCBlLmcuIHYtaWZcbiAgICAgICAgZWxzZSBpZiAoa2VlcENvbW1lbnQgfHwgY2hpbGQudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICAgICAgcmV0LnB1c2goa2V5ICE9IG51bGwgPyBjbG9uZVZOb2RlKGNoaWxkLCB7IGtleSB9KSA6IGNoaWxkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyAjMTEyNiBpZiBhIHRyYW5zaXRpb24gY2hpbGRyZW4gbGlzdCBjb250YWlucyBtdWx0aXBsZSBzdWIgZnJhZ21lbnRzLCB0aGVzZVxuICAgIC8vIGZyYWdtZW50cyB3aWxsIGJlIG1lcmdlZCBpbnRvIGEgZmxhdCBjaGlsZHJlbiBhcnJheS4gU2luY2UgZWFjaCB2LWZvclxuICAgIC8vIGZyYWdtZW50IG1heSBjb250YWluIGRpZmZlcmVudCBzdGF0aWMgYmluZGluZ3MgaW5zaWRlLCB3ZSBuZWVkIHRvIGRlLW9wXG4gICAgLy8gdGhlc2UgY2hpbGRyZW4gdG8gZm9yY2UgZnVsbCBkaWZmcyB0byBlbnN1cmUgY29ycmVjdCBiZWhhdmlvci5cbiAgICBpZiAoa2V5ZWRGcmFnbWVudENvdW50ID4gMSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmV0W2ldLnBhdGNoRmxhZyA9IC0yIC8qIFBhdGNoRmxhZ3MuQkFJTCAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG4vLyBpbXBsZW1lbnRhdGlvbiwgY2xvc2UgdG8gbm8tb3BcbmZ1bmN0aW9uIGRlZmluZUNvbXBvbmVudChvcHRpb25zKSB7XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24ob3B0aW9ucykgPyB7IHNldHVwOiBvcHRpb25zLCBuYW1lOiBvcHRpb25zLm5hbWUgfSA6IG9wdGlvbnM7XG59XG5cbmNvbnN0IGlzQXN5bmNXcmFwcGVyID0gKGkpID0+ICEhaS50eXBlLl9fYXN5bmNMb2FkZXI7XG5mdW5jdGlvbiBkZWZpbmVBc3luY0NvbXBvbmVudChzb3VyY2UpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihzb3VyY2UpKSB7XG4gICAgICAgIHNvdXJjZSA9IHsgbG9hZGVyOiBzb3VyY2UgfTtcbiAgICB9XG4gICAgY29uc3QgeyBsb2FkZXIsIGxvYWRpbmdDb21wb25lbnQsIGVycm9yQ29tcG9uZW50LCBkZWxheSA9IDIwMCwgdGltZW91dCwgLy8gdW5kZWZpbmVkID0gbmV2ZXIgdGltZXMgb3V0XG4gICAgc3VzcGVuc2libGUgPSB0cnVlLCBvbkVycm9yOiB1c2VyT25FcnJvciB9ID0gc291cmNlO1xuICAgIGxldCBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XG4gICAgbGV0IHJlc29sdmVkQ29tcDtcbiAgICBsZXQgcmV0cmllcyA9IDA7XG4gICAgY29uc3QgcmV0cnkgPSAoKSA9PiB7XG4gICAgICAgIHJldHJpZXMrKztcbiAgICAgICAgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xuICAgICAgICByZXR1cm4gbG9hZCgpO1xuICAgIH07XG4gICAgY29uc3QgbG9hZCA9ICgpID0+IHtcbiAgICAgICAgbGV0IHRoaXNSZXF1ZXN0O1xuICAgICAgICByZXR1cm4gKHBlbmRpbmdSZXF1ZXN0IHx8XG4gICAgICAgICAgICAodGhpc1JlcXVlc3QgPSBwZW5kaW5nUmVxdWVzdCA9XG4gICAgICAgICAgICAgICAgbG9hZGVyKClcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVyciA9IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyIDogbmV3IEVycm9yKFN0cmluZyhlcnIpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXJPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJSZXRyeSA9ICgpID0+IHJlc29sdmUocmV0cnkoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlckZhaWwgPSAoKSA9PiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyT25FcnJvcihlcnIsIHVzZXJSZXRyeSwgdXNlckZhaWwsIHJldHJpZXMgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGNvbXApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNSZXF1ZXN0ICE9PSBwZW5kaW5nUmVxdWVzdCAmJiBwZW5kaW5nUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBlbmRpbmdSZXF1ZXN0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWNvbXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEFzeW5jIGNvbXBvbmVudCBsb2FkZXIgcmVzb2x2ZWQgdG8gdW5kZWZpbmVkLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgSWYgeW91IGFyZSB1c2luZyByZXRyeSgpLCBtYWtlIHN1cmUgdG8gcmV0dXJuIGl0cyByZXR1cm4gdmFsdWUuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gaW50ZXJvcCBtb2R1bGUgZGVmYXVsdFxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGNvbXAuX19lc01vZHVsZSB8fCBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNvbXAgJiYgIWlzT2JqZWN0KGNvbXApICYmICFpc0Z1bmN0aW9uKGNvbXApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYXN5bmMgY29tcG9uZW50IGxvYWQgcmVzdWx0OiAke2NvbXB9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRDb21wID0gY29tcDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXA7XG4gICAgICAgICAgICAgICAgfSkpKTtcbiAgICB9O1xuICAgIHJldHVybiBkZWZpbmVDb21wb25lbnQoe1xuICAgICAgICBuYW1lOiAnQXN5bmNDb21wb25lbnRXcmFwcGVyJyxcbiAgICAgICAgX19hc3luY0xvYWRlcjogbG9hZCxcbiAgICAgICAgZ2V0IF9fYXN5bmNSZXNvbHZlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlZENvbXA7XG4gICAgICAgIH0sXG4gICAgICAgIHNldHVwKCkge1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgICAgICAgICAvLyBhbHJlYWR5IHJlc29sdmVkXG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRDb21wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGNyZWF0ZUlubmVyQ29tcChyZXNvbHZlZENvbXAsIGluc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIDEzIC8qIEVycm9yQ29kZXMuQVNZTkNfQ09NUE9ORU5UX0xPQURFUiAqLywgIWVycm9yQ29tcG9uZW50IC8qIGRvIG5vdCB0aHJvdyBpbiBkZXYgaWYgdXNlciBwcm92aWRlZCBlcnJvciBjb21wb25lbnQgKi8pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIHN1c3BlbnNlLWNvbnRyb2xsZWQgb3IgU1NSLlxuICAgICAgICAgICAgaWYgKChzdXNwZW5zaWJsZSAmJiBpbnN0YW5jZS5zdXNwZW5zZSkgfHxcbiAgICAgICAgICAgICAgICAoaXNJblNTUkNvbXBvbmVudFNldHVwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkKClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oY29tcCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBjcmVhdGVJbm5lckNvbXAoY29tcCwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBlcnJvckNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjcmVhdGVWTm9kZShlcnJvckNvbXBvbmVudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2FkZWQgPSByZWYoZmFsc2UpO1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSByZWYoKTtcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5ZWQgPSByZWYoISFkZWxheSk7XG4gICAgICAgICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZGVsYXllZC52YWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2FkZWQudmFsdWUgJiYgIWVycm9yLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYEFzeW5jIGNvbXBvbmVudCB0aW1lZCBvdXQgYWZ0ZXIgJHt0aW1lb3V0fW1zLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IudmFsdWUgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvYWQoKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBsb2FkZWQudmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5wYXJlbnQgJiYgaXNLZWVwQWxpdmUoaW5zdGFuY2UucGFyZW50LnZub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwYXJlbnQgaXMga2VlcC1hbGl2ZSwgZm9yY2UgdXBkYXRlIHNvIHRoZSBsb2FkZWQgY29tcG9uZW50J3NcbiAgICAgICAgICAgICAgICAgICAgLy8gbmFtZSBpcyB0YWtlbiBpbnRvIGFjY291bnRcbiAgICAgICAgICAgICAgICAgICAgcXVldWVKb2IoaW5zdGFuY2UucGFyZW50LnVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgZXJyb3IudmFsdWUgPSBlcnI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGxvYWRlZC52YWx1ZSAmJiByZXNvbHZlZENvbXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUlubmVyQ29tcChyZXNvbHZlZENvbXAsIGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IudmFsdWUgJiYgZXJyb3JDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKGVycm9yQ29tcG9uZW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxvYWRpbmdDb21wb25lbnQgJiYgIWRlbGF5ZWQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKGxvYWRpbmdDb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUlubmVyQ29tcChjb21wLCBwYXJlbnQpIHtcbiAgICBjb25zdCB7IHJlZiwgcHJvcHMsIGNoaWxkcmVuLCBjZSB9ID0gcGFyZW50LnZub2RlO1xuICAgIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUoY29tcCwgcHJvcHMsIGNoaWxkcmVuKTtcbiAgICAvLyBlbnN1cmUgaW5uZXIgY29tcG9uZW50IGluaGVyaXRzIHRoZSBhc3luYyB3cmFwcGVyJ3MgcmVmIG93bmVyXG4gICAgdm5vZGUucmVmID0gcmVmO1xuICAgIC8vIHBhc3MgdGhlIGN1c3RvbSBlbGVtZW50IGNhbGxiYWNrIG9uIHRvIHRoZSBpbm5lciBjb21wXG4gICAgLy8gYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSBhc3luYyB3cmFwcGVyXG4gICAgdm5vZGUuY2UgPSBjZTtcbiAgICBkZWxldGUgcGFyZW50LnZub2RlLmNlO1xuICAgIHJldHVybiB2bm9kZTtcbn1cblxuY29uc3QgaXNLZWVwQWxpdmUgPSAodm5vZGUpID0+IHZub2RlLnR5cGUuX19pc0tlZXBBbGl2ZTtcbmNvbnN0IEtlZXBBbGl2ZUltcGwgPSB7XG4gICAgbmFtZTogYEtlZXBBbGl2ZWAsXG4gICAgLy8gTWFya2VyIGZvciBzcGVjaWFsIGhhbmRsaW5nIGluc2lkZSB0aGUgcmVuZGVyZXIuIFdlIGFyZSBub3QgdXNpbmcgYSA9PT1cbiAgICAvLyBjaGVjayBkaXJlY3RseSBvbiBLZWVwQWxpdmUgaW4gdGhlIHJlbmRlcmVyLCBiZWNhdXNlIGltcG9ydGluZyBpdCBkaXJlY3RseVxuICAgIC8vIHdvdWxkIHByZXZlbnQgaXQgZnJvbSBiZWluZyB0cmVlLXNoYWtlbi5cbiAgICBfX2lzS2VlcEFsaXZlOiB0cnVlLFxuICAgIHByb3BzOiB7XG4gICAgICAgIGluY2x1ZGU6IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldLFxuICAgICAgICBleGNsdWRlOiBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XSxcbiAgICAgICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXG4gICAgfSxcbiAgICBzZXR1cChwcm9wcywgeyBzbG90cyB9KSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgICAgIC8vIEtlZXBBbGl2ZSBjb21tdW5pY2F0ZXMgd2l0aCB0aGUgaW5zdGFudGlhdGVkIHJlbmRlcmVyIHZpYSB0aGVcbiAgICAgICAgLy8gY3R4IHdoZXJlIHRoZSByZW5kZXJlciBwYXNzZXMgaW4gaXRzIGludGVybmFscyxcbiAgICAgICAgLy8gYW5kIHRoZSBLZWVwQWxpdmUgaW5zdGFuY2UgZXhwb3NlcyBhY3RpdmF0ZS9kZWFjdGl2YXRlIGltcGxlbWVudGF0aW9ucy5cbiAgICAgICAgLy8gVGhlIHdob2xlIHBvaW50IG9mIHRoaXMgaXMgdG8gYXZvaWQgaW1wb3J0aW5nIEtlZXBBbGl2ZSBkaXJlY3RseSBpbiB0aGVcbiAgICAgICAgLy8gcmVuZGVyZXIgdG8gZmFjaWxpdGF0ZSB0cmVlLXNoYWtpbmcuXG4gICAgICAgIGNvbnN0IHNoYXJlZENvbnRleHQgPSBpbnN0YW5jZS5jdHg7XG4gICAgICAgIC8vIGlmIHRoZSBpbnRlcm5hbCByZW5kZXJlciBpcyBub3QgcmVnaXN0ZXJlZCwgaXQgaW5kaWNhdGVzIHRoYXQgdGhpcyBpcyBzZXJ2ZXItc2lkZSByZW5kZXJpbmcsXG4gICAgICAgIC8vIGZvciBLZWVwQWxpdmUsIHdlIGp1c3QgbmVlZCB0byByZW5kZXIgaXRzIGNoaWxkcmVuXG4gICAgICAgIGlmICghc2hhcmVkQ29udGV4dC5yZW5kZXJlcikge1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgJiYgc2xvdHMuZGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgPyBjaGlsZHJlblswXSA6IGNoaWxkcmVuO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3Qga2V5cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBudWxsO1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICAgICAgaW5zdGFuY2UuX192X2NhY2hlID0gY2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50U3VzcGVuc2UgPSBpbnN0YW5jZS5zdXNwZW5zZTtcbiAgICAgICAgY29uc3QgeyByZW5kZXJlcjogeyBwOiBwYXRjaCwgbTogbW92ZSwgdW06IF91bm1vdW50LCBvOiB7IGNyZWF0ZUVsZW1lbnQgfSB9IH0gPSBzaGFyZWRDb250ZXh0O1xuICAgICAgICBjb25zdCBzdG9yYWdlQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHNoYXJlZENvbnRleHQuYWN0aXZhdGUgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRywgb3B0aW1pemVkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudDtcbiAgICAgICAgICAgIG1vdmUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCAwIC8qIE1vdmVUeXBlLkVOVEVSICovLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgICAgICAvLyBpbiBjYXNlIHByb3BzIGhhdmUgY2hhbmdlZFxuICAgICAgICAgICAgcGF0Y2goaW5zdGFuY2Uudm5vZGUsIHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgdm5vZGUuc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5pc0RlYWN0aXZhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmEpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UuYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHZub2RlSG9vayA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLm9uVm5vZGVNb3VudGVkO1xuICAgICAgICAgICAgICAgIGlmICh2bm9kZUhvb2spIHtcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgaW5zdGFuY2UucGFyZW50LCB2bm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgY29tcG9uZW50cyB0cmVlXG4gICAgICAgICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRBZGRlZChpbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHNoYXJlZENvbnRleHQuZGVhY3RpdmF0ZSA9ICh2bm9kZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnQ7XG4gICAgICAgICAgICBtb3ZlKHZub2RlLCBzdG9yYWdlQ29udGFpbmVyLCBudWxsLCAxIC8qIE1vdmVUeXBlLkxFQVZFICovLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5kYSkge1xuICAgICAgICAgICAgICAgICAgICBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5kYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHZub2RlSG9vayA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLm9uVm5vZGVVbm1vdW50ZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHZub2RlSG9vaykge1xuICAgICAgICAgICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBpbnN0YW5jZS5wYXJlbnQsIHZub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuaXNEZWFjdGl2YXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBjb21wb25lbnRzIHRyZWVcbiAgICAgICAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gdW5tb3VudCh2bm9kZSkge1xuICAgICAgICAgICAgLy8gcmVzZXQgdGhlIHNoYXBlRmxhZyBzbyBpdCBjYW4gYmUgcHJvcGVybHkgdW5tb3VudGVkXG4gICAgICAgICAgICByZXNldFNoYXBlRmxhZyh2bm9kZSk7XG4gICAgICAgICAgICBfdW5tb3VudCh2bm9kZSwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwcnVuZUNhY2hlKGZpbHRlcikge1xuICAgICAgICAgICAgY2FjaGUuZm9yRWFjaCgodm5vZGUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHZub2RlLnR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lICYmICghZmlsdGVyIHx8ICFmaWx0ZXIobmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeShrZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50IHx8IGNhY2hlZC50eXBlICE9PSBjdXJyZW50LnR5cGUpIHtcbiAgICAgICAgICAgICAgICB1bm1vdW50KGNhY2hlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gY3VycmVudCBhY3RpdmUgaW5zdGFuY2Ugc2hvdWxkIG5vIGxvbmdlciBiZSBrZXB0LWFsaXZlLlxuICAgICAgICAgICAgICAgIC8vIHdlIGNhbid0IHVubW91bnQgaXQgbm93IGJ1dCBpdCBtaWdodCBiZSBsYXRlciwgc28gcmVzZXQgaXRzIGZsYWcgbm93LlxuICAgICAgICAgICAgICAgIHJlc2V0U2hhcGVGbGFnKGN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FjaGUuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICBrZXlzLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBydW5lIGNhY2hlIG9uIGluY2x1ZGUvZXhjbHVkZSBwcm9wIGNoYW5nZVxuICAgICAgICB3YXRjaCgoKSA9PiBbcHJvcHMuaW5jbHVkZSwgcHJvcHMuZXhjbHVkZV0sIChbaW5jbHVkZSwgZXhjbHVkZV0pID0+IHtcbiAgICAgICAgICAgIGluY2x1ZGUgJiYgcHJ1bmVDYWNoZShuYW1lID0+IG1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpO1xuICAgICAgICAgICAgZXhjbHVkZSAmJiBwcnVuZUNhY2hlKG5hbWUgPT4gIW1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpO1xuICAgICAgICB9LCBcbiAgICAgICAgLy8gcHJ1bmUgcG9zdC1yZW5kZXIgYWZ0ZXIgYGN1cnJlbnRgIGhhcyBiZWVuIHVwZGF0ZWRcbiAgICAgICAgeyBmbHVzaDogJ3Bvc3QnLCBkZWVwOiB0cnVlIH0pO1xuICAgICAgICAvLyBjYWNoZSBzdWIgdHJlZSBhZnRlciByZW5kZXJcbiAgICAgICAgbGV0IHBlbmRpbmdDYWNoZUtleSA9IG51bGw7XG4gICAgICAgIGNvbnN0IGNhY2hlU3VidHJlZSA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIGZpeCAjMTYyMSwgdGhlIHBlbmRpbmdDYWNoZUtleSBjb3VsZCBiZSAwXG4gICAgICAgICAgICBpZiAocGVuZGluZ0NhY2hlS2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjYWNoZS5zZXQocGVuZGluZ0NhY2hlS2V5LCBnZXRJbm5lckNoaWxkKGluc3RhbmNlLnN1YlRyZWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgb25Nb3VudGVkKGNhY2hlU3VidHJlZSk7XG4gICAgICAgIG9uVXBkYXRlZChjYWNoZVN1YnRyZWUpO1xuICAgICAgICBvbkJlZm9yZVVubW91bnQoKCkgPT4ge1xuICAgICAgICAgICAgY2FjaGUuZm9yRWFjaChjYWNoZWQgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc3ViVHJlZSwgc3VzcGVuc2UgfSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZub2RlID0gZ2V0SW5uZXJDaGlsZChzdWJUcmVlKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkLnR5cGUgPT09IHZub2RlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudCBpbnN0YW5jZSB3aWxsIGJlIHVubW91bnRlZCBhcyBwYXJ0IG9mIGtlZXAtYWxpdmUncyB1bm1vdW50XG4gICAgICAgICAgICAgICAgICAgIHJlc2V0U2hhcGVGbGFnKHZub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGludm9rZSBpdHMgZGVhY3RpdmF0ZWQgaG9vayBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhID0gdm5vZGUuY29tcG9uZW50LmRhO1xuICAgICAgICAgICAgICAgICAgICBkYSAmJiBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoZGEsIHN1c3BlbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1bm1vdW50KGNhY2hlZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBwZW5kaW5nQ2FjaGVLZXkgPSBudWxsO1xuICAgICAgICAgICAgaWYgKCFzbG90cy5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQoKTtcbiAgICAgICAgICAgIGNvbnN0IHJhd1ZOb2RlID0gY2hpbGRyZW5bMF07XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihgS2VlcEFsaXZlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIGNvbXBvbmVudCBjaGlsZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzVk5vZGUocmF3Vk5vZGUpIHx8XG4gICAgICAgICAgICAgICAgKCEocmF3Vk5vZGUuc2hhcGVGbGFnICYgNCAvKiBTaGFwZUZsYWdzLlNUQVRFRlVMX0NPTVBPTkVOVCAqLykgJiZcbiAgICAgICAgICAgICAgICAgICAgIShyYXdWTm9kZS5zaGFwZUZsYWcgJiAxMjggLyogU2hhcGVGbGFncy5TVVNQRU5TRSAqLykpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhd1ZOb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHZub2RlID0gZ2V0SW5uZXJDaGlsZChyYXdWTm9kZSk7XG4gICAgICAgICAgICBjb25zdCBjb21wID0gdm5vZGUudHlwZTtcbiAgICAgICAgICAgIC8vIGZvciBhc3luYyBjb21wb25lbnRzLCBuYW1lIGNoZWNrIHNob3VsZCBiZSBiYXNlZCBpbiBpdHMgbG9hZGVkXG4gICAgICAgICAgICAvLyBpbm5lciBjb21wb25lbnQgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShpc0FzeW5jV3JhcHBlcih2bm9kZSlcbiAgICAgICAgICAgICAgICA/IHZub2RlLnR5cGUuX19hc3luY1Jlc29sdmVkIHx8IHt9XG4gICAgICAgICAgICAgICAgOiBjb21wKTtcbiAgICAgICAgICAgIGNvbnN0IHsgaW5jbHVkZSwgZXhjbHVkZSwgbWF4IH0gPSBwcm9wcztcbiAgICAgICAgICAgIGlmICgoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpKSB8fFxuICAgICAgICAgICAgICAgIChleGNsdWRlICYmIG5hbWUgJiYgbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSkpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gdm5vZGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhd1ZOb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qga2V5ID0gdm5vZGUua2V5ID09IG51bGwgPyBjb21wIDogdm5vZGUua2V5O1xuICAgICAgICAgICAgY29uc3QgY2FjaGVkVk5vZGUgPSBjYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgICAgIC8vIGNsb25lIHZub2RlIGlmIGl0J3MgcmV1c2VkIGJlY2F1c2Ugd2UgYXJlIGdvaW5nIHRvIG11dGF0ZSBpdFxuICAgICAgICAgICAgaWYgKHZub2RlLmVsKSB7XG4gICAgICAgICAgICAgICAgdm5vZGUgPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAocmF3Vk5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNoYXBlRmxhZ3MuU1VTUEVOU0UgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmF3Vk5vZGUuc3NDb250ZW50ID0gdm5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gIzE1MTMgaXQncyBwb3NzaWJsZSBmb3IgdGhlIHJldHVybmVkIHZub2RlIHRvIGJlIGNsb25lZCBkdWUgdG8gYXR0clxuICAgICAgICAgICAgLy8gZmFsbHRocm91Z2ggb3Igc2NvcGVJZCwgc28gdGhlIHZub2RlIGhlcmUgbWF5IG5vdCBiZSB0aGUgZmluYWwgdm5vZGVcbiAgICAgICAgICAgIC8vIHRoYXQgaXMgbW91bnRlZC4gSW5zdGVhZCBvZiBjYWNoaW5nIGl0IGRpcmVjdGx5LCB3ZSBzdG9yZSB0aGUgcGVuZGluZ1xuICAgICAgICAgICAgLy8ga2V5IGFuZCBjYWNoZSBgaW5zdGFuY2Uuc3ViVHJlZWAgKHRoZSBub3JtYWxpemVkIHZub2RlKSBpblxuICAgICAgICAgICAgLy8gYmVmb3JlTW91bnQvYmVmb3JlVXBkYXRlIGhvb2tzLlxuICAgICAgICAgICAgcGVuZGluZ0NhY2hlS2V5ID0ga2V5O1xuICAgICAgICAgICAgaWYgKGNhY2hlZFZOb2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gY29weSBvdmVyIG1vdW50ZWQgc3RhdGVcbiAgICAgICAgICAgICAgICB2bm9kZS5lbCA9IGNhY2hlZFZOb2RlLmVsO1xuICAgICAgICAgICAgICAgIHZub2RlLmNvbXBvbmVudCA9IGNhY2hlZFZOb2RlLmNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICBpZiAodm5vZGUudHJhbnNpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAvLyByZWN1cnNpdmVseSB1cGRhdGUgdHJhbnNpdGlvbiBob29rcyBvbiBzdWJUcmVlXG4gICAgICAgICAgICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZSwgdm5vZGUudHJhbnNpdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGF2b2lkIHZub2RlIGJlaW5nIG1vdW50ZWQgYXMgZnJlc2hcbiAgICAgICAgICAgICAgICB2bm9kZS5zaGFwZUZsYWcgfD0gNTEyIC8qIFNoYXBlRmxhZ3MuQ09NUE9ORU5UX0tFUFRfQUxJVkUgKi87XG4gICAgICAgICAgICAgICAgLy8gbWFrZSB0aGlzIGtleSB0aGUgZnJlc2hlc3RcbiAgICAgICAgICAgICAgICBrZXlzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgICAgIC8vIHBydW5lIG9sZGVzdCBlbnRyeVxuICAgICAgICAgICAgICAgIGlmIChtYXggJiYga2V5cy5zaXplID4gcGFyc2VJbnQobWF4LCAxMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGtleXMudmFsdWVzKCkubmV4dCgpLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhdm9pZCB2bm9kZSBiZWluZyB1bm1vdW50ZWRcbiAgICAgICAgICAgIHZub2RlLnNoYXBlRmxhZyB8PSAyNTYgLyogU2hhcGVGbGFncy5DT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi87XG4gICAgICAgICAgICBjdXJyZW50ID0gdm5vZGU7XG4gICAgICAgICAgICByZXR1cm4gaXNTdXNwZW5zZShyYXdWTm9kZS50eXBlKSA/IHJhd1ZOb2RlIDogdm5vZGU7XG4gICAgICAgIH07XG4gICAgfVxufTtcbi8vIGV4cG9ydCB0aGUgcHVibGljIHR5cGUgZm9yIGgvdHN4IGluZmVyZW5jZVxuLy8gYWxzbyB0byBhdm9pZCBpbmxpbmUgaW1wb3J0KCkgaW4gZ2VuZXJhdGVkIGQudHMgZmlsZXNcbmNvbnN0IEtlZXBBbGl2ZSA9IEtlZXBBbGl2ZUltcGw7XG5mdW5jdGlvbiBtYXRjaGVzKHBhdHRlcm4sIG5hbWUpIHtcbiAgICBpZiAoaXNBcnJheShwYXR0ZXJuKSkge1xuICAgICAgICByZXR1cm4gcGF0dGVybi5zb21lKChwKSA9PiBtYXRjaGVzKHAsIG5hbWUpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTdHJpbmcocGF0dGVybikpIHtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmNsdWRlcyhuYW1lKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGF0dGVybi50ZXN0KSB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gb25BY3RpdmF0ZWQoaG9vaywgdGFyZ2V0KSB7XG4gICAgcmVnaXN0ZXJLZWVwQWxpdmVIb29rKGhvb2ssIFwiYVwiIC8qIExpZmVjeWNsZUhvb2tzLkFDVElWQVRFRCAqLywgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIG9uRGVhY3RpdmF0ZWQoaG9vaywgdGFyZ2V0KSB7XG4gICAgcmVnaXN0ZXJLZWVwQWxpdmVIb29rKGhvb2ssIFwiZGFcIiAvKiBMaWZlY3ljbGVIb29rcy5ERUFDVElWQVRFRCAqLywgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyS2VlcEFsaXZlSG9vayhob29rLCB0eXBlLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpIHtcbiAgICAvLyBjYWNoZSB0aGUgZGVhY3RpdmF0ZSBicmFuY2ggY2hlY2sgd3JhcHBlciBmb3IgaW5qZWN0ZWQgaG9va3Mgc28gdGhlIHNhbWVcbiAgICAvLyBob29rIGNhbiBiZSBwcm9wZXJseSBkZWR1cGVkIGJ5IHRoZSBzY2hlZHVsZXIuIFwiX193ZGNcIiBzdGFuZHMgZm9yIFwid2l0aFxuICAgIC8vIGRlYWN0aXZhdGlvbiBjaGVja1wiLlxuICAgIGNvbnN0IHdyYXBwZWRIb29rID0gaG9vay5fX3dkYyB8fFxuICAgICAgICAoaG9vay5fX3dkYyA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIG9ubHkgZmlyZSB0aGUgaG9vayBpZiB0aGUgdGFyZ2V0IGluc3RhbmNlIGlzIE5PVCBpbiBhIGRlYWN0aXZhdGVkIGJyYW5jaC5cbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0O1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5pc0RlYWN0aXZhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhvb2soKTtcbiAgICAgICAgfSk7XG4gICAgaW5qZWN0SG9vayh0eXBlLCB3cmFwcGVkSG9vaywgdGFyZ2V0KTtcbiAgICAvLyBJbiBhZGRpdGlvbiB0byByZWdpc3RlcmluZyBpdCBvbiB0aGUgdGFyZ2V0IGluc3RhbmNlLCB3ZSB3YWxrIHVwIHRoZSBwYXJlbnRcbiAgICAvLyBjaGFpbiBhbmQgcmVnaXN0ZXIgaXQgb24gYWxsIGFuY2VzdG9yIGluc3RhbmNlcyB0aGF0IGFyZSBrZWVwLWFsaXZlIHJvb3RzLlxuICAgIC8vIFRoaXMgYXZvaWRzIHRoZSBuZWVkIHRvIHdhbGsgdGhlIGVudGlyZSBjb21wb25lbnQgdHJlZSB3aGVuIGludm9raW5nIHRoZXNlXG4gICAgLy8gaG9va3MsIGFuZCBtb3JlIGltcG9ydGFudGx5LCBhdm9pZHMgdGhlIG5lZWQgdG8gdHJhY2sgY2hpbGQgY29tcG9uZW50cyBpblxuICAgIC8vIGFycmF5cy5cbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0LnBhcmVudDtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudC5wYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChpc0tlZXBBbGl2ZShjdXJyZW50LnBhcmVudC52bm9kZSkpIHtcbiAgICAgICAgICAgICAgICBpbmplY3RUb0tlZXBBbGl2ZVJvb3Qod3JhcHBlZEhvb2ssIHR5cGUsIHRhcmdldCwgY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpbmplY3RUb0tlZXBBbGl2ZVJvb3QoaG9vaywgdHlwZSwgdGFyZ2V0LCBrZWVwQWxpdmVSb290KSB7XG4gICAgLy8gaW5qZWN0SG9vayB3cmFwcyB0aGUgb3JpZ2luYWwgZm9yIGVycm9yIGhhbmRsaW5nLCBzbyBtYWtlIHN1cmUgdG8gcmVtb3ZlXG4gICAgLy8gdGhlIHdyYXBwZWQgdmVyc2lvbi5cbiAgICBjb25zdCBpbmplY3RlZCA9IGluamVjdEhvb2sodHlwZSwgaG9vaywga2VlcEFsaXZlUm9vdCwgdHJ1ZSAvKiBwcmVwZW5kICovKTtcbiAgICBvblVubW91bnRlZCgoKSA9PiB7XG4gICAgICAgIHJlbW92ZShrZWVwQWxpdmVSb290W3R5cGVdLCBpbmplY3RlZCk7XG4gICAgfSwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIHJlc2V0U2hhcGVGbGFnKHZub2RlKSB7XG4gICAgLy8gYml0d2lzZSBvcGVyYXRpb25zIHRvIHJlbW92ZSBrZWVwIGFsaXZlIGZsYWdzXG4gICAgdm5vZGUuc2hhcGVGbGFnICY9IH4yNTYgLyogU2hhcGVGbGFncy5DT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi87XG4gICAgdm5vZGUuc2hhcGVGbGFnICY9IH41MTIgLyogU2hhcGVGbGFncy5DT01QT05FTlRfS0VQVF9BTElWRSAqLztcbn1cbmZ1bmN0aW9uIGdldElubmVyQ2hpbGQodm5vZGUpIHtcbiAgICByZXR1cm4gdm5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNoYXBlRmxhZ3MuU1VTUEVOU0UgKi8gPyB2bm9kZS5zc0NvbnRlbnQgOiB2bm9kZTtcbn1cblxuZnVuY3Rpb24gaW5qZWN0SG9vayh0eXBlLCBob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UsIHByZXBlbmQgPSBmYWxzZSkge1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgaG9va3MgPSB0YXJnZXRbdHlwZV0gfHwgKHRhcmdldFt0eXBlXSA9IFtdKTtcbiAgICAgICAgLy8gY2FjaGUgdGhlIGVycm9yIGhhbmRsaW5nIHdyYXBwZXIgZm9yIGluamVjdGVkIGhvb2tzIHNvIHRoZSBzYW1lIGhvb2tcbiAgICAgICAgLy8gY2FuIGJlIHByb3Blcmx5IGRlZHVwZWQgYnkgdGhlIHNjaGVkdWxlci4gXCJfX3dlaFwiIHN0YW5kcyBmb3IgXCJ3aXRoIGVycm9yXG4gICAgICAgIC8vIGhhbmRsaW5nXCIuXG4gICAgICAgIGNvbnN0IHdyYXBwZWRIb29rID0gaG9vay5fX3dlaCB8fFxuICAgICAgICAgICAgKGhvb2suX193ZWggPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuaXNVbm1vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkaXNhYmxlIHRyYWNraW5nIGluc2lkZSBhbGwgbGlmZWN5Y2xlIGhvb2tzXG4gICAgICAgICAgICAgICAgLy8gc2luY2UgdGhleSBjYW4gcG90ZW50aWFsbHkgYmUgY2FsbGVkIGluc2lkZSBlZmZlY3RzLlxuICAgICAgICAgICAgICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICAgICAgICAgICAgICAvLyBTZXQgY3VycmVudEluc3RhbmNlIGR1cmluZyBob29rIGludm9jYXRpb24uXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBhc3N1bWVzIHRoZSBob29rIGRvZXMgbm90IHN5bmNocm9ub3VzbHkgdHJpZ2dlciBvdGhlciBob29rcywgd2hpY2hcbiAgICAgICAgICAgICAgICAvLyBjYW4gb25seSBiZSBmYWxzZSB3aGVuIHRoZSB1c2VyIGRvZXMgc29tZXRoaW5nIHJlYWxseSBmdW5reS5cbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2UodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCB0YXJnZXQsIHR5cGUsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIHVuc2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgcmVzZXRUcmFja2luZygpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByZXBlbmQpIHtcbiAgICAgICAgICAgIGhvb2tzLnVuc2hpZnQod3JhcHBlZEhvb2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaG9va3MucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyYXBwZWRIb29rO1xuICAgIH1cbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgY29uc3QgYXBpTmFtZSA9IHRvSGFuZGxlcktleShFcnJvclR5cGVTdHJpbmdzW3R5cGVdLnJlcGxhY2UoLyBob29rJC8sICcnKSk7XG4gICAgICAgIHdhcm4oYCR7YXBpTmFtZX0gaXMgY2FsbGVkIHdoZW4gdGhlcmUgaXMgbm8gYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZSB0byBiZSBgICtcbiAgICAgICAgICAgIGBhc3NvY2lhdGVkIHdpdGguIGAgK1xuICAgICAgICAgICAgYExpZmVjeWNsZSBpbmplY3Rpb24gQVBJcyBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBleGVjdXRpb24gb2Ygc2V0dXAoKS5gICtcbiAgICAgICAgICAgIChgIElmIHlvdSBhcmUgdXNpbmcgYXN5bmMgc2V0dXAoKSwgbWFrZSBzdXJlIHRvIHJlZ2lzdGVyIGxpZmVjeWNsZSBgICtcbiAgICAgICAgICAgICAgICAgICAgYGhvb2tzIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQgc3RhdGVtZW50LmBcbiAgICAgICAgICAgICAgICApKTtcbiAgICB9XG59XG5jb25zdCBjcmVhdGVIb29rID0gKGxpZmVjeWNsZSkgPT4gKGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkgPT4gXG4vLyBwb3N0LWNyZWF0ZSBsaWZlY3ljbGUgcmVnaXN0cmF0aW9ucyBhcmUgbm9vcHMgZHVyaW5nIFNTUiAoZXhjZXB0IGZvciBzZXJ2ZXJQcmVmZXRjaClcbighaXNJblNTUkNvbXBvbmVudFNldHVwIHx8IGxpZmVjeWNsZSA9PT0gXCJzcFwiIC8qIExpZmVjeWNsZUhvb2tzLlNFUlZFUl9QUkVGRVRDSCAqLykgJiZcbiAgICBpbmplY3RIb29rKGxpZmVjeWNsZSwgKC4uLmFyZ3MpID0+IGhvb2soLi4uYXJncyksIHRhcmdldCk7XG5jb25zdCBvbkJlZm9yZU1vdW50ID0gY3JlYXRlSG9vayhcImJtXCIgLyogTGlmZWN5Y2xlSG9va3MuQkVGT1JFX01PVU5UICovKTtcbmNvbnN0IG9uTW91bnRlZCA9IGNyZWF0ZUhvb2soXCJtXCIgLyogTGlmZWN5Y2xlSG9va3MuTU9VTlRFRCAqLyk7XG5jb25zdCBvbkJlZm9yZVVwZGF0ZSA9IGNyZWF0ZUhvb2soXCJidVwiIC8qIExpZmVjeWNsZUhvb2tzLkJFRk9SRV9VUERBVEUgKi8pO1xuY29uc3Qgb25VcGRhdGVkID0gY3JlYXRlSG9vayhcInVcIiAvKiBMaWZlY3ljbGVIb29rcy5VUERBVEVEICovKTtcbmNvbnN0IG9uQmVmb3JlVW5tb3VudCA9IGNyZWF0ZUhvb2soXCJidW1cIiAvKiBMaWZlY3ljbGVIb29rcy5CRUZPUkVfVU5NT1VOVCAqLyk7XG5jb25zdCBvblVubW91bnRlZCA9IGNyZWF0ZUhvb2soXCJ1bVwiIC8qIExpZmVjeWNsZUhvb2tzLlVOTU9VTlRFRCAqLyk7XG5jb25zdCBvblNlcnZlclByZWZldGNoID0gY3JlYXRlSG9vayhcInNwXCIgLyogTGlmZWN5Y2xlSG9va3MuU0VSVkVSX1BSRUZFVENIICovKTtcbmNvbnN0IG9uUmVuZGVyVHJpZ2dlcmVkID0gY3JlYXRlSG9vayhcInJ0Z1wiIC8qIExpZmVjeWNsZUhvb2tzLlJFTkRFUl9UUklHR0VSRUQgKi8pO1xuY29uc3Qgb25SZW5kZXJUcmFja2VkID0gY3JlYXRlSG9vayhcInJ0Y1wiIC8qIExpZmVjeWNsZUhvb2tzLlJFTkRFUl9UUkFDS0VEICovKTtcbmZ1bmN0aW9uIG9uRXJyb3JDYXB0dXJlZChob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpIHtcbiAgICBpbmplY3RIb29rKFwiZWNcIiAvKiBMaWZlY3ljbGVIb29rcy5FUlJPUl9DQVBUVVJFRCAqLywgaG9vaywgdGFyZ2V0KTtcbn1cblxuLyoqXG5SdW50aW1lIGhlbHBlciBmb3IgYXBwbHlpbmcgZGlyZWN0aXZlcyB0byBhIHZub2RlLiBFeGFtcGxlIHVzYWdlOlxuXG5jb25zdCBjb21wID0gcmVzb2x2ZUNvbXBvbmVudCgnY29tcCcpXG5jb25zdCBmb28gPSByZXNvbHZlRGlyZWN0aXZlKCdmb28nKVxuY29uc3QgYmFyID0gcmVzb2x2ZURpcmVjdGl2ZSgnYmFyJylcblxucmV0dXJuIHdpdGhEaXJlY3RpdmVzKGgoY29tcCksIFtcbiAgW2ZvbywgdGhpcy54XSxcbiAgW2JhciwgdGhpcy55XVxuXSlcbiovXG5mdW5jdGlvbiB2YWxpZGF0ZURpcmVjdGl2ZU5hbWUobmFtZSkge1xuICAgIGlmIChpc0J1aWx0SW5EaXJlY3RpdmUobmFtZSkpIHtcbiAgICAgICAgd2FybignRG8gbm90IHVzZSBidWlsdC1pbiBkaXJlY3RpdmUgaWRzIGFzIGN1c3RvbSBkaXJlY3RpdmUgaWQ6ICcgKyBuYW1lKTtcbiAgICB9XG59XG4vKipcbiAqIEFkZHMgZGlyZWN0aXZlcyB0byBhIFZOb2RlLlxuICovXG5mdW5jdGlvbiB3aXRoRGlyZWN0aXZlcyh2bm9kZSwgZGlyZWN0aXZlcykge1xuICAgIGNvbnN0IGludGVybmFsSW5zdGFuY2UgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4oYHdpdGhEaXJlY3RpdmVzIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHJlbmRlciBmdW5jdGlvbnMuYCk7XG4gICAgICAgIHJldHVybiB2bm9kZTtcbiAgICB9XG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRFeHBvc2VQcm94eShpbnRlcm5hbEluc3RhbmNlKSB8fFxuICAgICAgICBpbnRlcm5hbEluc3RhbmNlLnByb3h5O1xuICAgIGNvbnN0IGJpbmRpbmdzID0gdm5vZGUuZGlycyB8fCAodm5vZGUuZGlycyA9IFtdKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpcmVjdGl2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IFtkaXIsIHZhbHVlLCBhcmcsIG1vZGlmaWVycyA9IEVNUFRZX09CSl0gPSBkaXJlY3RpdmVzW2ldO1xuICAgICAgICBpZiAoZGlyKSB7XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihkaXIpKSB7XG4gICAgICAgICAgICAgICAgZGlyID0ge1xuICAgICAgICAgICAgICAgICAgICBtb3VudGVkOiBkaXIsXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQ6IGRpclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlyLmRlZXApIHtcbiAgICAgICAgICAgICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICAgICAgICBkaXIsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgb2xkVmFsdWU6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBhcmcsXG4gICAgICAgICAgICAgICAgbW9kaWZpZXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm5vZGU7XG59XG5mdW5jdGlvbiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBwcmV2Vk5vZGUsIGluc3RhbmNlLCBuYW1lKSB7XG4gICAgY29uc3QgYmluZGluZ3MgPSB2bm9kZS5kaXJzO1xuICAgIGNvbnN0IG9sZEJpbmRpbmdzID0gcHJldlZOb2RlICYmIHByZXZWTm9kZS5kaXJzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYmluZGluZyA9IGJpbmRpbmdzW2ldO1xuICAgICAgICBpZiAob2xkQmluZGluZ3MpIHtcbiAgICAgICAgICAgIGJpbmRpbmcub2xkVmFsdWUgPSBvbGRCaW5kaW5nc1tpXS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaG9vayA9IGJpbmRpbmcuZGlyW25hbWVdO1xuICAgICAgICBpZiAoaG9vaykge1xuICAgICAgICAgICAgLy8gZGlzYWJsZSB0cmFja2luZyBpbnNpZGUgYWxsIGxpZmVjeWNsZSBob29rc1xuICAgICAgICAgICAgLy8gc2luY2UgdGhleSBjYW4gcG90ZW50aWFsbHkgYmUgY2FsbGVkIGluc2lkZSBlZmZlY3RzLlxuICAgICAgICAgICAgcGF1c2VUcmFja2luZygpO1xuICAgICAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgaW5zdGFuY2UsIDggLyogRXJyb3JDb2Rlcy5ESVJFQ1RJVkVfSE9PSyAqLywgW1xuICAgICAgICAgICAgICAgIHZub2RlLmVsLFxuICAgICAgICAgICAgICAgIGJpbmRpbmcsXG4gICAgICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICAgICAgcHJldlZOb2RlXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgQ09NUE9ORU5UUyA9ICdjb21wb25lbnRzJztcbmNvbnN0IERJUkVDVElWRVMgPSAnZGlyZWN0aXZlcyc7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnQobmFtZSwgbWF5YmVTZWxmUmVmZXJlbmNlKSB7XG4gICAgcmV0dXJuIHJlc29sdmVBc3NldChDT01QT05FTlRTLCBuYW1lLCB0cnVlLCBtYXliZVNlbGZSZWZlcmVuY2UpIHx8IG5hbWU7XG59XG5jb25zdCBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UID0gU3ltYm9sKCk7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVEeW5hbWljQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgIGlmIChpc1N0cmluZyhjb21wb25lbnQpKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlQXNzZXQoQ09NUE9ORU5UUywgY29tcG9uZW50LCBmYWxzZSkgfHwgY29tcG9uZW50O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gaW52YWxpZCB0eXBlcyB3aWxsIGZhbGx0aHJvdWdoIHRvIGNyZWF0ZVZOb2RlIGFuZCByYWlzZSB3YXJuaW5nXG4gICAgICAgIHJldHVybiAoY29tcG9uZW50IHx8IE5VTExfRFlOQU1JQ19DT01QT05FTlQpO1xuICAgIH1cbn1cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZURpcmVjdGl2ZShuYW1lKSB7XG4gICAgcmV0dXJuIHJlc29sdmVBc3NldChESVJFQ1RJVkVTLCBuYW1lKTtcbn1cbi8vIGltcGxlbWVudGF0aW9uXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQodHlwZSwgbmFtZSwgd2Fybk1pc3NpbmcgPSB0cnVlLCBtYXliZVNlbGZSZWZlcmVuY2UgPSBmYWxzZSkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlIHx8IGN1cnJlbnRJbnN0YW5jZTtcbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcbiAgICAgICAgLy8gZXhwbGljaXQgc2VsZiBuYW1lIGhhcyBoaWdoZXN0IHByaW9yaXR5XG4gICAgICAgIGlmICh0eXBlID09PSBDT01QT05FTlRTKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxmTmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50LCBmYWxzZSAvKiBkbyBub3QgaW5jbHVkZSBpbmZlcnJlZCBuYW1lIHRvIGF2b2lkIGJyZWFraW5nIGV4aXN0aW5nIGNvZGUgKi8pO1xuICAgICAgICAgICAgaWYgKHNlbGZOYW1lICYmXG4gICAgICAgICAgICAgICAgKHNlbGZOYW1lID09PSBuYW1lIHx8XG4gICAgICAgICAgICAgICAgICAgIHNlbGZOYW1lID09PSBjYW1lbGl6ZShuYW1lKSB8fFxuICAgICAgICAgICAgICAgICAgICBzZWxmTmFtZSA9PT0gY2FwaXRhbGl6ZShjYW1lbGl6ZShuYW1lKSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbXBvbmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSBcbiAgICAgICAgLy8gbG9jYWwgcmVnaXN0cmF0aW9uXG4gICAgICAgIC8vIGNoZWNrIGluc3RhbmNlW3R5cGVdIGZpcnN0IHdoaWNoIGlzIHJlc29sdmVkIGZvciBvcHRpb25zIEFQSVxuICAgICAgICByZXNvbHZlKGluc3RhbmNlW3R5cGVdIHx8IENvbXBvbmVudFt0eXBlXSwgbmFtZSkgfHxcbiAgICAgICAgICAgIC8vIGdsb2JhbCByZWdpc3RyYXRpb25cbiAgICAgICAgICAgIHJlc29sdmUoaW5zdGFuY2UuYXBwQ29udGV4dFt0eXBlXSwgbmFtZSk7XG4gICAgICAgIGlmICghcmVzICYmIG1heWJlU2VsZlJlZmVyZW5jZSkge1xuICAgICAgICAgICAgLy8gZmFsbGJhY2sgdG8gaW1wbGljaXQgc2VsZi1yZWZlcmVuY2VcbiAgICAgICAgICAgIHJldHVybiBDb21wb25lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgICAgICAgICBjb25zdCBleHRyYSA9IHR5cGUgPT09IENPTVBPTkVOVFNcbiAgICAgICAgICAgICAgICA/IGBcXG5JZiB0aGlzIGlzIGEgbmF0aXZlIGN1c3RvbSBlbGVtZW50LCBtYWtlIHN1cmUgdG8gZXhjbHVkZSBpdCBmcm9tIGAgK1xuICAgICAgICAgICAgICAgICAgICBgY29tcG9uZW50IHJlc29sdXRpb24gdmlhIGNvbXBpbGVyT3B0aW9ucy5pc0N1c3RvbUVsZW1lbnQuYFxuICAgICAgICAgICAgICAgIDogYGA7XG4gICAgICAgICAgICB3YXJuKGBGYWlsZWQgdG8gcmVzb2x2ZSAke3R5cGUuc2xpY2UoMCwgLTEpfTogJHtuYW1lfSR7ZXh0cmF9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIHdhcm4oYHJlc29sdmUke2NhcGl0YWxpemUodHlwZS5zbGljZSgwLCAtMSkpfSBgICtcbiAgICAgICAgICAgIGBjYW4gb25seSBiZSB1c2VkIGluIHJlbmRlcigpIG9yIHNldHVwKCkuYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZShyZWdpc3RyeSwgbmFtZSkge1xuICAgIHJldHVybiAocmVnaXN0cnkgJiZcbiAgICAgICAgKHJlZ2lzdHJ5W25hbWVdIHx8XG4gICAgICAgICAgICByZWdpc3RyeVtjYW1lbGl6ZShuYW1lKV0gfHxcbiAgICAgICAgICAgIHJlZ2lzdHJ5W2NhcGl0YWxpemUoY2FtZWxpemUobmFtZSkpXSkpO1xufVxuXG4vKipcbiAqIEFjdHVhbCBpbXBsZW1lbnRhdGlvblxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0KHNvdXJjZSwgcmVuZGVySXRlbSwgY2FjaGUsIGluZGV4KSB7XG4gICAgbGV0IHJldDtcbiAgICBjb25zdCBjYWNoZWQgPSAoY2FjaGUgJiYgY2FjaGVbaW5kZXhdKTtcbiAgICBpZiAoaXNBcnJheShzb3VyY2UpIHx8IGlzU3RyaW5nKHNvdXJjZSkpIHtcbiAgICAgICAgcmV0ID0gbmV3IEFycmF5KHNvdXJjZS5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oc291cmNlW2ldLCBpLCB1bmRlZmluZWQsIGNhY2hlZCAmJiBjYWNoZWRbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIU51bWJlci5pc0ludGVnZXIoc291cmNlKSkge1xuICAgICAgICAgICAgd2FybihgVGhlIHYtZm9yIHJhbmdlIGV4cGVjdCBhbiBpbnRlZ2VyIHZhbHVlIGJ1dCBnb3QgJHtzb3VyY2V9LmApO1xuICAgICAgICB9XG4gICAgICAgIHJldCA9IG5ldyBBcnJheShzb3VyY2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZTsgaSsrKSB7XG4gICAgICAgICAgICByZXRbaV0gPSByZW5kZXJJdGVtKGkgKyAxLCBpLCB1bmRlZmluZWQsIGNhY2hlZCAmJiBjYWNoZWRbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgICAgaWYgKHNvdXJjZVtTeW1ib2wuaXRlcmF0b3JdKSB7XG4gICAgICAgICAgICByZXQgPSBBcnJheS5mcm9tKHNvdXJjZSwgKGl0ZW0sIGkpID0+IHJlbmRlckl0ZW0oaXRlbSwgaSwgdW5kZWZpbmVkLCBjYWNoZWQgJiYgY2FjaGVkW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICAgICAgICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICByZXRbaV0gPSByZW5kZXJJdGVtKHNvdXJjZVtrZXldLCBrZXksIGksIGNhY2hlZCAmJiBjYWNoZWRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXQgPSBbXTtcbiAgICB9XG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICAgIGNhY2hlW2luZGV4XSA9IHJldDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBDb21waWxlciBydW50aW1lIGhlbHBlciBmb3IgY3JlYXRpbmcgZHluYW1pYyBzbG90cyBvYmplY3RcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNsb3RzKHNsb3RzLCBkeW5hbWljU2xvdHMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGR5bmFtaWNTbG90cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBzbG90ID0gZHluYW1pY1Nsb3RzW2ldO1xuICAgICAgICAvLyBhcnJheSBvZiBkeW5hbWljIHNsb3QgZ2VuZXJhdGVkIGJ5IDx0ZW1wbGF0ZSB2LWZvcj1cIi4uLlwiICNbLi4uXT5cbiAgICAgICAgaWYgKGlzQXJyYXkoc2xvdCkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2xvdC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHNsb3RzW3Nsb3Rbal0ubmFtZV0gPSBzbG90W2pdLmZuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNsb3QpIHtcbiAgICAgICAgICAgIC8vIGNvbmRpdGlvbmFsIHNpbmdsZSBzbG90IGdlbmVyYXRlZCBieSA8dGVtcGxhdGUgdi1pZj1cIi4uLlwiICNmb28+XG4gICAgICAgICAgICBzbG90c1tzbG90Lm5hbWVdID0gc2xvdC5rZXlcbiAgICAgICAgICAgICAgICA/ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IHNsb3QuZm4oLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGF0dGFjaCBicmFuY2gga2V5IHNvIGVhY2ggY29uZGl0aW9uYWwgYnJhbmNoIGlzIGNvbnNpZGVyZWQgYVxuICAgICAgICAgICAgICAgICAgICAvLyBkaWZmZXJlbnQgZnJhZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5rZXkgPSBzbG90LmtleTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiBzbG90LmZuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzbG90cztcbn1cblxuLyoqXG4gKiBDb21waWxlciBydW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIGA8c2xvdC8+YFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVuZGVyU2xvdChzbG90cywgbmFtZSwgcHJvcHMgPSB7fSwgXG4vLyB0aGlzIGlzIG5vdCBhIHVzZXItZmFjaW5nIGZ1bmN0aW9uLCBzbyB0aGUgZmFsbGJhY2sgaXMgYWx3YXlzIGdlbmVyYXRlZCBieVxuLy8gdGhlIGNvbXBpbGVyIGFuZCBndWFyYW50ZWVkIHRvIGJlIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGFuIGFycmF5XG5mYWxsYmFjaywgbm9TbG90dGVkKSB7XG4gICAgaWYgKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5pc0NFIHx8XG4gICAgICAgIChjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UucGFyZW50ICYmXG4gICAgICAgICAgICBpc0FzeW5jV3JhcHBlcihjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UucGFyZW50KSAmJlxuICAgICAgICAgICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLnBhcmVudC5pc0NFKSkge1xuICAgICAgICBpZiAobmFtZSAhPT0gJ2RlZmF1bHQnKVxuICAgICAgICAgICAgcHJvcHMubmFtZSA9IG5hbWU7XG4gICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSgnc2xvdCcsIHByb3BzLCBmYWxsYmFjayAmJiBmYWxsYmFjaygpKTtcbiAgICB9XG4gICAgbGV0IHNsb3QgPSBzbG90c1tuYW1lXTtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHNsb3QgJiYgc2xvdC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHdhcm4oYFNTUi1vcHRpbWl6ZWQgc2xvdCBmdW5jdGlvbiBkZXRlY3RlZCBpbiBhIG5vbi1TU1Itb3B0aW1pemVkIHJlbmRlciBgICtcbiAgICAgICAgICAgIGBmdW5jdGlvbi4gWW91IG5lZWQgdG8gbWFyayB0aGlzIGNvbXBvbmVudCB3aXRoICRkeW5hbWljLXNsb3RzIGluIHRoZSBgICtcbiAgICAgICAgICAgIGBwYXJlbnQgdGVtcGxhdGUuYCk7XG4gICAgICAgIHNsb3QgPSAoKSA9PiBbXTtcbiAgICB9XG4gICAgLy8gYSBjb21waWxlZCBzbG90IGRpc2FibGVzIGJsb2NrIHRyYWNraW5nIGJ5IGRlZmF1bHQgdG8gYXZvaWQgbWFudWFsXG4gICAgLy8gaW52b2NhdGlvbiBpbnRlcmZlcmluZyB3aXRoIHRlbXBsYXRlLWJhc2VkIGJsb2NrIHRyYWNraW5nLCBidXQgaW5cbiAgICAvLyBgcmVuZGVyU2xvdGAgd2UgY2FuIGJlIHN1cmUgdGhhdCBpdCdzIHRlbXBsYXRlLWJhc2VkIHNvIHdlIGNhbiBmb3JjZVxuICAgIC8vIGVuYWJsZSBpdC5cbiAgICBpZiAoc2xvdCAmJiBzbG90Ll9jKSB7XG4gICAgICAgIHNsb3QuX2QgPSBmYWxzZTtcbiAgICB9XG4gICAgb3BlbkJsb2NrKCk7XG4gICAgY29uc3QgdmFsaWRTbG90Q29udGVudCA9IHNsb3QgJiYgZW5zdXJlVmFsaWRWTm9kZShzbG90KHByb3BzKSk7XG4gICAgY29uc3QgcmVuZGVyZWQgPSBjcmVhdGVCbG9jayhGcmFnbWVudCwge1xuICAgICAgICBrZXk6IHByb3BzLmtleSB8fFxuICAgICAgICAgICAgLy8gc2xvdCBjb250ZW50IGFycmF5IG9mIGEgZHluYW1pYyBjb25kaXRpb25hbCBzbG90IG1heSBoYXZlIGEgYnJhbmNoXG4gICAgICAgICAgICAvLyBrZXkgYXR0YWNoZWQgaW4gdGhlIGBjcmVhdGVTbG90c2AgaGVscGVyLCByZXNwZWN0IHRoYXRcbiAgICAgICAgICAgICh2YWxpZFNsb3RDb250ZW50ICYmIHZhbGlkU2xvdENvbnRlbnQua2V5KSB8fFxuICAgICAgICAgICAgYF8ke25hbWV9YFxuICAgIH0sIHZhbGlkU2xvdENvbnRlbnQgfHwgKGZhbGxiYWNrID8gZmFsbGJhY2soKSA6IFtdKSwgdmFsaWRTbG90Q29udGVudCAmJiBzbG90cy5fID09PSAxIC8qIFNsb3RGbGFncy5TVEFCTEUgKi9cbiAgICAgICAgPyA2NCAvKiBQYXRjaEZsYWdzLlNUQUJMRV9GUkFHTUVOVCAqL1xuICAgICAgICA6IC0yIC8qIFBhdGNoRmxhZ3MuQkFJTCAqLyk7XG4gICAgaWYgKCFub1Nsb3R0ZWQgJiYgcmVuZGVyZWQuc2NvcGVJZCkge1xuICAgICAgICByZW5kZXJlZC5zbG90U2NvcGVJZHMgPSBbcmVuZGVyZWQuc2NvcGVJZCArICctcyddO1xuICAgIH1cbiAgICBpZiAoc2xvdCAmJiBzbG90Ll9jKSB7XG4gICAgICAgIHNsb3QuX2QgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVuZGVyZWQ7XG59XG5mdW5jdGlvbiBlbnN1cmVWYWxpZFZOb2RlKHZub2Rlcykge1xuICAgIHJldHVybiB2bm9kZXMuc29tZShjaGlsZCA9PiB7XG4gICAgICAgIGlmICghaXNWTm9kZShjaGlsZCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IENvbW1lbnQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSBGcmFnbWVudCAmJlxuICAgICAgICAgICAgIWVuc3VyZVZhbGlkVk5vZGUoY2hpbGQuY2hpbGRyZW4pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KVxuICAgICAgICA/IHZub2Rlc1xuICAgICAgICA6IG51bGw7XG59XG5cbi8qKlxuICogRm9yIHByZWZpeGluZyBrZXlzIGluIHYtb249XCJvYmpcIiB3aXRoIFwib25cIlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdG9IYW5kbGVycyhvYmosIHByZXNlcnZlQ2FzZUlmTmVjZXNzYXJ5KSB7XG4gICAgY29uc3QgcmV0ID0ge307XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNPYmplY3Qob2JqKSkge1xuICAgICAgICB3YXJuKGB2LW9uIHdpdGggbm8gYXJndW1lbnQgZXhwZWN0cyBhbiBvYmplY3QgdmFsdWUuYCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICByZXRbcHJlc2VydmVDYXNlSWZOZWNlc3NhcnkgJiYgL1tBLVpdLy50ZXN0KGtleSlcbiAgICAgICAgICAgID8gYG9uOiR7a2V5fWBcbiAgICAgICAgICAgIDogdG9IYW5kbGVyS2V5KGtleSldID0gb2JqW2tleV07XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogIzI0MzcgSW4gVnVlIDMsIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBkbyBub3QgaGF2ZSBhIHB1YmxpYyBpbnN0YW5jZSBwcm94eSBidXRcbiAqIHRoZXkgZXhpc3QgaW4gdGhlIGludGVybmFsIHBhcmVudCBjaGFpbi4gRm9yIGNvZGUgdGhhdCByZWxpZXMgb24gdHJhdmVyc2luZ1xuICogcHVibGljICRwYXJlbnQgY2hhaW5zLCBza2lwIGZ1bmN0aW9uYWwgb25lcyBhbmQgZ28gdG8gdGhlIHBhcmVudCBpbnN0ZWFkLlxuICovXG5jb25zdCBnZXRQdWJsaWNJbnN0YW5jZSA9IChpKSA9PiB7XG4gICAgaWYgKCFpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoaXNTdGF0ZWZ1bENvbXBvbmVudChpKSlcbiAgICAgICAgcmV0dXJuIGdldEV4cG9zZVByb3h5KGkpIHx8IGkucHJveHk7XG4gICAgcmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGkucGFyZW50KTtcbn07XG5jb25zdCBwdWJsaWNQcm9wZXJ0aWVzTWFwID0gXG4vLyBNb3ZlIFBVUkUgbWFya2VyIHRvIG5ldyBsaW5lIHRvIHdvcmthcm91bmQgY29tcGlsZXIgZGlzY2FyZGluZyBpdFxuLy8gZHVlIHRvIHR5cGUgYW5ub3RhdGlvblxuLyojX19QVVJFX18qLyBleHRlbmQoT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICAgICQ6IGkgPT4gaSxcbiAgICAkZWw6IGkgPT4gaS52bm9kZS5lbCxcbiAgICAkZGF0YTogaSA9PiBpLmRhdGEsXG4gICAgJHByb3BzOiBpID0+ICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBzaGFsbG93UmVhZG9ubHkoaS5wcm9wcykgOiBpLnByb3BzKSxcbiAgICAkYXR0cnM6IGkgPT4gKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IHNoYWxsb3dSZWFkb25seShpLmF0dHJzKSA6IGkuYXR0cnMpLFxuICAgICRzbG90czogaSA9PiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gc2hhbGxvd1JlYWRvbmx5KGkuc2xvdHMpIDogaS5zbG90cyksXG4gICAgJHJlZnM6IGkgPT4gKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IHNoYWxsb3dSZWFkb25seShpLnJlZnMpIDogaS5yZWZzKSxcbiAgICAkcGFyZW50OiBpID0+IGdldFB1YmxpY0luc3RhbmNlKGkucGFyZW50KSxcbiAgICAkcm9vdDogaSA9PiBnZXRQdWJsaWNJbnN0YW5jZShpLnJvb3QpLFxuICAgICRlbWl0OiBpID0+IGkuZW1pdCxcbiAgICAkb3B0aW9uczogaSA9PiAoX19WVUVfT1BUSU9OU19BUElfXyA/IHJlc29sdmVNZXJnZWRPcHRpb25zKGkpIDogaS50eXBlKSxcbiAgICAkZm9yY2VVcGRhdGU6IGkgPT4gaS5mIHx8IChpLmYgPSAoKSA9PiBxdWV1ZUpvYihpLnVwZGF0ZSkpLFxuICAgICRuZXh0VGljazogaSA9PiBpLm4gfHwgKGkubiA9IG5leHRUaWNrLmJpbmQoaS5wcm94eSkpLFxuICAgICR3YXRjaDogaSA9PiAoX19WVUVfT1BUSU9OU19BUElfXyA/IGluc3RhbmNlV2F0Y2guYmluZChpKSA6IE5PT1ApXG59KTtcbmNvbnN0IGlzUmVzZXJ2ZWRQcmVmaXggPSAoa2V5KSA9PiBrZXkgPT09ICdfJyB8fCBrZXkgPT09ICckJztcbmNvbnN0IGhhc1NldHVwQmluZGluZyA9IChzdGF0ZSwga2V5KSA9PiBzdGF0ZSAhPT0gRU1QVFlfT0JKICYmICFzdGF0ZS5fX2lzU2NyaXB0U2V0dXAgJiYgaGFzT3duKHN0YXRlLCBrZXkpO1xuY29uc3QgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzID0ge1xuICAgIGdldCh7IF86IGluc3RhbmNlIH0sIGtleSkge1xuICAgICAgICBjb25zdCB7IGN0eCwgc2V0dXBTdGF0ZSwgZGF0YSwgcHJvcHMsIGFjY2Vzc0NhY2hlLCB0eXBlLCBhcHBDb250ZXh0IH0gPSBpbnN0YW5jZTtcbiAgICAgICAgLy8gZm9yIGludGVybmFsIGZvcm1hdHRlcnMgdG8ga25vdyB0aGF0IHRoaXMgaXMgYSBWdWUgaW5zdGFuY2VcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBrZXkgPT09ICdfX2lzVnVlJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGF0YSAvIHByb3BzIC8gY3R4XG4gICAgICAgIC8vIFRoaXMgZ2V0dGVyIGdldHMgY2FsbGVkIGZvciBldmVyeSBwcm9wZXJ0eSBhY2Nlc3Mgb24gdGhlIHJlbmRlciBjb250ZXh0XG4gICAgICAgIC8vIGR1cmluZyByZW5kZXIgYW5kIGlzIGEgbWFqb3IgaG90c3BvdC4gVGhlIG1vc3QgZXhwZW5zaXZlIHBhcnQgb2YgdGhpc1xuICAgICAgICAvLyBpcyB0aGUgbXVsdGlwbGUgaGFzT3duKCkgY2FsbHMuIEl0J3MgbXVjaCBmYXN0ZXIgdG8gZG8gYSBzaW1wbGUgcHJvcGVydHlcbiAgICAgICAgLy8gYWNjZXNzIG9uIGEgcGxhaW4gb2JqZWN0LCBzbyB3ZSB1c2UgYW4gYWNjZXNzQ2FjaGUgb2JqZWN0ICh3aXRoIG51bGxcbiAgICAgICAgLy8gcHJvdG90eXBlKSB0byBtZW1vaXplIHdoYXQgYWNjZXNzIHR5cGUgYSBrZXkgY29ycmVzcG9uZHMgdG8uXG4gICAgICAgIGxldCBub3JtYWxpemVkUHJvcHM7XG4gICAgICAgIGlmIChrZXlbMF0gIT09ICckJykge1xuICAgICAgICAgICAgY29uc3QgbiA9IGFjY2Vzc0NhY2hlW2tleV07XG4gICAgICAgICAgICBpZiAobiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBBY2Nlc3NUeXBlcy5TRVRVUCAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXR1cFN0YXRlW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMiAvKiBBY2Nlc3NUeXBlcy5EQVRBICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0IC8qIEFjY2Vzc1R5cGVzLkNPTlRFWFQgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4W2tleV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBBY2Nlc3NUeXBlcy5QUk9QUyAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wc1trZXldO1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0OiBqdXN0IGZhbGx0aHJvdWdoXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzU2V0dXBCaW5kaW5nKHNldHVwU3RhdGUsIGtleSkpIHtcbiAgICAgICAgICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMSAvKiBBY2Nlc3NUeXBlcy5TRVRVUCAqLztcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0dXBTdGF0ZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihkYXRhLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDIgLyogQWNjZXNzVHlwZXMuREFUQSAqLztcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgICAvLyBvbmx5IGNhY2hlIG90aGVyIHByb3BlcnRpZXMgd2hlbiBpbnN0YW5jZSBoYXMgZGVjbGFyZWQgKHRodXMgc3RhYmxlKVxuICAgICAgICAgICAgLy8gcHJvcHNcbiAgICAgICAgICAgIChub3JtYWxpemVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wc09wdGlvbnNbMF0pICYmXG4gICAgICAgICAgICAgICAgaGFzT3duKG5vcm1hbGl6ZWRQcm9wcywga2V5KSkge1xuICAgICAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAzIC8qIEFjY2Vzc1R5cGVzLlBST1BTICovO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3R4ICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGN0eCwga2V5KSkge1xuICAgICAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSA0IC8qIEFjY2Vzc1R5cGVzLkNPTlRFWFQgKi87XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fVlVFX09QVElPTlNfQVBJX18gfHwgc2hvdWxkQ2FjaGVBY2Nlc3MpIHtcbiAgICAgICAgICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMCAvKiBBY2Nlc3NUeXBlcy5PVEhFUiAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwdWJsaWNHZXR0ZXIgPSBwdWJsaWNQcm9wZXJ0aWVzTWFwW2tleV07XG4gICAgICAgIGxldCBjc3NNb2R1bGUsIGdsb2JhbFByb3BlcnRpZXM7XG4gICAgICAgIC8vIHB1YmxpYyAkeHh4IHByb3BlcnRpZXNcbiAgICAgICAgaWYgKHB1YmxpY0dldHRlcikge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJyRhdHRycycpIHtcbiAgICAgICAgICAgICAgICB0cmFjayhpbnN0YW5jZSwgXCJnZXRcIiAvKiBUcmFja09wVHlwZXMuR0VUICovLCBrZXkpO1xuICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHB1YmxpY0dldHRlcihpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgIC8vIGNzcyBtb2R1bGUgKGluamVjdGVkIGJ5IHZ1ZS1sb2FkZXIpXG4gICAgICAgIChjc3NNb2R1bGUgPSB0eXBlLl9fY3NzTW9kdWxlcykgJiZcbiAgICAgICAgICAgIChjc3NNb2R1bGUgPSBjc3NNb2R1bGVba2V5XSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjc3NNb2R1bGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3R4ICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGN0eCwga2V5KSkge1xuICAgICAgICAgICAgLy8gdXNlciBtYXkgc2V0IGN1c3RvbSBwcm9wZXJ0aWVzIHRvIGB0aGlzYCB0aGF0IHN0YXJ0IHdpdGggYCRgXG4gICAgICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gNCAvKiBBY2Nlc3NUeXBlcy5DT05URVhUICovO1xuICAgICAgICAgICAgcmV0dXJuIGN0eFtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAvLyBnbG9iYWwgcHJvcGVydGllc1xuICAgICAgICAoKGdsb2JhbFByb3BlcnRpZXMgPSBhcHBDb250ZXh0LmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzKSxcbiAgICAgICAgICAgIGhhc093bihnbG9iYWxQcm9wZXJ0aWVzLCBrZXkpKSkge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBnbG9iYWxQcm9wZXJ0aWVzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgJiZcbiAgICAgICAgICAgICghaXNTdHJpbmcoa2V5KSB8fFxuICAgICAgICAgICAgICAgIC8vICMxMDkxIGF2b2lkIGludGVybmFsIGlzUmVmL2lzVk5vZGUgY2hlY2tzIG9uIGNvbXBvbmVudCBpbnN0YW5jZSBsZWFkaW5nXG4gICAgICAgICAgICAgICAgLy8gdG8gaW5maW5pdGUgd2FybmluZyBsb29wXG4gICAgICAgICAgICAgICAga2V5LmluZGV4T2YoJ19fdicpICE9PSAwKSkge1xuICAgICAgICAgICAgaWYgKGRhdGEgIT09IEVNUFRZX09CSiAmJiBpc1Jlc2VydmVkUHJlZml4KGtleVswXSkgJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KGtleSl9IG11c3QgYmUgYWNjZXNzZWQgdmlhICRkYXRhIGJlY2F1c2UgaXQgc3RhcnRzIHdpdGggYSByZXNlcnZlZCBgICtcbiAgICAgICAgICAgICAgICAgICAgYGNoYXJhY3RlciAoXCIkXCIgb3IgXCJfXCIpIGFuZCBpcyBub3QgcHJveGllZCBvbiB0aGUgcmVuZGVyIGNvbnRleHQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbnN0YW5jZSA9PT0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgd2FybihgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShrZXkpfSB3YXMgYWNjZXNzZWQgZHVyaW5nIHJlbmRlciBgICtcbiAgICAgICAgICAgICAgICAgICAgYGJ1dCBpcyBub3QgZGVmaW5lZCBvbiBpbnN0YW5jZS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2V0KHsgXzogaW5zdGFuY2UgfSwga2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCB7IGRhdGEsIHNldHVwU3RhdGUsIGN0eCB9ID0gaW5zdGFuY2U7XG4gICAgICAgIGlmIChoYXNTZXR1cEJpbmRpbmcoc2V0dXBTdGF0ZSwga2V5KSkge1xuICAgICAgICAgICAgc2V0dXBTdGF0ZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgIHNldHVwU3RhdGUuX19pc1NjcmlwdFNldHVwICYmXG4gICAgICAgICAgICBoYXNPd24oc2V0dXBTdGF0ZSwga2V5KSkge1xuICAgICAgICAgICAgd2FybihgQ2Fubm90IG11dGF0ZSA8c2NyaXB0IHNldHVwPiBiaW5kaW5nIFwiJHtrZXl9XCIgZnJvbSBPcHRpb25zIEFQSS5gKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcbiAgICAgICAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFzT3duKGluc3RhbmNlLnByb3BzLCBrZXkpKSB7XG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybihgQXR0ZW1wdGluZyB0byBtdXRhdGUgcHJvcCBcIiR7a2V5fVwiLiBQcm9wcyBhcmUgcmVhZG9ubHkuYCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleVswXSA9PT0gJyQnICYmIGtleS5zbGljZSgxKSBpbiBpbnN0YW5jZSkge1xuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICAgICAgd2FybihgQXR0ZW1wdGluZyB0byBtdXRhdGUgcHVibGljIHByb3BlcnR5IFwiJHtrZXl9XCIuIGAgK1xuICAgICAgICAgICAgICAgICAgICBgUHJvcGVydGllcyBzdGFydGluZyB3aXRoICQgYXJlIHJlc2VydmVkIGFuZCByZWFkb25seS5gKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYga2V5IGluIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3R4W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGhhcyh7IF86IHsgZGF0YSwgc2V0dXBTdGF0ZSwgYWNjZXNzQ2FjaGUsIGN0eCwgYXBwQ29udGV4dCwgcHJvcHNPcHRpb25zIH0gfSwga2V5KSB7XG4gICAgICAgIGxldCBub3JtYWxpemVkUHJvcHM7XG4gICAgICAgIHJldHVybiAoISFhY2Nlc3NDYWNoZVtrZXldIHx8XG4gICAgICAgICAgICAoZGF0YSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihkYXRhLCBrZXkpKSB8fFxuICAgICAgICAgICAgaGFzU2V0dXBCaW5kaW5nKHNldHVwU3RhdGUsIGtleSkgfHxcbiAgICAgICAgICAgICgobm9ybWFsaXplZFByb3BzID0gcHJvcHNPcHRpb25zWzBdKSAmJiBoYXNPd24obm9ybWFsaXplZFByb3BzLCBrZXkpKSB8fFxuICAgICAgICAgICAgaGFzT3duKGN0eCwga2V5KSB8fFxuICAgICAgICAgICAgaGFzT3duKHB1YmxpY1Byb3BlcnRpZXNNYXAsIGtleSkgfHxcbiAgICAgICAgICAgIGhhc093bihhcHBDb250ZXh0LmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzLCBrZXkpKTtcbiAgICB9LFxuICAgIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yLmdldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBpbnZhbGlkYXRlIGtleSBjYWNoZSBvZiBhIGdldHRlciBiYXNlZCBwcm9wZXJ0eSAjNTQxN1xuICAgICAgICAgICAgdGFyZ2V0Ll8uYWNjZXNzQ2FjaGVba2V5XSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFzT3duKGRlc2NyaXB0b3IsICd2YWx1ZScpKSB7XG4gICAgICAgICAgICB0aGlzLnNldCh0YXJnZXQsIGtleSwgZGVzY3JpcHRvci52YWx1ZSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn07XG5pZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFmYWxzZSkge1xuICAgIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycy5vd25LZXlzID0gKHRhcmdldCkgPT4ge1xuICAgICAgICB3YXJuKGBBdm9pZCBhcHAgbG9naWMgdGhhdCByZWxpZXMgb24gZW51bWVyYXRpbmcga2V5cyBvbiBhIGNvbXBvbmVudCBpbnN0YW5jZS4gYCArXG4gICAgICAgICAgICBgVGhlIGtleXMgd2lsbCBiZSBlbXB0eSBpbiBwcm9kdWN0aW9uIG1vZGUgdG8gYXZvaWQgcGVyZm9ybWFuY2Ugb3ZlcmhlYWQuYCk7XG4gICAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcbiAgICB9O1xufVxuY29uc3QgUnVudGltZUNvbXBpbGVkUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzID0gLyojX19QVVJFX18qLyBleHRlbmQoe30sIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycywge1xuICAgIGdldCh0YXJnZXQsIGtleSkge1xuICAgICAgICAvLyBmYXN0IHBhdGggZm9yIHVuc2NvcGFibGVzIHdoZW4gdXNpbmcgYHdpdGhgIGJsb2NrXG4gICAgICAgIGlmIChrZXkgPT09IFN5bWJvbC51bnNjb3BhYmxlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMuZ2V0KHRhcmdldCwga2V5LCB0YXJnZXQpO1xuICAgIH0sXG4gICAgaGFzKF8sIGtleSkge1xuICAgICAgICBjb25zdCBoYXMgPSBrZXlbMF0gIT09ICdfJyAmJiAhaXNHbG9iYWxseVdoaXRlbGlzdGVkKGtleSk7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWhhcyAmJiBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMuaGFzKF8sIGtleSkpIHtcbiAgICAgICAgICAgIHdhcm4oYFByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoa2V5KX0gc2hvdWxkIG5vdCBzdGFydCB3aXRoIF8gd2hpY2ggaXMgYSByZXNlcnZlZCBwcmVmaXggZm9yIFZ1ZSBpbnRlcm5hbHMuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhcztcbiAgICB9XG59KTtcbi8vIGRldiBvbmx5XG4vLyBJbiBkZXYgbW9kZSwgdGhlIHByb3h5IHRhcmdldCBleHBvc2VzIHRoZSBzYW1lIHByb3BlcnRpZXMgYXMgc2VlbiBvbiBgdGhpc2Bcbi8vIGZvciBlYXNpZXIgY29uc29sZSBpbnNwZWN0aW9uLiBJbiBwcm9kIG1vZGUgaXQgd2lsbCBiZSBhbiBlbXB0eSBvYmplY3Qgc29cbi8vIHRoZXNlIHByb3BlcnRpZXMgZGVmaW5pdGlvbnMgY2FuIGJlIHNraXBwZWQuXG5mdW5jdGlvbiBjcmVhdGVEZXZSZW5kZXJDb250ZXh0KGluc3RhbmNlKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0ge307XG4gICAgLy8gZXhwb3NlIGludGVybmFsIGluc3RhbmNlIGZvciBwcm94eSBoYW5kbGVyc1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGBfYCwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBnZXQ6ICgpID0+IGluc3RhbmNlXG4gICAgfSk7XG4gICAgLy8gZXhwb3NlIHB1YmxpYyBwcm9wZXJ0aWVzXG4gICAgT2JqZWN0LmtleXMocHVibGljUHJvcGVydGllc01hcCkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiBwdWJsaWNQcm9wZXJ0aWVzTWFwW2tleV0oaW5zdGFuY2UpLFxuICAgICAgICAgICAgLy8gaW50ZXJjZXB0ZWQgYnkgdGhlIHByb3h5IHNvIG5vIG5lZWQgZm9yIGltcGxlbWVudGF0aW9uLFxuICAgICAgICAgICAgLy8gYnV0IG5lZWRlZCB0byBwcmV2ZW50IHNldCBlcnJvcnNcbiAgICAgICAgICAgIHNldDogTk9PUFxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuLy8gZGV2IG9ubHlcbmZ1bmN0aW9uIGV4cG9zZVByb3BzT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKSB7XG4gICAgY29uc3QgeyBjdHgsIHByb3BzT3B0aW9uczogW3Byb3BzT3B0aW9uc10gfSA9IGluc3RhbmNlO1xuICAgIGlmIChwcm9wc09wdGlvbnMpIHtcbiAgICAgICAgT2JqZWN0LmtleXMocHJvcHNPcHRpb25zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IGluc3RhbmNlLnByb3BzW2tleV0sXG4gICAgICAgICAgICAgICAgc2V0OiBOT09QXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8gZGV2IG9ubHlcbmZ1bmN0aW9uIGV4cG9zZVNldHVwU3RhdGVPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcbiAgICBjb25zdCB7IGN0eCwgc2V0dXBTdGF0ZSB9ID0gaW5zdGFuY2U7XG4gICAgT2JqZWN0LmtleXModG9SYXcoc2V0dXBTdGF0ZSkpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgaWYgKCFzZXR1cFN0YXRlLl9faXNTY3JpcHRTZXR1cCkge1xuICAgICAgICAgICAgaWYgKGlzUmVzZXJ2ZWRQcmVmaXgoa2V5WzBdKSkge1xuICAgICAgICAgICAgICAgIHdhcm4oYHNldHVwKCkgcmV0dXJuIHByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoa2V5KX0gc2hvdWxkIG5vdCBzdGFydCB3aXRoIFwiJFwiIG9yIFwiX1wiIGAgK1xuICAgICAgICAgICAgICAgICAgICBgd2hpY2ggYXJlIHJlc2VydmVkIHByZWZpeGVzIGZvciBWdWUgaW50ZXJuYWxzLmApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogKCkgPT4gc2V0dXBTdGF0ZVtrZXldLFxuICAgICAgICAgICAgICAgIHNldDogTk9PUFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRHVwbGljYXRlQ2hlY2tlcigpIHtcbiAgICBjb25zdCBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgcmV0dXJuICh0eXBlLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgICAgICAgIHdhcm4oYCR7dHlwZX0gcHJvcGVydHkgXCIke2tleX1cIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gJHtjYWNoZVtrZXldfS5gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlW2tleV0gPSB0eXBlO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmxldCBzaG91bGRDYWNoZUFjY2VzcyA9IHRydWU7XG5mdW5jdGlvbiBhcHBseU9wdGlvbnMoaW5zdGFuY2UpIHtcbiAgICBjb25zdCBvcHRpb25zID0gcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaW5zdGFuY2UpO1xuICAgIGNvbnN0IHB1YmxpY1RoaXMgPSBpbnN0YW5jZS5wcm94eTtcbiAgICBjb25zdCBjdHggPSBpbnN0YW5jZS5jdHg7XG4gICAgLy8gZG8gbm90IGNhY2hlIHByb3BlcnR5IGFjY2VzcyBvbiBwdWJsaWMgcHJveHkgZHVyaW5nIHN0YXRlIGluaXRpYWxpemF0aW9uXG4gICAgc2hvdWxkQ2FjaGVBY2Nlc3MgPSBmYWxzZTtcbiAgICAvLyBjYWxsIGJlZm9yZUNyZWF0ZSBmaXJzdCBiZWZvcmUgYWNjZXNzaW5nIG90aGVyIG9wdGlvbnMgc2luY2VcbiAgICAvLyB0aGUgaG9vayBtYXkgbXV0YXRlIHJlc29sdmVkIG9wdGlvbnMgKCMyNzkxKVxuICAgIGlmIChvcHRpb25zLmJlZm9yZUNyZWF0ZSkge1xuICAgICAgICBjYWxsSG9vayhvcHRpb25zLmJlZm9yZUNyZWF0ZSwgaW5zdGFuY2UsIFwiYmNcIiAvKiBMaWZlY3ljbGVIb29rcy5CRUZPUkVfQ1JFQVRFICovKTtcbiAgICB9XG4gICAgY29uc3QgeyBcbiAgICAvLyBzdGF0ZVxuICAgIGRhdGE6IGRhdGFPcHRpb25zLCBjb21wdXRlZDogY29tcHV0ZWRPcHRpb25zLCBtZXRob2RzLCB3YXRjaDogd2F0Y2hPcHRpb25zLCBwcm92aWRlOiBwcm92aWRlT3B0aW9ucywgaW5qZWN0OiBpbmplY3RPcHRpb25zLCBcbiAgICAvLyBsaWZlY3ljbGVcbiAgICBjcmVhdGVkLCBiZWZvcmVNb3VudCwgbW91bnRlZCwgYmVmb3JlVXBkYXRlLCB1cGRhdGVkLCBhY3RpdmF0ZWQsIGRlYWN0aXZhdGVkLCBiZWZvcmVEZXN0cm95LCBiZWZvcmVVbm1vdW50LCBkZXN0cm95ZWQsIHVubW91bnRlZCwgcmVuZGVyLCByZW5kZXJUcmFja2VkLCByZW5kZXJUcmlnZ2VyZWQsIGVycm9yQ2FwdHVyZWQsIHNlcnZlclByZWZldGNoLCBcbiAgICAvLyBwdWJsaWMgQVBJXG4gICAgZXhwb3NlLCBpbmhlcml0QXR0cnMsIFxuICAgIC8vIGFzc2V0c1xuICAgIGNvbXBvbmVudHMsIGRpcmVjdGl2ZXMsIGZpbHRlcnMgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gY3JlYXRlRHVwbGljYXRlQ2hlY2tlcigpIDogbnVsbDtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIGNvbnN0IFtwcm9wc09wdGlvbnNdID0gaW5zdGFuY2UucHJvcHNPcHRpb25zO1xuICAgICAgICBpZiAocHJvcHNPcHRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wc09wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJQcm9wc1wiIC8qIE9wdGlvblR5cGVzLlBST1BTICovLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG9wdGlvbnMgaW5pdGlhbGl6YXRpb24gb3JkZXIgKHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBWdWUgMik6XG4gICAgLy8gLSBwcm9wcyAoYWxyZWFkeSBkb25lIG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbilcbiAgICAvLyAtIGluamVjdFxuICAgIC8vIC0gbWV0aG9kc1xuICAgIC8vIC0gZGF0YSAoZGVmZXJyZWQgc2luY2UgaXQgcmVsaWVzIG9uIGB0aGlzYCBhY2Nlc3MpXG4gICAgLy8gLSBjb21wdXRlZFxuICAgIC8vIC0gd2F0Y2ggKGRlZmVycmVkIHNpbmNlIGl0IHJlbGllcyBvbiBgdGhpc2AgYWNjZXNzKVxuICAgIGlmIChpbmplY3RPcHRpb25zKSB7XG4gICAgICAgIHJlc29sdmVJbmplY3Rpb25zKGluamVjdE9wdGlvbnMsIGN0eCwgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzLCBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy51bndyYXBJbmplY3RlZFJlZik7XG4gICAgfVxuICAgIGlmIChtZXRob2RzKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG1ldGhvZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZEhhbmRsZXIgPSBtZXRob2RzW2tleV07XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihtZXRob2RIYW5kbGVyKSkge1xuICAgICAgICAgICAgICAgIC8vIEluIGRldiBtb2RlLCB3ZSB1c2UgdGhlIGBjcmVhdGVSZW5kZXJDb250ZXh0YCBmdW5jdGlvbiB0byBkZWZpbmVcbiAgICAgICAgICAgICAgICAvLyBtZXRob2RzIHRvIHRoZSBwcm94eSB0YXJnZXQsIGFuZCB0aG9zZSBhcmUgcmVhZC1vbmx5IGJ1dFxuICAgICAgICAgICAgICAgIC8vIHJlY29uZmlndXJhYmxlLCBzbyBpdCBuZWVkcyB0byBiZSByZWRlZmluZWQgaGVyZVxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWV0aG9kSGFuZGxlci5iaW5kKHB1YmxpY1RoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4W2tleV0gPSBtZXRob2RIYW5kbGVyLmJpbmQocHVibGljVGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiTWV0aG9kc1wiIC8qIE9wdGlvblR5cGVzLk1FVEhPRFMgKi8sIGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgd2FybihgTWV0aG9kIFwiJHtrZXl9XCIgaGFzIHR5cGUgXCIke3R5cGVvZiBtZXRob2RIYW5kbGVyfVwiIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkYXRhT3B0aW9ucykge1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc0Z1bmN0aW9uKGRhdGFPcHRpb25zKSkge1xuICAgICAgICAgICAgd2FybihgVGhlIGRhdGEgb3B0aW9uIG11c3QgYmUgYSBmdW5jdGlvbi4gYCArXG4gICAgICAgICAgICAgICAgYFBsYWluIG9iamVjdCB1c2FnZSBpcyBubyBsb25nZXIgc3VwcG9ydGVkLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBkYXRhT3B0aW9ucy5jYWxsKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpO1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGlzUHJvbWlzZShkYXRhKSkge1xuICAgICAgICAgICAgd2FybihgZGF0YSgpIHJldHVybmVkIGEgUHJvbWlzZSAtIG5vdGUgZGF0YSgpIGNhbm5vdCBiZSBhc3luYzsgSWYgeW91IGAgK1xuICAgICAgICAgICAgICAgIGBpbnRlbmQgdG8gcGVyZm9ybSBkYXRhIGZldGNoaW5nIGJlZm9yZSBjb21wb25lbnQgcmVuZGVycywgdXNlIGAgK1xuICAgICAgICAgICAgICAgIGBhc3luYyBzZXR1cCgpICsgPFN1c3BlbnNlPi5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybihgZGF0YSgpIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0LmApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5zdGFuY2UuZGF0YSA9IHJlYWN0aXZlKGRhdGEpO1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiRGF0YVwiIC8qIE9wdGlvblR5cGVzLkRBVEEgKi8sIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGV4cG9zZSBkYXRhIG9uIGN0eCBkdXJpbmcgZGV2XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNSZXNlcnZlZFByZWZpeChrZXlbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IGRhdGFba2V5XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQ6IE5PT1BcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHN0YXRlIGluaXRpYWxpemF0aW9uIGNvbXBsZXRlIGF0IHRoaXMgcG9pbnQgLSBzdGFydCBjYWNoaW5nIGFjY2Vzc1xuICAgIHNob3VsZENhY2hlQWNjZXNzID0gdHJ1ZTtcbiAgICBpZiAoY29tcHV0ZWRPcHRpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNvbXB1dGVkT3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3Qgb3B0ID0gY29tcHV0ZWRPcHRpb25zW2tleV07XG4gICAgICAgICAgICBjb25zdCBnZXQgPSBpc0Z1bmN0aW9uKG9wdClcbiAgICAgICAgICAgICAgICA/IG9wdC5iaW5kKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpXG4gICAgICAgICAgICAgICAgOiBpc0Z1bmN0aW9uKG9wdC5nZXQpXG4gICAgICAgICAgICAgICAgICAgID8gb3B0LmdldC5iaW5kKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpXG4gICAgICAgICAgICAgICAgICAgIDogTk9PUDtcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgZ2V0ID09PSBOT09QKSB7XG4gICAgICAgICAgICAgICAgd2FybihgQ29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBoYXMgbm8gZ2V0dGVyLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2V0ID0gIWlzRnVuY3Rpb24ob3B0KSAmJiBpc0Z1bmN0aW9uKG9wdC5zZXQpXG4gICAgICAgICAgICAgICAgPyBvcHQuc2V0LmJpbmQocHVibGljVGhpcylcbiAgICAgICAgICAgICAgICA6IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICA/ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYFdyaXRlIG9wZXJhdGlvbiBmYWlsZWQ6IGNvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgaXMgcmVhZG9ubHkuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiBOT09QO1xuICAgICAgICAgICAgY29uc3QgYyA9IGNvbXB1dGVkKHtcbiAgICAgICAgICAgICAgICBnZXQsXG4gICAgICAgICAgICAgICAgc2V0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogKCkgPT4gYy52YWx1ZSxcbiAgICAgICAgICAgICAgICBzZXQ6IHYgPT4gKGMudmFsdWUgPSB2KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiQ29tcHV0ZWRcIiAvKiBPcHRpb25UeXBlcy5DT01QVVRFRCAqLywga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAod2F0Y2hPcHRpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHdhdGNoT3B0aW9ucykge1xuICAgICAgICAgICAgY3JlYXRlV2F0Y2hlcih3YXRjaE9wdGlvbnNba2V5XSwgY3R4LCBwdWJsaWNUaGlzLCBrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwcm92aWRlT3B0aW9ucykge1xuICAgICAgICBjb25zdCBwcm92aWRlcyA9IGlzRnVuY3Rpb24ocHJvdmlkZU9wdGlvbnMpXG4gICAgICAgICAgICA/IHByb3ZpZGVPcHRpb25zLmNhbGwocHVibGljVGhpcylcbiAgICAgICAgICAgIDogcHJvdmlkZU9wdGlvbnM7XG4gICAgICAgIFJlZmxlY3Qub3duS2V5cyhwcm92aWRlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgcHJvdmlkZShrZXksIHByb3ZpZGVzW2tleV0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGNyZWF0ZWQpIHtcbiAgICAgICAgY2FsbEhvb2soY3JlYXRlZCwgaW5zdGFuY2UsIFwiY1wiIC8qIExpZmVjeWNsZUhvb2tzLkNSRUFURUQgKi8pO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWdpc3RlckxpZmVjeWNsZUhvb2socmVnaXN0ZXIsIGhvb2spIHtcbiAgICAgICAgaWYgKGlzQXJyYXkoaG9vaykpIHtcbiAgICAgICAgICAgIGhvb2suZm9yRWFjaChfaG9vayA9PiByZWdpc3RlcihfaG9vay5iaW5kKHB1YmxpY1RoaXMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaG9vaykge1xuICAgICAgICAgICAgcmVnaXN0ZXIoaG9vay5iaW5kKHB1YmxpY1RoaXMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25CZWZvcmVNb3VudCwgYmVmb3JlTW91bnQpO1xuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbk1vdW50ZWQsIG1vdW50ZWQpO1xuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkJlZm9yZVVwZGF0ZSwgYmVmb3JlVXBkYXRlKTtcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25VcGRhdGVkLCB1cGRhdGVkKTtcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25BY3RpdmF0ZWQsIGFjdGl2YXRlZCk7XG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uRGVhY3RpdmF0ZWQsIGRlYWN0aXZhdGVkKTtcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25FcnJvckNhcHR1cmVkLCBlcnJvckNhcHR1cmVkKTtcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25SZW5kZXJUcmFja2VkLCByZW5kZXJUcmFja2VkKTtcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25SZW5kZXJUcmlnZ2VyZWQsIHJlbmRlclRyaWdnZXJlZCk7XG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQmVmb3JlVW5tb3VudCwgYmVmb3JlVW5tb3VudCk7XG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uVW5tb3VudGVkLCB1bm1vdW50ZWQpO1xuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblNlcnZlclByZWZldGNoLCBzZXJ2ZXJQcmVmZXRjaCk7XG4gICAgaWYgKGlzQXJyYXkoZXhwb3NlKSkge1xuICAgICAgICBpZiAoZXhwb3NlLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgZXhwb3NlZCA9IGluc3RhbmNlLmV4cG9zZWQgfHwgKGluc3RhbmNlLmV4cG9zZWQgPSB7fSk7XG4gICAgICAgICAgICBleHBvc2UuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvc2VkLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBwdWJsaWNUaGlzW2tleV0sXG4gICAgICAgICAgICAgICAgICAgIHNldDogdmFsID0+IChwdWJsaWNUaGlzW2tleV0gPSB2YWwpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaW5zdGFuY2UuZXhwb3NlZCkge1xuICAgICAgICAgICAgaW5zdGFuY2UuZXhwb3NlZCA9IHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG9wdGlvbnMgdGhhdCBhcmUgaGFuZGxlZCB3aGVuIGNyZWF0aW5nIHRoZSBpbnN0YW5jZSBidXQgYWxzbyBuZWVkIHRvIGJlXG4gICAgLy8gYXBwbGllZCBmcm9tIG1peGluc1xuICAgIGlmIChyZW5kZXIgJiYgaW5zdGFuY2UucmVuZGVyID09PSBOT09QKSB7XG4gICAgICAgIGluc3RhbmNlLnJlbmRlciA9IHJlbmRlcjtcbiAgICB9XG4gICAgaWYgKGluaGVyaXRBdHRycyAhPSBudWxsKSB7XG4gICAgICAgIGluc3RhbmNlLmluaGVyaXRBdHRycyA9IGluaGVyaXRBdHRycztcbiAgICB9XG4gICAgLy8gYXNzZXQgb3B0aW9ucy5cbiAgICBpZiAoY29tcG9uZW50cylcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG4gICAgaWYgKGRpcmVjdGl2ZXMpXG4gICAgICAgIGluc3RhbmNlLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUluamVjdGlvbnMoaW5qZWN0T3B0aW9ucywgY3R4LCBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMgPSBOT09QLCB1bndyYXBSZWYgPSBmYWxzZSkge1xuICAgIGlmIChpc0FycmF5KGluamVjdE9wdGlvbnMpKSB7XG4gICAgICAgIGluamVjdE9wdGlvbnMgPSBub3JtYWxpemVJbmplY3QoaW5qZWN0T3B0aW9ucyk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIGluamVjdE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgb3B0ID0gaW5qZWN0T3B0aW9uc1trZXldO1xuICAgICAgICBsZXQgaW5qZWN0ZWQ7XG4gICAgICAgIGlmIChpc09iamVjdChvcHQpKSB7XG4gICAgICAgICAgICBpZiAoJ2RlZmF1bHQnIGluIG9wdCkge1xuICAgICAgICAgICAgICAgIGluamVjdGVkID0gaW5qZWN0KG9wdC5mcm9tIHx8IGtleSwgb3B0LmRlZmF1bHQsIHRydWUgLyogdHJlYXQgZGVmYXVsdCBmdW5jdGlvbiBhcyBmYWN0b3J5ICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluamVjdGVkID0gaW5qZWN0KG9wdC5mcm9tIHx8IGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbmplY3RlZCA9IGluamVjdChvcHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1JlZihpbmplY3RlZCkpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gcmVtb3ZlIHRoZSBjaGVjayBpbiAzLjNcbiAgICAgICAgICAgIGlmICh1bndyYXBSZWYpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IGluamVjdGVkLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBzZXQ6IHYgPT4gKGluamVjdGVkLnZhbHVlID0gdilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihgaW5qZWN0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBpcyBhIHJlZiBhbmQgd2lsbCBiZSBhdXRvLXVud3JhcHBlZCBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBhbmQgbm8gbG9uZ2VyIG5lZWRzIFxcYC52YWx1ZVxcYCBpbiB0aGUgbmV4dCBtaW5vciByZWxlYXNlLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBUbyBvcHQtaW4gdG8gdGhlIG5ldyBiZWhhdmlvciBub3csIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYHNldCBcXGBhcHAuY29uZmlnLnVud3JhcEluamVjdGVkUmVmID0gdHJ1ZVxcYCAodGhpcyBjb25maWcgaXMgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgdGVtcG9yYXJ5IGFuZCB3aWxsIG5vdCBiZSBuZWVkZWQgaW4gdGhlIGZ1dHVyZS4pYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eFtrZXldID0gaW5qZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdHhba2V5XSA9IGluamVjdGVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIkluamVjdFwiIC8qIE9wdGlvblR5cGVzLklOSkVDVCAqLywga2V5KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNhbGxIb29rKGhvb2ssIGluc3RhbmNlLCB0eXBlKSB7XG4gICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaXNBcnJheShob29rKVxuICAgICAgICA/IGhvb2subWFwKGggPT4gaC5iaW5kKGluc3RhbmNlLnByb3h5KSlcbiAgICAgICAgOiBob29rLmJpbmQoaW5zdGFuY2UucHJveHkpLCBpbnN0YW5jZSwgdHlwZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyKHJhdywgY3R4LCBwdWJsaWNUaGlzLCBrZXkpIHtcbiAgICBjb25zdCBnZXR0ZXIgPSBrZXkuaW5jbHVkZXMoJy4nKVxuICAgICAgICA/IGNyZWF0ZVBhdGhHZXR0ZXIocHVibGljVGhpcywga2V5KVxuICAgICAgICA6ICgpID0+IHB1YmxpY1RoaXNba2V5XTtcbiAgICBpZiAoaXNTdHJpbmcocmF3KSkge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gY3R4W3Jhd107XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgICAgICAgICB3YXRjaChnZXR0ZXIsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgd2FybihgSW52YWxpZCB3YXRjaCBoYW5kbGVyIHNwZWNpZmllZCBieSBrZXkgXCIke3Jhd31cImAsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24ocmF3KSkge1xuICAgICAgICB3YXRjaChnZXR0ZXIsIHJhdy5iaW5kKHB1YmxpY1RoaXMpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNPYmplY3QocmF3KSkge1xuICAgICAgICBpZiAoaXNBcnJheShyYXcpKSB7XG4gICAgICAgICAgICByYXcuZm9yRWFjaChyID0+IGNyZWF0ZVdhdGNoZXIociwgY3R4LCBwdWJsaWNUaGlzLCBrZXkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBpc0Z1bmN0aW9uKHJhdy5oYW5kbGVyKVxuICAgICAgICAgICAgICAgID8gcmF3LmhhbmRsZXIuYmluZChwdWJsaWNUaGlzKVxuICAgICAgICAgICAgICAgIDogY3R4W3Jhdy5oYW5kbGVyXTtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgICAgICAgICAgICAgd2F0Y2goZ2V0dGVyLCBoYW5kbGVyLCByYXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgd2FybihgSW52YWxpZCB3YXRjaCBoYW5kbGVyIHNwZWNpZmllZCBieSBrZXkgXCIke3Jhdy5oYW5kbGVyfVwiYCwgaGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIHdhcm4oYEludmFsaWQgd2F0Y2ggb3B0aW9uOiBcIiR7a2V5fVwiYCwgcmF3KTtcbiAgICB9XG59XG4vKipcbiAqIFJlc29sdmUgbWVyZ2VkIG9wdGlvbnMgYW5kIGNhY2hlIGl0IG9uIHRoZSBjb21wb25lbnQuXG4gKiBUaGlzIGlzIGRvbmUgb25seSBvbmNlIHBlci1jb21wb25lbnQgc2luY2UgdGhlIG1lcmdpbmcgZG9lcyBub3QgaW52b2x2ZVxuICogaW5zdGFuY2VzLlxuICovXG5mdW5jdGlvbiByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpbnN0YW5jZSkge1xuICAgIGNvbnN0IGJhc2UgPSBpbnN0YW5jZS50eXBlO1xuICAgIGNvbnN0IHsgbWl4aW5zLCBleHRlbmRzOiBleHRlbmRzT3B0aW9ucyB9ID0gYmFzZTtcbiAgICBjb25zdCB7IG1peGluczogZ2xvYmFsTWl4aW5zLCBvcHRpb25zQ2FjaGU6IGNhY2hlLCBjb25maWc6IHsgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzIH0gfSA9IGluc3RhbmNlLmFwcENvbnRleHQ7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGJhc2UpO1xuICAgIGxldCByZXNvbHZlZDtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgIHJlc29sdmVkID0gY2FjaGVkO1xuICAgIH1cbiAgICBlbHNlIGlmICghZ2xvYmFsTWl4aW5zLmxlbmd0aCAmJiAhbWl4aW5zICYmICFleHRlbmRzT3B0aW9ucykge1xuICAgICAgICB7XG4gICAgICAgICAgICByZXNvbHZlZCA9IGJhc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc29sdmVkID0ge307XG4gICAgICAgIGlmIChnbG9iYWxNaXhpbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBnbG9iYWxNaXhpbnMuZm9yRWFjaChtID0+IG1lcmdlT3B0aW9ucyhyZXNvbHZlZCwgbSwgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzLCB0cnVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgbWVyZ2VPcHRpb25zKHJlc29sdmVkLCBiYXNlLCBvcHRpb25NZXJnZVN0cmF0ZWdpZXMpO1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3QoYmFzZSkpIHtcbiAgICAgICAgY2FjaGUuc2V0KGJhc2UsIHJlc29sdmVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc29sdmVkO1xufVxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKHRvLCBmcm9tLCBzdHJhdHMsIGFzTWl4aW4gPSBmYWxzZSkge1xuICAgIGNvbnN0IHsgbWl4aW5zLCBleHRlbmRzOiBleHRlbmRzT3B0aW9ucyB9ID0gZnJvbTtcbiAgICBpZiAoZXh0ZW5kc09wdGlvbnMpIHtcbiAgICAgICAgbWVyZ2VPcHRpb25zKHRvLCBleHRlbmRzT3B0aW9ucywgc3RyYXRzLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKG1peGlucykge1xuICAgICAgICBtaXhpbnMuZm9yRWFjaCgobSkgPT4gbWVyZ2VPcHRpb25zKHRvLCBtLCBzdHJhdHMsIHRydWUpKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZnJvbSkge1xuICAgICAgICBpZiAoYXNNaXhpbiAmJiBrZXkgPT09ICdleHBvc2UnKSB7XG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgICAgICB3YXJuKGBcImV4cG9zZVwiIG9wdGlvbiBpcyBpZ25vcmVkIHdoZW4gZGVjbGFyZWQgaW4gbWl4aW5zIG9yIGV4dGVuZHMuIGAgK1xuICAgICAgICAgICAgICAgICAgICBgSXQgc2hvdWxkIG9ubHkgYmUgZGVjbGFyZWQgaW4gdGhlIGJhc2UgY29tcG9uZW50IGl0c2VsZi5gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmF0ID0gaW50ZXJuYWxPcHRpb25NZXJnZVN0cmF0c1trZXldIHx8IChzdHJhdHMgJiYgc3RyYXRzW2tleV0pO1xuICAgICAgICAgICAgdG9ba2V5XSA9IHN0cmF0ID8gc3RyYXQodG9ba2V5XSwgZnJvbVtrZXldKSA6IGZyb21ba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG87XG59XG5jb25zdCBpbnRlcm5hbE9wdGlvbk1lcmdlU3RyYXRzID0ge1xuICAgIGRhdGE6IG1lcmdlRGF0YUZuLFxuICAgIHByb3BzOiBtZXJnZU9iamVjdE9wdGlvbnMsXG4gICAgZW1pdHM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcbiAgICAvLyBvYmplY3RzXG4gICAgbWV0aG9kczogbWVyZ2VPYmplY3RPcHRpb25zLFxuICAgIGNvbXB1dGVkOiBtZXJnZU9iamVjdE9wdGlvbnMsXG4gICAgLy8gbGlmZWN5Y2xlXG4gICAgYmVmb3JlQ3JlYXRlOiBtZXJnZUFzQXJyYXksXG4gICAgY3JlYXRlZDogbWVyZ2VBc0FycmF5LFxuICAgIGJlZm9yZU1vdW50OiBtZXJnZUFzQXJyYXksXG4gICAgbW91bnRlZDogbWVyZ2VBc0FycmF5LFxuICAgIGJlZm9yZVVwZGF0ZTogbWVyZ2VBc0FycmF5LFxuICAgIHVwZGF0ZWQ6IG1lcmdlQXNBcnJheSxcbiAgICBiZWZvcmVEZXN0cm95OiBtZXJnZUFzQXJyYXksXG4gICAgYmVmb3JlVW5tb3VudDogbWVyZ2VBc0FycmF5LFxuICAgIGRlc3Ryb3llZDogbWVyZ2VBc0FycmF5LFxuICAgIHVubW91bnRlZDogbWVyZ2VBc0FycmF5LFxuICAgIGFjdGl2YXRlZDogbWVyZ2VBc0FycmF5LFxuICAgIGRlYWN0aXZhdGVkOiBtZXJnZUFzQXJyYXksXG4gICAgZXJyb3JDYXB0dXJlZDogbWVyZ2VBc0FycmF5LFxuICAgIHNlcnZlclByZWZldGNoOiBtZXJnZUFzQXJyYXksXG4gICAgLy8gYXNzZXRzXG4gICAgY29tcG9uZW50czogbWVyZ2VPYmplY3RPcHRpb25zLFxuICAgIGRpcmVjdGl2ZXM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcbiAgICAvLyB3YXRjaFxuICAgIHdhdGNoOiBtZXJnZVdhdGNoT3B0aW9ucyxcbiAgICAvLyBwcm92aWRlIC8gaW5qZWN0XG4gICAgcHJvdmlkZTogbWVyZ2VEYXRhRm4sXG4gICAgaW5qZWN0OiBtZXJnZUluamVjdFxufTtcbmZ1bmN0aW9uIG1lcmdlRGF0YUZuKHRvLCBmcm9tKSB7XG4gICAgaWYgKCFmcm9tKSB7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG4gICAgaWYgKCF0bykge1xuICAgICAgICByZXR1cm4gZnJvbTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbigpIHtcbiAgICAgICAgcmV0dXJuIChleHRlbmQpKGlzRnVuY3Rpb24odG8pID8gdG8uY2FsbCh0aGlzLCB0aGlzKSA6IHRvLCBpc0Z1bmN0aW9uKGZyb20pID8gZnJvbS5jYWxsKHRoaXMsIHRoaXMpIDogZnJvbSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlSW5qZWN0KHRvLCBmcm9tKSB7XG4gICAgcmV0dXJuIG1lcmdlT2JqZWN0T3B0aW9ucyhub3JtYWxpemVJbmplY3QodG8pLCBub3JtYWxpemVJbmplY3QoZnJvbSkpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplSW5qZWN0KHJhdykge1xuICAgIGlmIChpc0FycmF5KHJhdykpIHtcbiAgICAgICAgY29uc3QgcmVzID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXNbcmF3W2ldXSA9IHJhd1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICByZXR1cm4gcmF3O1xufVxuZnVuY3Rpb24gbWVyZ2VBc0FycmF5KHRvLCBmcm9tKSB7XG4gICAgcmV0dXJuIHRvID8gWy4uLm5ldyBTZXQoW10uY29uY2F0KHRvLCBmcm9tKSldIDogZnJvbTtcbn1cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0T3B0aW9ucyh0bywgZnJvbSkge1xuICAgIHJldHVybiB0byA/IGV4dGVuZChleHRlbmQoT2JqZWN0LmNyZWF0ZShudWxsKSwgdG8pLCBmcm9tKSA6IGZyb207XG59XG5mdW5jdGlvbiBtZXJnZVdhdGNoT3B0aW9ucyh0bywgZnJvbSkge1xuICAgIGlmICghdG8pXG4gICAgICAgIHJldHVybiBmcm9tO1xuICAgIGlmICghZnJvbSlcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIGNvbnN0IG1lcmdlZCA9IGV4dGVuZChPYmplY3QuY3JlYXRlKG51bGwpLCB0byk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZnJvbSkge1xuICAgICAgICBtZXJnZWRba2V5XSA9IG1lcmdlQXNBcnJheSh0b1trZXldLCBmcm9tW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBpc1N0YXRlZnVsLCAvLyByZXN1bHQgb2YgYml0d2lzZSBmbGFnIGNvbXBhcmlzb25cbmlzU1NSID0gZmFsc2UpIHtcbiAgICBjb25zdCBwcm9wcyA9IHt9O1xuICAgIGNvbnN0IGF0dHJzID0ge307XG4gICAgZGVmKGF0dHJzLCBJbnRlcm5hbE9iamVjdEtleSwgMSk7XG4gICAgaW5zdGFuY2UucHJvcHNEZWZhdWx0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKTtcbiAgICAvLyBlbnN1cmUgYWxsIGRlY2xhcmVkIHByb3Aga2V5cyBhcmUgcHJlc2VudFxuICAgIGZvciAoY29uc3Qga2V5IGluIGluc3RhbmNlLnByb3BzT3B0aW9uc1swXSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gcHJvcHMpKSB7XG4gICAgICAgICAgICBwcm9wc1trZXldID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHZhbGlkYXRpb25cbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIHZhbGlkYXRlUHJvcHMocmF3UHJvcHMgfHwge30sIHByb3BzLCBpbnN0YW5jZSk7XG4gICAgfVxuICAgIGlmIChpc1N0YXRlZnVsKSB7XG4gICAgICAgIC8vIHN0YXRlZnVsXG4gICAgICAgIGluc3RhbmNlLnByb3BzID0gaXNTU1IgPyBwcm9wcyA6IHNoYWxsb3dSZWFjdGl2ZShwcm9wcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIWluc3RhbmNlLnR5cGUucHJvcHMpIHtcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uYWwgdy8gb3B0aW9uYWwgcHJvcHMsIHByb3BzID09PSBhdHRyc1xuICAgICAgICAgICAgaW5zdGFuY2UucHJvcHMgPSBhdHRycztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uYWwgdy8gZGVjbGFyZWQgcHJvcHNcbiAgICAgICAgICAgIGluc3RhbmNlLnByb3BzID0gcHJvcHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5zdGFuY2UuYXR0cnMgPSBhdHRycztcbn1cbmZ1bmN0aW9uIGlzSW5IbXJDb250ZXh0KGluc3RhbmNlKSB7XG4gICAgd2hpbGUgKGluc3RhbmNlKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZS50eXBlLl9faG1ySWQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaW5zdGFuY2UgPSBpbnN0YW5jZS5wYXJlbnQ7XG4gICAgfVxufVxuZnVuY3Rpb24gdXBkYXRlUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCByYXdQcmV2UHJvcHMsIG9wdGltaXplZCkge1xuICAgIGNvbnN0IHsgcHJvcHMsIGF0dHJzLCB2bm9kZTogeyBwYXRjaEZsYWcgfSB9ID0gaW5zdGFuY2U7XG4gICAgY29uc3QgcmF3Q3VycmVudFByb3BzID0gdG9SYXcocHJvcHMpO1xuICAgIGNvbnN0IFtvcHRpb25zXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcbiAgICBsZXQgaGFzQXR0cnNDaGFuZ2VkID0gZmFsc2U7XG4gICAgaWYgKFxuICAgIC8vIGFsd2F5cyBmb3JjZSBmdWxsIGRpZmYgaW4gZGV2XG4gICAgLy8gLSAjMTk0MiBpZiBobXIgaXMgZW5hYmxlZCB3aXRoIHNmYyBjb21wb25lbnRcbiAgICAvLyAtIHZpdGUjODcyIG5vbi1zZmMgY29tcG9uZW50IHVzZWQgYnkgc2ZjIGNvbXBvbmVudFxuICAgICEoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGlzSW5IbXJDb250ZXh0KGluc3RhbmNlKSkgJiZcbiAgICAgICAgKG9wdGltaXplZCB8fCBwYXRjaEZsYWcgPiAwKSAmJlxuICAgICAgICAhKHBhdGNoRmxhZyAmIDE2IC8qIFBhdGNoRmxhZ3MuRlVMTF9QUk9QUyAqLykpIHtcbiAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDggLyogUGF0Y2hGbGFncy5QUk9QUyAqLykge1xuICAgICAgICAgICAgLy8gQ29tcGlsZXItZ2VuZXJhdGVkIHByb3BzICYgbm8ga2V5cyBjaGFuZ2UsIGp1c3Qgc2V0IHRoZSB1cGRhdGVkXG4gICAgICAgICAgICAvLyB0aGUgcHJvcHMuXG4gICAgICAgICAgICBjb25zdCBwcm9wc1RvVXBkYXRlID0gaW5zdGFuY2Uudm5vZGUuZHluYW1pY1Byb3BzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wc1RvVXBkYXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGtleSA9IHByb3BzVG9VcGRhdGVbaV07XG4gICAgICAgICAgICAgICAgLy8gc2tpcCBpZiB0aGUgcHJvcCBrZXkgaXMgYSBkZWNsYXJlZCBlbWl0IGV2ZW50IGxpc3RlbmVyXG4gICAgICAgICAgICAgICAgaWYgKGlzRW1pdExpc3RlbmVyKGluc3RhbmNlLmVtaXRzT3B0aW9ucywga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUFJPUFMgZmxhZyBndWFyYW50ZWVzIHJhd1Byb3BzIHRvIGJlIG5vbi1udWxsXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByYXdQcm9wc1trZXldO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGF0dHIgLyBwcm9wcyBzZXBhcmF0aW9uIHdhcyBkb25lIG9uIGluaXQgYW5kIHdpbGwgYmUgY29uc2lzdGVudFxuICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGlzIGNvZGUgcGF0aCwgc28ganVzdCBjaGVjayBpZiBhdHRycyBoYXZlIGl0LlxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3duKGF0dHJzLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IGF0dHJzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbWVsaXplZEtleSA9IGNhbWVsaXplKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1tjYW1lbGl6ZWRLZXldID0gcmVzb2x2ZVByb3BWYWx1ZShvcHRpb25zLCByYXdDdXJyZW50UHJvcHMsIGNhbWVsaXplZEtleSwgdmFsdWUsIGluc3RhbmNlLCBmYWxzZSAvKiBpc0Fic2VudCAqLyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gYXR0cnNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gZnVsbCBwcm9wcyB1cGRhdGUuXG4gICAgICAgIGlmIChzZXRGdWxsUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBwcm9wcywgYXR0cnMpKSB7XG4gICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGluIGNhc2Ugb2YgZHluYW1pYyBwcm9wcywgY2hlY2sgaWYgd2UgbmVlZCB0byBkZWxldGUga2V5cyBmcm9tXG4gICAgICAgIC8vIHRoZSBwcm9wcyBvYmplY3RcbiAgICAgICAgbGV0IGtlYmFiS2V5O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByYXdDdXJyZW50UHJvcHMpIHtcbiAgICAgICAgICAgIGlmICghcmF3UHJvcHMgfHxcbiAgICAgICAgICAgICAgICAvLyBmb3IgY2FtZWxDYXNlXG4gICAgICAgICAgICAgICAgKCFoYXNPd24ocmF3UHJvcHMsIGtleSkgJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGUgb3JpZ2luYWwgcHJvcHMgd2FzIHBhc3NlZCBpbiBhcyBrZWJhYi1jYXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBjb252ZXJ0ZWQgdG8gY2FtZWxDYXNlICgjOTU1KVxuICAgICAgICAgICAgICAgICAgICAoKGtlYmFiS2V5ID0gaHlwaGVuYXRlKGtleSkpID09PSBrZXkgfHwgIWhhc093bihyYXdQcm9wcywga2ViYWJLZXkpKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmF3UHJldlByb3BzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgY2FtZWxDYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAocmF3UHJldlByb3BzW2tleV0gIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBrZWJhYi1jYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3UHJldlByb3BzW2tlYmFiS2V5XSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNba2V5XSA9IHJlc29sdmVQcm9wVmFsdWUob3B0aW9ucywgcmF3Q3VycmVudFByb3BzLCBrZXksIHVuZGVmaW5lZCwgaW5zdGFuY2UsIHRydWUgLyogaXNBYnNlbnQgKi8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcHJvcHNba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW4gdGhlIGNhc2Ugb2YgZnVuY3Rpb25hbCBjb21wb25lbnQgdy9vIHByb3BzIGRlY2xhcmF0aW9uLCBwcm9wcyBhbmRcbiAgICAgICAgLy8gYXR0cnMgcG9pbnQgdG8gdGhlIHNhbWUgb2JqZWN0IHNvIGl0IHNob3VsZCBhbHJlYWR5IGhhdmUgYmVlbiB1cGRhdGVkLlxuICAgICAgICBpZiAoYXR0cnMgIT09IHJhd0N1cnJlbnRQcm9wcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJhd1Byb3BzIHx8XG4gICAgICAgICAgICAgICAgICAgICghaGFzT3duKHJhd1Byb3BzLCBrZXkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoIWZhbHNlICkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhdHRyc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyB0cmlnZ2VyIHVwZGF0ZXMgZm9yICRhdHRycyBpbiBjYXNlIGl0J3MgdXNlZCBpbiBjb21wb25lbnQgc2xvdHNcbiAgICBpZiAoaGFzQXR0cnNDaGFuZ2VkKSB7XG4gICAgICAgIHRyaWdnZXIoaW5zdGFuY2UsIFwic2V0XCIgLyogVHJpZ2dlck9wVHlwZXMuU0VUICovLCAnJGF0dHJzJyk7XG4gICAgfVxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgdmFsaWRhdGVQcm9wcyhyYXdQcm9wcyB8fCB7fSwgcHJvcHMsIGluc3RhbmNlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRGdWxsUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBwcm9wcywgYXR0cnMpIHtcbiAgICBjb25zdCBbb3B0aW9ucywgbmVlZENhc3RLZXlzXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcbiAgICBsZXQgaGFzQXR0cnNDaGFuZ2VkID0gZmFsc2U7XG4gICAgbGV0IHJhd0Nhc3RWYWx1ZXM7XG4gICAgaWYgKHJhd1Byb3BzKSB7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiByYXdQcm9wcykge1xuICAgICAgICAgICAgLy8ga2V5LCByZWYgYXJlIHJlc2VydmVkIGFuZCBuZXZlciBwYXNzZWQgZG93blxuICAgICAgICAgICAgaWYgKGlzUmVzZXJ2ZWRQcm9wKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmF3UHJvcHNba2V5XTtcbiAgICAgICAgICAgIC8vIHByb3Agb3B0aW9uIG5hbWVzIGFyZSBjYW1lbGl6ZWQgZHVyaW5nIG5vcm1hbGl6YXRpb24sIHNvIHRvIHN1cHBvcnRcbiAgICAgICAgICAgIC8vIGtlYmFiIC0+IGNhbWVsIGNvbnZlcnNpb24gaGVyZSB3ZSBuZWVkIHRvIGNhbWVsaXplIHRoZSBrZXkuXG4gICAgICAgICAgICBsZXQgY2FtZWxLZXk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBoYXNPd24ob3B0aW9ucywgKGNhbWVsS2V5ID0gY2FtZWxpemUoa2V5KSkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFuZWVkQ2FzdEtleXMgfHwgIW5lZWRDYXN0S2V5cy5pbmNsdWRlcyhjYW1lbEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNbY2FtZWxLZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAocmF3Q2FzdFZhbHVlcyB8fCAocmF3Q2FzdFZhbHVlcyA9IHt9KSlbY2FtZWxLZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzRW1pdExpc3RlbmVyKGluc3RhbmNlLmVtaXRzT3B0aW9ucywga2V5KSkge1xuICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiBhdHRycykgfHwgdmFsdWUgIT09IGF0dHJzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobmVlZENhc3RLZXlzKSB7XG4gICAgICAgIGNvbnN0IHJhd0N1cnJlbnRQcm9wcyA9IHRvUmF3KHByb3BzKTtcbiAgICAgICAgY29uc3QgY2FzdFZhbHVlcyA9IHJhd0Nhc3RWYWx1ZXMgfHwgRU1QVFlfT0JKO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5lZWRDYXN0S2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gbmVlZENhc3RLZXlzW2ldO1xuICAgICAgICAgICAgcHJvcHNba2V5XSA9IHJlc29sdmVQcm9wVmFsdWUob3B0aW9ucywgcmF3Q3VycmVudFByb3BzLCBrZXksIGNhc3RWYWx1ZXNba2V5XSwgaW5zdGFuY2UsICFoYXNPd24oY2FzdFZhbHVlcywga2V5KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhhc0F0dHJzQ2hhbmdlZDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVQcm9wVmFsdWUob3B0aW9ucywgcHJvcHMsIGtleSwgdmFsdWUsIGluc3RhbmNlLCBpc0Fic2VudCkge1xuICAgIGNvbnN0IG9wdCA9IG9wdGlvbnNba2V5XTtcbiAgICBpZiAob3B0ICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgaGFzRGVmYXVsdCA9IGhhc093bihvcHQsICdkZWZhdWx0Jyk7XG4gICAgICAgIC8vIGRlZmF1bHQgdmFsdWVzXG4gICAgICAgIGlmIChoYXNEZWZhdWx0ICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IG9wdC5kZWZhdWx0O1xuICAgICAgICAgICAgaWYgKG9wdC50eXBlICE9PSBGdW5jdGlvbiAmJiBpc0Z1bmN0aW9uKGRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHByb3BzRGVmYXVsdHMgfSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gcHJvcHNEZWZhdWx0cykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHByb3BzRGVmYXVsdHNba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcHJvcHNEZWZhdWx0c1trZXldID0gZGVmYXVsdFZhbHVlLmNhbGwobnVsbCwgcHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICB1bnNldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGJvb2xlYW4gY2FzdGluZ1xuICAgICAgICBpZiAob3B0WzAgLyogQm9vbGVhbkZsYWdzLnNob3VsZENhc3QgKi9dKSB7XG4gICAgICAgICAgICBpZiAoaXNBYnNlbnQgJiYgIWhhc0RlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0WzEgLyogQm9vbGVhbkZsYWdzLnNob3VsZENhc3RUcnVlICovXSAmJlxuICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBub3JtYWxpemVQcm9wc09wdGlvbnMoY29tcCwgYXBwQ29udGV4dCwgYXNNaXhpbiA9IGZhbHNlKSB7XG4gICAgY29uc3QgY2FjaGUgPSBhcHBDb250ZXh0LnByb3BzQ2FjaGU7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGNvbXApO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgY29uc3QgcmF3ID0gY29tcC5wcm9wcztcbiAgICBjb25zdCBub3JtYWxpemVkID0ge307XG4gICAgY29uc3QgbmVlZENhc3RLZXlzID0gW107XG4gICAgLy8gYXBwbHkgbWl4aW4vZXh0ZW5kcyBwcm9wc1xuICAgIGxldCBoYXNFeHRlbmRzID0gZmFsc2U7XG4gICAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18gJiYgIWlzRnVuY3Rpb24oY29tcCkpIHtcbiAgICAgICAgY29uc3QgZXh0ZW5kUHJvcHMgPSAocmF3KSA9PiB7XG4gICAgICAgICAgICBoYXNFeHRlbmRzID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IFtwcm9wcywga2V5c10gPSBub3JtYWxpemVQcm9wc09wdGlvbnMocmF3LCBhcHBDb250ZXh0LCB0cnVlKTtcbiAgICAgICAgICAgIGV4dGVuZChub3JtYWxpemVkLCBwcm9wcyk7XG4gICAgICAgICAgICBpZiAoa2V5cylcbiAgICAgICAgICAgICAgICBuZWVkQ2FzdEtleXMucHVzaCguLi5rZXlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFhc01peGluICYmIGFwcENvbnRleHQubWl4aW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgYXBwQ29udGV4dC5taXhpbnMuZm9yRWFjaChleHRlbmRQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXAuZXh0ZW5kcykge1xuICAgICAgICAgICAgZXh0ZW5kUHJvcHMoY29tcC5leHRlbmRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcC5taXhpbnMpIHtcbiAgICAgICAgICAgIGNvbXAubWl4aW5zLmZvckVhY2goZXh0ZW5kUHJvcHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghcmF3ICYmICFoYXNFeHRlbmRzKSB7XG4gICAgICAgIGlmIChpc09iamVjdChjb21wKSkge1xuICAgICAgICAgICAgY2FjaGUuc2V0KGNvbXAsIEVNUFRZX0FSUik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEVNUFRZX0FSUjtcbiAgICB9XG4gICAgaWYgKGlzQXJyYXkocmF3KSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNTdHJpbmcocmF3W2ldKSkge1xuICAgICAgICAgICAgICAgIHdhcm4oYHByb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC5gLCByYXdbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGNhbWVsaXplKHJhd1tpXSk7XG4gICAgICAgICAgICBpZiAodmFsaWRhdGVQcm9wTmFtZShub3JtYWxpemVkS2V5KSkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRbbm9ybWFsaXplZEtleV0gPSBFTVBUWV9PQko7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocmF3KSB7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzT2JqZWN0KHJhdykpIHtcbiAgICAgICAgICAgIHdhcm4oYGludmFsaWQgcHJvcHMgb3B0aW9uc2AsIHJhdyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmF3KSB7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZVByb3BOYW1lKG5vcm1hbGl6ZWRLZXkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0ID0gcmF3W2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcCA9IChub3JtYWxpemVkW25vcm1hbGl6ZWRLZXldID1cbiAgICAgICAgICAgICAgICAgICAgaXNBcnJheShvcHQpIHx8IGlzRnVuY3Rpb24ob3B0KSA/IHsgdHlwZTogb3B0IH0gOiBPYmplY3QuYXNzaWduKHt9LCBvcHQpKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBib29sZWFuSW5kZXggPSBnZXRUeXBlSW5kZXgoQm9vbGVhbiwgcHJvcC50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5nSW5kZXggPSBnZXRUeXBlSW5kZXgoU3RyaW5nLCBwcm9wLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBwcm9wWzAgLyogQm9vbGVhbkZsYWdzLnNob3VsZENhc3QgKi9dID0gYm9vbGVhbkluZGV4ID4gLTE7XG4gICAgICAgICAgICAgICAgICAgIHByb3BbMSAvKiBCb29sZWFuRmxhZ3Muc2hvdWxkQ2FzdFRydWUgKi9dID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ0luZGV4IDwgMCB8fCBib29sZWFuSW5kZXggPCBzdHJpbmdJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHByb3AgbmVlZHMgYm9vbGVhbiBjYXN0aW5nIG9yIGRlZmF1bHQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvb2xlYW5JbmRleCA+IC0xIHx8IGhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZWVkQ2FzdEtleXMucHVzaChub3JtYWxpemVkS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXMgPSBbbm9ybWFsaXplZCwgbmVlZENhc3RLZXlzXTtcbiAgICBpZiAoaXNPYmplY3QoY29tcCkpIHtcbiAgICAgICAgY2FjaGUuc2V0KGNvbXAsIHJlcyk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BOYW1lKGtleSkge1xuICAgIGlmIChrZXlbMF0gIT09ICckJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIHdhcm4oYEludmFsaWQgcHJvcCBuYW1lOiBcIiR7a2V5fVwiIGlzIGEgcmVzZXJ2ZWQgcHJvcGVydHkuYCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIHVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayB0eXBlIGNvbnN0cnVjdG9yc1xuLy8gc28gdGhhdCBpdCB3b3JrcyBhY3Jvc3Mgdm1zIC8gaWZyYW1lcy5cbmZ1bmN0aW9uIGdldFR5cGUoY3Rvcikge1xuICAgIGNvbnN0IG1hdGNoID0gY3RvciAmJiBjdG9yLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqZnVuY3Rpb24gKFxcdyspLyk7XG4gICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiBjdG9yID09PSBudWxsID8gJ251bGwnIDogJyc7XG59XG5mdW5jdGlvbiBpc1NhbWVUeXBlKGEsIGIpIHtcbiAgICByZXR1cm4gZ2V0VHlwZShhKSA9PT0gZ2V0VHlwZShiKTtcbn1cbmZ1bmN0aW9uIGdldFR5cGVJbmRleCh0eXBlLCBleHBlY3RlZFR5cGVzKSB7XG4gICAgaWYgKGlzQXJyYXkoZXhwZWN0ZWRUeXBlcykpIHtcbiAgICAgICAgcmV0dXJuIGV4cGVjdGVkVHlwZXMuZmluZEluZGV4KHQgPT4gaXNTYW1lVHlwZSh0LCB0eXBlKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oZXhwZWN0ZWRUeXBlcykpIHtcbiAgICAgICAgcmV0dXJuIGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlcywgdHlwZSkgPyAwIDogLTE7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbi8qKlxuICogZGV2IG9ubHlcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhyYXdQcm9wcywgcHJvcHMsIGluc3RhbmNlKSB7XG4gICAgY29uc3QgcmVzb2x2ZWRWYWx1ZXMgPSB0b1Jhdyhwcm9wcyk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGluc3RhbmNlLnByb3BzT3B0aW9uc1swXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgIGxldCBvcHQgPSBvcHRpb25zW2tleV07XG4gICAgICAgIGlmIChvcHQgPT0gbnVsbClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB2YWxpZGF0ZVByb3Aoa2V5LCByZXNvbHZlZFZhbHVlc1trZXldLCBvcHQsICFoYXNPd24ocmF3UHJvcHMsIGtleSkgJiYgIWhhc093bihyYXdQcm9wcywgaHlwaGVuYXRlKGtleSkpKTtcbiAgICB9XG59XG4vKipcbiAqIGRldiBvbmx5XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcChuYW1lLCB2YWx1ZSwgcHJvcCwgaXNBYnNlbnQpIHtcbiAgICBjb25zdCB7IHR5cGUsIHJlcXVpcmVkLCB2YWxpZGF0b3IgfSA9IHByb3A7XG4gICAgLy8gcmVxdWlyZWQhXG4gICAgaWYgKHJlcXVpcmVkICYmIGlzQWJzZW50KSB7XG4gICAgICAgIHdhcm4oJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIG1pc3NpbmcgYnV0IG9wdGlvbmFsXG4gICAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB0eXBlIGNoZWNrXG4gICAgaWYgKHR5cGUgIT0gbnVsbCAmJiB0eXBlICE9PSB0cnVlKSB7XG4gICAgICAgIGxldCBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gaXNBcnJheSh0eXBlKSA/IHR5cGUgOiBbdHlwZV07XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgICAgICAgLy8gdmFsdWUgaXMgdmFsaWQgYXMgbG9uZyBhcyBvbmUgb2YgdGhlIHNwZWNpZmllZCB0eXBlcyBtYXRjaFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aCAmJiAhaXNWYWxpZDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB7IHZhbGlkLCBleHBlY3RlZFR5cGUgfSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVzW2ldKTtcbiAgICAgICAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChleHBlY3RlZFR5cGUgfHwgJycpO1xuICAgICAgICAgICAgaXNWYWxpZCA9IHZhbGlkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgICAgd2FybihnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBjdXN0b20gdmFsaWRhdG9yXG4gICAgaWYgKHZhbGlkYXRvciAmJiAhdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgICB3YXJuKCdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyk7XG4gICAgfVxufVxuY29uc3QgaXNTaW1wbGVUeXBlID0gLyojX19QVVJFX18qLyBtYWtlTWFwKCdTdHJpbmcsTnVtYmVyLEJvb2xlYW4sRnVuY3Rpb24sU3ltYm9sLEJpZ0ludCcpO1xuLyoqXG4gKiBkZXYgb25seVxuICovXG5mdW5jdGlvbiBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlKSB7XG4gICAgbGV0IHZhbGlkO1xuICAgIGNvbnN0IGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gICAgaWYgKGlzU2ltcGxlVHlwZShleHBlY3RlZFR5cGUpKSB7XG4gICAgICAgIGNvbnN0IHQgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIC8vIGZvciBwcmltaXRpdmUgd3JhcHBlciBvYmplY3RzXG4gICAgICAgIGlmICghdmFsaWQgJiYgdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICAgICAgdmFsaWQgPSBpc09iamVjdCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgICAgICB2YWxpZCA9IGlzQXJyYXkodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdudWxsJykge1xuICAgICAgICB2YWxpZCA9IHZhbHVlID09PSBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHZhbGlkLFxuICAgICAgICBleHBlY3RlZFR5cGVcbiAgICB9O1xufVxuLyoqXG4gKiBkZXYgb25seVxuICovXG5mdW5jdGlvbiBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgICBsZXQgbWVzc2FnZSA9IGBJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJHtuYW1lfVwiLmAgK1xuICAgICAgICBgIEV4cGVjdGVkICR7ZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignIHwgJyl9YDtcbiAgICBjb25zdCBleHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGVzWzBdO1xuICAgIGNvbnN0IHJlY2VpdmVkVHlwZSA9IHRvUmF3VHlwZSh2YWx1ZSk7XG4gICAgY29uc3QgZXhwZWN0ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIGV4cGVjdGVkVHlwZSk7XG4gICAgY29uc3QgcmVjZWl2ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIHJlY2VpdmVkVHlwZSk7XG4gICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IGV4cGVjdGVkIHZhbHVlXG4gICAgaWYgKGV4cGVjdGVkVHlwZXMubGVuZ3RoID09PSAxICYmXG4gICAgICAgIGlzRXhwbGljYWJsZShleHBlY3RlZFR5cGUpICYmXG4gICAgICAgICFpc0Jvb2xlYW4oZXhwZWN0ZWRUeXBlLCByZWNlaXZlZFR5cGUpKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gYCB3aXRoIHZhbHVlICR7ZXhwZWN0ZWRWYWx1ZX1gO1xuICAgIH1cbiAgICBtZXNzYWdlICs9IGAsIGdvdCAke3JlY2VpdmVkVHlwZX0gYDtcbiAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgcmVjZWl2ZWQgdmFsdWVcbiAgICBpZiAoaXNFeHBsaWNhYmxlKHJlY2VpdmVkVHlwZSkpIHtcbiAgICAgICAgbWVzc2FnZSArPSBgd2l0aCB2YWx1ZSAke3JlY2VpdmVkVmFsdWV9LmA7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xufVxuLyoqXG4gKiBkZXYgb25seVxuICovXG5mdW5jdGlvbiBzdHlsZVZhbHVlKHZhbHVlLCB0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09ICdTdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBgXCIke3ZhbHVlfVwiYDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ051bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGAke051bWJlcih2YWx1ZSl9YDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBgJHt2YWx1ZX1gO1xuICAgIH1cbn1cbi8qKlxuICogZGV2IG9ubHlcbiAqL1xuZnVuY3Rpb24gaXNFeHBsaWNhYmxlKHR5cGUpIHtcbiAgICBjb25zdCBleHBsaWNpdFR5cGVzID0gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nXTtcbiAgICByZXR1cm4gZXhwbGljaXRUeXBlcy5zb21lKGVsZW0gPT4gdHlwZS50b0xvd2VyQ2FzZSgpID09PSBlbGVtKTtcbn1cbi8qKlxuICogZGV2IG9ubHlcbiAqL1xuZnVuY3Rpb24gaXNCb29sZWFuKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gYXJncy5zb21lKGVsZW0gPT4gZWxlbS50b0xvd2VyQ2FzZSgpID09PSAnYm9vbGVhbicpO1xufVxuXG5jb25zdCBpc0ludGVybmFsS2V5ID0gKGtleSkgPT4ga2V5WzBdID09PSAnXycgfHwga2V5ID09PSAnJHN0YWJsZSc7XG5jb25zdCBub3JtYWxpemVTbG90VmFsdWUgPSAodmFsdWUpID0+IGlzQXJyYXkodmFsdWUpXG4gICAgPyB2YWx1ZS5tYXAobm9ybWFsaXplVk5vZGUpXG4gICAgOiBbbm9ybWFsaXplVk5vZGUodmFsdWUpXTtcbmNvbnN0IG5vcm1hbGl6ZVNsb3QgPSAoa2V5LCByYXdTbG90LCBjdHgpID0+IHtcbiAgICBpZiAocmF3U2xvdC5fbikge1xuICAgICAgICAvLyBhbHJlYWR5IG5vcm1hbGl6ZWQgLSAjNTM1M1xuICAgICAgICByZXR1cm4gcmF3U2xvdDtcbiAgICB9XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHdpdGhDdHgoKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjdXJyZW50SW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHdhcm4oYFNsb3QgXCIke2tleX1cIiBpbnZva2VkIG91dHNpZGUgb2YgdGhlIHJlbmRlciBmdW5jdGlvbjogYCArXG4gICAgICAgICAgICAgICAgYHRoaXMgd2lsbCBub3QgdHJhY2sgZGVwZW5kZW5jaWVzIHVzZWQgaW4gdGhlIHNsb3QuIGAgK1xuICAgICAgICAgICAgICAgIGBJbnZva2UgdGhlIHNsb3QgZnVuY3Rpb24gaW5zaWRlIHRoZSByZW5kZXIgZnVuY3Rpb24gaW5zdGVhZC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9ybWFsaXplU2xvdFZhbHVlKHJhd1Nsb3QoLi4uYXJncykpO1xuICAgIH0sIGN0eCk7XG4gICAgbm9ybWFsaXplZC5fYyA9IGZhbHNlO1xuICAgIHJldHVybiBub3JtYWxpemVkO1xufTtcbmNvbnN0IG5vcm1hbGl6ZU9iamVjdFNsb3RzID0gKHJhd1Nsb3RzLCBzbG90cywgaW5zdGFuY2UpID0+IHtcbiAgICBjb25zdCBjdHggPSByYXdTbG90cy5fY3R4O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHJhd1Nsb3RzKSB7XG4gICAgICAgIGlmIChpc0ludGVybmFsS2V5KGtleSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSByYXdTbG90c1trZXldO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHNsb3RzW2tleV0gPSBub3JtYWxpemVTbG90KGtleSwgdmFsdWUsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgICAgICEoZmFsc2UgKSkge1xuICAgICAgICAgICAgICAgIHdhcm4oYE5vbi1mdW5jdGlvbiB2YWx1ZSBlbmNvdW50ZXJlZCBmb3Igc2xvdCBcIiR7a2V5fVwiLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYFByZWZlciBmdW5jdGlvbiBzbG90cyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVNsb3RWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICBzbG90c1trZXldID0gKCkgPT4gbm9ybWFsaXplZDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBub3JtYWxpemVWTm9kZVNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbikgPT4ge1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgIWlzS2VlcEFsaXZlKGluc3RhbmNlLnZub2RlKSAmJlxuICAgICAgICAhKGZhbHNlICkpIHtcbiAgICAgICAgd2FybihgTm9uLWZ1bmN0aW9uIHZhbHVlIGVuY291bnRlcmVkIGZvciBkZWZhdWx0IHNsb3QuIGAgK1xuICAgICAgICAgICAgYFByZWZlciBmdW5jdGlvbiBzbG90cyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLmApO1xuICAgIH1cbiAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplU2xvdFZhbHVlKGNoaWxkcmVuKTtcbiAgICBpbnN0YW5jZS5zbG90cy5kZWZhdWx0ID0gKCkgPT4gbm9ybWFsaXplZDtcbn07XG5jb25zdCBpbml0U2xvdHMgPSAoaW5zdGFuY2UsIGNoaWxkcmVuKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlLnZub2RlLnNoYXBlRmxhZyAmIDMyIC8qIFNoYXBlRmxhZ3MuU0xPVFNfQ0hJTERSRU4gKi8pIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IGNoaWxkcmVuLl87XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAvLyB1c2VycyBjYW4gZ2V0IHRoZSBzaGFsbG93IHJlYWRvbmx5IHZlcnNpb24gb2YgdGhlIHNsb3RzIG9iamVjdCB0aHJvdWdoIGB0aGlzLiRzbG90c2AsXG4gICAgICAgICAgICAvLyB3ZSBzaG91bGQgYXZvaWQgdGhlIHByb3h5IG9iamVjdCBwb2xsdXRpbmcgdGhlIHNsb3RzIG9mIHRoZSBpbnRlcm5hbCBpbnN0YW5jZVxuICAgICAgICAgICAgaW5zdGFuY2Uuc2xvdHMgPSB0b1JhdyhjaGlsZHJlbik7XG4gICAgICAgICAgICAvLyBtYWtlIGNvbXBpbGVyIG1hcmtlciBub24tZW51bWVyYWJsZVxuICAgICAgICAgICAgZGVmKGNoaWxkcmVuLCAnXycsIHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9ybWFsaXplT2JqZWN0U2xvdHMoY2hpbGRyZW4sIChpbnN0YW5jZS5zbG90cyA9IHt9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGluc3RhbmNlLnNsb3RzID0ge307XG4gICAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICAgICAgbm9ybWFsaXplVk5vZGVTbG90cyhpbnN0YW5jZSwgY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlZihpbnN0YW5jZS5zbG90cywgSW50ZXJuYWxPYmplY3RLZXksIDEpO1xufTtcbmNvbnN0IHVwZGF0ZVNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbiwgb3B0aW1pemVkKSA9PiB7XG4gICAgY29uc3QgeyB2bm9kZSwgc2xvdHMgfSA9IGluc3RhbmNlO1xuICAgIGxldCBuZWVkRGVsZXRpb25DaGVjayA9IHRydWU7XG4gICAgbGV0IGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCA9IEVNUFRZX09CSjtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMzIgLyogU2hhcGVGbGFncy5TTE9UU19DSElMRFJFTiAqLykge1xuICAgICAgICBjb25zdCB0eXBlID0gY2hpbGRyZW4uXztcbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIC8vIGNvbXBpbGVkIHNsb3RzLlxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpc0htclVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gUGFyZW50IHdhcyBITVIgdXBkYXRlZCBzbyBzbG90IGNvbnRlbnQgbWF5IGhhdmUgY2hhbmdlZC5cbiAgICAgICAgICAgICAgICAvLyBmb3JjZSB1cGRhdGUgc2xvdHMgYW5kIG1hcmsgaW5zdGFuY2UgZm9yIGhtciBhcyB3ZWxsXG4gICAgICAgICAgICAgICAgZXh0ZW5kKHNsb3RzLCBjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpbWl6ZWQgJiYgdHlwZSA9PT0gMSAvKiBTbG90RmxhZ3MuU1RBQkxFICovKSB7XG4gICAgICAgICAgICAgICAgLy8gY29tcGlsZWQgQU5EIHN0YWJsZS5cbiAgICAgICAgICAgICAgICAvLyBubyBuZWVkIHRvIHVwZGF0ZSwgYW5kIHNraXAgc3RhbGUgc2xvdHMgcmVtb3ZhbC5cbiAgICAgICAgICAgICAgICBuZWVkRGVsZXRpb25DaGVjayA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY29tcGlsZWQgYnV0IGR5bmFtaWMgKHYtaWYvdi1mb3Igb24gc2xvdHMpIC0gdXBkYXRlIHNsb3RzLCBidXQgc2tpcFxuICAgICAgICAgICAgICAgIC8vIG5vcm1hbGl6YXRpb24uXG4gICAgICAgICAgICAgICAgZXh0ZW5kKHNsb3RzLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgLy8gIzI4OTNcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHJlbmRlcmluZyB0aGUgb3B0aW1pemVkIHNsb3RzIGJ5IG1hbnVhbGx5IHdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gZGVsZXRlIHRoZSBgc2xvdHMuX2AgZmxhZyBpZiBuZWNlc3NhcnkgdG8gbWFrZSBzdWJzZXF1ZW50IHVwZGF0ZXMgcmVsaWFibGUsXG4gICAgICAgICAgICAgICAgLy8gaS5lLiBsZXQgdGhlIGByZW5kZXJTbG90YCBjcmVhdGUgdGhlIGJhaWxlZCBGcmFnbWVudFxuICAgICAgICAgICAgICAgIGlmICghb3B0aW1pemVkICYmIHR5cGUgPT09IDEgLyogU2xvdEZsYWdzLlNUQUJMRSAqLykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2xvdHMuXztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZWVkRGVsZXRpb25DaGVjayA9ICFjaGlsZHJlbi4kc3RhYmxlO1xuICAgICAgICAgICAgbm9ybWFsaXplT2JqZWN0U2xvdHMoY2hpbGRyZW4sIHNsb3RzKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSBjaGlsZHJlbjtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgLy8gbm9uIHNsb3Qgb2JqZWN0IGNoaWxkcmVuIChkaXJlY3QgdmFsdWUpIHBhc3NlZCB0byBhIGNvbXBvbmVudFxuICAgICAgICBub3JtYWxpemVWTm9kZVNsb3RzKGluc3RhbmNlLCBjaGlsZHJlbik7XG4gICAgICAgIGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCA9IHsgZGVmYXVsdDogMSB9O1xuICAgIH1cbiAgICAvLyBkZWxldGUgc3RhbGUgc2xvdHNcbiAgICBpZiAobmVlZERlbGV0aW9uQ2hlY2spIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2xvdHMpIHtcbiAgICAgICAgICAgIGlmICghaXNJbnRlcm5hbEtleShrZXkpICYmICEoa2V5IGluIGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgc2xvdHNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUFwcENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXBwOiBudWxsLFxuICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICAgIGlzTmF0aXZlVGFnOiBOTyxcbiAgICAgICAgICAgIHBlcmZvcm1hbmNlOiBmYWxzZSxcbiAgICAgICAgICAgIGdsb2JhbFByb3BlcnRpZXM6IHt9LFxuICAgICAgICAgICAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiB7fSxcbiAgICAgICAgICAgIGVycm9ySGFuZGxlcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgd2FybkhhbmRsZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbXBpbGVyT3B0aW9uczoge31cbiAgICAgICAgfSxcbiAgICAgICAgbWl4aW5zOiBbXSxcbiAgICAgICAgY29tcG9uZW50czoge30sXG4gICAgICAgIGRpcmVjdGl2ZXM6IHt9LFxuICAgICAgICBwcm92aWRlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgb3B0aW9uc0NhY2hlOiBuZXcgV2Vha01hcCgpLFxuICAgICAgICBwcm9wc0NhY2hlOiBuZXcgV2Vha01hcCgpLFxuICAgICAgICBlbWl0c0NhY2hlOiBuZXcgV2Vha01hcCgpXG4gICAgfTtcbn1cbmxldCB1aWQgPSAwO1xuZnVuY3Rpb24gY3JlYXRlQXBwQVBJKHJlbmRlciwgaHlkcmF0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVBcHAocm9vdENvbXBvbmVudCwgcm9vdFByb3BzID0gbnVsbCkge1xuICAgICAgICBpZiAoIWlzRnVuY3Rpb24ocm9vdENvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHJvb3RDb21wb25lbnQgPSBPYmplY3QuYXNzaWduKHt9LCByb290Q29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm9vdFByb3BzICE9IG51bGwgJiYgIWlzT2JqZWN0KHJvb3RQcm9wcykpIHtcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGByb290IHByb3BzIHBhc3NlZCB0byBhcHAubW91bnQoKSBtdXN0IGJlIGFuIG9iamVjdC5gKTtcbiAgICAgICAgICAgIHJvb3RQcm9wcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUFwcENvbnRleHQoKTtcbiAgICAgICAgY29uc3QgaW5zdGFsbGVkUGx1Z2lucyA9IG5ldyBTZXQoKTtcbiAgICAgICAgbGV0IGlzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBhcHAgPSAoY29udGV4dC5hcHAgPSB7XG4gICAgICAgICAgICBfdWlkOiB1aWQrKyxcbiAgICAgICAgICAgIF9jb21wb25lbnQ6IHJvb3RDb21wb25lbnQsXG4gICAgICAgICAgICBfcHJvcHM6IHJvb3RQcm9wcyxcbiAgICAgICAgICAgIF9jb250YWluZXI6IG51bGwsXG4gICAgICAgICAgICBfY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgIF9pbnN0YW5jZTogbnVsbCxcbiAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgICBnZXQgY29uZmlnKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbmZpZztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQgY29uZmlnKHYpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYGFwcC5jb25maWcgY2Fubm90IGJlIHJlcGxhY2VkLiBNb2RpZnkgaW5kaXZpZHVhbCBvcHRpb25zIGluc3RlYWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVzZShwbHVnaW4sIC4uLm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5oYXMocGx1Z2luKSkge1xuICAgICAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybihgUGx1Z2luIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCB0byB0YXJnZXQgYXBwLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwbHVnaW4gJiYgaXNGdW5jdGlvbihwbHVnaW4uaW5zdGFsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFsbGVkUGx1Z2lucy5hZGQocGx1Z2luKTtcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luLmluc3RhbGwoYXBwLCAuLi5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihwbHVnaW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbGxlZFBsdWdpbnMuYWRkKHBsdWdpbik7XG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbihhcHAsIC4uLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQSBwbHVnaW4gbXVzdCBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3Qgd2l0aCBhbiBcImluc3RhbGxcIiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBmdW5jdGlvbi5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtaXhpbihtaXhpbikge1xuICAgICAgICAgICAgICAgIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udGV4dC5taXhpbnMuaW5jbHVkZXMobWl4aW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm1peGlucy5wdXNoKG1peGluKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oJ01peGluIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCB0byB0YXJnZXQgYXBwJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1peGluLm5hbWUgPyBgOiAke21peGluLm5hbWV9YCA6ICcnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ01peGlucyBhcmUgb25seSBhdmFpbGFibGUgaW4gYnVpbGRzIHN1cHBvcnRpbmcgT3B0aW9ucyBBUEknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb21wb25lbnQobmFtZSwgY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSwgY29udGV4dC5jb25maWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5jb21wb25lbnRzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNvbnRleHQuY29tcG9uZW50c1tuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKGBDb21wb25lbnQgXCIke25hbWV9XCIgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIGluIHRhcmdldCBhcHAuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRleHQuY29tcG9uZW50c1tuYW1lXSA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpcmVjdGl2ZShuYW1lLCBkaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFkaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjb250ZXh0LmRpcmVjdGl2ZXNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihgRGlyZWN0aXZlIFwiJHtuYW1lfVwiIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCBpbiB0YXJnZXQgYXBwLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250ZXh0LmRpcmVjdGl2ZXNbbmFtZV0gPSBkaXJlY3RpdmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb3VudChyb290Q29udGFpbmVyLCBpc0h5ZHJhdGUsIGlzU1ZHKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc01vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gIzU1NzFcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiByb290Q29udGFpbmVyLl9fdnVlX2FwcF9fKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBUaGVyZSBpcyBhbHJlYWR5IGFuIGFwcCBpbnN0YW5jZSBtb3VudGVkIG9uIHRoZSBob3N0IGNvbnRhaW5lci5cXG5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgIElmIHlvdSB3YW50IHRvIG1vdW50IGFub3RoZXIgYXBwIG9uIHRoZSBzYW1lIGhvc3QgY29udGFpbmVyLGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAgeW91IG5lZWQgdG8gdW5tb3VudCB0aGUgcHJldmlvdXMgYXBwIGJ5IGNhbGxpbmcgXFxgYXBwLnVubW91bnQoKVxcYCBmaXJzdC5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKHJvb3RDb21wb25lbnQsIHJvb3RQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIGFwcCBjb250ZXh0IG9uIHRoZSByb290IFZOb2RlLlxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgYmUgc2V0IG9uIHRoZSByb290IGluc3RhbmNlIG9uIGluaXRpYWwgbW91bnQuXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLmFwcENvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICAvLyBITVIgcm9vdCByZWxvYWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZWxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyKGNsb25lVk5vZGUodm5vZGUpLCByb290Q29udGFpbmVyLCBpc1NWRyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0h5ZHJhdGUgJiYgaHlkcmF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHlkcmF0ZSh2bm9kZSwgcm9vdENvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXIodm5vZGUsIHJvb3RDb250YWluZXIsIGlzU1ZHKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBhcHAuX2NvbnRhaW5lciA9IHJvb3RDb250YWluZXI7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RDb250YWluZXIuX192dWVfYXBwX18gPSBhcHA7XG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHAuX2luc3RhbmNlID0gdm5vZGUuY29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV2dG9vbHNJbml0QXBwKGFwcCwgdmVyc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEV4cG9zZVByb3h5KHZub2RlLmNvbXBvbmVudCkgfHwgdm5vZGUuY29tcG9uZW50LnByb3h5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQXBwIGhhcyBhbHJlYWR5IGJlZW4gbW91bnRlZC5cXG5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBJZiB5b3Ugd2FudCB0byByZW1vdW50IHRoZSBzYW1lIGFwcCwgbW92ZSB5b3VyIGFwcCBjcmVhdGlvbiBsb2dpYyBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBpbnRvIGEgZmFjdG9yeSBmdW5jdGlvbiBhbmQgY3JlYXRlIGZyZXNoIGFwcCBpbnN0YW5jZXMgZm9yIGVhY2ggYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgbW91bnQgLSBlLmcuIFxcYGNvbnN0IGNyZWF0ZU15QXBwID0gKCkgPT4gY3JlYXRlQXBwKEFwcClcXGBgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5tb3VudCgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNNb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcihudWxsLCBhcHAuX2NvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHAuX2luc3RhbmNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldnRvb2xzVW5tb3VudEFwcChhcHApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhcHAuX2NvbnRhaW5lci5fX3Z1ZV9hcHBfXztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYENhbm5vdCB1bm1vdW50IGFuIGFwcCB0aGF0IGlzIG5vdCBtb3VudGVkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm92aWRlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGtleSBpbiBjb250ZXh0LnByb3ZpZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEFwcCBhbHJlYWR5IHByb3ZpZGVzIHByb3BlcnR5IHdpdGgga2V5IFwiJHtTdHJpbmcoa2V5KX1cIi4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgSXQgd2lsbCBiZSBvdmVyd3JpdHRlbiB3aXRoIHRoZSBuZXcgdmFsdWUuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRleHQucHJvdmlkZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBhcHA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXBwO1xuICAgIH07XG59XG5cbi8qKlxuICogRnVuY3Rpb24gZm9yIGhhbmRsaW5nIGEgdGVtcGxhdGUgcmVmXG4gKi9cbmZ1bmN0aW9uIHNldFJlZihyYXdSZWYsIG9sZFJhd1JlZiwgcGFyZW50U3VzcGVuc2UsIHZub2RlLCBpc1VubW91bnQgPSBmYWxzZSkge1xuICAgIGlmIChpc0FycmF5KHJhd1JlZikpIHtcbiAgICAgICAgcmF3UmVmLmZvckVhY2goKHIsIGkpID0+IHNldFJlZihyLCBvbGRSYXdSZWYgJiYgKGlzQXJyYXkob2xkUmF3UmVmKSA/IG9sZFJhd1JlZltpXSA6IG9sZFJhd1JlZiksIHBhcmVudFN1c3BlbnNlLCB2bm9kZSwgaXNVbm1vdW50KSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzQXN5bmNXcmFwcGVyKHZub2RlKSAmJiAhaXNVbm1vdW50KSB7XG4gICAgICAgIC8vIHdoZW4gbW91bnRpbmcgYXN5bmMgY29tcG9uZW50cywgbm90aGluZyBuZWVkcyB0byBiZSBkb25lLFxuICAgICAgICAvLyBiZWNhdXNlIHRoZSB0ZW1wbGF0ZSByZWYgaXMgZm9yd2FyZGVkIHRvIGlubmVyIGNvbXBvbmVudFxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlZlZhbHVlID0gdm5vZGUuc2hhcGVGbGFnICYgNCAvKiBTaGFwZUZsYWdzLlNUQVRFRlVMX0NPTVBPTkVOVCAqL1xuICAgICAgICA/IGdldEV4cG9zZVByb3h5KHZub2RlLmNvbXBvbmVudCkgfHwgdm5vZGUuY29tcG9uZW50LnByb3h5XG4gICAgICAgIDogdm5vZGUuZWw7XG4gICAgY29uc3QgdmFsdWUgPSBpc1VubW91bnQgPyBudWxsIDogcmVmVmFsdWU7XG4gICAgY29uc3QgeyBpOiBvd25lciwgcjogcmVmIH0gPSByYXdSZWY7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhb3duZXIpIHtcbiAgICAgICAgd2FybihgTWlzc2luZyByZWYgb3duZXIgY29udGV4dC4gcmVmIGNhbm5vdCBiZSB1c2VkIG9uIGhvaXN0ZWQgdm5vZGVzLiBgICtcbiAgICAgICAgICAgIGBBIHZub2RlIHdpdGggcmVmIG11c3QgYmUgY3JlYXRlZCBpbnNpZGUgdGhlIHJlbmRlciBmdW5jdGlvbi5gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvbGRSZWYgPSBvbGRSYXdSZWYgJiYgb2xkUmF3UmVmLnI7XG4gICAgY29uc3QgcmVmcyA9IG93bmVyLnJlZnMgPT09IEVNUFRZX09CSiA/IChvd25lci5yZWZzID0ge30pIDogb3duZXIucmVmcztcbiAgICBjb25zdCBzZXR1cFN0YXRlID0gb3duZXIuc2V0dXBTdGF0ZTtcbiAgICAvLyBkeW5hbWljIHJlZiBjaGFuZ2VkLiB1bnNldCBvbGQgcmVmXG4gICAgaWYgKG9sZFJlZiAhPSBudWxsICYmIG9sZFJlZiAhPT0gcmVmKSB7XG4gICAgICAgIGlmIChpc1N0cmluZyhvbGRSZWYpKSB7XG4gICAgICAgICAgICByZWZzW29sZFJlZl0gPSBudWxsO1xuICAgICAgICAgICAgaWYgKGhhc093bihzZXR1cFN0YXRlLCBvbGRSZWYpKSB7XG4gICAgICAgICAgICAgICAgc2V0dXBTdGF0ZVtvbGRSZWZdID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1JlZihvbGRSZWYpKSB7XG4gICAgICAgICAgICBvbGRSZWYudmFsdWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc0Z1bmN0aW9uKHJlZikpIHtcbiAgICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKHJlZiwgb3duZXIsIDEyIC8qIEVycm9yQ29kZXMuRlVOQ1RJT05fUkVGICovLCBbdmFsdWUsIHJlZnNdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IF9pc1N0cmluZyA9IGlzU3RyaW5nKHJlZik7XG4gICAgICAgIGNvbnN0IF9pc1JlZiA9IGlzUmVmKHJlZik7XG4gICAgICAgIGlmIChfaXNTdHJpbmcgfHwgX2lzUmVmKSB7XG4gICAgICAgICAgICBjb25zdCBkb1NldCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmF3UmVmLmYpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBfaXNTdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gaGFzT3duKHNldHVwU3RhdGUsIHJlZilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNldHVwU3RhdGVbcmVmXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVmc1tyZWZdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHJlZi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5tb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNBcnJheShleGlzdGluZykgJiYgcmVtb3ZlKGV4aXN0aW5nLCByZWZWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkoZXhpc3RpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc1N0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZzW3JlZl0gPSBbcmVmVmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3duKHNldHVwU3RhdGUsIHJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHVwU3RhdGVbcmVmXSA9IHJlZnNbcmVmXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmLnZhbHVlID0gW3JlZlZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhd1JlZi5rKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmc1tyYXdSZWYua10gPSByZWYudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWV4aXN0aW5nLmluY2x1ZGVzKHJlZlZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLnB1c2gocmVmVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9pc1N0cmluZykge1xuICAgICAgICAgICAgICAgICAgICByZWZzW3JlZl0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc093bihzZXR1cFN0YXRlLCByZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR1cFN0YXRlW3JlZl0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfaXNSZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYXdSZWYuaylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnNbcmF3UmVmLmtdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKCdJbnZhbGlkIHRlbXBsYXRlIHJlZiB0eXBlOicsIHJlZiwgYCgke3R5cGVvZiByZWZ9KWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBkb1NldC5pZCA9IC0xO1xuICAgICAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChkb1NldCwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9TZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgIHdhcm4oJ0ludmFsaWQgdGVtcGxhdGUgcmVmIHR5cGU6JywgcmVmLCBgKCR7dHlwZW9mIHJlZn0pYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmxldCBoYXNNaXNtYXRjaCA9IGZhbHNlO1xuY29uc3QgaXNTVkdDb250YWluZXIgPSAoY29udGFpbmVyKSA9PiAvc3ZnLy50ZXN0KGNvbnRhaW5lci5uYW1lc3BhY2VVUkkpICYmIGNvbnRhaW5lci50YWdOYW1lICE9PSAnZm9yZWlnbk9iamVjdCc7XG5jb25zdCBpc0NvbW1lbnQgPSAobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBET01Ob2RlVHlwZXMuQ09NTUVOVCAqLztcbi8vIE5vdGU6IGh5ZHJhdGlvbiBpcyBET00tc3BlY2lmaWNcbi8vIEJ1dCB3ZSBoYXZlIHRvIHBsYWNlIGl0IGluIGNvcmUgZHVlIHRvIHRpZ2h0IGNvdXBsaW5nIHdpdGggY29yZSAtIHNwbGl0dGluZ1xuLy8gaXQgb3V0IGNyZWF0ZXMgYSB0b24gb2YgdW5uZWNlc3NhcnkgY29tcGxleGl0eS5cbi8vIEh5ZHJhdGlvbiBhbHNvIGRlcGVuZHMgb24gc29tZSByZW5kZXJlciBpbnRlcm5hbCBsb2dpYyB3aGljaCBuZWVkcyB0byBiZVxuLy8gcGFzc2VkIGluIHZpYSBhcmd1bWVudHMuXG5mdW5jdGlvbiBjcmVhdGVIeWRyYXRpb25GdW5jdGlvbnMocmVuZGVyZXJJbnRlcm5hbHMpIHtcbiAgICBjb25zdCB7IG10OiBtb3VudENvbXBvbmVudCwgcDogcGF0Y2gsIG86IHsgcGF0Y2hQcm9wLCBjcmVhdGVUZXh0LCBuZXh0U2libGluZywgcGFyZW50Tm9kZSwgcmVtb3ZlLCBpbnNlcnQsIGNyZWF0ZUNvbW1lbnQgfSB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XG4gICAgY29uc3QgaHlkcmF0ZSA9ICh2bm9kZSwgY29udGFpbmVyKSA9PiB7XG4gICAgICAgIGlmICghY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICAgICAgd2FybihgQXR0ZW1wdGluZyB0byBoeWRyYXRlIGV4aXN0aW5nIG1hcmt1cCBidXQgY29udGFpbmVyIGlzIGVtcHR5LiBgICtcbiAgICAgICAgICAgICAgICAgICAgYFBlcmZvcm1pbmcgZnVsbCBtb3VudCBpbnN0ZWFkLmApO1xuICAgICAgICAgICAgcGF0Y2gobnVsbCwgdm5vZGUsIGNvbnRhaW5lcik7XG4gICAgICAgICAgICBmbHVzaFBvc3RGbHVzaENicygpO1xuICAgICAgICAgICAgY29udGFpbmVyLl92bm9kZSA9IHZub2RlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGhhc01pc21hdGNoID0gZmFsc2U7XG4gICAgICAgIGh5ZHJhdGVOb2RlKGNvbnRhaW5lci5maXJzdENoaWxkLCB2bm9kZSwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIGZsdXNoUG9zdEZsdXNoQ2JzKCk7XG4gICAgICAgIGNvbnRhaW5lci5fdm5vZGUgPSB2bm9kZTtcbiAgICAgICAgaWYgKGhhc01pc21hdGNoICYmICFmYWxzZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBlcnJvciBzaG91bGQgc2hvdyB1cCBpbiBwcm9kdWN0aW9uXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBIeWRyYXRpb24gY29tcGxldGVkIGJ1dCBjb250YWlucyBtaXNtYXRjaGVzLmApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBoeWRyYXRlTm9kZSA9IChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQgPSBmYWxzZSkgPT4ge1xuICAgICAgICBjb25zdCBpc0ZyYWdtZW50U3RhcnQgPSBpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSAnWyc7XG4gICAgICAgIGNvbnN0IG9uTWlzbWF0Y2ggPSAoKSA9PiBoYW5kbGVNaXNtYXRjaChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBpc0ZyYWdtZW50U3RhcnQpO1xuICAgICAgICBjb25zdCB7IHR5cGUsIHJlZiwgc2hhcGVGbGFnLCBwYXRjaEZsYWcgfSA9IHZub2RlO1xuICAgICAgICBsZXQgZG9tVHlwZSA9IG5vZGUubm9kZVR5cGU7XG4gICAgICAgIHZub2RlLmVsID0gbm9kZTtcbiAgICAgICAgaWYgKHBhdGNoRmxhZyA9PT0gLTIgLyogUGF0Y2hGbGFncy5CQUlMICovKSB7XG4gICAgICAgICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZub2RlLmR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHROb2RlID0gbnVsbDtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFRleHQ6XG4gICAgICAgICAgICAgICAgaWYgKGRvbVR5cGUgIT09IDMgLyogRE9NTm9kZVR5cGVzLlRFWFQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gIzU3MjggZW1wdHkgdGV4dCBub2RlIGluc2lkZSBhIHNsb3QgY2FuIGNhdXNlIGh5ZHJhdGlvbiBmYWlsdXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhlIHNlcnZlciByZW5kZXJlZCBIVE1MIHdvbid0IGNvbnRhaW4gYSB0ZXh0IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZub2RlLmNoaWxkcmVuID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0KCh2bm9kZS5lbCA9IGNyZWF0ZVRleHQoJycpKSwgcGFyZW50Tm9kZShub2RlKSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZGF0YSAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEh5ZHJhdGlvbiB0ZXh0IG1pc21hdGNoOmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXFxuLSBDbGllbnQ6ICR7SlNPTi5zdHJpbmdpZnkobm9kZS5kYXRhKX1gICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFxcbi0gU2VydmVyOiAke0pTT04uc3RyaW5naWZ5KHZub2RlLmNoaWxkcmVuKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZub2RlLmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDb21tZW50OlxuICAgICAgICAgICAgICAgIGlmIChkb21UeXBlICE9PSA4IC8qIERPTU5vZGVUeXBlcy5DT01NRU5UICovIHx8IGlzRnJhZ21lbnRTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTdGF0aWM6XG4gICAgICAgICAgICAgICAgaWYgKGlzRnJhZ21lbnRTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbnRpcmUgdGVtcGxhdGUgaXMgc3RhdGljIGJ1dCBTU1JlZCBhcyBhIGZyYWdtZW50XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgZG9tVHlwZSA9IG5vZGUubm9kZVR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkb21UeXBlID09PSAxIC8qIERPTU5vZGVUeXBlcy5FTEVNRU5UICovIHx8IGRvbVR5cGUgPT09IDMgLyogRE9NTm9kZVR5cGVzLlRFWFQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGFuY2hvciwgYWRvcHQgY29udGVudFxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBzdGF0aWMgdm5vZGUgaGFzIGl0cyBjb250ZW50IHN0cmlwcGVkIGR1cmluZyBidWlsZCxcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRvcHQgaXQgZnJvbSB0aGUgc2VydmVyLXJlbmRlcmVkIEhUTUwuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lZWRUb0Fkb3B0Q29udGVudCA9ICF2bm9kZS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdm5vZGUuc3RhdGljQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5lZWRUb0Fkb3B0Q29udGVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2bm9kZS5jaGlsZHJlbiArPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZS5ub2RlVHlwZSA9PT0gMSAvKiBET01Ob2RlVHlwZXMuRUxFTUVOVCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXh0Tm9kZS5vdXRlckhUTUxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbmV4dE5vZGUuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSB2bm9kZS5zdGF0aWNDb3VudCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2bm9kZS5hbmNob3IgPSBuZXh0Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobmV4dE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0ZyYWdtZW50U3RhcnQgPyBuZXh0U2libGluZyhuZXh0Tm9kZSkgOiBuZXh0Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9uTWlzbWF0Y2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICAgICAgICAgIGlmICghaXNGcmFnbWVudFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBoeWRyYXRlRnJhZ21lbnQobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxIC8qIFNoYXBlRmxhZ3MuRUxFTUVOVCAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gMSAvKiBET01Ob2RlVHlwZXMuRUxFTUVOVCAqLyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdm5vZGUudHlwZS50b0xvd2VyQ2FzZSgpICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gaHlkcmF0ZUVsZW1lbnQobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiA2IC8qIFNoYXBlRmxhZ3MuQ09NUE9ORU5UICovKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gc2V0dGluZyB1cCB0aGUgcmVuZGVyIGVmZmVjdCwgaWYgdGhlIGluaXRpYWwgdm5vZGUgYWxyZWFkeVxuICAgICAgICAgICAgICAgICAgICAvLyBoYXMgLmVsIHNldCwgdGhlIGNvbXBvbmVudCB3aWxsIHBlcmZvcm0gaHlkcmF0aW9uIGluc3RlYWQgb2YgbW91bnRcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gaXRzIHN1Yi10cmVlLlxuICAgICAgICAgICAgICAgICAgICB2bm9kZS5zbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcmVudE5vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIG1vdW50Q29tcG9uZW50KHZub2RlLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHQ29udGFpbmVyKGNvbnRhaW5lciksIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudCBtYXkgYmUgYXN5bmMsIHNvIGluIHRoZSBjYXNlIG9mIGZyYWdtZW50cyB3ZSBjYW5ub3QgcmVseVxuICAgICAgICAgICAgICAgICAgICAvLyBvbiBjb21wb25lbnQncyByZW5kZXJlZCBvdXRwdXQgdG8gZGV0ZXJtaW5lIHRoZSBlbmQgb2YgdGhlIGZyYWdtZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIGluc3RlYWQsIHdlIGRvIGEgbG9va2FoZWFkIHRvIGZpbmQgdGhlIGVuZCBhbmNob3Igbm9kZS5cbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBpc0ZyYWdtZW50U3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbG9jYXRlQ2xvc2luZ0FzeW5jQW5jaG9yKG5vZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAvLyAjNDI5MyB0ZWxlcG9ydCBhcyBjb21wb25lbnQgcm9vdFxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dE5vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29tbWVudChuZXh0Tm9kZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlLmRhdGEgPT09ICd0ZWxlcG9ydCBlbmQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5leHROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyAjMzc4N1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBjb21wb25lbnQgaXMgYXN5bmMsIGl0IG1heSBnZXQgbW92ZWQgLyB1bm1vdW50ZWQgYmVmb3JlIGl0c1xuICAgICAgICAgICAgICAgICAgICAvLyBpbm5lciBjb21wb25lbnQgaXMgbG9hZGVkLCBzbyB3ZSBuZWVkIHRvIGdpdmUgaXQgYSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgICAgICAvLyB2bm9kZSB0aGF0IG1hdGNoZXMgaXRzIGFkb3B0ZWQgRE9NLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBc3luY1dyYXBwZXIodm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3ViVHJlZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0ZyYWdtZW50U3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlID0gY3JlYXRlVk5vZGUoRnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YlRyZWUuYW5jaG9yID0gbmV4dE5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXh0Tm9kZS5wcmV2aW91c1NpYmxpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjb250YWluZXIubGFzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubm9kZVR5cGUgPT09IDMgPyBjcmVhdGVUZXh0Vk5vZGUoJycpIDogY3JlYXRlVk5vZGUoJ2RpdicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZS5lbCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2bm9kZS5jb21wb25lbnQuc3ViVHJlZSA9IHN1YlRyZWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgNjQgLyogU2hhcGVGbGFncy5URUxFUE9SVCAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gOCAvKiBET01Ob2RlVHlwZXMuQ09NTUVOVCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IHZub2RlLnR5cGUuaHlkcmF0ZShub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBoeWRyYXRlQ2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDEyOCAvKiBTaGFwZUZsYWdzLlNVU1BFTlNFICovKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gdm5vZGUudHlwZS5oeWRyYXRlKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWR0NvbnRhaW5lcihwYXJlbnROb2RlKG5vZGUpKSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBoeWRyYXRlTm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKCdJbnZhbGlkIEhvc3RWTm9kZSB0eXBlOicsIHR5cGUsIGAoJHt0eXBlb2YgdHlwZX0pYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZWYgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0UmVmKHJlZiwgbnVsbCwgcGFyZW50U3VzcGVuc2UsIHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dE5vZGU7XG4gICAgfTtcbiAgICBjb25zdCBoeWRyYXRlRWxlbWVudCA9IChlbCwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgICAgIG9wdGltaXplZCA9IG9wdGltaXplZCB8fCAhIXZub2RlLmR5bmFtaWNDaGlsZHJlbjtcbiAgICAgICAgY29uc3QgeyB0eXBlLCBwcm9wcywgcGF0Y2hGbGFnLCBzaGFwZUZsYWcsIGRpcnMgfSA9IHZub2RlO1xuICAgICAgICAvLyAjNDAwNiBmb3IgZm9ybSBlbGVtZW50cyB3aXRoIG5vbi1zdHJpbmcgdi1tb2RlbCB2YWx1ZSBiaW5kaW5nc1xuICAgICAgICAvLyBlLmcuIDxvcHRpb24gOnZhbHVlPVwib2JqXCI+LCA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgOnRydWUtdmFsdWU9XCIxXCI+XG4gICAgICAgIGNvbnN0IGZvcmNlUGF0Y2hWYWx1ZSA9ICh0eXBlID09PSAnaW5wdXQnICYmIGRpcnMpIHx8IHR5cGUgPT09ICdvcHRpb24nO1xuICAgICAgICAvLyBza2lwIHByb3BzICYgY2hpbGRyZW4gaWYgdGhpcyBpcyBob2lzdGVkIHN0YXRpYyBub2Rlc1xuICAgICAgICAvLyAjNTQwNSBpbiBkZXYsIGFsd2F5cyBoeWRyYXRlIGNoaWxkcmVuIGZvciBITVJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBmb3JjZVBhdGNoVmFsdWUgfHwgcGF0Y2hGbGFnICE9PSAtMSAvKiBQYXRjaEZsYWdzLkhPSVNURUQgKi8pIHtcbiAgICAgICAgICAgIGlmIChkaXJzKSB7XG4gICAgICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnY3JlYXRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcHJvcHNcbiAgICAgICAgICAgIGlmIChwcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChmb3JjZVBhdGNoVmFsdWUgfHxcbiAgICAgICAgICAgICAgICAgICAgIW9wdGltaXplZCB8fFxuICAgICAgICAgICAgICAgICAgICBwYXRjaEZsYWcgJiAoMTYgLyogUGF0Y2hGbGFncy5GVUxMX1BST1BTICovIHwgMzIgLyogUGF0Y2hGbGFncy5IWURSQVRFX0VWRU5UUyAqLykpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZm9yY2VQYXRjaFZhbHVlICYmIGtleS5lbmRzV2l0aCgndmFsdWUnKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaXNPbihrZXkpICYmICFpc1Jlc2VydmVkUHJvcChrZXkpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoUHJvcChlbCwga2V5LCBudWxsLCBwcm9wc1trZXldLCBmYWxzZSwgdW5kZWZpbmVkLCBwYXJlbnRDb21wb25lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3BzLm9uQ2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmFzdCBwYXRoIGZvciBjbGljayBsaXN0ZW5lcnMgKHdoaWNoIGlzIG1vc3Qgb2Z0ZW4pIHRvIGF2b2lkXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGluZyB0aHJvdWdoIHByb3BzLlxuICAgICAgICAgICAgICAgICAgICBwYXRjaFByb3AoZWwsICdvbkNsaWNrJywgbnVsbCwgcHJvcHMub25DbGljaywgZmFsc2UsIHVuZGVmaW5lZCwgcGFyZW50Q29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB2bm9kZSAvIGRpcmVjdGl2ZSBob29rc1xuICAgICAgICAgICAgbGV0IHZub2RlSG9va3M7XG4gICAgICAgICAgICBpZiAoKHZub2RlSG9va3MgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpKSB7XG4gICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9va3MsIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpcnMpIHtcbiAgICAgICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdiZWZvcmVNb3VudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh2bm9kZUhvb2tzID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZU1vdW50ZWQpIHx8IGRpcnMpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZUVmZmVjdFdpdGhTdXNwZW5zZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZub2RlSG9va3MgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9va3MsIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ21vdW50ZWQnKTtcbiAgICAgICAgICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGlsZHJlblxuICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIFNoYXBlRmxhZ3MuQVJSQVlfQ0hJTERSRU4gKi8gJiZcbiAgICAgICAgICAgICAgICAvLyBza2lwIGlmIGVsZW1lbnQgaGFzIGlubmVySFRNTCAvIHRleHRDb250ZW50XG4gICAgICAgICAgICAgICAgIShwcm9wcyAmJiAocHJvcHMuaW5uZXJIVE1MIHx8IHByb3BzLnRleHRDb250ZW50KSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGh5ZHJhdGVDaGlsZHJlbihlbC5maXJzdENoaWxkLCB2bm9kZSwgZWwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICBsZXQgaGFzV2FybmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFoYXNXYXJuZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEh5ZHJhdGlvbiBjaGlsZHJlbiBtaXNtYXRjaCBpbiA8JHt2bm9kZS50eXBlfT46IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBzZXJ2ZXIgcmVuZGVyZWQgZWxlbWVudCBjb250YWlucyBtb3JlIGNoaWxkIG5vZGVzIHRoYW4gY2xpZW50IHZkb20uYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBTU1JlZCBET00gY29udGFpbnMgbW9yZSBub2RlcyB0aGFuIGl0IHNob3VsZC4gUmVtb3ZlIHRoZW0uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1ciA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmUoY3VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiA4IC8qIFNoYXBlRmxhZ3MuVEVYVF9DSElMRFJFTiAqLykge1xuICAgICAgICAgICAgICAgIGlmIChlbC50ZXh0Q29udGVudCAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEh5ZHJhdGlvbiB0ZXh0IGNvbnRlbnQgbWlzbWF0Y2ggaW4gPCR7dm5vZGUudHlwZX0+OlxcbmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAtIENsaWVudDogJHtlbC50ZXh0Q29udGVudH1cXG5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgLSBTZXJ2ZXI6ICR7dm5vZGUuY2hpbGRyZW59YCk7XG4gICAgICAgICAgICAgICAgICAgIGVsLnRleHRDb250ZW50ID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbC5uZXh0U2libGluZztcbiAgICB9O1xuICAgIGNvbnN0IGh5ZHJhdGVDaGlsZHJlbiA9IChub2RlLCBwYXJlbnRWTm9kZSwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgICAgICBvcHRpbWl6ZWQgPSBvcHRpbWl6ZWQgfHwgISFwYXJlbnRWTm9kZS5keW5hbWljQ2hpbGRyZW47XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50Vk5vZGUuY2hpbGRyZW47XG4gICAgICAgIGNvbnN0IGwgPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGxldCBoYXNXYXJuZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHZub2RlID0gb3B0aW1pemVkXG4gICAgICAgICAgICAgICAgPyBjaGlsZHJlbltpXVxuICAgICAgICAgICAgICAgIDogKGNoaWxkcmVuW2ldID0gbm9ybWFsaXplVk5vZGUoY2hpbGRyZW5baV0pKTtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGh5ZHJhdGVOb2RlKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2bm9kZS50eXBlID09PSBUZXh0ICYmICF2bm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWhhc1dhcm5lZCkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKGBIeWRyYXRpb24gY2hpbGRyZW4gbWlzbWF0Y2ggaW4gPCR7Y29udGFpbmVyLnRhZ05hbWUudG9Mb3dlckNhc2UoKX0+OiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBzZXJ2ZXIgcmVuZGVyZWQgZWxlbWVudCBjb250YWlucyBmZXdlciBjaGlsZCBub2RlcyB0aGFuIGNsaWVudCB2ZG9tLmApO1xuICAgICAgICAgICAgICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0aGUgU1NSZWQgRE9NIGRpZG4ndCBjb250YWluIGVub3VnaCBub2Rlcy4gTW91bnQgdGhlIG1pc3Npbmcgb25lcy5cbiAgICAgICAgICAgICAgICBwYXRjaChudWxsLCB2bm9kZSwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWR0NvbnRhaW5lcihjb250YWluZXIpLCBzbG90U2NvcGVJZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgY29uc3QgaHlkcmF0ZUZyYWdtZW50ID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgICAgICBjb25zdCB7IHNsb3RTY29wZUlkczogZnJhZ21lbnRTbG90U2NvcGVJZHMgfSA9IHZub2RlO1xuICAgICAgICBpZiAoZnJhZ21lbnRTbG90U2NvcGVJZHMpIHtcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkc1xuICAgICAgICAgICAgICAgID8gc2xvdFNjb3BlSWRzLmNvbmNhdChmcmFnbWVudFNsb3RTY29wZUlkcylcbiAgICAgICAgICAgICAgICA6IGZyYWdtZW50U2xvdFNjb3BlSWRzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcmVudE5vZGUobm9kZSk7XG4gICAgICAgIGNvbnN0IG5leHQgPSBoeWRyYXRlQ2hpbGRyZW4obmV4dFNpYmxpbmcobm9kZSksIHZub2RlLCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgaWYgKG5leHQgJiYgaXNDb21tZW50KG5leHQpICYmIG5leHQuZGF0YSA9PT0gJ10nKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dFNpYmxpbmcoKHZub2RlLmFuY2hvciA9IG5leHQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZyYWdtZW50IGRpZG4ndCBoeWRyYXRlIHN1Y2Nlc3NmdWxseSwgc2luY2Ugd2UgZGlkbid0IGdldCBhIGVuZCBhbmNob3JcbiAgICAgICAgICAgIC8vIGJhY2suIFRoaXMgc2hvdWxkIGhhdmUgbGVkIHRvIG5vZGUvY2hpbGRyZW4gbWlzbWF0Y2ggd2FybmluZ3MuXG4gICAgICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAvLyBzaW5jZSB0aGUgYW5jaG9yIGlzIG1pc3NpbmcsIHdlIG5lZWQgdG8gY3JlYXRlIG9uZSBhbmQgaW5zZXJ0IGl0XG4gICAgICAgICAgICBpbnNlcnQoKHZub2RlLmFuY2hvciA9IGNyZWF0ZUNvbW1lbnQoYF1gKSksIGNvbnRhaW5lciwgbmV4dCk7XG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlTWlzbWF0Y2ggPSAobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgaXNGcmFnbWVudCkgPT4ge1xuICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgd2FybihgSHlkcmF0aW9uIG5vZGUgbWlzbWF0Y2g6XFxuLSBDbGllbnQgdm5vZGU6YCwgdm5vZGUudHlwZSwgYFxcbi0gU2VydmVyIHJlbmRlcmVkIERPTTpgLCBub2RlLCBub2RlLm5vZGVUeXBlID09PSAzIC8qIERPTU5vZGVUeXBlcy5URVhUICovXG4gICAgICAgICAgICAgICAgPyBgKHRleHQpYFxuICAgICAgICAgICAgICAgIDogaXNDb21tZW50KG5vZGUpICYmIG5vZGUuZGF0YSA9PT0gJ1snXG4gICAgICAgICAgICAgICAgICAgID8gYChzdGFydCBvZiBmcmFnbWVudClgXG4gICAgICAgICAgICAgICAgICAgIDogYGApO1xuICAgICAgICB2bm9kZS5lbCA9IG51bGw7XG4gICAgICAgIGlmIChpc0ZyYWdtZW50KSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgZXhjZXNzaXZlIGZyYWdtZW50IG5vZGVzXG4gICAgICAgICAgICBjb25zdCBlbmQgPSBsb2NhdGVDbG9zaW5nQXN5bmNBbmNob3Iobm9kZSk7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0ICE9PSBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKG5leHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHQgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50Tm9kZShub2RlKTtcbiAgICAgICAgcmVtb3ZlKG5vZGUpO1xuICAgICAgICBwYXRjaChudWxsLCB2bm9kZSwgY29udGFpbmVyLCBuZXh0LCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWR0NvbnRhaW5lcihjb250YWluZXIpLCBzbG90U2NvcGVJZHMpO1xuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICAgIGNvbnN0IGxvY2F0ZUNsb3NpbmdBc3luY0FuY2hvciA9IChub2RlKSA9PiB7XG4gICAgICAgIGxldCBtYXRjaCA9IDA7XG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBub2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgICBpZiAobm9kZSAmJiBpc0NvbW1lbnQobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5kYXRhID09PSAnWycpXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoKys7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZGF0YSA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2gtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIHJldHVybiBbaHlkcmF0ZSwgaHlkcmF0ZU5vZGVdO1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cbmxldCBzdXBwb3J0ZWQ7XG5sZXQgcGVyZjtcbmZ1bmN0aW9uIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgdHlwZSkge1xuICAgIGlmIChpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy5wZXJmb3JtYW5jZSAmJiBpc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgIHBlcmYubWFyayhgdnVlLSR7dHlwZX0tJHtpbnN0YW5jZS51aWR9YCk7XG4gICAgfVxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgIGRldnRvb2xzUGVyZlN0YXJ0KGluc3RhbmNlLCB0eXBlLCBpc1N1cHBvcnRlZCgpID8gcGVyZi5ub3coKSA6IERhdGUubm93KCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVuZE1lYXN1cmUoaW5zdGFuY2UsIHR5cGUpIHtcbiAgICBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcucGVyZm9ybWFuY2UgJiYgaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICBjb25zdCBzdGFydFRhZyA9IGB2dWUtJHt0eXBlfS0ke2luc3RhbmNlLnVpZH1gO1xuICAgICAgICBjb25zdCBlbmRUYWcgPSBzdGFydFRhZyArIGA6ZW5kYDtcbiAgICAgICAgcGVyZi5tYXJrKGVuZFRhZyk7XG4gICAgICAgIHBlcmYubWVhc3VyZShgPCR7Zm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgaW5zdGFuY2UudHlwZSl9PiAke3R5cGV9YCwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XG4gICAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgIH1cbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICBkZXZ0b29sc1BlcmZFbmQoaW5zdGFuY2UsIHR5cGUsIGlzU3VwcG9ydGVkKCkgPyBwZXJmLm5vdygpIDogRGF0ZS5ub3coKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XG4gICAgaWYgKHN1cHBvcnRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzdXBwb3J0ZWQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucGVyZm9ybWFuY2UpIHtcbiAgICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgcGVyZiA9IHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc3VwcG9ydGVkO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgb25seSBjYWxsZWQgaW4gZXNtLWJ1bmRsZXIgYnVpbGRzLlxuICogSXQgaXMgY2FsbGVkIHdoZW4gYSByZW5kZXJlciBpcyBjcmVhdGVkLCBpbiBgYmFzZUNyZWF0ZVJlbmRlcmVyYCBzbyB0aGF0XG4gKiBpbXBvcnRpbmcgcnVudGltZS1jb3JlIGlzIHNpZGUtZWZmZWN0cyBmcmVlLlxuICpcbiAqIGlzdGFuYnVsLWlnbm9yZS1uZXh0XG4gKi9cbmZ1bmN0aW9uIGluaXRGZWF0dXJlRmxhZ3MoKSB7XG4gICAgY29uc3QgbmVlZFdhcm4gPSBbXTtcbiAgICBpZiAodHlwZW9mIF9fVlVFX09QVElPTlNfQVBJX18gIT09ICdib29sZWFuJykge1xuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgbmVlZFdhcm4ucHVzaChgX19WVUVfT1BUSU9OU19BUElfX2ApO1xuICAgICAgICBnZXRHbG9iYWxUaGlzKCkuX19WVUVfT1BUSU9OU19BUElfXyA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgX19WVUVfUFJPRF9ERVZUT09MU19fICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIG5lZWRXYXJuLnB1c2goYF9fVlVFX1BST0RfREVWVE9PTFNfX2ApO1xuICAgICAgICBnZXRHbG9iYWxUaGlzKCkuX19WVUVfUFJPRF9ERVZUT09MU19fID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgbmVlZFdhcm4ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IG11bHRpID0gbmVlZFdhcm4ubGVuZ3RoID4gMTtcbiAgICAgICAgY29uc29sZS53YXJuKGBGZWF0dXJlIGZsYWcke211bHRpID8gYHNgIDogYGB9ICR7bmVlZFdhcm4uam9pbignLCAnKX0gJHttdWx0aSA/IGBhcmVgIDogYGlzYH0gbm90IGV4cGxpY2l0bHkgZGVmaW5lZC4gWW91IGFyZSBydW5uaW5nIHRoZSBlc20tYnVuZGxlciBidWlsZCBvZiBWdWUsIGAgK1xuICAgICAgICAgICAgYHdoaWNoIGV4cGVjdHMgdGhlc2UgY29tcGlsZS10aW1lIGZlYXR1cmUgZmxhZ3MgdG8gYmUgZ2xvYmFsbHkgaW5qZWN0ZWQgYCArXG4gICAgICAgICAgICBgdmlhIHRoZSBidW5kbGVyIGNvbmZpZyBpbiBvcmRlciB0byBnZXQgYmV0dGVyIHRyZWUtc2hha2luZyBpbiB0aGUgYCArXG4gICAgICAgICAgICBgcHJvZHVjdGlvbiBidW5kbGUuXFxuXFxuYCArXG4gICAgICAgICAgICBgRm9yIG1vcmUgZGV0YWlscywgc2VlIGh0dHBzOi8vbGluay52dWVqcy5vcmcvZmVhdHVyZS1mbGFncy5gKTtcbiAgICB9XG59XG5cbmNvbnN0IHF1ZXVlUG9zdFJlbmRlckVmZmVjdCA9IHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlXG4gICAgO1xuLyoqXG4gKiBUaGUgY3JlYXRlUmVuZGVyZXIgZnVuY3Rpb24gYWNjZXB0cyB0d28gZ2VuZXJpYyBhcmd1bWVudHM6XG4gKiBIb3N0Tm9kZSBhbmQgSG9zdEVsZW1lbnQsIGNvcnJlc3BvbmRpbmcgdG8gTm9kZSBhbmQgRWxlbWVudCB0eXBlcyBpbiB0aGVcbiAqIGhvc3QgZW52aXJvbm1lbnQuIEZvciBleGFtcGxlLCBmb3IgcnVudGltZS1kb20sIEhvc3ROb2RlIHdvdWxkIGJlIHRoZSBET01cbiAqIGBOb2RlYCBpbnRlcmZhY2UgYW5kIEhvc3RFbGVtZW50IHdvdWxkIGJlIHRoZSBET00gYEVsZW1lbnRgIGludGVyZmFjZS5cbiAqXG4gKiBDdXN0b20gcmVuZGVyZXJzIGNhbiBwYXNzIGluIHRoZSBwbGF0Zm9ybSBzcGVjaWZpYyB0eXBlcyBsaWtlIHRoaXM6XG4gKlxuICogYGBgIGpzXG4gKiBjb25zdCB7IHJlbmRlciwgY3JlYXRlQXBwIH0gPSBjcmVhdGVSZW5kZXJlcjxOb2RlLCBFbGVtZW50Pih7XG4gKiAgIHBhdGNoUHJvcCxcbiAqICAgLi4ubm9kZU9wc1xuICogfSlcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJlcihvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJhc2VDcmVhdGVSZW5kZXJlcihvcHRpb25zKTtcbn1cbi8vIFNlcGFyYXRlIEFQSSBmb3IgY3JlYXRpbmcgaHlkcmF0aW9uLWVuYWJsZWQgcmVuZGVyZXIuXG4vLyBIeWRyYXRpb24gbG9naWMgaXMgb25seSB1c2VkIHdoZW4gY2FsbGluZyB0aGlzIGZ1bmN0aW9uLCBtYWtpbmcgaXRcbi8vIHRyZWUtc2hha2FibGUuXG5mdW5jdGlvbiBjcmVhdGVIeWRyYXRpb25SZW5kZXJlcihvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJhc2VDcmVhdGVSZW5kZXJlcihvcHRpb25zLCBjcmVhdGVIeWRyYXRpb25GdW5jdGlvbnMpO1xufVxuLy8gaW1wbGVtZW50YXRpb25cbmZ1bmN0aW9uIGJhc2VDcmVhdGVSZW5kZXJlcihvcHRpb25zLCBjcmVhdGVIeWRyYXRpb25GbnMpIHtcbiAgICAvLyBjb21waWxlLXRpbWUgZmVhdHVyZSBmbGFncyBjaGVja1xuICAgIHtcbiAgICAgICAgaW5pdEZlYXR1cmVGbGFncygpO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBnZXRHbG9iYWxUaGlzKCk7XG4gICAgdGFyZ2V0Ll9fVlVFX18gPSB0cnVlO1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgIHNldERldnRvb2xzSG9vayh0YXJnZXQuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXywgdGFyZ2V0KTtcbiAgICB9XG4gICAgY29uc3QgeyBpbnNlcnQ6IGhvc3RJbnNlcnQsIHJlbW92ZTogaG9zdFJlbW92ZSwgcGF0Y2hQcm9wOiBob3N0UGF0Y2hQcm9wLCBjcmVhdGVFbGVtZW50OiBob3N0Q3JlYXRlRWxlbWVudCwgY3JlYXRlVGV4dDogaG9zdENyZWF0ZVRleHQsIGNyZWF0ZUNvbW1lbnQ6IGhvc3RDcmVhdGVDb21tZW50LCBzZXRUZXh0OiBob3N0U2V0VGV4dCwgc2V0RWxlbWVudFRleHQ6IGhvc3RTZXRFbGVtZW50VGV4dCwgcGFyZW50Tm9kZTogaG9zdFBhcmVudE5vZGUsIG5leHRTaWJsaW5nOiBob3N0TmV4dFNpYmxpbmcsIHNldFNjb3BlSWQ6IGhvc3RTZXRTY29wZUlkID0gTk9PUCwgaW5zZXJ0U3RhdGljQ29udGVudDogaG9zdEluc2VydFN0YXRpY0NvbnRlbnQgfSA9IG9wdGlvbnM7XG4gICAgLy8gTm90ZTogZnVuY3Rpb25zIGluc2lkZSB0aGlzIGNsb3N1cmUgc2hvdWxkIHVzZSBgY29uc3QgeHh4ID0gKCkgPT4ge31gXG4gICAgLy8gc3R5bGUgaW4gb3JkZXIgdG8gcHJldmVudCBiZWluZyBpbmxpbmVkIGJ5IG1pbmlmaWVycy5cbiAgICBjb25zdCBwYXRjaCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yID0gbnVsbCwgcGFyZW50Q29tcG9uZW50ID0gbnVsbCwgcGFyZW50U3VzcGVuc2UgPSBudWxsLCBpc1NWRyA9IGZhbHNlLCBzbG90U2NvcGVJZHMgPSBudWxsLCBvcHRpbWl6ZWQgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNIbXJVcGRhdGluZyA/IGZhbHNlIDogISFuMi5keW5hbWljQ2hpbGRyZW4pID0+IHtcbiAgICAgICAgaWYgKG4xID09PSBuMikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhdGNoaW5nICYgbm90IHNhbWUgdHlwZSwgdW5tb3VudCBvbGQgdHJlZVxuICAgICAgICBpZiAobjEgJiYgIWlzU2FtZVZOb2RlVHlwZShuMSwgbjIpKSB7XG4gICAgICAgICAgICBhbmNob3IgPSBnZXROZXh0SG9zdE5vZGUobjEpO1xuICAgICAgICAgICAgdW5tb3VudChuMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgICAgICBuMSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4yLnBhdGNoRmxhZyA9PT0gLTIgLyogUGF0Y2hGbGFncy5CQUlMICovKSB7XG4gICAgICAgICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIG4yLmR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB0eXBlLCByZWYsIHNoYXBlRmxhZyB9ID0gbjI7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBUZXh0OlxuICAgICAgICAgICAgICAgIHByb2Nlc3NUZXh0KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDb21tZW50OlxuICAgICAgICAgICAgICAgIHByb2Nlc3NDb21tZW50Tm9kZShuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU3RhdGljOlxuICAgICAgICAgICAgICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdW50U3RhdGljTm9kZShuMiwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoU3RhdGljTm9kZShuMSwgbjIsIGNvbnRhaW5lciwgaXNTVkcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgICAgICAgICAgcHJvY2Vzc0ZyYWdtZW50KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxIC8qIFNoYXBlRmxhZ3MuRUxFTUVOVCAqLykge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzRWxlbWVudChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiA2IC8qIFNoYXBlRmxhZ3MuQ09NUE9ORU5UICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NDb21wb25lbnQobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgNjQgLyogU2hhcGVGbGFncy5URUxFUE9SVCAqLykge1xuICAgICAgICAgICAgICAgICAgICB0eXBlLnByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBpbnRlcm5hbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiAxMjggLyogU2hhcGVGbGFncy5TVVNQRU5TRSAqLykge1xuICAgICAgICAgICAgICAgICAgICB0eXBlLnByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBpbnRlcm5hbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBWTm9kZSB0eXBlOicsIHR5cGUsIGAoJHt0eXBlb2YgdHlwZX0pYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNldCByZWZcbiAgICAgICAgaWYgKHJlZiAhPSBudWxsICYmIHBhcmVudENvbXBvbmVudCkge1xuICAgICAgICAgICAgc2V0UmVmKHJlZiwgbjEgJiYgbjEucmVmLCBwYXJlbnRTdXNwZW5zZSwgbjIgfHwgbjEsICFuMik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHByb2Nlc3NUZXh0ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpID0+IHtcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoKG4yLmVsID0gaG9zdENyZWF0ZVRleHQobjIuY2hpbGRyZW4pKSwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZWwgPSAobjIuZWwgPSBuMS5lbCk7XG4gICAgICAgICAgICBpZiAobjIuY2hpbGRyZW4gIT09IG4xLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgaG9zdFNldFRleHQoZWwsIG4yLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcHJvY2Vzc0NvbW1lbnROb2RlID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpID0+IHtcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoKG4yLmVsID0gaG9zdENyZWF0ZUNvbW1lbnQobjIuY2hpbGRyZW4gfHwgJycpKSwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhlcmUncyBubyBzdXBwb3J0IGZvciBkeW5hbWljIGNvbW1lbnRzXG4gICAgICAgICAgICBuMi5lbCA9IG4xLmVsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBtb3VudFN0YXRpY05vZGUgPSAobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRykgPT4ge1xuICAgICAgICBbbjIuZWwsIG4yLmFuY2hvcl0gPSBob3N0SW5zZXJ0U3RhdGljQ29udGVudChuMi5jaGlsZHJlbiwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHLCBuMi5lbCwgbjIuYW5jaG9yKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldiAvIEhNUiBvbmx5XG4gICAgICovXG4gICAgY29uc3QgcGF0Y2hTdGF0aWNOb2RlID0gKG4xLCBuMiwgY29udGFpbmVyLCBpc1NWRykgPT4ge1xuICAgICAgICAvLyBzdGF0aWMgbm9kZXMgYXJlIG9ubHkgcGF0Y2hlZCBkdXJpbmcgZGV2IGZvciBITVJcbiAgICAgICAgaWYgKG4yLmNoaWxkcmVuICE9PSBuMS5jaGlsZHJlbikge1xuICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gaG9zdE5leHRTaWJsaW5nKG4xLmFuY2hvcik7XG4gICAgICAgICAgICAvLyByZW1vdmUgZXhpc3RpbmdcbiAgICAgICAgICAgIHJlbW92ZVN0YXRpY05vZGUobjEpO1xuICAgICAgICAgICAgW24yLmVsLCBuMi5hbmNob3JdID0gaG9zdEluc2VydFN0YXRpY0NvbnRlbnQobjIuY2hpbGRyZW4sIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuMi5lbCA9IG4xLmVsO1xuICAgICAgICAgICAgbjIuYW5jaG9yID0gbjEuYW5jaG9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBtb3ZlU3RhdGljTm9kZSA9ICh7IGVsLCBhbmNob3IgfSwgY29udGFpbmVyLCBuZXh0U2libGluZykgPT4ge1xuICAgICAgICBsZXQgbmV4dDtcbiAgICAgICAgd2hpbGUgKGVsICYmIGVsICE9PSBhbmNob3IpIHtcbiAgICAgICAgICAgIG5leHQgPSBob3N0TmV4dFNpYmxpbmcoZWwpO1xuICAgICAgICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBuZXh0U2libGluZyk7XG4gICAgICAgICAgICBlbCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaG9zdEluc2VydChhbmNob3IsIGNvbnRhaW5lciwgbmV4dFNpYmxpbmcpO1xuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlU3RhdGljTm9kZSA9ICh7IGVsLCBhbmNob3IgfSkgPT4ge1xuICAgICAgICBsZXQgbmV4dDtcbiAgICAgICAgd2hpbGUgKGVsICYmIGVsICE9PSBhbmNob3IpIHtcbiAgICAgICAgICAgIG5leHQgPSBob3N0TmV4dFNpYmxpbmcoZWwpO1xuICAgICAgICAgICAgaG9zdFJlbW92ZShlbCk7XG4gICAgICAgICAgICBlbCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaG9zdFJlbW92ZShhbmNob3IpO1xuICAgIH07XG4gICAgY29uc3QgcHJvY2Vzc0VsZW1lbnQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgICAgIGlzU1ZHID0gaXNTVkcgfHwgbjIudHlwZSA9PT0gJ3N2Zyc7XG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICAgICAgICBtb3VudEVsZW1lbnQobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGF0Y2hFbGVtZW50KG4xLCBuMiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbW91bnRFbGVtZW50ID0gKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgICAgIGxldCBlbDtcbiAgICAgICAgbGV0IHZub2RlSG9vaztcbiAgICAgICAgY29uc3QgeyB0eXBlLCBwcm9wcywgc2hhcGVGbGFnLCB0cmFuc2l0aW9uLCBkaXJzIH0gPSB2bm9kZTtcbiAgICAgICAgZWwgPSB2bm9kZS5lbCA9IGhvc3RDcmVhdGVFbGVtZW50KHZub2RlLnR5cGUsIGlzU1ZHLCBwcm9wcyAmJiBwcm9wcy5pcywgcHJvcHMpO1xuICAgICAgICAvLyBtb3VudCBjaGlsZHJlbiBmaXJzdCwgc2luY2Ugc29tZSBwcm9wcyBtYXkgcmVseSBvbiBjaGlsZCBjb250ZW50XG4gICAgICAgIC8vIGJlaW5nIGFscmVhZHkgcmVuZGVyZWQsIGUuZy4gYDxzZWxlY3QgdmFsdWU+YFxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgOCAvKiBTaGFwZUZsYWdzLlRFWFRfQ0hJTERSRU4gKi8pIHtcbiAgICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChlbCwgdm5vZGUuY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIFNoYXBlRmxhZ3MuQVJSQVlfQ0hJTERSRU4gKi8pIHtcbiAgICAgICAgICAgIG1vdW50Q2hpbGRyZW4odm5vZGUuY2hpbGRyZW4sIGVsLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRyAmJiB0eXBlICE9PSAnZm9yZWlnbk9iamVjdCcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlycykge1xuICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnY3JlYXRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHByb3BzXG4gICAgICAgIGlmIChwcm9wcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAndmFsdWUnICYmICFpc1Jlc2VydmVkUHJvcChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIGtleSwgbnVsbCwgcHJvcHNba2V5XSwgaXNTVkcsIHZub2RlLmNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU3BlY2lhbCBjYXNlIGZvciBzZXR0aW5nIHZhbHVlIG9uIERPTSBlbGVtZW50czpcbiAgICAgICAgICAgICAqIC0gaXQgY2FuIGJlIG9yZGVyLXNlbnNpdGl2ZSAoZS5nLiBzaG91bGQgYmUgc2V0ICphZnRlciogbWluL21heCwgIzIzMjUsICM0MDI0KVxuICAgICAgICAgICAgICogLSBpdCBuZWVkcyB0byBiZSBmb3JjZWQgKCMxNDcxKVxuICAgICAgICAgICAgICogIzIzNTMgcHJvcG9zZXMgYWRkaW5nIGFub3RoZXIgcmVuZGVyZXIgb3B0aW9uIHRvIGNvbmZpZ3VyZSB0aGlzLCBidXRcbiAgICAgICAgICAgICAqIHRoZSBwcm9wZXJ0aWVzIGFmZmVjdHMgYXJlIHNvIGZpbml0ZSBpdCBpcyB3b3J0aCBzcGVjaWFsIGNhc2luZyBpdFxuICAgICAgICAgICAgICogaGVyZSB0byByZWR1Y2UgdGhlIGNvbXBsZXhpdHkuIChTcGVjaWFsIGNhc2luZyBpdCBhbHNvIHNob3VsZCBub3RcbiAgICAgICAgICAgICAqIGFmZmVjdCBub24tRE9NIHJlbmRlcmVycylcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKCd2YWx1ZScgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCAndmFsdWUnLCBudWxsLCBwcm9wcy52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHZub2RlSG9vayA9IHByb3BzLm9uVm5vZGVCZWZvcmVNb3VudCkpIHtcbiAgICAgICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzY29wZUlkXG4gICAgICAgIHNldFNjb3BlSWQoZWwsIHZub2RlLCB2bm9kZS5zY29wZUlkLCBzbG90U2NvcGVJZHMsIHBhcmVudENvbXBvbmVudCk7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWwsICdfX3Zub2RlJywge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB2bm9kZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWwsICdfX3Z1ZVBhcmVudENvbXBvbmVudCcsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlycykge1xuICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnYmVmb3JlTW91bnQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAjMTU4MyBGb3IgaW5zaWRlIHN1c3BlbnNlICsgc3VzcGVuc2Ugbm90IHJlc29sdmVkIGNhc2UsIGVudGVyIGhvb2sgc2hvdWxkIGNhbGwgd2hlbiBzdXNwZW5zZSByZXNvbHZlZFxuICAgICAgICAvLyAjMTY4OSBGb3IgaW5zaWRlIHN1c3BlbnNlICsgc3VzcGVuc2UgcmVzb2x2ZWQgY2FzZSwganVzdCBjYWxsIGl0XG4gICAgICAgIGNvbnN0IG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzID0gKCFwYXJlbnRTdXNwZW5zZSB8fCAocGFyZW50U3VzcGVuc2UgJiYgIXBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpKSAmJlxuICAgICAgICAgICAgdHJhbnNpdGlvbiAmJlxuICAgICAgICAgICAgIXRyYW5zaXRpb24ucGVyc2lzdGVkO1xuICAgICAgICBpZiAobmVlZENhbGxUcmFuc2l0aW9uSG9va3MpIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xuICAgICAgICB9XG4gICAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgaWYgKCh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlTW91bnRlZCkgfHxcbiAgICAgICAgICAgIG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzIHx8XG4gICAgICAgICAgICBkaXJzKSB7XG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICAgICAgICAgICAgICBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyAmJiB0cmFuc2l0aW9uLmVudGVyKGVsKTtcbiAgICAgICAgICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ21vdW50ZWQnKTtcbiAgICAgICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2V0U2NvcGVJZCA9IChlbCwgdm5vZGUsIHNjb3BlSWQsIHNsb3RTY29wZUlkcywgcGFyZW50Q29tcG9uZW50KSA9PiB7XG4gICAgICAgIGlmIChzY29wZUlkKSB7XG4gICAgICAgICAgICBob3N0U2V0U2NvcGVJZChlbCwgc2NvcGVJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNsb3RTY29wZUlkcykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbG90U2NvcGVJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBob3N0U2V0U2NvcGVJZChlbCwgc2xvdFNjb3BlSWRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50Q29tcG9uZW50KSB7XG4gICAgICAgICAgICBsZXQgc3ViVHJlZSA9IHBhcmVudENvbXBvbmVudC5zdWJUcmVlO1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgICAgIHN1YlRyZWUucGF0Y2hGbGFnID4gMCAmJlxuICAgICAgICAgICAgICAgIHN1YlRyZWUucGF0Y2hGbGFnICYgMjA0OCAvKiBQYXRjaEZsYWdzLkRFVl9ST09UX0ZSQUdNRU5UICovKSB7XG4gICAgICAgICAgICAgICAgc3ViVHJlZSA9XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclNpbmdsZVJvb3Qoc3ViVHJlZS5jaGlsZHJlbikgfHwgc3ViVHJlZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2bm9kZSA9PT0gc3ViVHJlZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudFZOb2RlID0gcGFyZW50Q29tcG9uZW50LnZub2RlO1xuICAgICAgICAgICAgICAgIHNldFNjb3BlSWQoZWwsIHBhcmVudFZOb2RlLCBwYXJlbnRWTm9kZS5zY29wZUlkLCBwYXJlbnRWTm9kZS5zbG90U2NvcGVJZHMsIHBhcmVudENvbXBvbmVudC5wYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBtb3VudENoaWxkcmVuID0gKGNoaWxkcmVuLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBzdGFydCA9IDApID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gKGNoaWxkcmVuW2ldID0gb3B0aW1pemVkXG4gICAgICAgICAgICAgICAgPyBjbG9uZUlmTW91bnRlZChjaGlsZHJlbltpXSlcbiAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVZOb2RlKGNoaWxkcmVuW2ldKSk7XG4gICAgICAgICAgICBwYXRjaChudWxsLCBjaGlsZCwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHBhdGNoRWxlbWVudCA9IChuMSwgbjIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgICAgICBjb25zdCBlbCA9IChuMi5lbCA9IG4xLmVsKTtcbiAgICAgICAgbGV0IHsgcGF0Y2hGbGFnLCBkeW5hbWljQ2hpbGRyZW4sIGRpcnMgfSA9IG4yO1xuICAgICAgICAvLyAjMTQyNiB0YWtlIHRoZSBvbGQgdm5vZGUncyBwYXRjaCBmbGFnIGludG8gYWNjb3VudCBzaW5jZSB1c2VyIG1heSBjbG9uZSBhXG4gICAgICAgIC8vIGNvbXBpbGVyLWdlbmVyYXRlZCB2bm9kZSwgd2hpY2ggZGUtb3B0cyB0byBGVUxMX1BST1BTXG4gICAgICAgIHBhdGNoRmxhZyB8PSBuMS5wYXRjaEZsYWcgJiAxNiAvKiBQYXRjaEZsYWdzLkZVTExfUFJPUFMgKi87XG4gICAgICAgIGNvbnN0IG9sZFByb3BzID0gbjEucHJvcHMgfHwgRU1QVFlfT0JKO1xuICAgICAgICBjb25zdCBuZXdQcm9wcyA9IG4yLnByb3BzIHx8IEVNUFRZX09CSjtcbiAgICAgICAgbGV0IHZub2RlSG9vaztcbiAgICAgICAgLy8gZGlzYWJsZSByZWN1cnNlIGluIGJlZm9yZVVwZGF0ZSBob29rc1xuICAgICAgICBwYXJlbnRDb21wb25lbnQgJiYgdG9nZ2xlUmVjdXJzZShwYXJlbnRDb21wb25lbnQsIGZhbHNlKTtcbiAgICAgICAgaWYgKCh2bm9kZUhvb2sgPSBuZXdQcm9wcy5vblZub2RlQmVmb3JlVXBkYXRlKSkge1xuICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCBuMiwgbjEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXJzKSB7XG4gICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKG4yLCBuMSwgcGFyZW50Q29tcG9uZW50LCAnYmVmb3JlVXBkYXRlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50Q29tcG9uZW50ICYmIHRvZ2dsZVJlY3Vyc2UocGFyZW50Q29tcG9uZW50LCB0cnVlKTtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpc0htclVwZGF0aW5nKSB7XG4gICAgICAgICAgICAvLyBITVIgdXBkYXRlZCwgZm9yY2UgZnVsbCBkaWZmXG4gICAgICAgICAgICBwYXRjaEZsYWcgPSAwO1xuICAgICAgICAgICAgb3B0aW1pemVkID0gZmFsc2U7XG4gICAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFyZUNoaWxkcmVuU1ZHID0gaXNTVkcgJiYgbjIudHlwZSAhPT0gJ2ZvcmVpZ25PYmplY3QnO1xuICAgICAgICBpZiAoZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICAgICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4objEuZHluYW1pY0NoaWxkcmVuLCBkeW5hbWljQ2hpbGRyZW4sIGVsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBhcmVDaGlsZHJlblNWRywgc2xvdFNjb3BlSWRzKTtcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgcGFyZW50Q29tcG9uZW50ICYmIHBhcmVudENvbXBvbmVudC50eXBlLl9faG1ySWQpIHtcbiAgICAgICAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIW9wdGltaXplZCkge1xuICAgICAgICAgICAgLy8gZnVsbCBkaWZmXG4gICAgICAgICAgICBwYXRjaENoaWxkcmVuKG4xLCBuMiwgZWwsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGFyZUNoaWxkcmVuU1ZHLCBzbG90U2NvcGVJZHMsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0Y2hGbGFnID4gMCkge1xuICAgICAgICAgICAgLy8gdGhlIHByZXNlbmNlIG9mIGEgcGF0Y2hGbGFnIG1lYW5zIHRoaXMgZWxlbWVudCdzIHJlbmRlciBjb2RlIHdhc1xuICAgICAgICAgICAgLy8gZ2VuZXJhdGVkIGJ5IHRoZSBjb21waWxlciBhbmQgY2FuIHRha2UgdGhlIGZhc3QgcGF0aC5cbiAgICAgICAgICAgIC8vIGluIHRoaXMgcGF0aCBvbGQgbm9kZSBhbmQgbmV3IG5vZGUgYXJlIGd1YXJhbnRlZWQgdG8gaGF2ZSB0aGUgc2FtZSBzaGFwZVxuICAgICAgICAgICAgLy8gKGkuZS4gYXQgdGhlIGV4YWN0IHNhbWUgcG9zaXRpb24gaW4gdGhlIHNvdXJjZSB0ZW1wbGF0ZSlcbiAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgJiAxNiAvKiBQYXRjaEZsYWdzLkZVTExfUFJPUFMgKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50IHByb3BzIGNvbnRhaW4gZHluYW1pYyBrZXlzLCBmdWxsIGRpZmYgbmVlZGVkXG4gICAgICAgICAgICAgICAgcGF0Y2hQcm9wcyhlbCwgbjIsIG9sZFByb3BzLCBuZXdQcm9wcywgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY2xhc3NcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGZsYWcgaXMgbWF0Y2hlZCB3aGVuIHRoZSBlbGVtZW50IGhhcyBkeW5hbWljIGNsYXNzIGJpbmRpbmdzLlxuICAgICAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgJiAyIC8qIFBhdGNoRmxhZ3MuQ0xBU1MgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZFByb3BzLmNsYXNzICE9PSBuZXdQcm9wcy5jbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgJ2NsYXNzJywgbnVsbCwgbmV3UHJvcHMuY2xhc3MsIGlzU1ZHKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzdHlsZVxuICAgICAgICAgICAgICAgIC8vIHRoaXMgZmxhZyBpcyBtYXRjaGVkIHdoZW4gdGhlIGVsZW1lbnQgaGFzIGR5bmFtaWMgc3R5bGUgYmluZGluZ3NcbiAgICAgICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgNCAvKiBQYXRjaEZsYWdzLlNUWUxFICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsICdzdHlsZScsIG9sZFByb3BzLnN0eWxlLCBuZXdQcm9wcy5zdHlsZSwgaXNTVkcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBwcm9wc1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgZmxhZyBpcyBtYXRjaGVkIHdoZW4gdGhlIGVsZW1lbnQgaGFzIGR5bmFtaWMgcHJvcC9hdHRyIGJpbmRpbmdzXG4gICAgICAgICAgICAgICAgLy8gb3RoZXIgdGhhbiBjbGFzcyBhbmQgc3R5bGUuIFRoZSBrZXlzIG9mIGR5bmFtaWMgcHJvcC9hdHRycyBhcmUgc2F2ZWQgZm9yXG4gICAgICAgICAgICAgICAgLy8gZmFzdGVyIGl0ZXJhdGlvbi5cbiAgICAgICAgICAgICAgICAvLyBOb3RlIGR5bmFtaWMga2V5cyBsaWtlIDpbZm9vXT1cImJhclwiIHdpbGwgY2F1c2UgdGhpcyBvcHRpbWl6YXRpb24gdG9cbiAgICAgICAgICAgICAgICAvLyBiYWlsIG91dCBhbmQgZ28gdGhyb3VnaCBhIGZ1bGwgZGlmZiBiZWNhdXNlIHdlIG5lZWQgdG8gdW5zZXQgdGhlIG9sZCBrZXlcbiAgICAgICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgOCAvKiBQYXRjaEZsYWdzLlBST1BTICovKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBmbGFnIGlzIHByZXNlbnQgdGhlbiBkeW5hbWljUHJvcHMgbXVzdCBiZSBub24tbnVsbFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wc1RvVXBkYXRlID0gbjIuZHluYW1pY1Byb3BzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzVG9VcGRhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHByb3BzVG9VcGRhdGVbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gb2xkUHJvcHNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBuZXdQcm9wc1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIzE0NzEgZm9yY2UgcGF0Y2ggdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9PSBwcmV2IHx8IGtleSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIGtleSwgcHJldiwgbmV4dCwgaXNTVkcsIG4xLmNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGV4dFxuICAgICAgICAgICAgLy8gVGhpcyBmbGFnIGlzIG1hdGNoZWQgd2hlbiB0aGUgZWxlbWVudCBoYXMgb25seSBkeW5hbWljIHRleHQgY2hpbGRyZW4uXG4gICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgMSAvKiBQYXRjaEZsYWdzLlRFWFQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAobjEuY2hpbGRyZW4gIT09IG4yLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChlbCwgbjIuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghb3B0aW1pemVkICYmIGR5bmFtaWNDaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyB1bm9wdGltaXplZCwgZnVsbCBkaWZmXG4gICAgICAgICAgICBwYXRjaFByb3BzKGVsLCBuMiwgb2xkUHJvcHMsIG5ld1Byb3BzLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh2bm9kZUhvb2sgPSBuZXdQcm9wcy5vblZub2RlVXBkYXRlZCkgfHwgZGlycykge1xuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB2bm9kZUhvb2sgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCBuMiwgbjEpO1xuICAgICAgICAgICAgICAgIGRpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayhuMiwgbjEsIHBhcmVudENvbXBvbmVudCwgJ3VwZGF0ZWQnKTtcbiAgICAgICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gVGhlIGZhc3QgcGF0aCBmb3IgYmxvY2tzLlxuICAgIGNvbnN0IHBhdGNoQmxvY2tDaGlsZHJlbiA9IChvbGRDaGlsZHJlbiwgbmV3Q2hpbGRyZW4sIGZhbGxiYWNrQ29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG9sZFZOb2RlID0gb2xkQ2hpbGRyZW5baV07XG4gICAgICAgICAgICBjb25zdCBuZXdWTm9kZSA9IG5ld0NoaWxkcmVuW2ldO1xuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBjb250YWluZXIgKHBhcmVudCBlbGVtZW50KSBmb3IgdGhlIHBhdGNoLlxuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gXG4gICAgICAgICAgICAvLyBvbGRWTm9kZSBtYXkgYmUgYW4gZXJyb3JlZCBhc3luYyBzZXR1cCgpIGNvbXBvbmVudCBpbnNpZGUgU3VzcGVuc2VcbiAgICAgICAgICAgIC8vIHdoaWNoIHdpbGwgbm90IGhhdmUgYSBtb3VudGVkIGVsZW1lbnRcbiAgICAgICAgICAgIG9sZFZOb2RlLmVsICYmXG4gICAgICAgICAgICAgICAgLy8gLSBJbiB0aGUgY2FzZSBvZiBhIEZyYWdtZW50LCB3ZSBuZWVkIHRvIHByb3ZpZGUgdGhlIGFjdHVhbCBwYXJlbnRcbiAgICAgICAgICAgICAgICAvLyBvZiB0aGUgRnJhZ21lbnQgaXRzZWxmIHNvIGl0IGNhbiBtb3ZlIGl0cyBjaGlsZHJlbi5cbiAgICAgICAgICAgICAgICAob2xkVk5vZGUudHlwZSA9PT0gRnJhZ21lbnQgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gLSBJbiB0aGUgY2FzZSBvZiBkaWZmZXJlbnQgbm9kZXMsIHRoZXJlIGlzIGdvaW5nIHRvIGJlIGEgcmVwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggYWxzbyByZXF1aXJlcyB0aGUgY29ycmVjdCBwYXJlbnQgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgICFpc1NhbWVWTm9kZVR5cGUob2xkVk5vZGUsIG5ld1ZOb2RlKSB8fFxuICAgICAgICAgICAgICAgICAgICAvLyAtIEluIHRoZSBjYXNlIG9mIGEgY29tcG9uZW50LCBpdCBjb3VsZCBjb250YWluIGFueXRoaW5nLlxuICAgICAgICAgICAgICAgICAgICBvbGRWTm9kZS5zaGFwZUZsYWcgJiAoNiAvKiBTaGFwZUZsYWdzLkNPTVBPTkVOVCAqLyB8IDY0IC8qIFNoYXBlRmxhZ3MuVEVMRVBPUlQgKi8pKVxuICAgICAgICAgICAgICAgID8gaG9zdFBhcmVudE5vZGUob2xkVk5vZGUuZWwpXG4gICAgICAgICAgICAgICAgOiAvLyBJbiBvdGhlciBjYXNlcywgdGhlIHBhcmVudCBjb250YWluZXIgaXMgbm90IGFjdHVhbGx5IHVzZWQgc28gd2VcbiAgICAgICAgICAgICAgICAgICAgLy8ganVzdCBwYXNzIHRoZSBibG9jayBlbGVtZW50IGhlcmUgdG8gYXZvaWQgYSBET00gcGFyZW50Tm9kZSBjYWxsLlxuICAgICAgICAgICAgICAgICAgICBmYWxsYmFja0NvbnRhaW5lcjtcbiAgICAgICAgICAgIHBhdGNoKG9sZFZOb2RlLCBuZXdWTm9kZSwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcGF0Y2hQcm9wcyA9IChlbCwgdm5vZGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpID0+IHtcbiAgICAgICAgaWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcykge1xuICAgICAgICAgICAgaWYgKG9sZFByb3BzICE9PSBFTVBUWV9PQkopIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvbGRQcm9wcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUmVzZXJ2ZWRQcm9wKGtleSkgJiYgIShrZXkgaW4gbmV3UHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIG9sZFByb3BzW2tleV0sIG51bGwsIGlzU1ZHLCB2bm9kZS5jaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5ld1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgLy8gZW1wdHkgc3RyaW5nIGlzIG5vdCB2YWxpZCBwcm9wXG4gICAgICAgICAgICAgICAgaWYgKGlzUmVzZXJ2ZWRQcm9wKGtleSkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBuZXdQcm9wc1trZXldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBvbGRQcm9wc1trZXldO1xuICAgICAgICAgICAgICAgIC8vIGRlZmVyIHBhdGNoaW5nIHZhbHVlXG4gICAgICAgICAgICAgICAgaWYgKG5leHQgIT09IHByZXYgJiYga2V5ICE9PSAndmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIGtleSwgcHJldiwgbmV4dCwgaXNTVkcsIHZub2RlLmNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgndmFsdWUnIGluIG5ld1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgJ3ZhbHVlJywgb2xkUHJvcHMudmFsdWUsIG5ld1Byb3BzLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcHJvY2Vzc0ZyYWdtZW50ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgICAgICBjb25zdCBmcmFnbWVudFN0YXJ0QW5jaG9yID0gKG4yLmVsID0gbjEgPyBuMS5lbCA6IGhvc3RDcmVhdGVUZXh0KCcnKSk7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50RW5kQW5jaG9yID0gKG4yLmFuY2hvciA9IG4xID8gbjEuYW5jaG9yIDogaG9zdENyZWF0ZVRleHQoJycpKTtcbiAgICAgICAgbGV0IHsgcGF0Y2hGbGFnLCBkeW5hbWljQ2hpbGRyZW4sIHNsb3RTY29wZUlkczogZnJhZ21lbnRTbG90U2NvcGVJZHMgfSA9IG4yO1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICAvLyAjNTUyMyBkZXYgcm9vdCBmcmFnbWVudCBtYXkgaW5oZXJpdCBkaXJlY3RpdmVzXG4gICAgICAgICAgICAoaXNIbXJVcGRhdGluZyB8fCBwYXRjaEZsYWcgJiAyMDQ4IC8qIFBhdGNoRmxhZ3MuREVWX1JPT1RfRlJBR01FTlQgKi8pKSB7XG4gICAgICAgICAgICAvLyBITVIgdXBkYXRlZCAvIERldiByb290IGZyYWdtZW50ICh3LyBjb21tZW50cyksIGZvcmNlIGZ1bGwgZGlmZlxuICAgICAgICAgICAgcGF0Y2hGbGFnID0gMDtcbiAgICAgICAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIGEgc2xvdCBmcmFnbWVudCB3aXRoIDpzbG90dGVkIHNjb3BlIGlkc1xuICAgICAgICBpZiAoZnJhZ21lbnRTbG90U2NvcGVJZHMpIHtcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkc1xuICAgICAgICAgICAgICAgID8gc2xvdFNjb3BlSWRzLmNvbmNhdChmcmFnbWVudFNsb3RTY29wZUlkcylcbiAgICAgICAgICAgICAgICA6IGZyYWdtZW50U2xvdFNjb3BlSWRzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICAgICAgICBob3N0SW5zZXJ0KGZyYWdtZW50U3RhcnRBbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoZnJhZ21lbnRFbmRBbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgICAgIC8vIGEgZnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBhcnJheSBjaGlsZHJlblxuICAgICAgICAgICAgLy8gc2luY2UgdGhleSBhcmUgZWl0aGVyIGdlbmVyYXRlZCBieSB0aGUgY29tcGlsZXIsIG9yIGltcGxpY2l0bHkgY3JlYXRlZFxuICAgICAgICAgICAgLy8gZnJvbSBhcnJheXMuXG4gICAgICAgICAgICBtb3VudENoaWxkcmVuKG4yLmNoaWxkcmVuLCBjb250YWluZXIsIGZyYWdtZW50RW5kQW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyA+IDAgJiZcbiAgICAgICAgICAgICAgICBwYXRjaEZsYWcgJiA2NCAvKiBQYXRjaEZsYWdzLlNUQUJMRV9GUkFHTUVOVCAqLyAmJlxuICAgICAgICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbiAmJlxuICAgICAgICAgICAgICAgIC8vICMyNzE1IHRoZSBwcmV2aW91cyBmcmFnbWVudCBjb3VsZCd2ZSBiZWVuIGEgQkFJTGVkIG9uZSBhcyBhIHJlc3VsdFxuICAgICAgICAgICAgICAgIC8vIG9mIHJlbmRlclNsb3QoKSB3aXRoIG5vIHZhbGlkIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgbjEuZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgLy8gYSBzdGFibGUgZnJhZ21lbnQgKHRlbXBsYXRlIHJvb3Qgb3IgPHRlbXBsYXRlIHYtZm9yPikgZG9lc24ndCBuZWVkIHRvXG4gICAgICAgICAgICAgICAgLy8gcGF0Y2ggY2hpbGRyZW4gb3JkZXIsIGJ1dCBpdCBtYXkgY29udGFpbiBkeW5hbWljQ2hpbGRyZW4uXG4gICAgICAgICAgICAgICAgcGF0Y2hCbG9ja0NoaWxkcmVuKG4xLmR5bmFtaWNDaGlsZHJlbiwgZHluYW1pY0NoaWxkcmVuLCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMpO1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgcGFyZW50Q29tcG9uZW50ICYmIHBhcmVudENvbXBvbmVudC50eXBlLl9faG1ySWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAvLyAjMjA4MCBpZiB0aGUgc3RhYmxlIGZyYWdtZW50IGhhcyBhIGtleSwgaXQncyBhIDx0ZW1wbGF0ZSB2LWZvcj4gdGhhdCBtYXlcbiAgICAgICAgICAgICAgICAvLyAgZ2V0IG1vdmVkIGFyb3VuZC4gTWFrZSBzdXJlIGFsbCByb290IGxldmVsIHZub2RlcyBpbmhlcml0IGVsLlxuICAgICAgICAgICAgICAgIC8vICMyMTM0IG9yIGlmIGl0J3MgYSBjb21wb25lbnQgcm9vdCwgaXQgbWF5IGFsc28gZ2V0IG1vdmVkIGFyb3VuZFxuICAgICAgICAgICAgICAgIC8vIGFzIHRoZSBjb21wb25lbnQgaXMgYmVpbmcgbW92ZWQuXG4gICAgICAgICAgICAgICAgbjIua2V5ICE9IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgKHBhcmVudENvbXBvbmVudCAmJiBuMiA9PT0gcGFyZW50Q29tcG9uZW50LnN1YlRyZWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yLCB0cnVlIC8qIHNoYWxsb3cgKi8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGtleWVkIC8gdW5rZXllZCwgb3IgbWFudWFsIGZyYWdtZW50cy5cbiAgICAgICAgICAgICAgICAvLyBmb3Iga2V5ZWQgJiB1bmtleWVkLCBzaW5jZSB0aGV5IGFyZSBjb21waWxlciBnZW5lcmF0ZWQgZnJvbSB2LWZvcixcbiAgICAgICAgICAgICAgICAvLyBlYWNoIGNoaWxkIGlzIGd1YXJhbnRlZWQgdG8gYmUgYSBibG9jayBzbyB0aGUgZnJhZ21lbnQgd2lsbCBuZXZlclxuICAgICAgICAgICAgICAgIC8vIGhhdmUgZHluYW1pY0NoaWxkcmVuLlxuICAgICAgICAgICAgICAgIHBhdGNoQ2hpbGRyZW4objEsIG4yLCBjb250YWluZXIsIGZyYWdtZW50RW5kQW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwcm9jZXNzQ29tcG9uZW50ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgICAgICBuMi5zbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHM7XG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobjIuc2hhcGVGbGFnICYgNTEyIC8qIFNoYXBlRmxhZ3MuQ09NUE9ORU5UX0tFUFRfQUxJVkUgKi8pIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnQuY3R4LmFjdGl2YXRlKG4yLCBjb250YWluZXIsIGFuY2hvciwgaXNTVkcsIG9wdGltaXplZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb3VudENvbXBvbmVudChuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXBkYXRlQ29tcG9uZW50KG4xLCBuMiwgb3B0aW1pemVkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbW91bnRDb21wb25lbnQgPSAoaW5pdGlhbFZOb2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCkgPT4ge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IChpbml0aWFsVk5vZGUuY29tcG9uZW50ID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2UoaW5pdGlhbFZOb2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKSk7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaW5zdGFuY2UudHlwZS5fX2htcklkKSB7XG4gICAgICAgICAgICByZWdpc3RlckhNUihpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KGluaXRpYWxWTm9kZSk7XG4gICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBtb3VudGApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGluamVjdCByZW5kZXJlciBpbnRlcm5hbHMgZm9yIGtlZXBBbGl2ZVxuICAgICAgICBpZiAoaXNLZWVwQWxpdmUoaW5pdGlhbFZOb2RlKSkge1xuICAgICAgICAgICAgaW5zdGFuY2UuY3R4LnJlbmRlcmVyID0gaW50ZXJuYWxzO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlc29sdmUgcHJvcHMgYW5kIHNsb3RzIGZvciBzZXR1cCBjb250ZXh0XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBpbml0YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXR1cENvbXBvbmVudChpbnN0YW5jZSk7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYGluaXRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzZXR1cCgpIGlzIGFzeW5jLiBUaGlzIGNvbXBvbmVudCByZWxpZXMgb24gYXN5bmMgbG9naWMgdG8gYmUgcmVzb2x2ZWRcbiAgICAgICAgLy8gYmVmb3JlIHByb2NlZWRpbmdcbiAgICAgICAgaWYgKGluc3RhbmNlLmFzeW5jRGVwKSB7XG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSAmJiBwYXJlbnRTdXNwZW5zZS5yZWdpc3RlckRlcChpbnN0YW5jZSwgc2V0dXBSZW5kZXJFZmZlY3QpO1xuICAgICAgICAgICAgLy8gR2l2ZSBpdCBhIHBsYWNlaG9sZGVyIGlmIHRoaXMgaXMgbm90IGh5ZHJhdGlvblxuICAgICAgICAgICAgLy8gVE9ETyBoYW5kbGUgc2VsZi1kZWZpbmVkIGZhbGxiYWNrXG4gICAgICAgICAgICBpZiAoIWluaXRpYWxWTm9kZS5lbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gKGluc3RhbmNlLnN1YlRyZWUgPSBjcmVhdGVWTm9kZShDb21tZW50KSk7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc0NvbW1lbnROb2RlKG51bGwsIHBsYWNlaG9sZGVyLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0dXBSZW5kZXJFZmZlY3QoaW5zdGFuY2UsIGluaXRpYWxWTm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBtb3VudGApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB1cGRhdGVDb21wb25lbnQgPSAobjEsIG4yLCBvcHRpbWl6ZWQpID0+IHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSAobjIuY29tcG9uZW50ID0gbjEuY29tcG9uZW50KTtcbiAgICAgICAgaWYgKHNob3VsZFVwZGF0ZUNvbXBvbmVudChuMSwgbjIsIG9wdGltaXplZCkpIHtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZS5hc3luY0RlcCAmJlxuICAgICAgICAgICAgICAgICFpbnN0YW5jZS5hc3luY1Jlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gYXN5bmMgJiBzdGlsbCBwZW5kaW5nIC0ganVzdCB1cGRhdGUgcHJvcHMgYW5kIHNsb3RzXG4gICAgICAgICAgICAgICAgLy8gc2luY2UgdGhlIGNvbXBvbmVudCdzIHJlYWN0aXZlIGVmZmVjdCBmb3IgcmVuZGVyIGlzbid0IHNldC11cCB5ZXRcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChuMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlcihpbnN0YW5jZSwgbjIsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBub3JtYWwgdXBkYXRlXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UubmV4dCA9IG4yO1xuICAgICAgICAgICAgICAgIC8vIGluIGNhc2UgdGhlIGNoaWxkIGNvbXBvbmVudCBpcyBhbHNvIHF1ZXVlZCwgcmVtb3ZlIGl0IHRvIGF2b2lkXG4gICAgICAgICAgICAgICAgLy8gZG91YmxlIHVwZGF0aW5nIHRoZSBzYW1lIGNoaWxkIGNvbXBvbmVudCBpbiB0aGUgc2FtZSBmbHVzaC5cbiAgICAgICAgICAgICAgICBpbnZhbGlkYXRlSm9iKGluc3RhbmNlLnVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgLy8gaW5zdGFuY2UudXBkYXRlIGlzIHRoZSByZWFjdGl2ZSBlZmZlY3QuXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBubyB1cGRhdGUgbmVlZGVkLiBqdXN0IGNvcHkgb3ZlciBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBuMi5lbCA9IG4xLmVsO1xuICAgICAgICAgICAgaW5zdGFuY2Uudm5vZGUgPSBuMjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2V0dXBSZW5kZXJFZmZlY3QgPSAoaW5zdGFuY2UsIGluaXRpYWxWTm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudFVwZGF0ZUZuID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpbnN0YW5jZS5pc01vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgdm5vZGVIb29rO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZWwsIHByb3BzIH0gPSBpbml0aWFsVk5vZGU7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBibSwgbSwgcGFyZW50IH0gPSBpbnN0YW5jZTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0FzeW5jV3JhcHBlclZOb2RlID0gaXNBc3luY1dyYXBwZXIoaW5pdGlhbFZOb2RlKTtcbiAgICAgICAgICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgLy8gYmVmb3JlTW91bnQgaG9va1xuICAgICAgICAgICAgICAgIGlmIChibSkge1xuICAgICAgICAgICAgICAgICAgICBpbnZva2VBcnJheUZucyhibSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG9uVm5vZGVCZWZvcmVNb3VudFxuICAgICAgICAgICAgICAgIGlmICghaXNBc3luY1dyYXBwZXJWTm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZUJlZm9yZU1vdW50KSkge1xuICAgICAgICAgICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIGluaXRpYWxWTm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmIChlbCAmJiBoeWRyYXRlTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB2bm9kZSBoYXMgYWRvcHRlZCBob3N0IG5vZGUgLSBwZXJmb3JtIGh5ZHJhdGlvbiBpbnN0ZWFkIG9mIG1vdW50LlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoeWRyYXRlU3ViVHJlZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnN1YlRyZWUgPSByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgaHlkcmF0ZWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaHlkcmF0ZU5vZGUoZWwsIGluc3RhbmNlLnN1YlRyZWUsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYGh5ZHJhdGVgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXN5bmNXcmFwcGVyVk5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxWTm9kZS50eXBlLl9fYXN5bmNMb2FkZXIoKS50aGVuKFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90ZTogd2UgYXJlIG1vdmluZyB0aGUgcmVuZGVyIGNhbGwgaW50byBhbiBhc3luYyBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIG1lYW5zIGl0IHdvbid0IHRyYWNrIGRlcGVuZGVuY2llcyAtIGJ1dCBpdCdzIG9rIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgc2VydmVyLXJlbmRlcmVkIGFzeW5jIHdyYXBwZXIgaXMgYWxyZWFkeSBpbiByZXNvbHZlZCBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGl0IHdpbGwgbmV2ZXIgbmVlZCB0byBjaGFuZ2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAoKSA9PiAhaW5zdGFuY2UuaXNVbm1vdW50ZWQgJiYgaHlkcmF0ZVN1YlRyZWUoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoeWRyYXRlU3ViVHJlZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJUcmVlID0gKGluc3RhbmNlLnN1YlRyZWUgPSByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIHN1YlRyZWUsIGNvbnRhaW5lciwgYW5jaG9yLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFZOb2RlLmVsID0gc3ViVHJlZS5lbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbW91bnRlZCBob29rXG4gICAgICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KG0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gb25Wbm9kZU1vdW50ZWRcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXN5bmNXcmFwcGVyVk5vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzY29wZWRJbml0aWFsVk5vZGUgPSBpbml0aWFsVk5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIHNjb3BlZEluaXRpYWxWTm9kZSksIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYWN0aXZhdGVkIGhvb2sgZm9yIGtlZXAtYWxpdmUgcm9vdHMuXG4gICAgICAgICAgICAgICAgLy8gIzE3NDIgYWN0aXZhdGVkIGhvb2sgbXVzdCBiZSBhY2Nlc3NlZCBhZnRlciBmaXJzdCByZW5kZXJcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGUgaG9vayBtYXkgYmUgaW5qZWN0ZWQgYnkgYSBjaGlsZCBrZWVwLWFsaXZlXG4gICAgICAgICAgICAgICAgaWYgKGluaXRpYWxWTm9kZS5zaGFwZUZsYWcgJiAyNTYgLyogU2hhcGVGbGFncy5DT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgKHBhcmVudCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBc3luY1dyYXBwZXIocGFyZW50LnZub2RlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LnZub2RlLnNoYXBlRmxhZyAmIDI1NiAvKiBTaGFwZUZsYWdzLkNPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRSAqLykpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuYSAmJiBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoaW5zdGFuY2UuYSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50QWRkZWQoaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAjMjQ1ODogZGVmZXJlbmNlIG1vdW50LW9ubHkgb2JqZWN0IHBhcmFtZXRlcnMgdG8gcHJldmVudCBtZW1sZWFrc1xuICAgICAgICAgICAgICAgIGluaXRpYWxWTm9kZSA9IGNvbnRhaW5lciA9IGFuY2hvciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGVDb21wb25lbnRcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRyaWdnZXJlZCBieSBtdXRhdGlvbiBvZiBjb21wb25lbnQncyBvd24gc3RhdGUgKG5leHQ6IG51bGwpXG4gICAgICAgICAgICAgICAgLy8gT1IgcGFyZW50IGNhbGxpbmcgcHJvY2Vzc0NvbXBvbmVudCAobmV4dDogVk5vZGUpXG4gICAgICAgICAgICAgICAgbGV0IHsgbmV4dCwgYnUsIHUsIHBhcmVudCwgdm5vZGUgfSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgICAgIGxldCBvcmlnaW5OZXh0ID0gbmV4dDtcbiAgICAgICAgICAgICAgICBsZXQgdm5vZGVIb29rO1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KG5leHQgfHwgaW5zdGFuY2Uudm5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBEaXNhbGxvdyBjb21wb25lbnQgZWZmZWN0IHJlY3Vyc2lvbiBkdXJpbmcgcHJlLWxpZmVjeWNsZSBob29rcy5cbiAgICAgICAgICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5lbCA9IHZub2RlLmVsO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIoaW5zdGFuY2UsIG5leHQsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gdm5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGJlZm9yZVVwZGF0ZSBob29rXG4gICAgICAgICAgICAgICAgaWYgKGJ1KSB7XG4gICAgICAgICAgICAgICAgICAgIGludm9rZUFycmF5Rm5zKGJ1KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gb25Wbm9kZUJlZm9yZVVwZGF0ZVxuICAgICAgICAgICAgICAgIGlmICgodm5vZGVIb29rID0gbmV4dC5wcm9wcyAmJiBuZXh0LnByb3BzLm9uVm5vZGVCZWZvcmVVcGRhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgbmV4dCwgdm5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAvLyByZW5kZXJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0VHJlZSA9IHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2VHJlZSA9IGluc3RhbmNlLnN1YlRyZWU7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uuc3ViVHJlZSA9IG5leHRUcmVlO1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGF0Y2gocHJldlRyZWUsIG5leHRUcmVlLCBcbiAgICAgICAgICAgICAgICAvLyBwYXJlbnQgbWF5IGhhdmUgY2hhbmdlZCBpZiBpdCdzIGluIGEgdGVsZXBvcnRcbiAgICAgICAgICAgICAgICBob3N0UGFyZW50Tm9kZShwcmV2VHJlZS5lbCksIFxuICAgICAgICAgICAgICAgIC8vIGFuY2hvciBtYXkgaGF2ZSBjaGFuZ2VkIGlmIGl0J3MgaW4gYSBmcmFnbWVudFxuICAgICAgICAgICAgICAgIGdldE5leHRIb3N0Tm9kZShwcmV2VHJlZSksIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpO1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQuZWwgPSBuZXh0VHJlZS5lbDtcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luTmV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzZWxmLXRyaWdnZXJlZCB1cGRhdGUuIEluIGNhc2Ugb2YgSE9DLCB1cGRhdGUgcGFyZW50IGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAvLyB2bm9kZSBlbC4gSE9DIGlzIGluZGljYXRlZCBieSBwYXJlbnQgaW5zdGFuY2UncyBzdWJUcmVlIHBvaW50aW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGNoaWxkIGNvbXBvbmVudCdzIHZub2RlXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUhPQ0hvc3RFbChpbnN0YW5jZSwgbmV4dFRyZWUuZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGVkIGhvb2tcbiAgICAgICAgICAgICAgICBpZiAodSkge1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QodSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBvblZub2RlVXBkYXRlZFxuICAgICAgICAgICAgICAgIGlmICgodm5vZGVIb29rID0gbmV4dC5wcm9wcyAmJiBuZXh0LnByb3BzLm9uVm5vZGVVcGRhdGVkKSkge1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4gaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBuZXh0LCB2bm9kZSksIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICAgICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRVcGRhdGVkKGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gY3JlYXRlIHJlYWN0aXZlIGVmZmVjdCBmb3IgcmVuZGVyaW5nXG4gICAgICAgIGNvbnN0IGVmZmVjdCA9IChpbnN0YW5jZS5lZmZlY3QgPSBuZXcgUmVhY3RpdmVFZmZlY3QoY29tcG9uZW50VXBkYXRlRm4sICgpID0+IHF1ZXVlSm9iKHVwZGF0ZSksIGluc3RhbmNlLnNjb3BlIC8vIHRyYWNrIGl0IGluIGNvbXBvbmVudCdzIGVmZmVjdCBzY29wZVxuICAgICAgICApKTtcbiAgICAgICAgY29uc3QgdXBkYXRlID0gKGluc3RhbmNlLnVwZGF0ZSA9ICgpID0+IGVmZmVjdC5ydW4oKSk7XG4gICAgICAgIHVwZGF0ZS5pZCA9IGluc3RhbmNlLnVpZDtcbiAgICAgICAgLy8gYWxsb3dSZWN1cnNlXG4gICAgICAgIC8vICMxODAxLCAjMjA0MyBjb21wb25lbnQgcmVuZGVyIGVmZmVjdHMgc2hvdWxkIGFsbG93IHJlY3Vyc2l2ZSB1cGRhdGVzXG4gICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIHRydWUpO1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICBlZmZlY3Qub25UcmFjayA9IGluc3RhbmNlLnJ0Y1xuICAgICAgICAgICAgICAgID8gZSA9PiBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5ydGMsIGUpXG4gICAgICAgICAgICAgICAgOiB2b2lkIDA7XG4gICAgICAgICAgICBlZmZlY3Qub25UcmlnZ2VyID0gaW5zdGFuY2UucnRnXG4gICAgICAgICAgICAgICAgPyBlID0+IGludm9rZUFycmF5Rm5zKGluc3RhbmNlLnJ0ZywgZSlcbiAgICAgICAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgICAgICAgIHVwZGF0ZS5vd25lckluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlKCk7XG4gICAgfTtcbiAgICBjb25zdCB1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIgPSAoaW5zdGFuY2UsIG5leHRWTm9kZSwgb3B0aW1pemVkKSA9PiB7XG4gICAgICAgIG5leHRWTm9kZS5jb21wb25lbnQgPSBpbnN0YW5jZTtcbiAgICAgICAgY29uc3QgcHJldlByb3BzID0gaW5zdGFuY2Uudm5vZGUucHJvcHM7XG4gICAgICAgIGluc3RhbmNlLnZub2RlID0gbmV4dFZOb2RlO1xuICAgICAgICBpbnN0YW5jZS5uZXh0ID0gbnVsbDtcbiAgICAgICAgdXBkYXRlUHJvcHMoaW5zdGFuY2UsIG5leHRWTm9kZS5wcm9wcywgcHJldlByb3BzLCBvcHRpbWl6ZWQpO1xuICAgICAgICB1cGRhdGVTbG90cyhpbnN0YW5jZSwgbmV4dFZOb2RlLmNoaWxkcmVuLCBvcHRpbWl6ZWQpO1xuICAgICAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgICAgIC8vIHByb3BzIHVwZGF0ZSBtYXkgaGF2ZSB0cmlnZ2VyZWQgcHJlLWZsdXNoIHdhdGNoZXJzLlxuICAgICAgICAvLyBmbHVzaCB0aGVtIGJlZm9yZSB0aGUgcmVuZGVyIHVwZGF0ZS5cbiAgICAgICAgZmx1c2hQcmVGbHVzaENicygpO1xuICAgICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgfTtcbiAgICBjb25zdCBwYXRjaENoaWxkcmVuID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCA9IGZhbHNlKSA9PiB7XG4gICAgICAgIGNvbnN0IGMxID0gbjEgJiYgbjEuY2hpbGRyZW47XG4gICAgICAgIGNvbnN0IHByZXZTaGFwZUZsYWcgPSBuMSA/IG4xLnNoYXBlRmxhZyA6IDA7XG4gICAgICAgIGNvbnN0IGMyID0gbjIuY2hpbGRyZW47XG4gICAgICAgIGNvbnN0IHsgcGF0Y2hGbGFnLCBzaGFwZUZsYWcgfSA9IG4yO1xuICAgICAgICAvLyBmYXN0IHBhdGhcbiAgICAgICAgaWYgKHBhdGNoRmxhZyA+IDApIHtcbiAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgJiAxMjggLyogUGF0Y2hGbGFncy5LRVlFRF9GUkFHTUVOVCAqLykge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgY291bGQgYmUgZWl0aGVyIGZ1bGx5LWtleWVkIG9yIG1peGVkIChzb21lIGtleWVkIHNvbWUgbm90KVxuICAgICAgICAgICAgICAgIC8vIHByZXNlbmNlIG9mIHBhdGNoRmxhZyBtZWFucyBjaGlsZHJlbiBhcmUgZ3VhcmFudGVlZCB0byBiZSBhcnJheXNcbiAgICAgICAgICAgICAgICBwYXRjaEtleWVkQ2hpbGRyZW4oYzEsIGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXRjaEZsYWcgJiAyNTYgLyogUGF0Y2hGbGFncy5VTktFWUVEX0ZSQUdNRU5UICovKSB7XG4gICAgICAgICAgICAgICAgLy8gdW5rZXllZFxuICAgICAgICAgICAgICAgIHBhdGNoVW5rZXllZENoaWxkcmVuKGMxLCBjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNoaWxkcmVuIGhhcyAzIHBvc3NpYmlsaXRpZXM6IHRleHQsIGFycmF5IG9yIG5vIGNoaWxkcmVuLlxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgOCAvKiBTaGFwZUZsYWdzLlRFWFRfQ0hJTERSRU4gKi8pIHtcbiAgICAgICAgICAgIC8vIHRleHQgY2hpbGRyZW4gZmFzdCBwYXRoXG4gICAgICAgICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDE2IC8qIFNoYXBlRmxhZ3MuQVJSQVlfQ0hJTERSRU4gKi8pIHtcbiAgICAgICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oYzEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMyICE9PSBjMSkge1xuICAgICAgICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChjb250YWluZXIsIGMyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwcmV2U2hhcGVGbGFnICYgMTYgLyogU2hhcGVGbGFncy5BUlJBWV9DSElMRFJFTiAqLykge1xuICAgICAgICAgICAgICAgIC8vIHByZXYgY2hpbGRyZW4gd2FzIGFycmF5XG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIFNoYXBlRmxhZ3MuQVJSQVlfQ0hJTERSRU4gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHdvIGFycmF5cywgY2Fubm90IGFzc3VtZSBhbnl0aGluZywgZG8gZnVsbCBkaWZmXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoS2V5ZWRDaGlsZHJlbihjMSwgYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gbmV3IGNoaWxkcmVuLCBqdXN0IHVubW91bnQgb2xkXG4gICAgICAgICAgICAgICAgICAgIHVubW91bnRDaGlsZHJlbihjMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcHJldiBjaGlsZHJlbiB3YXMgdGV4dCBPUiBudWxsXG4gICAgICAgICAgICAgICAgLy8gbmV3IGNoaWxkcmVuIGlzIGFycmF5IE9SIG51bGxcbiAgICAgICAgICAgICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDggLyogU2hhcGVGbGFncy5URVhUX0NISUxEUkVOICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChjb250YWluZXIsICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbW91bnQgbmV3IGlmIGFycmF5XG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIFNoYXBlRmxhZ3MuQVJSQVlfQ0hJTERSRU4gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgbW91bnRDaGlsZHJlbihjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwYXRjaFVua2V5ZWRDaGlsZHJlbiA9IChjMSwgYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICAgICAgYzEgPSBjMSB8fCBFTVBUWV9BUlI7XG4gICAgICAgIGMyID0gYzIgfHwgRU1QVFlfQVJSO1xuICAgICAgICBjb25zdCBvbGRMZW5ndGggPSBjMS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG5ld0xlbmd0aCA9IGMyLmxlbmd0aDtcbiAgICAgICAgY29uc3QgY29tbW9uTGVuZ3RoID0gTWF0aC5taW4ob2xkTGVuZ3RoLCBuZXdMZW5ndGgpO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbW1vbkxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0Q2hpbGQgPSAoYzJbaV0gPSBvcHRpbWl6ZWRcbiAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGMyW2ldKVxuICAgICAgICAgICAgICAgIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pKTtcbiAgICAgICAgICAgIHBhdGNoKGMxW2ldLCBuZXh0Q2hpbGQsIGNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2xkTGVuZ3RoID4gbmV3TGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgb2xkXG4gICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oYzEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUsIGZhbHNlLCBjb21tb25MZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbW91bnQgbmV3XG4gICAgICAgICAgICBtb3VudENoaWxkcmVuKGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBjb21tb25MZW5ndGgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBjYW4gYmUgYWxsLWtleWVkIG9yIG1peGVkXG4gICAgY29uc3QgcGF0Y2hLZXllZENoaWxkcmVuID0gKGMxLCBjMiwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGNvbnN0IGwyID0gYzIubGVuZ3RoO1xuICAgICAgICBsZXQgZTEgPSBjMS5sZW5ndGggLSAxOyAvLyBwcmV2IGVuZGluZyBpbmRleFxuICAgICAgICBsZXQgZTIgPSBsMiAtIDE7IC8vIG5leHQgZW5kaW5nIGluZGV4XG4gICAgICAgIC8vIDEuIHN5bmMgZnJvbSBzdGFydFxuICAgICAgICAvLyAoYSBiKSBjXG4gICAgICAgIC8vIChhIGIpIGQgZVxuICAgICAgICB3aGlsZSAoaSA8PSBlMSAmJiBpIDw9IGUyKSB7XG4gICAgICAgICAgICBjb25zdCBuMSA9IGMxW2ldO1xuICAgICAgICAgICAgY29uc3QgbjIgPSAoYzJbaV0gPSBvcHRpbWl6ZWRcbiAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGMyW2ldKVxuICAgICAgICAgICAgICAgIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pKTtcbiAgICAgICAgICAgIGlmIChpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSkge1xuICAgICAgICAgICAgICAgIHBhdGNoKG4xLCBuMiwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMi4gc3luYyBmcm9tIGVuZFxuICAgICAgICAvLyBhIChiIGMpXG4gICAgICAgIC8vIGQgZSAoYiBjKVxuICAgICAgICB3aGlsZSAoaSA8PSBlMSAmJiBpIDw9IGUyKSB7XG4gICAgICAgICAgICBjb25zdCBuMSA9IGMxW2UxXTtcbiAgICAgICAgICAgIGNvbnN0IG4yID0gKGMyW2UyXSA9IG9wdGltaXplZFxuICAgICAgICAgICAgICAgID8gY2xvbmVJZk1vdW50ZWQoYzJbZTJdKVxuICAgICAgICAgICAgICAgIDogbm9ybWFsaXplVk5vZGUoYzJbZTJdKSk7XG4gICAgICAgICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcbiAgICAgICAgICAgICAgICBwYXRjaChuMSwgbjIsIGNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZTEtLTtcbiAgICAgICAgICAgIGUyLS07XG4gICAgICAgIH1cbiAgICAgICAgLy8gMy4gY29tbW9uIHNlcXVlbmNlICsgbW91bnRcbiAgICAgICAgLy8gKGEgYilcbiAgICAgICAgLy8gKGEgYikgY1xuICAgICAgICAvLyBpID0gMiwgZTEgPSAxLCBlMiA9IDJcbiAgICAgICAgLy8gKGEgYilcbiAgICAgICAgLy8gYyAoYSBiKVxuICAgICAgICAvLyBpID0gMCwgZTEgPSAtMSwgZTIgPSAwXG4gICAgICAgIGlmIChpID4gZTEpIHtcbiAgICAgICAgICAgIGlmIChpIDw9IGUyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFBvcyA9IGUyICsgMTtcbiAgICAgICAgICAgICAgICBjb25zdCBhbmNob3IgPSBuZXh0UG9zIDwgbDIgPyBjMltuZXh0UG9zXS5lbCA6IHBhcmVudEFuY2hvcjtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA8PSBlMikge1xuICAgICAgICAgICAgICAgICAgICBwYXRjaChudWxsLCAoYzJbaV0gPSBvcHRpbWl6ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKSksIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIDQuIGNvbW1vbiBzZXF1ZW5jZSArIHVubW91bnRcbiAgICAgICAgLy8gKGEgYikgY1xuICAgICAgICAvLyAoYSBiKVxuICAgICAgICAvLyBpID0gMiwgZTEgPSAyLCBlMiA9IDFcbiAgICAgICAgLy8gYSAoYiBjKVxuICAgICAgICAvLyAoYiBjKVxuICAgICAgICAvLyBpID0gMCwgZTEgPSAwLCBlMiA9IC0xXG4gICAgICAgIGVsc2UgaWYgKGkgPiBlMikge1xuICAgICAgICAgICAgd2hpbGUgKGkgPD0gZTEpIHtcbiAgICAgICAgICAgICAgICB1bm1vdW50KGMxW2ldLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gNS4gdW5rbm93biBzZXF1ZW5jZVxuICAgICAgICAvLyBbaSAuLi4gZTEgKyAxXTogYSBiIFtjIGQgZV0gZiBnXG4gICAgICAgIC8vIFtpIC4uLiBlMiArIDFdOiBhIGIgW2UgZCBjIGhdIGYgZ1xuICAgICAgICAvLyBpID0gMiwgZTEgPSA0LCBlMiA9IDVcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzMSA9IGk7IC8vIHByZXYgc3RhcnRpbmcgaW5kZXhcbiAgICAgICAgICAgIGNvbnN0IHMyID0gaTsgLy8gbmV4dCBzdGFydGluZyBpbmRleFxuICAgICAgICAgICAgLy8gNS4xIGJ1aWxkIGtleTppbmRleCBtYXAgZm9yIG5ld0NoaWxkcmVuXG4gICAgICAgICAgICBjb25zdCBrZXlUb05ld0luZGV4TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgZm9yIChpID0gczI7IGkgPD0gZTI7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IChjMltpXSA9IG9wdGltaXplZFxuICAgICAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGMyW2ldKVxuICAgICAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKSk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGlsZC5rZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGtleVRvTmV3SW5kZXhNYXAuaGFzKG5leHRDaGlsZC5rZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBEdXBsaWNhdGUga2V5cyBmb3VuZCBkdXJpbmcgdXBkYXRlOmAsIEpTT04uc3RyaW5naWZ5KG5leHRDaGlsZC5rZXkpLCBgTWFrZSBzdXJlIGtleXMgYXJlIHVuaXF1ZS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBrZXlUb05ld0luZGV4TWFwLnNldChuZXh0Q2hpbGQua2V5LCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyA1LjIgbG9vcCB0aHJvdWdoIG9sZCBjaGlsZHJlbiBsZWZ0IHRvIGJlIHBhdGNoZWQgYW5kIHRyeSB0byBwYXRjaFxuICAgICAgICAgICAgLy8gbWF0Y2hpbmcgbm9kZXMgJiByZW1vdmUgbm9kZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnRcbiAgICAgICAgICAgIGxldCBqO1xuICAgICAgICAgICAgbGV0IHBhdGNoZWQgPSAwO1xuICAgICAgICAgICAgY29uc3QgdG9CZVBhdGNoZWQgPSBlMiAtIHMyICsgMTtcbiAgICAgICAgICAgIGxldCBtb3ZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gdXNlZCB0byB0cmFjayB3aGV0aGVyIGFueSBub2RlIGhhcyBtb3ZlZFxuICAgICAgICAgICAgbGV0IG1heE5ld0luZGV4U29GYXIgPSAwO1xuICAgICAgICAgICAgLy8gd29ya3MgYXMgTWFwPG5ld0luZGV4LCBvbGRJbmRleD5cbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBvbGRJbmRleCBpcyBvZmZzZXQgYnkgKzFcbiAgICAgICAgICAgIC8vIGFuZCBvbGRJbmRleCA9IDAgaXMgYSBzcGVjaWFsIHZhbHVlIGluZGljYXRpbmcgdGhlIG5ldyBub2RlIGhhc1xuICAgICAgICAgICAgLy8gbm8gY29ycmVzcG9uZGluZyBvbGQgbm9kZS5cbiAgICAgICAgICAgIC8vIHVzZWQgZm9yIGRldGVybWluaW5nIGxvbmdlc3Qgc3RhYmxlIHN1YnNlcXVlbmNlXG4gICAgICAgICAgICBjb25zdCBuZXdJbmRleFRvT2xkSW5kZXhNYXAgPSBuZXcgQXJyYXkodG9CZVBhdGNoZWQpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRvQmVQYXRjaGVkOyBpKyspXG4gICAgICAgICAgICAgICAgbmV3SW5kZXhUb09sZEluZGV4TWFwW2ldID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IHMxOyBpIDw9IGUxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2Q2hpbGQgPSBjMVtpXTtcbiAgICAgICAgICAgICAgICBpZiAocGF0Y2hlZCA+PSB0b0JlUGF0Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhbGwgbmV3IGNoaWxkcmVuIGhhdmUgYmVlbiBwYXRjaGVkIHNvIHRoaXMgY2FuIG9ubHkgYmUgYSByZW1vdmFsXG4gICAgICAgICAgICAgICAgICAgIHVubW91bnQocHJldkNoaWxkLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBuZXdJbmRleDtcbiAgICAgICAgICAgICAgICBpZiAocHJldkNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0luZGV4ID0ga2V5VG9OZXdJbmRleE1hcC5nZXQocHJldkNoaWxkLmtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBrZXktbGVzcyBub2RlLCB0cnkgdG8gbG9jYXRlIGEga2V5LWxlc3Mgbm9kZSBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IHMyOyBqIDw9IGUyOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdJbmRleFRvT2xkSW5kZXhNYXBbaiAtIHMyXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzU2FtZVZOb2RlVHlwZShwcmV2Q2hpbGQsIGMyW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0luZGV4ID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV3SW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB1bm1vdW50KHByZXZDaGlsZCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdJbmRleFRvT2xkSW5kZXhNYXBbbmV3SW5kZXggLSBzMl0gPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0luZGV4ID49IG1heE5ld0luZGV4U29GYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heE5ld0luZGV4U29GYXIgPSBuZXdJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXRjaChwcmV2Q2hpbGQsIGMyW25ld0luZGV4XSwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgICAgICAgICBwYXRjaGVkKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gNS4zIG1vdmUgYW5kIG1vdW50XG4gICAgICAgICAgICAvLyBnZW5lcmF0ZSBsb25nZXN0IHN0YWJsZSBzdWJzZXF1ZW5jZSBvbmx5IHdoZW4gbm9kZXMgaGF2ZSBtb3ZlZFxuICAgICAgICAgICAgY29uc3QgaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2UgPSBtb3ZlZFxuICAgICAgICAgICAgICAgID8gZ2V0U2VxdWVuY2UobmV3SW5kZXhUb09sZEluZGV4TWFwKVxuICAgICAgICAgICAgICAgIDogRU1QVFlfQVJSO1xuICAgICAgICAgICAgaiA9IGluY3JlYXNpbmdOZXdJbmRleFNlcXVlbmNlLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAvLyBsb29waW5nIGJhY2t3YXJkcyBzbyB0aGF0IHdlIGNhbiB1c2UgbGFzdCBwYXRjaGVkIG5vZGUgYXMgYW5jaG9yXG4gICAgICAgICAgICBmb3IgKGkgPSB0b0JlUGF0Y2hlZCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gczIgKyBpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IGMyW25leHRJbmRleF07XG4gICAgICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gbmV4dEluZGV4ICsgMSA8IGwyID8gYzJbbmV4dEluZGV4ICsgMV0uZWwgOiBwYXJlbnRBbmNob3I7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0luZGV4VG9PbGRJbmRleE1hcFtpXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtb3VudCBuZXdcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2gobnVsbCwgbmV4dENoaWxkLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBpZjpcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gc3RhYmxlIHN1YnNlcXVlbmNlIChlLmcuIGEgcmV2ZXJzZSlcbiAgICAgICAgICAgICAgICAgICAgLy8gT1IgY3VycmVudCBub2RlIGlzIG5vdCBhbW9uZyB0aGUgc3RhYmxlIHNlcXVlbmNlXG4gICAgICAgICAgICAgICAgICAgIGlmIChqIDwgMCB8fCBpICE9PSBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZVtqXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZShuZXh0Q2hpbGQsIGNvbnRhaW5lciwgYW5jaG9yLCAyIC8qIE1vdmVUeXBlLlJFT1JERVIgKi8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBtb3ZlID0gKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUsIHBhcmVudFN1c3BlbnNlID0gbnVsbCkgPT4ge1xuICAgICAgICBjb25zdCB7IGVsLCB0eXBlLCB0cmFuc2l0aW9uLCBjaGlsZHJlbiwgc2hhcGVGbGFnIH0gPSB2bm9kZTtcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDYgLyogU2hhcGVGbGFncy5DT01QT05FTlQgKi8pIHtcbiAgICAgICAgICAgIG1vdmUodm5vZGUuY29tcG9uZW50LnN1YlRyZWUsIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEyOCAvKiBTaGFwZUZsYWdzLlNVU1BFTlNFICovKSB7XG4gICAgICAgICAgICB2bm9kZS5zdXNwZW5zZS5tb3ZlKGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDY0IC8qIFNoYXBlRmxhZ3MuVEVMRVBPUlQgKi8pIHtcbiAgICAgICAgICAgIHR5cGUubW92ZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIGludGVybmFscyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IEZyYWdtZW50KSB7XG4gICAgICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbW92ZShjaGlsZHJlbltpXSwgY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhvc3RJbnNlcnQodm5vZGUuYW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFN0YXRpYykge1xuICAgICAgICAgICAgbW92ZVN0YXRpY05vZGUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBzaW5nbGUgbm9kZXNcbiAgICAgICAgY29uc3QgbmVlZFRyYW5zaXRpb24gPSBtb3ZlVHlwZSAhPT0gMiAvKiBNb3ZlVHlwZS5SRU9SREVSICovICYmXG4gICAgICAgICAgICBzaGFwZUZsYWcgJiAxIC8qIFNoYXBlRmxhZ3MuRUxFTUVOVCAqLyAmJlxuICAgICAgICAgICAgdHJhbnNpdGlvbjtcbiAgICAgICAgaWYgKG5lZWRUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAobW92ZVR5cGUgPT09IDAgLyogTW92ZVR5cGUuRU5URVIgKi8pIHtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcbiAgICAgICAgICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHRyYW5zaXRpb24uZW50ZXIoZWwpLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGxlYXZlLCBkZWxheUxlYXZlLCBhZnRlckxlYXZlIH0gPSB0cmFuc2l0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbW92ZSA9ICgpID0+IGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwZXJmb3JtTGVhdmUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxlYXZlKGVsLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChkZWxheUxlYXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGF5TGVhdmUoZWwsIHJlbW92ZSwgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBlcmZvcm1MZWF2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdW5tb3VudCA9ICh2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUgPSBmYWxzZSwgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcbiAgICAgICAgY29uc3QgeyB0eXBlLCBwcm9wcywgcmVmLCBjaGlsZHJlbiwgZHluYW1pY0NoaWxkcmVuLCBzaGFwZUZsYWcsIHBhdGNoRmxhZywgZGlycyB9ID0gdm5vZGU7XG4gICAgICAgIC8vIHVuc2V0IHJlZlxuICAgICAgICBpZiAocmVmICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFJlZihyZWYsIG51bGwsIHBhcmVudFN1c3BlbnNlLCB2bm9kZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDI1NiAvKiBTaGFwZUZsYWdzLkNPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRSAqLykge1xuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LmN0eC5kZWFjdGl2YXRlKHZub2RlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaG91bGRJbnZva2VEaXJzID0gc2hhcGVGbGFnICYgMSAvKiBTaGFwZUZsYWdzLkVMRU1FTlQgKi8gJiYgZGlycztcbiAgICAgICAgY29uc3Qgc2hvdWxkSW52b2tlVm5vZGVIb29rID0gIWlzQXN5bmNXcmFwcGVyKHZub2RlKTtcbiAgICAgICAgbGV0IHZub2RlSG9vaztcbiAgICAgICAgaWYgKHNob3VsZEludm9rZVZub2RlSG9vayAmJlxuICAgICAgICAgICAgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVVbm1vdW50KSkge1xuICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDYgLyogU2hhcGVGbGFncy5DT01QT05FTlQgKi8pIHtcbiAgICAgICAgICAgIHVubW91bnRDb21wb25lbnQodm5vZGUuY29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEyOCAvKiBTaGFwZUZsYWdzLlNVU1BFTlNFICovKSB7XG4gICAgICAgICAgICAgICAgdm5vZGUuc3VzcGVuc2UudW5tb3VudChwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG91bGRJbnZva2VEaXJzKSB7XG4gICAgICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnYmVmb3JlVW5tb3VudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDY0IC8qIFNoYXBlRmxhZ3MuVEVMRVBPUlQgKi8pIHtcbiAgICAgICAgICAgICAgICB2bm9kZS50eXBlLnJlbW92ZSh2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgb3B0aW1pemVkLCBpbnRlcm5hbHMsIGRvUmVtb3ZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGR5bmFtaWNDaGlsZHJlbiAmJlxuICAgICAgICAgICAgICAgIC8vICMxMTUzOiBmYXN0IHBhdGggc2hvdWxkIG5vdCBiZSB0YWtlbiBmb3Igbm9uLXN0YWJsZSAodi1mb3IpIGZyYWdtZW50c1xuICAgICAgICAgICAgICAgICh0eXBlICE9PSBGcmFnbWVudCB8fFxuICAgICAgICAgICAgICAgICAgICAocGF0Y2hGbGFnID4gMCAmJiBwYXRjaEZsYWcgJiA2NCAvKiBQYXRjaEZsYWdzLlNUQUJMRV9GUkFHTUVOVCAqLykpKSB7XG4gICAgICAgICAgICAgICAgLy8gZmFzdCBwYXRoIGZvciBibG9jayBub2Rlczogb25seSBuZWVkIHRvIHVubW91bnQgZHluYW1pYyBjaGlsZHJlbi5cbiAgICAgICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oZHluYW1pY0NoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgodHlwZSA9PT0gRnJhZ21lbnQgJiZcbiAgICAgICAgICAgICAgICBwYXRjaEZsYWcgJlxuICAgICAgICAgICAgICAgICAgICAoMTI4IC8qIFBhdGNoRmxhZ3MuS0VZRURfRlJBR01FTlQgKi8gfCAyNTYgLyogUGF0Y2hGbGFncy5VTktFWUVEX0ZSQUdNRU5UICovKSkgfHxcbiAgICAgICAgICAgICAgICAoIW9wdGltaXplZCAmJiBzaGFwZUZsYWcgJiAxNiAvKiBTaGFwZUZsYWdzLkFSUkFZX0NISUxEUkVOICovKSkge1xuICAgICAgICAgICAgICAgIHVubW91bnRDaGlsZHJlbihjaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZG9SZW1vdmUpIHtcbiAgICAgICAgICAgICAgICByZW1vdmUodm5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgoc2hvdWxkSW52b2tlVm5vZGVIb29rICYmXG4gICAgICAgICAgICAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZVVubW91bnRlZCkpIHx8XG4gICAgICAgICAgICBzaG91bGRJbnZva2VEaXJzKSB7XG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICAgICAgICAgICAgICBzaG91bGRJbnZva2VEaXJzICYmXG4gICAgICAgICAgICAgICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ3VubW91bnRlZCcpO1xuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmUgPSB2bm9kZSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdHlwZSwgZWwsIGFuY2hvciwgdHJhbnNpdGlvbiB9ID0gdm5vZGU7XG4gICAgICAgIGlmICh0eXBlID09PSBGcmFnbWVudCkge1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgICAgIHZub2RlLnBhdGNoRmxhZyA+IDAgJiZcbiAgICAgICAgICAgICAgICB2bm9kZS5wYXRjaEZsYWcgJiAyMDQ4IC8qIFBhdGNoRmxhZ3MuREVWX1JPT1RfRlJBR01FTlQgKi8gJiZcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uICYmXG4gICAgICAgICAgICAgICAgIXRyYW5zaXRpb24ucGVyc2lzdGVkKSB7XG4gICAgICAgICAgICAgICAgdm5vZGUuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBDb21tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0UmVtb3ZlKGNoaWxkLmVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZShjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbW92ZUZyYWdtZW50KGVsLCBhbmNob3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBTdGF0aWMpIHtcbiAgICAgICAgICAgIHJlbW92ZVN0YXRpY05vZGUodm5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBlcmZvcm1SZW1vdmUgPSAoKSA9PiB7XG4gICAgICAgICAgICBob3N0UmVtb3ZlKGVsKTtcbiAgICAgICAgICAgIGlmICh0cmFuc2l0aW9uICYmICF0cmFuc2l0aW9uLnBlcnNpc3RlZCAmJiB0cmFuc2l0aW9uLmFmdGVyTGVhdmUpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLmFmdGVyTGVhdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEgLyogU2hhcGVGbGFncy5FTEVNRU5UICovICYmXG4gICAgICAgICAgICB0cmFuc2l0aW9uICYmXG4gICAgICAgICAgICAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbGVhdmUsIGRlbGF5TGVhdmUgfSA9IHRyYW5zaXRpb247XG4gICAgICAgICAgICBjb25zdCBwZXJmb3JtTGVhdmUgPSAoKSA9PiBsZWF2ZShlbCwgcGVyZm9ybVJlbW92ZSk7XG4gICAgICAgICAgICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgICAgICAgICAgICAgIGRlbGF5TGVhdmUodm5vZGUuZWwsIHBlcmZvcm1SZW1vdmUsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZXJmb3JtTGVhdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBlcmZvcm1SZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlRnJhZ21lbnQgPSAoY3VyLCBlbmQpID0+IHtcbiAgICAgICAgLy8gRm9yIGZyYWdtZW50cywgZGlyZWN0bHkgcmVtb3ZlIGFsbCBjb250YWluZWQgRE9NIG5vZGVzLlxuICAgICAgICAvLyAoZnJhZ21lbnQgY2hpbGQgbm9kZXMgY2Fubm90IGhhdmUgdHJhbnNpdGlvbilcbiAgICAgICAgbGV0IG5leHQ7XG4gICAgICAgIHdoaWxlIChjdXIgIT09IGVuZCkge1xuICAgICAgICAgICAgbmV4dCA9IGhvc3ROZXh0U2libGluZyhjdXIpO1xuICAgICAgICAgICAgaG9zdFJlbW92ZShjdXIpO1xuICAgICAgICAgICAgY3VyID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBob3N0UmVtb3ZlKGVuZCk7XG4gICAgfTtcbiAgICBjb25zdCB1bm1vdW50Q29tcG9uZW50ID0gKGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpID0+IHtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpbnN0YW5jZS50eXBlLl9faG1ySWQpIHtcbiAgICAgICAgICAgIHVucmVnaXN0ZXJITVIoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgYnVtLCBzY29wZSwgdXBkYXRlLCBzdWJUcmVlLCB1bSB9ID0gaW5zdGFuY2U7XG4gICAgICAgIC8vIGJlZm9yZVVubW91bnQgaG9va1xuICAgICAgICBpZiAoYnVtKSB7XG4gICAgICAgICAgICBpbnZva2VBcnJheUZucyhidW0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0b3AgZWZmZWN0cyBpbiBjb21wb25lbnQgc2NvcGVcbiAgICAgICAgc2NvcGUuc3RvcCgpO1xuICAgICAgICAvLyB1cGRhdGUgbWF5IGJlIG51bGwgaWYgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGJlZm9yZSBpdHMgYXN5bmNcbiAgICAgICAgLy8gc2V0dXAgaGFzIHJlc29sdmVkLlxuICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICAvLyBzbyB0aGF0IHNjaGVkdWxlciB3aWxsIG5vIGxvbmdlciBpbnZva2UgaXRcbiAgICAgICAgICAgIHVwZGF0ZS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHVubW91bnQoc3ViVHJlZSwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdW5tb3VudGVkIGhvb2tcbiAgICAgICAgaWYgKHVtKSB7XG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QodW0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgaW5zdGFuY2UuaXNVbm1vdW50ZWQgPSB0cnVlO1xuICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgIC8vIEEgY29tcG9uZW50IHdpdGggYXN5bmMgZGVwIGluc2lkZSBhIHBlbmRpbmcgc3VzcGVuc2UgaXMgdW5tb3VudGVkIGJlZm9yZVxuICAgICAgICAvLyBpdHMgYXN5bmMgZGVwIHJlc29sdmVzLiBUaGlzIHNob3VsZCByZW1vdmUgdGhlIGRlcCBmcm9tIHRoZSBzdXNwZW5zZSwgYW5kXG4gICAgICAgIC8vIGNhdXNlIHRoZSBzdXNwZW5zZSB0byByZXNvbHZlIGltbWVkaWF0ZWx5IGlmIHRoYXQgd2FzIHRoZSBsYXN0IGRlcC5cbiAgICAgICAgaWYgKHBhcmVudFN1c3BlbnNlICYmXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nQnJhbmNoICYmXG4gICAgICAgICAgICAhcGFyZW50U3VzcGVuc2UuaXNVbm1vdW50ZWQgJiZcbiAgICAgICAgICAgIGluc3RhbmNlLmFzeW5jRGVwICYmXG4gICAgICAgICAgICAhaW5zdGFuY2UuYXN5bmNSZXNvbHZlZCAmJlxuICAgICAgICAgICAgaW5zdGFuY2Uuc3VzcGVuc2VJZCA9PT0gcGFyZW50U3VzcGVuc2UucGVuZGluZ0lkKSB7XG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZS5kZXBzLS07XG4gICAgICAgICAgICBpZiAocGFyZW50U3VzcGVuc2UuZGVwcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRSZW1vdmVkKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdW5tb3VudENoaWxkcmVuID0gKGNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSA9IGZhbHNlLCBvcHRpbWl6ZWQgPSBmYWxzZSwgc3RhcnQgPSAwKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB1bm1vdW50KGNoaWxkcmVuW2ldLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSwgb3B0aW1pemVkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZ2V0TmV4dEhvc3ROb2RlID0gdm5vZGUgPT4ge1xuICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNiAvKiBTaGFwZUZsYWdzLkNPTVBPTkVOVCAqLykge1xuICAgICAgICAgICAgcmV0dXJuIGdldE5leHRIb3N0Tm9kZSh2bm9kZS5jb21wb25lbnQuc3ViVHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEyOCAvKiBTaGFwZUZsYWdzLlNVU1BFTlNFICovKSB7XG4gICAgICAgICAgICByZXR1cm4gdm5vZGUuc3VzcGVuc2UubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBob3N0TmV4dFNpYmxpbmcoKHZub2RlLmFuY2hvciB8fCB2bm9kZS5lbCkpO1xuICAgIH07XG4gICAgY29uc3QgcmVuZGVyID0gKHZub2RlLCBjb250YWluZXIsIGlzU1ZHKSA9PiB7XG4gICAgICAgIGlmICh2bm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyLl92bm9kZSkge1xuICAgICAgICAgICAgICAgIHVubW91bnQoY29udGFpbmVyLl92bm9kZSwgbnVsbCwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXRjaChjb250YWluZXIuX3Zub2RlIHx8IG51bGwsIHZub2RlLCBjb250YWluZXIsIG51bGwsIG51bGwsIG51bGwsIGlzU1ZHKTtcbiAgICAgICAgfVxuICAgICAgICBmbHVzaFByZUZsdXNoQ2JzKCk7XG4gICAgICAgIGZsdXNoUG9zdEZsdXNoQ2JzKCk7XG4gICAgICAgIGNvbnRhaW5lci5fdm5vZGUgPSB2bm9kZTtcbiAgICB9O1xuICAgIGNvbnN0IGludGVybmFscyA9IHtcbiAgICAgICAgcDogcGF0Y2gsXG4gICAgICAgIHVtOiB1bm1vdW50LFxuICAgICAgICBtOiBtb3ZlLFxuICAgICAgICByOiByZW1vdmUsXG4gICAgICAgIG10OiBtb3VudENvbXBvbmVudCxcbiAgICAgICAgbWM6IG1vdW50Q2hpbGRyZW4sXG4gICAgICAgIHBjOiBwYXRjaENoaWxkcmVuLFxuICAgICAgICBwYmM6IHBhdGNoQmxvY2tDaGlsZHJlbixcbiAgICAgICAgbjogZ2V0TmV4dEhvc3ROb2RlLFxuICAgICAgICBvOiBvcHRpb25zXG4gICAgfTtcbiAgICBsZXQgaHlkcmF0ZTtcbiAgICBsZXQgaHlkcmF0ZU5vZGU7XG4gICAgaWYgKGNyZWF0ZUh5ZHJhdGlvbkZucykge1xuICAgICAgICBbaHlkcmF0ZSwgaHlkcmF0ZU5vZGVdID0gY3JlYXRlSHlkcmF0aW9uRm5zKGludGVybmFscyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJlbmRlcixcbiAgICAgICAgaHlkcmF0ZSxcbiAgICAgICAgY3JlYXRlQXBwOiBjcmVhdGVBcHBBUEkocmVuZGVyLCBoeWRyYXRlKVxuICAgIH07XG59XG5mdW5jdGlvbiB0b2dnbGVSZWN1cnNlKHsgZWZmZWN0LCB1cGRhdGUgfSwgYWxsb3dlZCkge1xuICAgIGVmZmVjdC5hbGxvd1JlY3Vyc2UgPSB1cGRhdGUuYWxsb3dSZWN1cnNlID0gYWxsb3dlZDtcbn1cbi8qKlxuICogIzExNTZcbiAqIFdoZW4gYSBjb21wb25lbnQgaXMgSE1SLWVuYWJsZWQsIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYWxsIHN0YXRpYyBub2Rlc1xuICogaW5zaWRlIGEgYmxvY2sgYWxzbyBpbmhlcml0IHRoZSBET00gZWxlbWVudCBmcm9tIHRoZSBwcmV2aW91cyB0cmVlIHNvIHRoYXRcbiAqIEhNUiB1cGRhdGVzICh3aGljaCBhcmUgZnVsbCB1cGRhdGVzKSBjYW4gcmV0cmlldmUgdGhlIGVsZW1lbnQgZm9yIHBhdGNoaW5nLlxuICpcbiAqICMyMDgwXG4gKiBJbnNpZGUga2V5ZWQgYHRlbXBsYXRlYCBmcmFnbWVudCBzdGF0aWMgY2hpbGRyZW4sIGlmIGEgZnJhZ21lbnQgaXMgbW92ZWQsXG4gKiB0aGUgY2hpbGRyZW4gd2lsbCBhbHdheXMgYmUgbW92ZWQuIFRoZXJlZm9yZSwgaW4gb3JkZXIgdG8gZW5zdXJlIGNvcnJlY3QgbW92ZVxuICogcG9zaXRpb24sIGVsIHNob3VsZCBiZSBpbmhlcml0ZWQgZnJvbSBwcmV2aW91cyBub2Rlcy5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIsIHNoYWxsb3cgPSBmYWxzZSkge1xuICAgIGNvbnN0IGNoMSA9IG4xLmNoaWxkcmVuO1xuICAgIGNvbnN0IGNoMiA9IG4yLmNoaWxkcmVuO1xuICAgIGlmIChpc0FycmF5KGNoMSkgJiYgaXNBcnJheShjaDIpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2gxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG9ubHkgY2FsbGVkIGluIHRoZSBvcHRpbWl6ZWQgcGF0aCBzbyBhcnJheSBjaGlsZHJlbiBhcmVcbiAgICAgICAgICAgIC8vIGd1YXJhbnRlZWQgdG8gYmUgdm5vZGVzXG4gICAgICAgICAgICBjb25zdCBjMSA9IGNoMVtpXTtcbiAgICAgICAgICAgIGxldCBjMiA9IGNoMltpXTtcbiAgICAgICAgICAgIGlmIChjMi5zaGFwZUZsYWcgJiAxIC8qIFNoYXBlRmxhZ3MuRUxFTUVOVCAqLyAmJiAhYzIuZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMyLnBhdGNoRmxhZyA8PSAwIHx8IGMyLnBhdGNoRmxhZyA9PT0gMzIgLyogUGF0Y2hGbGFncy5IWURSQVRFX0VWRU5UUyAqLykge1xuICAgICAgICAgICAgICAgICAgICBjMiA9IGNoMltpXSA9IGNsb25lSWZNb3VudGVkKGNoMltpXSk7XG4gICAgICAgICAgICAgICAgICAgIGMyLmVsID0gYzEuZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc2hhbGxvdylcbiAgICAgICAgICAgICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihjMSwgYzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gIzY4NTIgYWxzbyBpbmhlcml0IGZvciB0ZXh0IG5vZGVzXG4gICAgICAgICAgICBpZiAoYzIudHlwZSA9PT0gVGV4dCkge1xuICAgICAgICAgICAgICAgIGMyLmVsID0gYzEuZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhbHNvIGluaGVyaXQgZm9yIGNvbW1lbnQgbm9kZXMsIGJ1dCBub3QgcGxhY2Vob2xkZXJzIChlLmcuIHYtaWYgd2hpY2hcbiAgICAgICAgICAgIC8vIHdvdWxkIGhhdmUgcmVjZWl2ZWQgLmVsIGR1cmluZyBibG9jayBwYXRjaClcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgYzIudHlwZSA9PT0gQ29tbWVudCAmJiAhYzIuZWwpIHtcbiAgICAgICAgICAgICAgICBjMi5lbCA9IGMxLmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTG9uZ2VzdF9pbmNyZWFzaW5nX3N1YnNlcXVlbmNlXG5mdW5jdGlvbiBnZXRTZXF1ZW5jZShhcnIpIHtcbiAgICBjb25zdCBwID0gYXJyLnNsaWNlKCk7XG4gICAgY29uc3QgcmVzdWx0ID0gWzBdO1xuICAgIGxldCBpLCBqLCB1LCB2LCBjO1xuICAgIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyckkgPSBhcnJbaV07XG4gICAgICAgIGlmIChhcnJJICE9PSAwKSB7XG4gICAgICAgICAgICBqID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChhcnJbal0gPCBhcnJJKSB7XG4gICAgICAgICAgICAgICAgcFtpXSA9IGo7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1ID0gMDtcbiAgICAgICAgICAgIHYgPSByZXN1bHQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlICh1IDwgdikge1xuICAgICAgICAgICAgICAgIGMgPSAodSArIHYpID4+IDE7XG4gICAgICAgICAgICAgICAgaWYgKGFycltyZXN1bHRbY11dIDwgYXJySSkge1xuICAgICAgICAgICAgICAgICAgICB1ID0gYyArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2ID0gYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJySSA8IGFycltyZXN1bHRbdV1dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHBbaV0gPSByZXN1bHRbdSAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRbdV0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHUgPSByZXN1bHQubGVuZ3RoO1xuICAgIHYgPSByZXN1bHRbdSAtIDFdO1xuICAgIHdoaWxlICh1LS0gPiAwKSB7XG4gICAgICAgIHJlc3VsdFt1XSA9IHY7XG4gICAgICAgIHYgPSBwW3ZdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCBpc1RlbGVwb3J0ID0gKHR5cGUpID0+IHR5cGUuX19pc1RlbGVwb3J0O1xuY29uc3QgaXNUZWxlcG9ydERpc2FibGVkID0gKHByb3BzKSA9PiBwcm9wcyAmJiAocHJvcHMuZGlzYWJsZWQgfHwgcHJvcHMuZGlzYWJsZWQgPT09ICcnKTtcbmNvbnN0IGlzVGFyZ2V0U1ZHID0gKHRhcmdldCkgPT4gdHlwZW9mIFNWR0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQ7XG5jb25zdCByZXNvbHZlVGFyZ2V0ID0gKHByb3BzLCBzZWxlY3QpID0+IHtcbiAgICBjb25zdCB0YXJnZXRTZWxlY3RvciA9IHByb3BzICYmIHByb3BzLnRvO1xuICAgIGlmIChpc1N0cmluZyh0YXJnZXRTZWxlY3RvcikpIHtcbiAgICAgICAgaWYgKCFzZWxlY3QpIHtcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgICAgIHdhcm4oYEN1cnJlbnQgcmVuZGVyZXIgZG9lcyBub3Qgc3VwcG9ydCBzdHJpbmcgdGFyZ2V0IGZvciBUZWxlcG9ydHMuIGAgK1xuICAgICAgICAgICAgICAgICAgICBgKG1pc3NpbmcgcXVlcnlTZWxlY3RvciByZW5kZXJlciBvcHRpb24pYCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHNlbGVjdCh0YXJnZXRTZWxlY3Rvcik7XG4gICAgICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBGYWlsZWQgdG8gbG9jYXRlIFRlbGVwb3J0IHRhcmdldCB3aXRoIHNlbGVjdG9yIFwiJHt0YXJnZXRTZWxlY3Rvcn1cIi4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgTm90ZSB0aGUgdGFyZ2V0IGVsZW1lbnQgbXVzdCBleGlzdCBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkIC0gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgaS5lLiB0aGUgdGFyZ2V0IGNhbm5vdCBiZSByZW5kZXJlZCBieSB0aGUgY29tcG9uZW50IGl0c2VsZiwgYW5kIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGlkZWFsbHkgc2hvdWxkIGJlIG91dHNpZGUgb2YgdGhlIGVudGlyZSBWdWUgY29tcG9uZW50IHRyZWUuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICF0YXJnZXRTZWxlY3RvciAmJiAhaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xuICAgICAgICAgICAgd2FybihgSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQ6ICR7dGFyZ2V0U2VsZWN0b3J9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldFNlbGVjdG9yO1xuICAgIH1cbn07XG5jb25zdCBUZWxlcG9ydEltcGwgPSB7XG4gICAgX19pc1RlbGVwb3J0OiB0cnVlLFxuICAgIHByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBpbnRlcm5hbHMpIHtcbiAgICAgICAgY29uc3QgeyBtYzogbW91bnRDaGlsZHJlbiwgcGM6IHBhdGNoQ2hpbGRyZW4sIHBiYzogcGF0Y2hCbG9ja0NoaWxkcmVuLCBvOiB7IGluc2VydCwgcXVlcnlTZWxlY3RvciwgY3JlYXRlVGV4dCwgY3JlYXRlQ29tbWVudCB9IH0gPSBpbnRlcm5hbHM7XG4gICAgICAgIGNvbnN0IGRpc2FibGVkID0gaXNUZWxlcG9ydERpc2FibGVkKG4yLnByb3BzKTtcbiAgICAgICAgbGV0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiwgZHluYW1pY0NoaWxkcmVuIH0gPSBuMjtcbiAgICAgICAgLy8gIzMzMDJcbiAgICAgICAgLy8gSE1SIHVwZGF0ZWQsIGZvcmNlIGZ1bGwgZGlmZlxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGlzSG1yVXBkYXRpbmcpIHtcbiAgICAgICAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gaW5zZXJ0IGFuY2hvcnMgaW4gdGhlIG1haW4gdmlld1xuICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSAobjIuZWwgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcbiAgICAgICAgICAgICAgICA/IGNyZWF0ZUNvbW1lbnQoJ3RlbGVwb3J0IHN0YXJ0JylcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZVRleHQoJycpKTtcbiAgICAgICAgICAgIGNvbnN0IG1haW5BbmNob3IgPSAobjIuYW5jaG9yID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVDb21tZW50KCd0ZWxlcG9ydCBlbmQnKVxuICAgICAgICAgICAgICAgIDogY3JlYXRlVGV4dCgnJykpO1xuICAgICAgICAgICAgaW5zZXJ0KHBsYWNlaG9sZGVyLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgICAgICBpbnNlcnQobWFpbkFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gKG4yLnRhcmdldCA9IHJlc29sdmVUYXJnZXQobjIucHJvcHMsIHF1ZXJ5U2VsZWN0b3IpKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEFuY2hvciA9IChuMi50YXJnZXRBbmNob3IgPSBjcmVhdGVUZXh0KCcnKSk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0KHRhcmdldEFuY2hvciwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAvLyAjMjY1MiB3ZSBjb3VsZCBiZSB0ZWxlcG9ydGluZyBmcm9tIGEgbm9uLVNWRyB0cmVlIGludG8gYW4gU1ZHIHRyZWVcbiAgICAgICAgICAgICAgICBpc1NWRyA9IGlzU1ZHIHx8IGlzVGFyZ2V0U1ZHKHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQgb24gbW91bnQ6JywgdGFyZ2V0LCBgKCR7dHlwZW9mIHRhcmdldH0pYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtb3VudCA9IChjb250YWluZXIsIGFuY2hvcikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRlbGVwb3J0ICphbHdheXMqIGhhcyBBcnJheSBjaGlsZHJlbi4gVGhpcyBpcyBlbmZvcmNlZCBpbiBib3RoIHRoZVxuICAgICAgICAgICAgICAgIC8vIGNvbXBpbGVyIGFuZCB2bm9kZSBjaGlsZHJlbiBub3JtYWxpemF0aW9uLlxuICAgICAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNiAvKiBTaGFwZUZsYWdzLkFSUkFZX0NISUxEUkVOICovKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdW50Q2hpbGRyZW4oY2hpbGRyZW4sIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBtb3VudChjb250YWluZXIsIG1haW5BbmNob3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgbW91bnQodGFyZ2V0LCB0YXJnZXRBbmNob3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gdXBkYXRlIGNvbnRlbnRcbiAgICAgICAgICAgIG4yLmVsID0gbjEuZWw7XG4gICAgICAgICAgICBjb25zdCBtYWluQW5jaG9yID0gKG4yLmFuY2hvciA9IG4xLmFuY2hvcik7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAobjIudGFyZ2V0ID0gbjEudGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEFuY2hvciA9IChuMi50YXJnZXRBbmNob3IgPSBuMS50YXJnZXRBbmNob3IpO1xuICAgICAgICAgICAgY29uc3Qgd2FzRGlzYWJsZWQgPSBpc1RlbGVwb3J0RGlzYWJsZWQobjEucHJvcHMpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudENvbnRhaW5lciA9IHdhc0Rpc2FibGVkID8gY29udGFpbmVyIDogdGFyZ2V0O1xuICAgICAgICAgICAgY29uc3QgY3VycmVudEFuY2hvciA9IHdhc0Rpc2FibGVkID8gbWFpbkFuY2hvciA6IHRhcmdldEFuY2hvcjtcbiAgICAgICAgICAgIGlzU1ZHID0gaXNTVkcgfHwgaXNUYXJnZXRTVkcodGFyZ2V0KTtcbiAgICAgICAgICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBmYXN0IHBhdGggd2hlbiB0aGUgdGVsZXBvcnQgaGFwcGVucyB0byBiZSBhIGJsb2NrIHJvb3RcbiAgICAgICAgICAgICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4objEuZHluYW1pY0NoaWxkcmVuLCBkeW5hbWljQ2hpbGRyZW4sIGN1cnJlbnRDb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMpO1xuICAgICAgICAgICAgICAgIC8vIGV2ZW4gaW4gYmxvY2sgdHJlZSBtb2RlIHdlIG5lZWQgdG8gbWFrZSBzdXJlIGFsbCByb290LWxldmVsIG5vZGVzXG4gICAgICAgICAgICAgICAgLy8gaW4gdGhlIHRlbGVwb3J0IGluaGVyaXQgcHJldmlvdXMgRE9NIHJlZmVyZW5jZXMgc28gdGhhdCB0aGV5IGNhblxuICAgICAgICAgICAgICAgIC8vIGJlIG1vdmVkIGluIGZ1dHVyZSBwYXRjaGVzLlxuICAgICAgICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFvcHRpbWl6ZWQpIHtcbiAgICAgICAgICAgICAgICBwYXRjaENoaWxkcmVuKG4xLCBuMiwgY3VycmVudENvbnRhaW5lciwgY3VycmVudEFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF3YXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbmFibGVkIC0+IGRpc2FibGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgaW50byBtYWluIGNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICBtb3ZlVGVsZXBvcnQobjIsIGNvbnRhaW5lciwgbWFpbkFuY2hvciwgaW50ZXJuYWxzLCAxIC8qIFRlbGVwb3J0TW92ZVR5cGVzLlRPR0dMRSAqLyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGFyZ2V0IGNoYW5nZWRcbiAgICAgICAgICAgICAgICBpZiAoKG4yLnByb3BzICYmIG4yLnByb3BzLnRvKSAhPT0gKG4xLnByb3BzICYmIG4xLnByb3BzLnRvKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0VGFyZ2V0ID0gKG4yLnRhcmdldCA9IHJlc29sdmVUYXJnZXQobjIucHJvcHMsIHF1ZXJ5U2VsZWN0b3IpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVUZWxlcG9ydChuMiwgbmV4dFRhcmdldCwgbnVsbCwgaW50ZXJuYWxzLCAwIC8qIFRlbGVwb3J0TW92ZVR5cGVzLlRBUkdFVF9DSEFOR0UgKi8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQgb24gdXBkYXRlOicsIHRhcmdldCwgYCgke3R5cGVvZiB0YXJnZXR9KWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdhc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRpc2FibGVkIC0+IGVuYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBpbnRvIHRlbGVwb3J0IHRhcmdldFxuICAgICAgICAgICAgICAgICAgICBtb3ZlVGVsZXBvcnQobjIsIHRhcmdldCwgdGFyZ2V0QW5jaG9yLCBpbnRlcm5hbHMsIDEgLyogVGVsZXBvcnRNb3ZlVHlwZXMuVE9HR0xFICovKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlQ3NzVmFycyhuMik7XG4gICAgfSxcbiAgICByZW1vdmUodm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG9wdGltaXplZCwgeyB1bTogdW5tb3VudCwgbzogeyByZW1vdmU6IGhvc3RSZW1vdmUgfSB9LCBkb1JlbW92ZSkge1xuICAgICAgICBjb25zdCB7IHNoYXBlRmxhZywgY2hpbGRyZW4sIGFuY2hvciwgdGFyZ2V0QW5jaG9yLCB0YXJnZXQsIHByb3BzIH0gPSB2bm9kZTtcbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgaG9zdFJlbW92ZSh0YXJnZXRBbmNob3IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFuIHVubW91bnRlZCB0ZWxlcG9ydCBzaG91bGQgYWx3YXlzIHJlbW92ZSBpdHMgY2hpbGRyZW4gaWYgbm90IGRpc2FibGVkXG4gICAgICAgIGlmIChkb1JlbW92ZSB8fCAhaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xuICAgICAgICAgICAgaG9zdFJlbW92ZShhbmNob3IpO1xuICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIFNoYXBlRmxhZ3MuQVJSQVlfQ0hJTERSRU4gKi8pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgICAgIHVubW91bnQoY2hpbGQsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUsICEhY2hpbGQuZHluYW1pY0NoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1vdmU6IG1vdmVUZWxlcG9ydCxcbiAgICBoeWRyYXRlOiBoeWRyYXRlVGVsZXBvcnRcbn07XG5mdW5jdGlvbiBtb3ZlVGVsZXBvcnQodm5vZGUsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yLCB7IG86IHsgaW5zZXJ0IH0sIG06IG1vdmUgfSwgbW92ZVR5cGUgPSAyIC8qIFRlbGVwb3J0TW92ZVR5cGVzLlJFT1JERVIgKi8pIHtcbiAgICAvLyBtb3ZlIHRhcmdldCBhbmNob3IgaWYgdGhpcyBpcyBhIHRhcmdldCBjaGFuZ2UuXG4gICAgaWYgKG1vdmVUeXBlID09PSAwIC8qIFRlbGVwb3J0TW92ZVR5cGVzLlRBUkdFVF9DSEFOR0UgKi8pIHtcbiAgICAgICAgaW5zZXJ0KHZub2RlLnRhcmdldEFuY2hvciwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xuICAgIH1cbiAgICBjb25zdCB7IGVsLCBhbmNob3IsIHNoYXBlRmxhZywgY2hpbGRyZW4sIHByb3BzIH0gPSB2bm9kZTtcbiAgICBjb25zdCBpc1Jlb3JkZXIgPSBtb3ZlVHlwZSA9PT0gMiAvKiBUZWxlcG9ydE1vdmVUeXBlcy5SRU9SREVSICovO1xuICAgIC8vIG1vdmUgbWFpbiB2aWV3IGFuY2hvciBpZiB0aGlzIGlzIGEgcmUtb3JkZXIuXG4gICAgaWYgKGlzUmVvcmRlcikge1xuICAgICAgICBpbnNlcnQoZWwsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcbiAgICB9XG4gICAgLy8gaWYgdGhpcyBpcyBhIHJlLW9yZGVyIGFuZCB0ZWxlcG9ydCBpcyBlbmFibGVkIChjb250ZW50IGlzIGluIHRhcmdldClcbiAgICAvLyBkbyBub3QgbW92ZSBjaGlsZHJlbi4gU28gdGhlIG9wcG9zaXRlIGlzOiBvbmx5IG1vdmUgY2hpbGRyZW4gaWYgdGhpc1xuICAgIC8vIGlzIG5vdCBhIHJlb3JkZXIsIG9yIHRoZSB0ZWxlcG9ydCBpcyBkaXNhYmxlZFxuICAgIGlmICghaXNSZW9yZGVyIHx8IGlzVGVsZXBvcnREaXNhYmxlZChwcm9wcykpIHtcbiAgICAgICAgLy8gVGVsZXBvcnQgaGFzIGVpdGhlciBBcnJheSBjaGlsZHJlbiBvciBubyBjaGlsZHJlbi5cbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIFNoYXBlRmxhZ3MuQVJSQVlfQ0hJTERSRU4gKi8pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtb3ZlKGNoaWxkcmVuW2ldLCBjb250YWluZXIsIHBhcmVudEFuY2hvciwgMiAvKiBNb3ZlVHlwZS5SRU9SREVSICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBtb3ZlIG1haW4gdmlldyBhbmNob3IgaWYgdGhpcyBpcyBhIHJlLW9yZGVyLlxuICAgIGlmIChpc1Jlb3JkZXIpIHtcbiAgICAgICAgaW5zZXJ0KGFuY2hvciwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGh5ZHJhdGVUZWxlcG9ydChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHsgbzogeyBuZXh0U2libGluZywgcGFyZW50Tm9kZSwgcXVlcnlTZWxlY3RvciB9IH0sIGh5ZHJhdGVDaGlsZHJlbikge1xuICAgIGNvbnN0IHRhcmdldCA9ICh2bm9kZS50YXJnZXQgPSByZXNvbHZlVGFyZ2V0KHZub2RlLnByb3BzLCBxdWVyeVNlbGVjdG9yKSk7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgICAvLyBpZiBtdWx0aXBsZSB0ZWxlcG9ydHMgcmVuZGVyZWQgdG8gdGhlIHNhbWUgdGFyZ2V0IGVsZW1lbnQsIHdlIG5lZWQgdG9cbiAgICAgICAgLy8gcGljayB1cCBmcm9tIHdoZXJlIHRoZSBsYXN0IHRlbGVwb3J0IGZpbmlzaGVkIGluc3RlYWQgb2YgdGhlIGZpcnN0IG5vZGVcbiAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHRhcmdldC5fbHBhIHx8IHRhcmdldC5maXJzdENoaWxkO1xuICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTYgLyogU2hhcGVGbGFncy5BUlJBWV9DSElMRFJFTiAqLykge1xuICAgICAgICAgICAgaWYgKGlzVGVsZXBvcnREaXNhYmxlZCh2bm9kZS5wcm9wcykpIHtcbiAgICAgICAgICAgICAgICB2bm9kZS5hbmNob3IgPSBoeWRyYXRlQ2hpbGRyZW4obmV4dFNpYmxpbmcobm9kZSksIHZub2RlLCBwYXJlbnROb2RlKG5vZGUpLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgdm5vZGUudGFyZ2V0QW5jaG9yID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZub2RlLmFuY2hvciA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICAgICAgICAgIC8vIGxvb2thaGVhZCB1bnRpbCB3ZSBmaW5kIHRoZSB0YXJnZXQgYW5jaG9yXG4gICAgICAgICAgICAgICAgLy8gd2UgY2Fubm90IHJlbHkgb24gcmV0dXJuIHZhbHVlIG9mIGh5ZHJhdGVDaGlsZHJlbigpIGJlY2F1c2UgdGhlcmVcbiAgICAgICAgICAgICAgICAvLyBjb3VsZCBiZSBuZXN0ZWQgdGVsZXBvcnRzXG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldEFuY2hvciA9IHRhcmdldE5vZGU7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRhcmdldEFuY2hvcikge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRBbmNob3IgPSBuZXh0U2libGluZyh0YXJnZXRBbmNob3IpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0QW5jaG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRBbmNob3Iubm9kZVR5cGUgPT09IDggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEFuY2hvci5kYXRhID09PSAndGVsZXBvcnQgYW5jaG9yJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdm5vZGUudGFyZ2V0QW5jaG9yID0gdGFyZ2V0QW5jaG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Ll9scGEgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlLnRhcmdldEFuY2hvciAmJiBuZXh0U2libGluZyh2bm9kZS50YXJnZXRBbmNob3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaHlkcmF0ZUNoaWxkcmVuKHRhcmdldE5vZGUsIHZub2RlLCB0YXJnZXQsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVDc3NWYXJzKHZub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlLmFuY2hvciAmJiBuZXh0U2libGluZyh2bm9kZS5hbmNob3IpO1xufVxuLy8gRm9yY2UtY2FzdGVkIHB1YmxpYyB0eXBpbmcgZm9yIGggYW5kIFRTWCBwcm9wcyBpbmZlcmVuY2VcbmNvbnN0IFRlbGVwb3J0ID0gVGVsZXBvcnRJbXBsO1xuZnVuY3Rpb24gdXBkYXRlQ3NzVmFycyh2bm9kZSkge1xuICAgIC8vIHByZXNlbmNlIG9mIC51dCBtZXRob2QgaW5kaWNhdGVzIG93bmVyIGNvbXBvbmVudCB1c2VzIGNzcyB2YXJzLlxuICAgIC8vIGNvZGUgcGF0aCBoZXJlIGNhbiBhc3N1bWUgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAgICBjb25zdCBjdHggPSB2bm9kZS5jdHg7XG4gICAgaWYgKGN0eCAmJiBjdHgudXQpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB2bm9kZS5jaGlsZHJlblswXS5lbDtcbiAgICAgICAgd2hpbGUgKG5vZGUgIT09IHZub2RlLnRhcmdldEFuY2hvcikge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpXG4gICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtdi1vd25lcicsIGN0eC51aWQpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnV0KCk7XG4gICAgfVxufVxuXG5jb25zdCBGcmFnbWVudCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnRnJhZ21lbnQnIDogdW5kZWZpbmVkKTtcbmNvbnN0IFRleHQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ1RleHQnIDogdW5kZWZpbmVkKTtcbmNvbnN0IENvbW1lbnQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ0NvbW1lbnQnIDogdW5kZWZpbmVkKTtcbmNvbnN0IFN0YXRpYyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnU3RhdGljJyA6IHVuZGVmaW5lZCk7XG4vLyBTaW5jZSB2LWlmIGFuZCB2LWZvciBhcmUgdGhlIHR3byBwb3NzaWJsZSB3YXlzIG5vZGUgc3RydWN0dXJlIGNhbiBkeW5hbWljYWxseVxuLy8gY2hhbmdlLCBvbmNlIHdlIGNvbnNpZGVyIHYtaWYgYnJhbmNoZXMgYW5kIGVhY2ggdi1mb3IgZnJhZ21lbnQgYSBibG9jaywgd2Vcbi8vIGNhbiBkaXZpZGUgYSB0ZW1wbGF0ZSBpbnRvIG5lc3RlZCBibG9ja3MsIGFuZCB3aXRoaW4gZWFjaCBibG9jayB0aGUgbm9kZVxuLy8gc3RydWN0dXJlIHdvdWxkIGJlIHN0YWJsZS4gVGhpcyBhbGxvd3MgdXMgdG8gc2tpcCBtb3N0IGNoaWxkcmVuIGRpZmZpbmdcbi8vIGFuZCBvbmx5IHdvcnJ5IGFib3V0IHRoZSBkeW5hbWljIG5vZGVzIChpbmRpY2F0ZWQgYnkgcGF0Y2ggZmxhZ3MpLlxuY29uc3QgYmxvY2tTdGFjayA9IFtdO1xubGV0IGN1cnJlbnRCbG9jayA9IG51bGw7XG4vKipcbiAqIE9wZW4gYSBibG9jay5cbiAqIFRoaXMgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGBjcmVhdGVCbG9ja2AuIEl0IGNhbm5vdCBiZSBwYXJ0IG9mIGBjcmVhdGVCbG9ja2BcbiAqIGJlY2F1c2UgdGhlIGNoaWxkcmVuIG9mIHRoZSBibG9jayBhcmUgZXZhbHVhdGVkIGJlZm9yZSBgY3JlYXRlQmxvY2tgIGl0c2VsZlxuICogaXMgY2FsbGVkLiBUaGUgZ2VuZXJhdGVkIGNvZGUgdHlwaWNhbGx5IGxvb2tzIGxpa2UgdGhpczpcbiAqXG4gKiBgYGBqc1xuICogZnVuY3Rpb24gcmVuZGVyKCkge1xuICogICByZXR1cm4gKG9wZW5CbG9jaygpLGNyZWF0ZUJsb2NrKCdkaXYnLCBudWxsLCBbLi4uXSkpXG4gKiB9XG4gKiBgYGBcbiAqIGRpc2FibGVUcmFja2luZyBpcyB0cnVlIHdoZW4gY3JlYXRpbmcgYSB2LWZvciBmcmFnbWVudCBibG9jaywgc2luY2UgYSB2LWZvclxuICogZnJhZ21lbnQgYWx3YXlzIGRpZmZzIGl0cyBjaGlsZHJlbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBvcGVuQmxvY2soZGlzYWJsZVRyYWNraW5nID0gZmFsc2UpIHtcbiAgICBibG9ja1N0YWNrLnB1c2goKGN1cnJlbnRCbG9jayA9IGRpc2FibGVUcmFja2luZyA/IG51bGwgOiBbXSkpO1xufVxuZnVuY3Rpb24gY2xvc2VCbG9jaygpIHtcbiAgICBibG9ja1N0YWNrLnBvcCgpO1xuICAgIGN1cnJlbnRCbG9jayA9IGJsb2NrU3RhY2tbYmxvY2tTdGFjay5sZW5ndGggLSAxXSB8fCBudWxsO1xufVxuLy8gV2hldGhlciB3ZSBzaG91bGQgYmUgdHJhY2tpbmcgZHluYW1pYyBjaGlsZCBub2RlcyBpbnNpZGUgYSBibG9jay5cbi8vIE9ubHkgdHJhY2tzIHdoZW4gdGhpcyB2YWx1ZSBpcyA+IDBcbi8vIFdlIGFyZSBub3QgdXNpbmcgYSBzaW1wbGUgYm9vbGVhbiBiZWNhdXNlIHRoaXMgdmFsdWUgbWF5IG5lZWQgdG8gYmVcbi8vIGluY3JlbWVudGVkL2RlY3JlbWVudGVkIGJ5IG5lc3RlZCB1c2FnZSBvZiB2LW9uY2UgKHNlZSBiZWxvdylcbmxldCBpc0Jsb2NrVHJlZUVuYWJsZWQgPSAxO1xuLyoqXG4gKiBCbG9jayB0cmFja2luZyBzb21ldGltZXMgbmVlZHMgdG8gYmUgZGlzYWJsZWQsIGZvciBleGFtcGxlIGR1cmluZyB0aGVcbiAqIGNyZWF0aW9uIG9mIGEgdHJlZSB0aGF0IG5lZWRzIHRvIGJlIGNhY2hlZCBieSB2LW9uY2UuIFRoZSBjb21waWxlciBnZW5lcmF0ZXNcbiAqIGNvZGUgbGlrZSB0aGlzOlxuICpcbiAqIGBgYCBqc1xuICogX2NhY2hlWzFdIHx8IChcbiAqICAgc2V0QmxvY2tUcmFja2luZygtMSksXG4gKiAgIF9jYWNoZVsxXSA9IGNyZWF0ZVZOb2RlKC4uLiksXG4gKiAgIHNldEJsb2NrVHJhY2tpbmcoMSksXG4gKiAgIF9jYWNoZVsxXVxuICogKVxuICogYGBgXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0QmxvY2tUcmFja2luZyh2YWx1ZSkge1xuICAgIGlzQmxvY2tUcmVlRW5hYmxlZCArPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHNldHVwQmxvY2sodm5vZGUpIHtcbiAgICAvLyBzYXZlIGN1cnJlbnQgYmxvY2sgY2hpbGRyZW4gb24gdGhlIGJsb2NrIHZub2RlXG4gICAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID1cbiAgICAgICAgaXNCbG9ja1RyZWVFbmFibGVkID4gMCA/IGN1cnJlbnRCbG9jayB8fCBFTVBUWV9BUlIgOiBudWxsO1xuICAgIC8vIGNsb3NlIGJsb2NrXG4gICAgY2xvc2VCbG9jaygpO1xuICAgIC8vIGEgYmxvY2sgaXMgYWx3YXlzIGdvaW5nIHRvIGJlIHBhdGNoZWQsIHNvIHRyYWNrIGl0IGFzIGEgY2hpbGQgb2YgaXRzXG4gICAgLy8gcGFyZW50IGJsb2NrXG4gICAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiYgY3VycmVudEJsb2NrKSB7XG4gICAgICAgIGN1cnJlbnRCbG9jay5wdXNoKHZub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50QmxvY2sodHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcywgc2hhcGVGbGFnKSB7XG4gICAgcmV0dXJuIHNldHVwQmxvY2soY3JlYXRlQmFzZVZOb2RlKHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMsIHNoYXBlRmxhZywgdHJ1ZSAvKiBpc0Jsb2NrICovKSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIGJsb2NrIHJvb3Qgdm5vZGUuIFRha2VzIHRoZSBzYW1lIGV4YWN0IGFyZ3VtZW50cyBhcyBgY3JlYXRlVk5vZGVgLlxuICogQSBibG9jayByb290IGtlZXBzIHRyYWNrIG9mIGR5bmFtaWMgbm9kZXMgd2l0aGluIHRoZSBibG9jayBpbiB0aGVcbiAqIGBkeW5hbWljQ2hpbGRyZW5gIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrKHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMpIHtcbiAgICByZXR1cm4gc2V0dXBCbG9jayhjcmVhdGVWTm9kZSh0eXBlLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzLCB0cnVlIC8qIGlzQmxvY2s6IHByZXZlbnQgYSBibG9jayBmcm9tIHRyYWNraW5nIGl0c2VsZiAqLykpO1xufVxuZnVuY3Rpb24gaXNWTm9kZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA/IHZhbHVlLl9fdl9pc1ZOb2RlID09PSB0cnVlIDogZmFsc2U7XG59XG5mdW5jdGlvbiBpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSB7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICBuMi5zaGFwZUZsYWcgJiA2IC8qIFNoYXBlRmxhZ3MuQ09NUE9ORU5UICovICYmXG4gICAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5oYXMobjIudHlwZSkpIHtcbiAgICAgICAgLy8gIzcwNDIsIGVuc3VyZSB0aGUgdm5vZGUgYmVpbmcgdW5tb3VudGVkIGR1cmluZyBITVJcbiAgICAgICAgLy8gYml0d2lzZSBvcGVyYXRpb25zIHRvIHJlbW92ZSBrZWVwIGFsaXZlIGZsYWdzXG4gICAgICAgIG4xLnNoYXBlRmxhZyAmPSB+MjU2IC8qIFNoYXBlRmxhZ3MuQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFICovO1xuICAgICAgICBuMi5zaGFwZUZsYWcgJj0gfjUxMiAvKiBTaGFwZUZsYWdzLkNPTVBPTkVOVF9LRVBUX0FMSVZFICovO1xuICAgICAgICAvLyBITVIgb25seTogaWYgdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBob3QtdXBkYXRlZCwgZm9yY2UgYSByZWxvYWQuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG4xLnR5cGUgPT09IG4yLnR5cGUgJiYgbjEua2V5ID09PSBuMi5rZXk7XG59XG5sZXQgdm5vZGVBcmdzVHJhbnNmb3JtZXI7XG4vKipcbiAqIEludGVybmFsIEFQSSBmb3IgcmVnaXN0ZXJpbmcgYW4gYXJndW1lbnRzIHRyYW5zZm9ybSBmb3IgY3JlYXRlVk5vZGVcbiAqIHVzZWQgZm9yIGNyZWF0aW5nIHN0dWJzIGluIHRoZSB0ZXN0LXV0aWxzXG4gKiBJdCBpcyAqaW50ZXJuYWwqIGJ1dCBuZWVkcyB0byBiZSBleHBvc2VkIGZvciB0ZXN0LXV0aWxzIHRvIHBpY2sgdXAgcHJvcGVyXG4gKiB0eXBpbmdzXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybVZOb2RlQXJncyh0cmFuc2Zvcm1lcikge1xuICAgIHZub2RlQXJnc1RyYW5zZm9ybWVyID0gdHJhbnNmb3JtZXI7XG59XG5jb25zdCBjcmVhdGVWTm9kZVdpdGhBcmdzVHJhbnNmb3JtID0gKC4uLmFyZ3MpID0+IHtcbiAgICByZXR1cm4gX2NyZWF0ZVZOb2RlKC4uLih2bm9kZUFyZ3NUcmFuc2Zvcm1lclxuICAgICAgICA/IHZub2RlQXJnc1RyYW5zZm9ybWVyKGFyZ3MsIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSlcbiAgICAgICAgOiBhcmdzKSk7XG59O1xuY29uc3QgSW50ZXJuYWxPYmplY3RLZXkgPSBgX192SW50ZXJuYWxgO1xuY29uc3Qgbm9ybWFsaXplS2V5ID0gKHsga2V5IH0pID0+IGtleSAhPSBudWxsID8ga2V5IDogbnVsbDtcbmNvbnN0IG5vcm1hbGl6ZVJlZiA9ICh7IHJlZiwgcmVmX2tleSwgcmVmX2ZvciB9KSA9PiB7XG4gICAgcmV0dXJuIChyZWYgIT0gbnVsbFxuICAgICAgICA/IGlzU3RyaW5nKHJlZikgfHwgaXNSZWYocmVmKSB8fCBpc0Z1bmN0aW9uKHJlZilcbiAgICAgICAgICAgID8geyBpOiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UsIHI6IHJlZiwgazogcmVmX2tleSwgZjogISFyZWZfZm9yIH1cbiAgICAgICAgICAgIDogcmVmXG4gICAgICAgIDogbnVsbCk7XG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVZOb2RlKHR5cGUsIHByb3BzID0gbnVsbCwgY2hpbGRyZW4gPSBudWxsLCBwYXRjaEZsYWcgPSAwLCBkeW5hbWljUHJvcHMgPSBudWxsLCBzaGFwZUZsYWcgPSB0eXBlID09PSBGcmFnbWVudCA/IDAgOiAxIC8qIFNoYXBlRmxhZ3MuRUxFTUVOVCAqLywgaXNCbG9ja05vZGUgPSBmYWxzZSwgbmVlZEZ1bGxDaGlsZHJlbk5vcm1hbGl6YXRpb24gPSBmYWxzZSkge1xuICAgIGNvbnN0IHZub2RlID0ge1xuICAgICAgICBfX3ZfaXNWTm9kZTogdHJ1ZSxcbiAgICAgICAgX192X3NraXA6IHRydWUsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHByb3BzLFxuICAgICAgICBrZXk6IHByb3BzICYmIG5vcm1hbGl6ZUtleShwcm9wcyksXG4gICAgICAgIHJlZjogcHJvcHMgJiYgbm9ybWFsaXplUmVmKHByb3BzKSxcbiAgICAgICAgc2NvcGVJZDogY3VycmVudFNjb3BlSWQsXG4gICAgICAgIHNsb3RTY29wZUlkczogbnVsbCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIGNvbXBvbmVudDogbnVsbCxcbiAgICAgICAgc3VzcGVuc2U6IG51bGwsXG4gICAgICAgIHNzQ29udGVudDogbnVsbCxcbiAgICAgICAgc3NGYWxsYmFjazogbnVsbCxcbiAgICAgICAgZGlyczogbnVsbCxcbiAgICAgICAgdHJhbnNpdGlvbjogbnVsbCxcbiAgICAgICAgZWw6IG51bGwsXG4gICAgICAgIGFuY2hvcjogbnVsbCxcbiAgICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgICB0YXJnZXRBbmNob3I6IG51bGwsXG4gICAgICAgIHN0YXRpY0NvdW50OiAwLFxuICAgICAgICBzaGFwZUZsYWcsXG4gICAgICAgIHBhdGNoRmxhZyxcbiAgICAgICAgZHluYW1pY1Byb3BzLFxuICAgICAgICBkeW5hbWljQ2hpbGRyZW46IG51bGwsXG4gICAgICAgIGFwcENvbnRleHQ6IG51bGwsXG4gICAgICAgIGN0eDogY3VycmVudFJlbmRlcmluZ0luc3RhbmNlXG4gICAgfTtcbiAgICBpZiAobmVlZEZ1bGxDaGlsZHJlbk5vcm1hbGl6YXRpb24pIHtcbiAgICAgICAgbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuKTtcbiAgICAgICAgLy8gbm9ybWFsaXplIHN1c3BlbnNlIGNoaWxkcmVuXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxMjggLyogU2hhcGVGbGFncy5TVVNQRU5TRSAqLykge1xuICAgICAgICAgICAgdHlwZS5ub3JtYWxpemUodm5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgIC8vIGNvbXBpbGVkIGVsZW1lbnQgdm5vZGUgLSBpZiBjaGlsZHJlbiBpcyBwYXNzZWQsIG9ubHkgcG9zc2libGUgdHlwZXMgYXJlXG4gICAgICAgIC8vIHN0cmluZyBvciBBcnJheS5cbiAgICAgICAgdm5vZGUuc2hhcGVGbGFnIHw9IGlzU3RyaW5nKGNoaWxkcmVuKVxuICAgICAgICAgICAgPyA4IC8qIFNoYXBlRmxhZ3MuVEVYVF9DSElMRFJFTiAqL1xuICAgICAgICAgICAgOiAxNiAvKiBTaGFwZUZsYWdzLkFSUkFZX0NISUxEUkVOICovO1xuICAgIH1cbiAgICAvLyB2YWxpZGF0ZSBrZXlcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHZub2RlLmtleSAhPT0gdm5vZGUua2V5KSB7XG4gICAgICAgIHdhcm4oYFZOb2RlIGNyZWF0ZWQgd2l0aCBpbnZhbGlkIGtleSAoTmFOKS4gVk5vZGUgdHlwZTpgLCB2bm9kZS50eXBlKTtcbiAgICB9XG4gICAgLy8gdHJhY2sgdm5vZGUgZm9yIGJsb2NrIHRyZWVcbiAgICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJlxuICAgICAgICAvLyBhdm9pZCBhIGJsb2NrIG5vZGUgZnJvbSB0cmFja2luZyBpdHNlbGZcbiAgICAgICAgIWlzQmxvY2tOb2RlICYmXG4gICAgICAgIC8vIGhhcyBjdXJyZW50IHBhcmVudCBibG9ja1xuICAgICAgICBjdXJyZW50QmxvY2sgJiZcbiAgICAgICAgLy8gcHJlc2VuY2Ugb2YgYSBwYXRjaCBmbGFnIGluZGljYXRlcyB0aGlzIG5vZGUgbmVlZHMgcGF0Y2hpbmcgb24gdXBkYXRlcy5cbiAgICAgICAgLy8gY29tcG9uZW50IG5vZGVzIGFsc28gc2hvdWxkIGFsd2F5cyBiZSBwYXRjaGVkLCBiZWNhdXNlIGV2ZW4gaWYgdGhlXG4gICAgICAgIC8vIGNvbXBvbmVudCBkb2Vzbid0IG5lZWQgdG8gdXBkYXRlLCBpdCBuZWVkcyB0byBwZXJzaXN0IHRoZSBpbnN0YW5jZSBvbiB0b1xuICAgICAgICAvLyB0aGUgbmV4dCB2bm9kZSBzbyB0aGF0IGl0IGNhbiBiZSBwcm9wZXJseSB1bm1vdW50ZWQgbGF0ZXIuXG4gICAgICAgICh2bm9kZS5wYXRjaEZsYWcgPiAwIHx8IHNoYXBlRmxhZyAmIDYgLyogU2hhcGVGbGFncy5DT01QT05FTlQgKi8pICYmXG4gICAgICAgIC8vIHRoZSBFVkVOVFMgZmxhZyBpcyBvbmx5IGZvciBoeWRyYXRpb24gYW5kIGlmIGl0IGlzIHRoZSBvbmx5IGZsYWcsIHRoZVxuICAgICAgICAvLyB2bm9kZSBzaG91bGQgbm90IGJlIGNvbnNpZGVyZWQgZHluYW1pYyBkdWUgdG8gaGFuZGxlciBjYWNoaW5nLlxuICAgICAgICB2bm9kZS5wYXRjaEZsYWcgIT09IDMyIC8qIFBhdGNoRmxhZ3MuSFlEUkFURV9FVkVOVFMgKi8pIHtcbiAgICAgICAgY3VycmVudEJsb2NrLnB1c2godm5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGU7XG59XG5jb25zdCBjcmVhdGVWTm9kZSA9ICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBjcmVhdGVWTm9kZVdpdGhBcmdzVHJhbnNmb3JtIDogX2NyZWF0ZVZOb2RlKTtcbmZ1bmN0aW9uIF9jcmVhdGVWTm9kZSh0eXBlLCBwcm9wcyA9IG51bGwsIGNoaWxkcmVuID0gbnVsbCwgcGF0Y2hGbGFnID0gMCwgZHluYW1pY1Byb3BzID0gbnVsbCwgaXNCbG9ja05vZGUgPSBmYWxzZSkge1xuICAgIGlmICghdHlwZSB8fCB0eXBlID09PSBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UKSB7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIXR5cGUpIHtcbiAgICAgICAgICAgIHdhcm4oYEludmFsaWQgdm5vZGUgdHlwZSB3aGVuIGNyZWF0aW5nIHZub2RlOiAke3R5cGV9LmApO1xuICAgICAgICB9XG4gICAgICAgIHR5cGUgPSBDb21tZW50O1xuICAgIH1cbiAgICBpZiAoaXNWTm9kZSh0eXBlKSkge1xuICAgICAgICAvLyBjcmVhdGVWTm9kZSByZWNlaXZpbmcgYW4gZXhpc3Rpbmcgdm5vZGUuIFRoaXMgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAgIC8vIDxjb21wb25lbnQgOmlzPVwidm5vZGVcIi8+XG4gICAgICAgIC8vICMyMDc4IG1ha2Ugc3VyZSB0byBtZXJnZSByZWZzIGR1cmluZyB0aGUgY2xvbmUgaW5zdGVhZCBvZiBvdmVyd3JpdGluZyBpdFxuICAgICAgICBjb25zdCBjbG9uZWQgPSBjbG9uZVZOb2RlKHR5cGUsIHByb3BzLCB0cnVlIC8qIG1lcmdlUmVmOiB0cnVlICovKTtcbiAgICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBub3JtYWxpemVDaGlsZHJlbihjbG9uZWQsIGNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiAhaXNCbG9ja05vZGUgJiYgY3VycmVudEJsb2NrKSB7XG4gICAgICAgICAgICBpZiAoY2xvbmVkLnNoYXBlRmxhZyAmIDYgLyogU2hhcGVGbGFncy5DT01QT05FTlQgKi8pIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50QmxvY2tbY3VycmVudEJsb2NrLmluZGV4T2YodHlwZSldID0gY2xvbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJsb2NrLnB1c2goY2xvbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjbG9uZWQucGF0Y2hGbGFnIHw9IC0yIC8qIFBhdGNoRmxhZ3MuQkFJTCAqLztcbiAgICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9XG4gICAgLy8gY2xhc3MgY29tcG9uZW50IG5vcm1hbGl6YXRpb24uXG4gICAgaWYgKGlzQ2xhc3NDb21wb25lbnQodHlwZSkpIHtcbiAgICAgICAgdHlwZSA9IHR5cGUuX192Y2NPcHRzO1xuICAgIH1cbiAgICAvLyBjbGFzcyAmIHN0eWxlIG5vcm1hbGl6YXRpb24uXG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIC8vIGZvciByZWFjdGl2ZSBvciBwcm94eSBvYmplY3RzLCB3ZSBuZWVkIHRvIGNsb25lIGl0IHRvIGVuYWJsZSBtdXRhdGlvbi5cbiAgICAgICAgcHJvcHMgPSBndWFyZFJlYWN0aXZlUHJvcHMocHJvcHMpO1xuICAgICAgICBsZXQgeyBjbGFzczoga2xhc3MsIHN0eWxlIH0gPSBwcm9wcztcbiAgICAgICAgaWYgKGtsYXNzICYmICFpc1N0cmluZyhrbGFzcykpIHtcbiAgICAgICAgICAgIHByb3BzLmNsYXNzID0gbm9ybWFsaXplQ2xhc3Moa2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc09iamVjdChzdHlsZSkpIHtcbiAgICAgICAgICAgIC8vIHJlYWN0aXZlIHN0YXRlIG9iamVjdHMgbmVlZCB0byBiZSBjbG9uZWQgc2luY2UgdGhleSBhcmUgbGlrZWx5IHRvIGJlXG4gICAgICAgICAgICAvLyBtdXRhdGVkXG4gICAgICAgICAgICBpZiAoaXNQcm94eShzdHlsZSkgJiYgIWlzQXJyYXkoc3R5bGUpKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUgPSBleHRlbmQoe30sIHN0eWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3BzLnN0eWxlID0gbm9ybWFsaXplU3R5bGUoc3R5bGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVuY29kZSB0aGUgdm5vZGUgdHlwZSBpbmZvcm1hdGlvbiBpbnRvIGEgYml0bWFwXG4gICAgY29uc3Qgc2hhcGVGbGFnID0gaXNTdHJpbmcodHlwZSlcbiAgICAgICAgPyAxIC8qIFNoYXBlRmxhZ3MuRUxFTUVOVCAqL1xuICAgICAgICA6IGlzU3VzcGVuc2UodHlwZSlcbiAgICAgICAgICAgID8gMTI4IC8qIFNoYXBlRmxhZ3MuU1VTUEVOU0UgKi9cbiAgICAgICAgICAgIDogaXNUZWxlcG9ydCh0eXBlKVxuICAgICAgICAgICAgICAgID8gNjQgLyogU2hhcGVGbGFncy5URUxFUE9SVCAqL1xuICAgICAgICAgICAgICAgIDogaXNPYmplY3QodHlwZSlcbiAgICAgICAgICAgICAgICAgICAgPyA0IC8qIFNoYXBlRmxhZ3MuU1RBVEVGVUxfQ09NUE9ORU5UICovXG4gICAgICAgICAgICAgICAgICAgIDogaXNGdW5jdGlvbih0eXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAyIC8qIFNoYXBlRmxhZ3MuRlVOQ1RJT05BTF9DT01QT05FTlQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIDogMDtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHNoYXBlRmxhZyAmIDQgLyogU2hhcGVGbGFncy5TVEFURUZVTF9DT01QT05FTlQgKi8gJiYgaXNQcm94eSh0eXBlKSkge1xuICAgICAgICB0eXBlID0gdG9SYXcodHlwZSk7XG4gICAgICAgIHdhcm4oYFZ1ZSByZWNlaXZlZCBhIENvbXBvbmVudCB3aGljaCB3YXMgbWFkZSBhIHJlYWN0aXZlIG9iamVjdC4gVGhpcyBjYW4gYCArXG4gICAgICAgICAgICBgbGVhZCB0byB1bm5lY2Vzc2FyeSBwZXJmb3JtYW5jZSBvdmVyaGVhZCwgYW5kIHNob3VsZCBiZSBhdm9pZGVkIGJ5IGAgK1xuICAgICAgICAgICAgYG1hcmtpbmcgdGhlIGNvbXBvbmVudCB3aXRoIFxcYG1hcmtSYXdcXGAgb3IgdXNpbmcgXFxgc2hhbGxvd1JlZlxcYCBgICtcbiAgICAgICAgICAgIGBpbnN0ZWFkIG9mIFxcYHJlZlxcYC5gLCBgXFxuQ29tcG9uZW50IHRoYXQgd2FzIG1hZGUgcmVhY3RpdmU6IGAsIHR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQmFzZVZOb2RlKHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMsIHNoYXBlRmxhZywgaXNCbG9ja05vZGUsIHRydWUpO1xufVxuZnVuY3Rpb24gZ3VhcmRSZWFjdGl2ZVByb3BzKHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGlzUHJveHkocHJvcHMpIHx8IEludGVybmFsT2JqZWN0S2V5IGluIHByb3BzXG4gICAgICAgID8gZXh0ZW5kKHt9LCBwcm9wcylcbiAgICAgICAgOiBwcm9wcztcbn1cbmZ1bmN0aW9uIGNsb25lVk5vZGUodm5vZGUsIGV4dHJhUHJvcHMsIG1lcmdlUmVmID0gZmFsc2UpIHtcbiAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgTk9UIHVzaW5nIHNwcmVhZCBvciBleHRlbmQgdG8gYXZvaWQgdGhlIHJ1bnRpbWVcbiAgICAvLyBrZXkgZW51bWVyYXRpb24gY29zdC5cbiAgICBjb25zdCB7IHByb3BzLCByZWYsIHBhdGNoRmxhZywgY2hpbGRyZW4gfSA9IHZub2RlO1xuICAgIGNvbnN0IG1lcmdlZFByb3BzID0gZXh0cmFQcm9wcyA/IG1lcmdlUHJvcHMocHJvcHMgfHwge30sIGV4dHJhUHJvcHMpIDogcHJvcHM7XG4gICAgY29uc3QgY2xvbmVkID0ge1xuICAgICAgICBfX3ZfaXNWTm9kZTogdHJ1ZSxcbiAgICAgICAgX192X3NraXA6IHRydWUsXG4gICAgICAgIHR5cGU6IHZub2RlLnR5cGUsXG4gICAgICAgIHByb3BzOiBtZXJnZWRQcm9wcyxcbiAgICAgICAga2V5OiBtZXJnZWRQcm9wcyAmJiBub3JtYWxpemVLZXkobWVyZ2VkUHJvcHMpLFxuICAgICAgICByZWY6IGV4dHJhUHJvcHMgJiYgZXh0cmFQcm9wcy5yZWZcbiAgICAgICAgICAgID8gLy8gIzIwNzggaW4gdGhlIGNhc2Ugb2YgPGNvbXBvbmVudCA6aXM9XCJ2bm9kZVwiIHJlZj1cImV4dHJhXCIvPlxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSB2bm9kZSBpdHNlbGYgYWxyZWFkeSBoYXMgYSByZWYsIGNsb25lVk5vZGUgd2lsbCBuZWVkIHRvIG1lcmdlXG4gICAgICAgICAgICAgICAgLy8gdGhlIHJlZnMgc28gdGhlIHNpbmdsZSB2bm9kZSBjYW4gYmUgc2V0IG9uIG11bHRpcGxlIHJlZnNcbiAgICAgICAgICAgICAgICBtZXJnZVJlZiAmJiByZWZcbiAgICAgICAgICAgICAgICAgICAgPyBpc0FycmF5KHJlZilcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVmLmNvbmNhdChub3JtYWxpemVSZWYoZXh0cmFQcm9wcykpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtyZWYsIG5vcm1hbGl6ZVJlZihleHRyYVByb3BzKV1cbiAgICAgICAgICAgICAgICAgICAgOiBub3JtYWxpemVSZWYoZXh0cmFQcm9wcylcbiAgICAgICAgICAgIDogcmVmLFxuICAgICAgICBzY29wZUlkOiB2bm9kZS5zY29wZUlkLFxuICAgICAgICBzbG90U2NvcGVJZHM6IHZub2RlLnNsb3RTY29wZUlkcyxcbiAgICAgICAgY2hpbGRyZW46IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBwYXRjaEZsYWcgPT09IC0xIC8qIFBhdGNoRmxhZ3MuSE9JU1RFRCAqLyAmJiBpc0FycmF5KGNoaWxkcmVuKVxuICAgICAgICAgICAgPyBjaGlsZHJlbi5tYXAoZGVlcENsb25lVk5vZGUpXG4gICAgICAgICAgICA6IGNoaWxkcmVuLFxuICAgICAgICB0YXJnZXQ6IHZub2RlLnRhcmdldCxcbiAgICAgICAgdGFyZ2V0QW5jaG9yOiB2bm9kZS50YXJnZXRBbmNob3IsXG4gICAgICAgIHN0YXRpY0NvdW50OiB2bm9kZS5zdGF0aWNDb3VudCxcbiAgICAgICAgc2hhcGVGbGFnOiB2bm9kZS5zaGFwZUZsYWcsXG4gICAgICAgIC8vIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgd2l0aCBleHRyYSBwcm9wcywgd2UgY2FuIG5vIGxvbmdlciBhc3N1bWUgaXRzXG4gICAgICAgIC8vIGV4aXN0aW5nIHBhdGNoIGZsYWcgdG8gYmUgcmVsaWFibGUgYW5kIG5lZWQgdG8gYWRkIHRoZSBGVUxMX1BST1BTIGZsYWcuXG4gICAgICAgIC8vIG5vdGU6IHByZXNlcnZlIGZsYWcgZm9yIGZyYWdtZW50cyBzaW5jZSB0aGV5IHVzZSB0aGUgZmxhZyBmb3IgY2hpbGRyZW5cbiAgICAgICAgLy8gZmFzdCBwYXRocyBvbmx5LlxuICAgICAgICBwYXRjaEZsYWc6IGV4dHJhUHJvcHMgJiYgdm5vZGUudHlwZSAhPT0gRnJhZ21lbnRcbiAgICAgICAgICAgID8gcGF0Y2hGbGFnID09PSAtMSAvLyBob2lzdGVkIG5vZGVcbiAgICAgICAgICAgICAgICA/IDE2IC8qIFBhdGNoRmxhZ3MuRlVMTF9QUk9QUyAqL1xuICAgICAgICAgICAgICAgIDogcGF0Y2hGbGFnIHwgMTYgLyogUGF0Y2hGbGFncy5GVUxMX1BST1BTICovXG4gICAgICAgICAgICA6IHBhdGNoRmxhZyxcbiAgICAgICAgZHluYW1pY1Byb3BzOiB2bm9kZS5keW5hbWljUHJvcHMsXG4gICAgICAgIGR5bmFtaWNDaGlsZHJlbjogdm5vZGUuZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICBhcHBDb250ZXh0OiB2bm9kZS5hcHBDb250ZXh0LFxuICAgICAgICBkaXJzOiB2bm9kZS5kaXJzLFxuICAgICAgICB0cmFuc2l0aW9uOiB2bm9kZS50cmFuc2l0aW9uLFxuICAgICAgICAvLyBUaGVzZSBzaG91bGQgdGVjaG5pY2FsbHkgb25seSBiZSBub24tbnVsbCBvbiBtb3VudGVkIFZOb2Rlcy4gSG93ZXZlcixcbiAgICAgICAgLy8gdGhleSAqc2hvdWxkKiBiZSBjb3BpZWQgZm9yIGtlcHQtYWxpdmUgdm5vZGVzLiBTbyB3ZSBqdXN0IGFsd2F5cyBjb3B5XG4gICAgICAgIC8vIHRoZW0gc2luY2UgdGhlbSBiZWluZyBub24tbnVsbCBkdXJpbmcgYSBtb3VudCBkb2Vzbid0IGFmZmVjdCB0aGUgbG9naWMgYXNcbiAgICAgICAgLy8gdGhleSB3aWxsIHNpbXBseSBiZSBvdmVyd3JpdHRlbi5cbiAgICAgICAgY29tcG9uZW50OiB2bm9kZS5jb21wb25lbnQsXG4gICAgICAgIHN1c3BlbnNlOiB2bm9kZS5zdXNwZW5zZSxcbiAgICAgICAgc3NDb250ZW50OiB2bm9kZS5zc0NvbnRlbnQgJiYgY2xvbmVWTm9kZSh2bm9kZS5zc0NvbnRlbnQpLFxuICAgICAgICBzc0ZhbGxiYWNrOiB2bm9kZS5zc0ZhbGxiYWNrICYmIGNsb25lVk5vZGUodm5vZGUuc3NGYWxsYmFjayksXG4gICAgICAgIGVsOiB2bm9kZS5lbCxcbiAgICAgICAgYW5jaG9yOiB2bm9kZS5hbmNob3IsXG4gICAgICAgIGN0eDogdm5vZGUuY3R4XG4gICAgfTtcbiAgICByZXR1cm4gY2xvbmVkO1xufVxuLyoqXG4gKiBEZXYgb25seSwgZm9yIEhNUiBvZiBob2lzdGVkIHZub2RlcyByZXVzZWQgaW4gdi1mb3JcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS92aXRlanMvdml0ZS9pc3N1ZXMvMjAyMlxuICovXG5mdW5jdGlvbiBkZWVwQ2xvbmVWTm9kZSh2bm9kZSkge1xuICAgIGNvbnN0IGNsb25lZCA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgIGlmIChpc0FycmF5KHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgICBjbG9uZWQuY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbi5tYXAoZGVlcENsb25lVk5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmVkO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUodGV4dCA9ICcgJywgZmxhZyA9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlVk5vZGUoVGV4dCwgbnVsbCwgdGV4dCwgZmxhZyk7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY1ZOb2RlKGNvbnRlbnQsIG51bWJlck9mTm9kZXMpIHtcbiAgICAvLyBBIHN0YXRpYyB2bm9kZSBjYW4gY29udGFpbiBtdWx0aXBsZSBzdHJpbmdpZmllZCBlbGVtZW50cywgYW5kIHRoZSBudW1iZXJcbiAgICAvLyBvZiBlbGVtZW50cyBpcyBuZWNlc3NhcnkgZm9yIGh5ZHJhdGlvbi5cbiAgICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKFN0YXRpYywgbnVsbCwgY29udGVudCk7XG4gICAgdm5vZGUuc3RhdGljQ291bnQgPSBudW1iZXJPZk5vZGVzO1xuICAgIHJldHVybiB2bm9kZTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29tbWVudFZOb2RlKHRleHQgPSAnJywgXG4vLyB3aGVuIHVzZWQgYXMgdGhlIHYtZWxzZSBicmFuY2gsIHRoZSBjb21tZW50IG5vZGUgbXVzdCBiZSBjcmVhdGVkIGFzIGFcbi8vIGJsb2NrIHRvIGVuc3VyZSBjb3JyZWN0IHVwZGF0ZXMuXG5hc0Jsb2NrID0gZmFsc2UpIHtcbiAgICByZXR1cm4gYXNCbG9ja1xuICAgICAgICA/IChvcGVuQmxvY2soKSwgY3JlYXRlQmxvY2soQ29tbWVudCwgbnVsbCwgdGV4dCkpXG4gICAgICAgIDogY3JlYXRlVk5vZGUoQ29tbWVudCwgbnVsbCwgdGV4dCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVWTm9kZShjaGlsZCkge1xuICAgIGlmIChjaGlsZCA9PSBudWxsIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIC8vIGVtcHR5IHBsYWNlaG9sZGVyXG4gICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShDb21tZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBcnJheShjaGlsZCkpIHtcbiAgICAgICAgLy8gZnJhZ21lbnRcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKEZyYWdtZW50LCBudWxsLCBcbiAgICAgICAgLy8gIzM2NjYsIGF2b2lkIHJlZmVyZW5jZSBwb2xsdXRpb24gd2hlbiByZXVzaW5nIHZub2RlXG4gICAgICAgIGNoaWxkLnNsaWNlKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgY2hpbGQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIGFscmVhZHkgdm5vZGUsIHRoaXMgc2hvdWxkIGJlIHRoZSBtb3N0IGNvbW1vbiBzaW5jZSBjb21waWxlZCB0ZW1wbGF0ZXNcbiAgICAgICAgLy8gYWx3YXlzIHByb2R1Y2UgYWxsLXZub2RlIGNoaWxkcmVuIGFycmF5c1xuICAgICAgICByZXR1cm4gY2xvbmVJZk1vdW50ZWQoY2hpbGQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gc3RyaW5ncyBhbmQgbnVtYmVyc1xuICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUoVGV4dCwgbnVsbCwgU3RyaW5nKGNoaWxkKSk7XG4gICAgfVxufVxuLy8gb3B0aW1pemVkIG5vcm1hbGl6YXRpb24gZm9yIHRlbXBsYXRlLWNvbXBpbGVkIHJlbmRlciBmbnNcbmZ1bmN0aW9uIGNsb25lSWZNb3VudGVkKGNoaWxkKSB7XG4gICAgcmV0dXJuIChjaGlsZC5lbCA9PT0gbnVsbCAmJiBjaGlsZC5wYXRjaEZsYWcgIT09IC0xIC8qIFBhdGNoRmxhZ3MuSE9JU1RFRCAqLykgfHxcbiAgICAgICAgY2hpbGQubWVtb1xuICAgICAgICA/IGNoaWxkXG4gICAgICAgIDogY2xvbmVWTm9kZShjaGlsZCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4pIHtcbiAgICBsZXQgdHlwZSA9IDA7XG4gICAgY29uc3QgeyBzaGFwZUZsYWcgfSA9IHZub2RlO1xuICAgIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgdHlwZSA9IDE2IC8qIFNoYXBlRmxhZ3MuQVJSQVlfQ0hJTERSRU4gKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmICgxIC8qIFNoYXBlRmxhZ3MuRUxFTUVOVCAqLyB8IDY0IC8qIFNoYXBlRmxhZ3MuVEVMRVBPUlQgKi8pKSB7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgc2xvdCB0byBwbGFpbiBjaGlsZHJlbiBmb3IgcGxhaW4gZWxlbWVudCBhbmQgVGVsZXBvcnRcbiAgICAgICAgICAgIGNvbnN0IHNsb3QgPSBjaGlsZHJlbi5kZWZhdWx0O1xuICAgICAgICAgICAgaWYgKHNsb3QpIHtcbiAgICAgICAgICAgICAgICAvLyBfYyBtYXJrZXIgaXMgYWRkZWQgYnkgd2l0aEN0eCgpIGluZGljYXRpbmcgdGhpcyBpcyBhIGNvbXBpbGVkIHNsb3RcbiAgICAgICAgICAgICAgICBzbG90Ll9jICYmIChzbG90Ll9kID0gZmFsc2UpO1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlLCBzbG90KCkpO1xuICAgICAgICAgICAgICAgIHNsb3QuX2MgJiYgKHNsb3QuX2QgPSB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHR5cGUgPSAzMiAvKiBTaGFwZUZsYWdzLlNMT1RTX0NISUxEUkVOICovO1xuICAgICAgICAgICAgY29uc3Qgc2xvdEZsYWcgPSBjaGlsZHJlbi5fO1xuICAgICAgICAgICAgaWYgKCFzbG90RmxhZyAmJiAhKEludGVybmFsT2JqZWN0S2V5IGluIGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLl9jdHggPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzbG90RmxhZyA9PT0gMyAvKiBTbG90RmxhZ3MuRk9SV0FSREVEICovICYmIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIC8vIGEgY2hpbGQgY29tcG9uZW50IHJlY2VpdmVzIGZvcndhcmRlZCBzbG90cyBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICAgICAgICAgICAgLy8gaXRzIHNsb3QgdHlwZSBpcyBkZXRlcm1pbmVkIGJ5IGl0cyBwYXJlbnQncyBzbG90IHR5cGUuXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5zbG90cy5fID09PSAxIC8qIFNsb3RGbGFncy5TVEFCTEUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4uXyA9IDEgLyogU2xvdEZsYWdzLlNUQUJMRSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLl8gPSAyIC8qIFNsb3RGbGFncy5EWU5BTUlDICovO1xuICAgICAgICAgICAgICAgICAgICB2bm9kZS5wYXRjaEZsYWcgfD0gMTAyNCAvKiBQYXRjaEZsYWdzLkRZTkFNSUNfU0xPVFMgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oY2hpbGRyZW4pKSB7XG4gICAgICAgIGNoaWxkcmVuID0geyBkZWZhdWx0OiBjaGlsZHJlbiwgX2N0eDogY3VycmVudFJlbmRlcmluZ0luc3RhbmNlIH07XG4gICAgICAgIHR5cGUgPSAzMiAvKiBTaGFwZUZsYWdzLlNMT1RTX0NISUxEUkVOICovO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2hpbGRyZW4gPSBTdHJpbmcoY2hpbGRyZW4pO1xuICAgICAgICAvLyBmb3JjZSB0ZWxlcG9ydCBjaGlsZHJlbiB0byBhcnJheSBzbyBpdCBjYW4gYmUgbW92ZWQgYXJvdW5kXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiA2NCAvKiBTaGFwZUZsYWdzLlRFTEVQT1JUICovKSB7XG4gICAgICAgICAgICB0eXBlID0gMTYgLyogU2hhcGVGbGFncy5BUlJBWV9DSElMRFJFTiAqLztcbiAgICAgICAgICAgIGNoaWxkcmVuID0gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHlwZSA9IDggLyogU2hhcGVGbGFncy5URVhUX0NISUxEUkVOICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZub2RlLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgdm5vZGUuc2hhcGVGbGFnIHw9IHR5cGU7XG59XG5mdW5jdGlvbiBtZXJnZVByb3BzKC4uLmFyZ3MpIHtcbiAgICBjb25zdCByZXQgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdG9NZXJnZSA9IGFyZ3NbaV07XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRvTWVyZ2UpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdjbGFzcycpIHtcbiAgICAgICAgICAgICAgICBpZiAocmV0LmNsYXNzICE9PSB0b01lcmdlLmNsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldC5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKFtyZXQuY2xhc3MsIHRvTWVyZ2UuY2xhc3NdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICAgICAgICByZXQuc3R5bGUgPSBub3JtYWxpemVTdHlsZShbcmV0LnN0eWxlLCB0b01lcmdlLnN0eWxlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc09uKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IHJldFtrZXldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluY29taW5nID0gdG9NZXJnZVtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChpbmNvbWluZyAmJlxuICAgICAgICAgICAgICAgICAgICBleGlzdGluZyAhPT0gaW5jb21pbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgIShpc0FycmF5KGV4aXN0aW5nKSAmJiBleGlzdGluZy5pbmNsdWRlcyhpbmNvbWluZykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldFtrZXldID0gZXhpc3RpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gW10uY29uY2F0KGV4aXN0aW5nLCBpbmNvbWluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaW5jb21pbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnJykge1xuICAgICAgICAgICAgICAgIHJldFtrZXldID0gdG9NZXJnZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBpbnZva2VWTm9kZUhvb2soaG9vaywgaW5zdGFuY2UsIHZub2RlLCBwcmV2Vk5vZGUgPSBudWxsKSB7XG4gICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgaW5zdGFuY2UsIDcgLyogRXJyb3JDb2Rlcy5WTk9ERV9IT09LICovLCBbXG4gICAgICAgIHZub2RlLFxuICAgICAgICBwcmV2Vk5vZGVcbiAgICBdKTtcbn1cblxuY29uc3QgZW1wdHlBcHBDb250ZXh0ID0gY3JlYXRlQXBwQ29udGV4dCgpO1xubGV0IHVpZCQxID0gMDtcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlKHZub2RlLCBwYXJlbnQsIHN1c3BlbnNlKSB7XG4gICAgY29uc3QgdHlwZSA9IHZub2RlLnR5cGU7XG4gICAgLy8gaW5oZXJpdCBwYXJlbnQgYXBwIGNvbnRleHQgLSBvciAtIGlmIHJvb3QsIGFkb3B0IGZyb20gcm9vdCB2bm9kZVxuICAgIGNvbnN0IGFwcENvbnRleHQgPSAocGFyZW50ID8gcGFyZW50LmFwcENvbnRleHQgOiB2bm9kZS5hcHBDb250ZXh0KSB8fCBlbXB0eUFwcENvbnRleHQ7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB7XG4gICAgICAgIHVpZDogdWlkJDErKyxcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgYXBwQ29udGV4dCxcbiAgICAgICAgcm9vdDogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgc3ViVHJlZTogbnVsbCxcbiAgICAgICAgZWZmZWN0OiBudWxsLFxuICAgICAgICB1cGRhdGU6IG51bGwsXG4gICAgICAgIHNjb3BlOiBuZXcgRWZmZWN0U2NvcGUodHJ1ZSAvKiBkZXRhY2hlZCAqLyksXG4gICAgICAgIHJlbmRlcjogbnVsbCxcbiAgICAgICAgcHJveHk6IG51bGwsXG4gICAgICAgIGV4cG9zZWQ6IG51bGwsXG4gICAgICAgIGV4cG9zZVByb3h5OiBudWxsLFxuICAgICAgICB3aXRoUHJveHk6IG51bGwsXG4gICAgICAgIHByb3ZpZGVzOiBwYXJlbnQgPyBwYXJlbnQucHJvdmlkZXMgOiBPYmplY3QuY3JlYXRlKGFwcENvbnRleHQucHJvdmlkZXMpLFxuICAgICAgICBhY2Nlc3NDYWNoZTogbnVsbCxcbiAgICAgICAgcmVuZGVyQ2FjaGU6IFtdLFxuICAgICAgICAvLyBsb2NhbCByZXNvbHZlZCBhc3NldHNcbiAgICAgICAgY29tcG9uZW50czogbnVsbCxcbiAgICAgICAgZGlyZWN0aXZlczogbnVsbCxcbiAgICAgICAgLy8gcmVzb2x2ZWQgcHJvcHMgYW5kIGVtaXRzIG9wdGlvbnNcbiAgICAgICAgcHJvcHNPcHRpb25zOiBub3JtYWxpemVQcm9wc09wdGlvbnModHlwZSwgYXBwQ29udGV4dCksXG4gICAgICAgIGVtaXRzT3B0aW9uczogbm9ybWFsaXplRW1pdHNPcHRpb25zKHR5cGUsIGFwcENvbnRleHQpLFxuICAgICAgICAvLyBlbWl0XG4gICAgICAgIGVtaXQ6IG51bGwsXG4gICAgICAgIGVtaXR0ZWQ6IG51bGwsXG4gICAgICAgIC8vIHByb3BzIGRlZmF1bHQgdmFsdWVcbiAgICAgICAgcHJvcHNEZWZhdWx0czogRU1QVFlfT0JKLFxuICAgICAgICAvLyBpbmhlcml0QXR0cnNcbiAgICAgICAgaW5oZXJpdEF0dHJzOiB0eXBlLmluaGVyaXRBdHRycyxcbiAgICAgICAgLy8gc3RhdGVcbiAgICAgICAgY3R4OiBFTVBUWV9PQkosXG4gICAgICAgIGRhdGE6IEVNUFRZX09CSixcbiAgICAgICAgcHJvcHM6IEVNUFRZX09CSixcbiAgICAgICAgYXR0cnM6IEVNUFRZX09CSixcbiAgICAgICAgc2xvdHM6IEVNUFRZX09CSixcbiAgICAgICAgcmVmczogRU1QVFlfT0JKLFxuICAgICAgICBzZXR1cFN0YXRlOiBFTVBUWV9PQkosXG4gICAgICAgIHNldHVwQ29udGV4dDogbnVsbCxcbiAgICAgICAgLy8gc3VzcGVuc2UgcmVsYXRlZFxuICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgc3VzcGVuc2VJZDogc3VzcGVuc2UgPyBzdXNwZW5zZS5wZW5kaW5nSWQgOiAwLFxuICAgICAgICBhc3luY0RlcDogbnVsbCxcbiAgICAgICAgYXN5bmNSZXNvbHZlZDogZmFsc2UsXG4gICAgICAgIC8vIGxpZmVjeWNsZSBob29rc1xuICAgICAgICAvLyBub3QgdXNpbmcgZW51bXMgaGVyZSBiZWNhdXNlIGl0IHJlc3VsdHMgaW4gY29tcHV0ZWQgcHJvcGVydGllc1xuICAgICAgICBpc01vdW50ZWQ6IGZhbHNlLFxuICAgICAgICBpc1VubW91bnRlZDogZmFsc2UsXG4gICAgICAgIGlzRGVhY3RpdmF0ZWQ6IGZhbHNlLFxuICAgICAgICBiYzogbnVsbCxcbiAgICAgICAgYzogbnVsbCxcbiAgICAgICAgYm06IG51bGwsXG4gICAgICAgIG06IG51bGwsXG4gICAgICAgIGJ1OiBudWxsLFxuICAgICAgICB1OiBudWxsLFxuICAgICAgICB1bTogbnVsbCxcbiAgICAgICAgYnVtOiBudWxsLFxuICAgICAgICBkYTogbnVsbCxcbiAgICAgICAgYTogbnVsbCxcbiAgICAgICAgcnRnOiBudWxsLFxuICAgICAgICBydGM6IG51bGwsXG4gICAgICAgIGVjOiBudWxsLFxuICAgICAgICBzcDogbnVsbFxuICAgIH07XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICBpbnN0YW5jZS5jdHggPSBjcmVhdGVEZXZSZW5kZXJDb250ZXh0KGluc3RhbmNlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGluc3RhbmNlLmN0eCA9IHsgXzogaW5zdGFuY2UgfTtcbiAgICB9XG4gICAgaW5zdGFuY2Uucm9vdCA9IHBhcmVudCA/IHBhcmVudC5yb290IDogaW5zdGFuY2U7XG4gICAgaW5zdGFuY2UuZW1pdCA9IGVtaXQkMS5iaW5kKG51bGwsIGluc3RhbmNlKTtcbiAgICAvLyBhcHBseSBjdXN0b20gZWxlbWVudCBzcGVjaWFsIGhhbmRsaW5nXG4gICAgaWYgKHZub2RlLmNlKSB7XG4gICAgICAgIHZub2RlLmNlKGluc3RhbmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIGluc3RhbmNlO1xufVxubGV0IGN1cnJlbnRJbnN0YW5jZSA9IG51bGw7XG5jb25zdCBnZXRDdXJyZW50SW5zdGFuY2UgPSAoKSA9PiBjdXJyZW50SW5zdGFuY2UgfHwgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuY29uc3Qgc2V0Q3VycmVudEluc3RhbmNlID0gKGluc3RhbmNlKSA9PiB7XG4gICAgY3VycmVudEluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgaW5zdGFuY2Uuc2NvcGUub24oKTtcbn07XG5jb25zdCB1bnNldEN1cnJlbnRJbnN0YW5jZSA9ICgpID0+IHtcbiAgICBjdXJyZW50SW5zdGFuY2UgJiYgY3VycmVudEluc3RhbmNlLnNjb3BlLm9mZigpO1xuICAgIGN1cnJlbnRJbnN0YW5jZSA9IG51bGw7XG59O1xuY29uc3QgaXNCdWlsdEluVGFnID0gLyojX19QVVJFX18qLyBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcpO1xuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUsIGNvbmZpZykge1xuICAgIGNvbnN0IGFwcElzTmF0aXZlVGFnID0gY29uZmlnLmlzTmF0aXZlVGFnIHx8IE5PO1xuICAgIGlmIChpc0J1aWx0SW5UYWcobmFtZSkgfHwgYXBwSXNOYXRpdmVUYWcobmFtZSkpIHtcbiAgICAgICAgd2FybignRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCBpZDogJyArIG5hbWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gaW5zdGFuY2Uudm5vZGUuc2hhcGVGbGFnICYgNCAvKiBTaGFwZUZsYWdzLlNUQVRFRlVMX0NPTVBPTkVOVCAqLztcbn1cbmxldCBpc0luU1NSQ29tcG9uZW50U2V0dXAgPSBmYWxzZTtcbmZ1bmN0aW9uIHNldHVwQ29tcG9uZW50KGluc3RhbmNlLCBpc1NTUiA9IGZhbHNlKSB7XG4gICAgaXNJblNTUkNvbXBvbmVudFNldHVwID0gaXNTU1I7XG4gICAgY29uc3QgeyBwcm9wcywgY2hpbGRyZW4gfSA9IGluc3RhbmNlLnZub2RlO1xuICAgIGNvbnN0IGlzU3RhdGVmdWwgPSBpc1N0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlKTtcbiAgICBpbml0UHJvcHMoaW5zdGFuY2UsIHByb3BzLCBpc1N0YXRlZnVsLCBpc1NTUik7XG4gICAgaW5pdFNsb3RzKGluc3RhbmNlLCBjaGlsZHJlbik7XG4gICAgY29uc3Qgc2V0dXBSZXN1bHQgPSBpc1N0YXRlZnVsXG4gICAgICAgID8gc2V0dXBTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSwgaXNTU1IpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGlzSW5TU1JDb21wb25lbnRTZXR1cCA9IGZhbHNlO1xuICAgIHJldHVybiBzZXR1cFJlc3VsdDtcbn1cbmZ1bmN0aW9uIHNldHVwU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IENvbXBvbmVudCA9IGluc3RhbmNlLnR5cGU7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICBpZiAoQ29tcG9uZW50Lm5hbWUpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShDb21wb25lbnQubmFtZSwgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChDb21wb25lbnQuY29tcG9uZW50cykge1xuICAgICAgICAgICAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyhDb21wb25lbnQuY29tcG9uZW50cyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWVzW2ldLCBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKENvbXBvbmVudC5kaXJlY3RpdmVzKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKENvbXBvbmVudC5kaXJlY3RpdmVzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZURpcmVjdGl2ZU5hbWUobmFtZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChDb21wb25lbnQuY29tcGlsZXJPcHRpb25zICYmIGlzUnVudGltZU9ubHkoKSkge1xuICAgICAgICAgICAgd2FybihgXCJjb21waWxlck9wdGlvbnNcIiBpcyBvbmx5IHN1cHBvcnRlZCB3aGVuIHVzaW5nIGEgYnVpbGQgb2YgVnVlIHRoYXQgYCArXG4gICAgICAgICAgICAgICAgYGluY2x1ZGVzIHRoZSBydW50aW1lIGNvbXBpbGVyLiBTaW5jZSB5b3UgYXJlIHVzaW5nIGEgcnVudGltZS1vbmx5IGAgK1xuICAgICAgICAgICAgICAgIGBidWlsZCwgdGhlIG9wdGlvbnMgc2hvdWxkIGJlIHBhc3NlZCB2aWEgeW91ciBidWlsZCB0b29sIGNvbmZpZyBpbnN0ZWFkLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIDAuIGNyZWF0ZSByZW5kZXIgcHJveHkgcHJvcGVydHkgYWNjZXNzIGNhY2hlXG4gICAgaW5zdGFuY2UuYWNjZXNzQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIC8vIDEuIGNyZWF0ZSBwdWJsaWMgaW5zdGFuY2UgLyByZW5kZXIgcHJveHlcbiAgICAvLyBhbHNvIG1hcmsgaXQgcmF3IHNvIGl0J3MgbmV2ZXIgb2JzZXJ2ZWRcbiAgICBpbnN0YW5jZS5wcm94eSA9IG1hcmtSYXcobmV3IFByb3h5KGluc3RhbmNlLmN0eCwgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzKSk7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICBleHBvc2VQcm9wc09uUmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XG4gICAgfVxuICAgIC8vIDIuIGNhbGwgc2V0dXAoKVxuICAgIGNvbnN0IHsgc2V0dXAgfSA9IENvbXBvbmVudDtcbiAgICBpZiAoc2V0dXApIHtcbiAgICAgICAgY29uc3Qgc2V0dXBDb250ZXh0ID0gKGluc3RhbmNlLnNldHVwQ29udGV4dCA9XG4gICAgICAgICAgICBzZXR1cC5sZW5ndGggPiAxID8gY3JlYXRlU2V0dXBDb250ZXh0KGluc3RhbmNlKSA6IG51bGwpO1xuICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgICAgIGNvbnN0IHNldHVwUmVzdWx0ID0gY2FsbFdpdGhFcnJvckhhbmRsaW5nKHNldHVwLCBpbnN0YW5jZSwgMCAvKiBFcnJvckNvZGVzLlNFVFVQX0ZVTkNUSU9OICovLCBbKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gc2hhbGxvd1JlYWRvbmx5KGluc3RhbmNlLnByb3BzKSA6IGluc3RhbmNlLnByb3BzLCBzZXR1cENvbnRleHRdKTtcbiAgICAgICAgcmVzZXRUcmFja2luZygpO1xuICAgICAgICB1bnNldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgICAgICBpZiAoaXNQcm9taXNlKHNldHVwUmVzdWx0KSkge1xuICAgICAgICAgICAgc2V0dXBSZXN1bHQudGhlbih1bnNldEN1cnJlbnRJbnN0YW5jZSwgdW5zZXRDdXJyZW50SW5zdGFuY2UpO1xuICAgICAgICAgICAgaWYgKGlzU1NSKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBwcm9taXNlIHNvIHNlcnZlci1yZW5kZXJlciBjYW4gd2FpdCBvbiBpdFxuICAgICAgICAgICAgICAgIHJldHVybiBzZXR1cFJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAudGhlbigocmVzb2x2ZWRSZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHJlc29sdmVkUmVzdWx0LCBpc1NTUik7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlLCBpbnN0YW5jZSwgMCAvKiBFcnJvckNvZGVzLlNFVFVQX0ZVTkNUSU9OICovKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGFzeW5jIHNldHVwIHJldHVybmVkIFByb21pc2UuXG4gICAgICAgICAgICAgICAgLy8gYmFpbCBoZXJlIGFuZCB3YWl0IGZvciByZS1lbnRyeS5cbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5hc3luY0RlcCA9IHNldHVwUmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWluc3RhbmNlLnN1c3BlbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSAoX2EgPSBDb21wb25lbnQubmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ0Fub255bW91cyc7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYENvbXBvbmVudCA8JHtuYW1lfT46IHNldHVwIGZ1bmN0aW9uIHJldHVybmVkIGEgcHJvbWlzZSwgYnV0IG5vIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYDxTdXNwZW5zZT4gYm91bmRhcnkgd2FzIGZvdW5kIGluIHRoZSBwYXJlbnQgY29tcG9uZW50IHRyZWUuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYEEgY29tcG9uZW50IHdpdGggYXN5bmMgc2V0dXAoKSBtdXN0IGJlIG5lc3RlZCBpbiBhIDxTdXNwZW5zZT4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgaW4gb3JkZXIgdG8gYmUgcmVuZGVyZWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHNldHVwUmVzdWx0LCBpc1NTUik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlLCBpc1NTUik7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHNldHVwUmVzdWx0LCBpc1NTUikge1xuICAgIGlmIChpc0Z1bmN0aW9uKHNldHVwUmVzdWx0KSkge1xuICAgICAgICAvLyBzZXR1cCByZXR1cm5lZCBhbiBpbmxpbmUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgICAgIGlmIChpbnN0YW5jZS50eXBlLl9fc3NySW5saW5lUmVuZGVyKSB7XG4gICAgICAgICAgICAvLyB3aGVuIHRoZSBmdW5jdGlvbidzIG5hbWUgaXMgYHNzclJlbmRlcmAgKGNvbXBpbGVkIGJ5IFNGQyBpbmxpbmUgbW9kZSksXG4gICAgICAgICAgICAvLyBzZXQgaXQgYXMgc3NyUmVuZGVyIGluc3RlYWQuXG4gICAgICAgICAgICBpbnN0YW5jZS5zc3JSZW5kZXIgPSBzZXR1cFJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnJlbmRlciA9IHNldHVwUmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHNldHVwUmVzdWx0KSkge1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGlzVk5vZGUoc2V0dXBSZXN1bHQpKSB7XG4gICAgICAgICAgICB3YXJuKGBzZXR1cCgpIHNob3VsZCBub3QgcmV0dXJuIFZOb2RlcyBkaXJlY3RseSAtIGAgK1xuICAgICAgICAgICAgICAgIGByZXR1cm4gYSByZW5kZXIgZnVuY3Rpb24gaW5zdGVhZC5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXR1cCByZXR1cm5lZCBiaW5kaW5ncy5cbiAgICAgICAgLy8gYXNzdW1pbmcgYSByZW5kZXIgZnVuY3Rpb24gY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZSBpcyBwcmVzZW50LlxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICAgICAgaW5zdGFuY2UuZGV2dG9vbHNSYXdTZXR1cFN0YXRlID0gc2V0dXBSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2Uuc2V0dXBTdGF0ZSA9IHByb3h5UmVmcyhzZXR1cFJlc3VsdCk7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgIGV4cG9zZVNldHVwU3RhdGVPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBzZXR1cFJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHdhcm4oYHNldHVwKCkgc2hvdWxkIHJldHVybiBhbiBvYmplY3QuIFJlY2VpdmVkOiAke3NldHVwUmVzdWx0ID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHNldHVwUmVzdWx0fWApO1xuICAgIH1cbiAgICBmaW5pc2hDb21wb25lbnRTZXR1cChpbnN0YW5jZSwgaXNTU1IpO1xufVxubGV0IGNvbXBpbGU7XG5sZXQgaW5zdGFsbFdpdGhQcm94eTtcbi8qKlxuICogRm9yIHJ1bnRpbWUtZG9tIHRvIHJlZ2lzdGVyIHRoZSBjb21waWxlci5cbiAqIE5vdGUgdGhlIGV4cG9ydGVkIG1ldGhvZCB1c2VzIGFueSB0byBhdm9pZCBkLnRzIHJlbHlpbmcgb24gdGhlIGNvbXBpbGVyIHR5cGVzLlxuICovXG5mdW5jdGlvbiByZWdpc3RlclJ1bnRpbWVDb21waWxlcihfY29tcGlsZSkge1xuICAgIGNvbXBpbGUgPSBfY29tcGlsZTtcbiAgICBpbnN0YWxsV2l0aFByb3h5ID0gaSA9PiB7XG4gICAgICAgIGlmIChpLnJlbmRlci5fcmMpIHtcbiAgICAgICAgICAgIGkud2l0aFByb3h5ID0gbmV3IFByb3h5KGkuY3R4LCBSdW50aW1lQ29tcGlsZWRQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8vIGRldiBvbmx5XG5jb25zdCBpc1J1bnRpbWVPbmx5ID0gKCkgPT4gIWNvbXBpbGU7XG5mdW5jdGlvbiBmaW5pc2hDb21wb25lbnRTZXR1cChpbnN0YW5jZSwgaXNTU1IsIHNraXBPcHRpb25zKSB7XG4gICAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcbiAgICAvLyB0ZW1wbGF0ZSAvIHJlbmRlciBmdW5jdGlvbiBub3JtYWxpemF0aW9uXG4gICAgLy8gY291bGQgYmUgYWxyZWFkeSBzZXQgd2hlbiByZXR1cm5lZCBmcm9tIHNldHVwKClcbiAgICBpZiAoIWluc3RhbmNlLnJlbmRlcikge1xuICAgICAgICAvLyBvbmx5IGRvIG9uLXRoZS1mbHkgY29tcGlsZSBpZiBub3QgaW4gU1NSIC0gU1NSIG9uLXRoZS1mbHkgY29tcGlsYXRpb25cbiAgICAgICAgLy8gaXMgZG9uZSBieSBzZXJ2ZXItcmVuZGVyZXJcbiAgICAgICAgaWYgKCFpc1NTUiAmJiBjb21waWxlICYmICFDb21wb25lbnQucmVuZGVyKSB7XG4gICAgICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IENvbXBvbmVudC50ZW1wbGF0ZSB8fFxuICAgICAgICAgICAgICAgIHJlc29sdmVNZXJnZWRPcHRpb25zKGluc3RhbmNlKS50ZW1wbGF0ZTtcbiAgICAgICAgICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgY29tcGlsZWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IGlzQ3VzdG9tRWxlbWVudCwgY29tcGlsZXJPcHRpb25zIH0gPSBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZztcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRlbGltaXRlcnMsIGNvbXBpbGVyT3B0aW9uczogY29tcG9uZW50Q29tcGlsZXJPcHRpb25zIH0gPSBDb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZmluYWxDb21waWxlck9wdGlvbnMgPSBleHRlbmQoZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgaXNDdXN0b21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBkZWxpbWl0ZXJzXG4gICAgICAgICAgICAgICAgfSwgY29tcGlsZXJPcHRpb25zKSwgY29tcG9uZW50Q29tcGlsZXJPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBDb21wb25lbnQucmVuZGVyID0gY29tcGlsZSh0ZW1wbGF0ZSwgZmluYWxDb21waWxlck9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYGNvbXBpbGVgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UucmVuZGVyID0gKENvbXBvbmVudC5yZW5kZXIgfHwgTk9PUCk7XG4gICAgICAgIC8vIGZvciBydW50aW1lLWNvbXBpbGVkIHJlbmRlciBmdW5jdGlvbnMgdXNpbmcgYHdpdGhgIGJsb2NrcywgdGhlIHJlbmRlclxuICAgICAgICAvLyBwcm94eSB1c2VkIG5lZWRzIGEgZGlmZmVyZW50IGBoYXNgIGhhbmRsZXIgd2hpY2ggaXMgbW9yZSBwZXJmb3JtYW50IGFuZFxuICAgICAgICAvLyBhbHNvIG9ubHkgYWxsb3dzIGEgd2hpdGVsaXN0IG9mIGdsb2JhbHMgdG8gZmFsbHRocm91Z2guXG4gICAgICAgIGlmIChpbnN0YWxsV2l0aFByb3h5KSB7XG4gICAgICAgICAgICBpbnN0YWxsV2l0aFByb3h5KGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBzdXBwb3J0IGZvciAyLnggb3B0aW9uc1xuICAgIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fICYmICEoZmFsc2UgKSkge1xuICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgICAgIGFwcGx5T3B0aW9ucyhpbnN0YW5jZSk7XG4gICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICAgICAgdW5zZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICB9XG4gICAgLy8gd2FybiBtaXNzaW5nIHRlbXBsYXRlL3JlbmRlclxuICAgIC8vIHRoZSBydW50aW1lIGNvbXBpbGF0aW9uIG9mIHRlbXBsYXRlIGluIFNTUiBpcyBkb25lIGJ5IHNlcnZlci1yZW5kZXJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFDb21wb25lbnQucmVuZGVyICYmIGluc3RhbmNlLnJlbmRlciA9PT0gTk9PUCAmJiAhaXNTU1IpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghY29tcGlsZSAmJiBDb21wb25lbnQudGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm4oYENvbXBvbmVudCBwcm92aWRlZCB0ZW1wbGF0ZSBvcHRpb24gYnV0IGAgK1xuICAgICAgICAgICAgICAgIGBydW50aW1lIGNvbXBpbGF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBidWlsZCBvZiBWdWUuYCArXG4gICAgICAgICAgICAgICAgKGAgQ29uZmlndXJlIHlvdXIgYnVuZGxlciB0byBhbGlhcyBcInZ1ZVwiIHRvIFwidnVlL2Rpc3QvdnVlLmVzbS1idW5kbGVyLmpzXCIuYFxuICAgICAgICAgICAgICAgICAgICApIC8qIHNob3VsZCBub3QgaGFwcGVuICovKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdhcm4oYENvbXBvbmVudCBpcyBtaXNzaW5nIHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbi5gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUF0dHJzUHJveHkoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gbmV3IFByb3h5KGluc3RhbmNlLmF0dHJzLCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICAgICAgICBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xuICAgICAgICAgICAgICAgIHRyYWNrKGluc3RhbmNlLCBcImdldFwiIC8qIFRyYWNrT3BUeXBlcy5HRVQgKi8sICckYXR0cnMnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0W2tleV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0KCkge1xuICAgICAgICAgICAgICAgIHdhcm4oYHNldHVwQ29udGV4dC5hdHRycyBpcyByZWFkb25seS5gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVsZXRlUHJvcGVydHkoKSB7XG4gICAgICAgICAgICAgICAgd2Fybihgc2V0dXBDb250ZXh0LmF0dHJzIGlzIHJlYWRvbmx5LmApO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICA6IHtcbiAgICAgICAgICAgIGdldCh0YXJnZXQsIGtleSkge1xuICAgICAgICAgICAgICAgIHRyYWNrKGluc3RhbmNlLCBcImdldFwiIC8qIFRyYWNrT3BUeXBlcy5HRVQgKi8sICckYXR0cnMnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0W2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlU2V0dXBDb250ZXh0KGluc3RhbmNlKSB7XG4gICAgY29uc3QgZXhwb3NlID0gZXhwb3NlZCA9PiB7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaW5zdGFuY2UuZXhwb3NlZCkge1xuICAgICAgICAgICAgd2FybihgZXhwb3NlKCkgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IG9uY2UgcGVyIHNldHVwKCkuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UuZXhwb3NlZCA9IGV4cG9zZWQgfHwge307XG4gICAgfTtcbiAgICBsZXQgYXR0cnM7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAvLyBXZSB1c2UgZ2V0dGVycyBpbiBkZXYgaW4gY2FzZSBsaWJzIGxpa2UgdGVzdC11dGlscyBvdmVyd3JpdGUgaW5zdGFuY2VcbiAgICAgICAgLy8gcHJvcGVydGllcyAob3ZlcndyaXRlcyBzaG91bGQgbm90IGJlIGRvbmUgaW4gcHJvZClcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgICAgICAgZ2V0IGF0dHJzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhdHRycyB8fCAoYXR0cnMgPSBjcmVhdGVBdHRyc1Byb3h5KGluc3RhbmNlKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IHNsb3RzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaGFsbG93UmVhZG9ubHkoaW5zdGFuY2Uuc2xvdHMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBlbWl0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoZXZlbnQsIC4uLmFyZ3MpID0+IGluc3RhbmNlLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4cG9zZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZXQgYXR0cnMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJzIHx8IChhdHRycyA9IGNyZWF0ZUF0dHJzUHJveHkoaW5zdGFuY2UpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzbG90czogaW5zdGFuY2Uuc2xvdHMsXG4gICAgICAgICAgICBlbWl0OiBpbnN0YW5jZS5lbWl0LFxuICAgICAgICAgICAgZXhwb3NlXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0RXhwb3NlUHJveHkoaW5zdGFuY2UpIHtcbiAgICBpZiAoaW5zdGFuY2UuZXhwb3NlZCkge1xuICAgICAgICByZXR1cm4gKGluc3RhbmNlLmV4cG9zZVByb3h5IHx8XG4gICAgICAgICAgICAoaW5zdGFuY2UuZXhwb3NlUHJveHkgPSBuZXcgUHJveHkocHJveHlSZWZzKG1hcmtSYXcoaW5zdGFuY2UuZXhwb3NlZCkpLCB7XG4gICAgICAgICAgICAgICAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0W2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5IGluIHB1YmxpY1Byb3BlcnRpZXNNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwdWJsaWNQcm9wZXJ0aWVzTWFwW2tleV0oaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoYXModGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleSBpbiB0YXJnZXQgfHwga2V5IGluIHB1YmxpY1Byb3BlcnRpZXNNYXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpKTtcbiAgICB9XG59XG5jb25zdCBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xuY29uc3QgY2xhc3NpZnkgPSAoc3RyKSA9PiBzdHIucmVwbGFjZShjbGFzc2lmeVJFLCBjID0+IGMudG9VcHBlckNhc2UoKSkucmVwbGFjZSgvWy1fXS9nLCAnJyk7XG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCwgaW5jbHVkZUluZmVycmVkID0gdHJ1ZSkge1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKENvbXBvbmVudClcbiAgICAgICAgPyBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWVcbiAgICAgICAgOiBDb21wb25lbnQubmFtZSB8fCAoaW5jbHVkZUluZmVycmVkICYmIENvbXBvbmVudC5fX25hbWUpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGZvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIENvbXBvbmVudCwgaXNSb290ID0gZmFsc2UpIHtcbiAgICBsZXQgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KTtcbiAgICBpZiAoIW5hbWUgJiYgQ29tcG9uZW50Ll9fZmlsZSkge1xuICAgICAgICBjb25zdCBtYXRjaCA9IENvbXBvbmVudC5fX2ZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwuXFx3KyQvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBuYW1lID0gbWF0Y2hbMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFuYW1lICYmIGluc3RhbmNlICYmIGluc3RhbmNlLnBhcmVudCkge1xuICAgICAgICAvLyB0cnkgdG8gaW5mZXIgdGhlIG5hbWUgYmFzZWQgb24gcmV2ZXJzZSByZXNvbHV0aW9uXG4gICAgICAgIGNvbnN0IGluZmVyRnJvbVJlZ2lzdHJ5ID0gKHJlZ2lzdHJ5KSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByZWdpc3RyeSkge1xuICAgICAgICAgICAgICAgIGlmIChyZWdpc3RyeVtrZXldID09PSBDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIG5hbWUgPVxuICAgICAgICAgICAgaW5mZXJGcm9tUmVnaXN0cnkoaW5zdGFuY2UuY29tcG9uZW50cyB8fFxuICAgICAgICAgICAgICAgIGluc3RhbmNlLnBhcmVudC50eXBlLmNvbXBvbmVudHMpIHx8IGluZmVyRnJvbVJlZ2lzdHJ5KGluc3RhbmNlLmFwcENvbnRleHQuY29tcG9uZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lID8gY2xhc3NpZnkobmFtZSkgOiBpc1Jvb3QgPyBgQXBwYCA6IGBBbm9ueW1vdXNgO1xufVxuZnVuY3Rpb24gaXNDbGFzc0NvbXBvbmVudCh2YWx1ZSkge1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKHZhbHVlKSAmJiAnX192Y2NPcHRzJyBpbiB2YWx1ZTtcbn1cblxuY29uc3QgY29tcHV0ZWQgPSAoKGdldHRlck9yT3B0aW9ucywgZGVidWdPcHRpb25zKSA9PiB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBjb21wdXRlZCQxKGdldHRlck9yT3B0aW9ucywgZGVidWdPcHRpb25zLCBpc0luU1NSQ29tcG9uZW50U2V0dXApO1xufSk7XG5cbi8vIGRldiBvbmx5XG5jb25zdCB3YXJuUnVudGltZVVzYWdlID0gKG1ldGhvZCkgPT4gd2FybihgJHttZXRob2R9KCkgaXMgYSBjb21waWxlci1oaW50IGhlbHBlciB0aGF0IGlzIG9ubHkgdXNhYmxlIGluc2lkZSBgICtcbiAgICBgPHNjcmlwdCBzZXR1cD4gb2YgYSBzaW5nbGUgZmlsZSBjb21wb25lbnQuIEl0cyBhcmd1bWVudHMgc2hvdWxkIGJlIGAgK1xuICAgIGBjb21waWxlZCBhd2F5IGFuZCBwYXNzaW5nIGl0IGF0IHJ1bnRpbWUgaGFzIG5vIGVmZmVjdC5gKTtcbi8vIGltcGxlbWVudGF0aW9uXG5mdW5jdGlvbiBkZWZpbmVQcm9wcygpIHtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZVByb3BzYCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLy8gaW1wbGVtZW50YXRpb25cbmZ1bmN0aW9uIGRlZmluZUVtaXRzKCkge1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lRW1pdHNgKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIFZ1ZSBgPHNjcmlwdCBzZXR1cD5gIGNvbXBpbGVyIG1hY3JvIGZvciBkZWNsYXJpbmcgYSBjb21wb25lbnQncyBleHBvc2VkXG4gKiBpbnN0YW5jZSBwcm9wZXJ0aWVzIHdoZW4gaXQgaXMgYWNjZXNzZWQgYnkgYSBwYXJlbnQgY29tcG9uZW50IHZpYSB0ZW1wbGF0ZVxuICogcmVmcy5cbiAqXG4gKiBgPHNjcmlwdCBzZXR1cD5gIGNvbXBvbmVudHMgYXJlIGNsb3NlZCBieSBkZWZhdWx0IC0gaS5lLiB2YXJpYWJsZXMgaW5zaWRlXG4gKiB0aGUgYDxzY3JpcHQgc2V0dXA+YCBzY29wZSBpcyBub3QgZXhwb3NlZCB0byBwYXJlbnQgdW5sZXNzIGV4cGxpY2l0bHkgZXhwb3NlZFxuICogdmlhIGBkZWZpbmVFeHBvc2VgLlxuICpcbiAqIFRoaXMgaXMgb25seSB1c2FibGUgaW5zaWRlIGA8c2NyaXB0IHNldHVwPmAsIGlzIGNvbXBpbGVkIGF3YXkgaW4gdGhlXG4gKiBvdXRwdXQgYW5kIHNob3VsZCAqKm5vdCoqIGJlIGFjdHVhbGx5IGNhbGxlZCBhdCBydW50aW1lLlxuICovXG5mdW5jdGlvbiBkZWZpbmVFeHBvc2UoZXhwb3NlZCkge1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lRXhwb3NlYCk7XG4gICAgfVxufVxuLyoqXG4gKiBWdWUgYDxzY3JpcHQgc2V0dXA+YCBjb21waWxlciBtYWNybyBmb3IgcHJvdmlkaW5nIHByb3BzIGRlZmF1bHQgdmFsdWVzIHdoZW5cbiAqIHVzaW5nIHR5cGUtYmFzZWQgYGRlZmluZVByb3BzYCBkZWNsYXJhdGlvbi5cbiAqXG4gKiBFeGFtcGxlIHVzYWdlOlxuICogYGBgdHNcbiAqIHdpdGhEZWZhdWx0cyhkZWZpbmVQcm9wczx7XG4gKiAgIHNpemU/OiBudW1iZXJcbiAqICAgbGFiZWxzPzogc3RyaW5nW11cbiAqIH0+KCksIHtcbiAqICAgc2l6ZTogMyxcbiAqICAgbGFiZWxzOiAoKSA9PiBbJ2RlZmF1bHQgbGFiZWwnXVxuICogfSlcbiAqIGBgYFxuICpcbiAqIFRoaXMgaXMgb25seSB1c2FibGUgaW5zaWRlIGA8c2NyaXB0IHNldHVwPmAsIGlzIGNvbXBpbGVkIGF3YXkgaW4gdGhlIG91dHB1dFxuICogYW5kIHNob3VsZCAqKm5vdCoqIGJlIGFjdHVhbGx5IGNhbGxlZCBhdCBydW50aW1lLlxuICovXG5mdW5jdGlvbiB3aXRoRGVmYXVsdHMocHJvcHMsIGRlZmF1bHRzKSB7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICB3YXJuUnVudGltZVVzYWdlKGB3aXRoRGVmYXVsdHNgKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB1c2VTbG90cygpIHtcbiAgICByZXR1cm4gZ2V0Q29udGV4dCgpLnNsb3RzO1xufVxuZnVuY3Rpb24gdXNlQXR0cnMoKSB7XG4gICAgcmV0dXJuIGdldENvbnRleHQoKS5hdHRycztcbn1cbmZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gICAgY29uc3QgaSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWkpIHtcbiAgICAgICAgd2FybihgdXNlQ29udGV4dCgpIGNhbGxlZCB3aXRob3V0IGFjdGl2ZSBpbnN0YW5jZS5gKTtcbiAgICB9XG4gICAgcmV0dXJuIGkuc2V0dXBDb250ZXh0IHx8IChpLnNldHVwQ29udGV4dCA9IGNyZWF0ZVNldHVwQ29udGV4dChpKSk7XG59XG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBtZXJnaW5nIGRlZmF1bHQgZGVjbGFyYXRpb25zLiBJbXBvcnRlZCBieSBjb21waWxlZCBjb2RlXG4gKiBvbmx5LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGVmYXVsdHMocmF3LCBkZWZhdWx0cykge1xuICAgIGNvbnN0IHByb3BzID0gaXNBcnJheShyYXcpXG4gICAgICAgID8gcmF3LnJlZHVjZSgobm9ybWFsaXplZCwgcCkgPT4gKChub3JtYWxpemVkW3BdID0ge30pLCBub3JtYWxpemVkKSwge30pXG4gICAgICAgIDogcmF3O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGRlZmF1bHRzKSB7XG4gICAgICAgIGNvbnN0IG9wdCA9IHByb3BzW2tleV07XG4gICAgICAgIGlmIChvcHQpIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KG9wdCkgfHwgaXNGdW5jdGlvbihvcHQpKSB7XG4gICAgICAgICAgICAgICAgcHJvcHNba2V5XSA9IHsgdHlwZTogb3B0LCBkZWZhdWx0OiBkZWZhdWx0c1trZXldIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHQuZGVmYXVsdCA9IGRlZmF1bHRzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBwcm9wc1trZXldID0geyBkZWZhdWx0OiBkZWZhdWx0c1trZXldIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICB3YXJuKGBwcm9wcyBkZWZhdWx0IGtleSBcIiR7a2V5fVwiIGhhcyBubyBjb3JyZXNwb25kaW5nIGRlY2xhcmF0aW9uLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wcztcbn1cbi8qKlxuICogVXNlZCB0byBjcmVhdGUgYSBwcm94eSBmb3IgdGhlIHJlc3QgZWxlbWVudCB3aGVuIGRlc3RydWN0dXJpbmcgcHJvcHMgd2l0aFxuICogZGVmaW5lUHJvcHMoKS5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBjcmVhdGVQcm9wc1Jlc3RQcm94eShwcm9wcywgZXhjbHVkZWRLZXlzKSB7XG4gICAgY29uc3QgcmV0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgaWYgKCFleGNsdWRlZEtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJldCwga2V5LCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHByb3BzW2tleV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG4vKipcbiAqIGA8c2NyaXB0IHNldHVwPmAgaGVscGVyIGZvciBwZXJzaXN0aW5nIHRoZSBjdXJyZW50IGluc3RhbmNlIGNvbnRleHQgb3ZlclxuICogYXN5bmMvYXdhaXQgZmxvd3MuXG4gKlxuICogYEB2dWUvY29tcGlsZXItc2ZjYCBjb252ZXJ0cyB0aGUgZm9sbG93aW5nOlxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCB4ID0gYXdhaXQgZm9vKClcbiAqIGBgYFxuICpcbiAqIGludG86XG4gKlxuICogYGBgdHNcbiAqIGxldCBfX3RlbXAsIF9fcmVzdG9yZVxuICogY29uc3QgeCA9ICgoW19fdGVtcCwgX19yZXN0b3JlXSA9IHdpdGhBc3luY0NvbnRleHQoKCkgPT4gZm9vKCkpKSxfX3RlbXA9YXdhaXQgX190ZW1wLF9fcmVzdG9yZSgpLF9fdGVtcClcbiAqIGBgYFxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHdpdGhBc3luY0NvbnRleHQoZ2V0QXdhaXRhYmxlKSB7XG4gICAgY29uc3QgY3R4ID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhY3R4KSB7XG4gICAgICAgIHdhcm4oYHdpdGhBc3luY0NvbnRleHQgY2FsbGVkIHdpdGhvdXQgYWN0aXZlIGN1cnJlbnQgaW5zdGFuY2UuIGAgK1xuICAgICAgICAgICAgYFRoaXMgaXMgbGlrZWx5IGEgYnVnLmApO1xuICAgIH1cbiAgICBsZXQgYXdhaXRhYmxlID0gZ2V0QXdhaXRhYmxlKCk7XG4gICAgdW5zZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICBpZiAoaXNQcm9taXNlKGF3YWl0YWJsZSkpIHtcbiAgICAgICAgYXdhaXRhYmxlID0gYXdhaXRhYmxlLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKGN0eCk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIFthd2FpdGFibGUsICgpID0+IHNldEN1cnJlbnRJbnN0YW5jZShjdHgpXTtcbn1cblxuLy8gQWN0dWFsIGltcGxlbWVudGF0aW9uXG5mdW5jdGlvbiBoKHR5cGUsIHByb3BzT3JDaGlsZHJlbiwgY2hpbGRyZW4pIHtcbiAgICBjb25zdCBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZiAobCA9PT0gMikge1xuICAgICAgICBpZiAoaXNPYmplY3QocHJvcHNPckNoaWxkcmVuKSAmJiAhaXNBcnJheShwcm9wc09yQ2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAvLyBzaW5nbGUgdm5vZGUgd2l0aG91dCBwcm9wc1xuICAgICAgICAgICAgaWYgKGlzVk5vZGUocHJvcHNPckNoaWxkcmVuKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBudWxsLCBbcHJvcHNPckNoaWxkcmVuXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwcm9wcyB3aXRob3V0IGNoaWxkcmVuXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHNPckNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG9taXQgcHJvcHNcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBudWxsLCBwcm9wc09yQ2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAobCA+IDMpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsID09PSAzICYmIGlzVk5vZGUoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBjaGlsZHJlbiA9IFtjaGlsZHJlbl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIHByb3BzT3JDaGlsZHJlbiwgY2hpbGRyZW4pO1xuICAgIH1cbn1cblxuY29uc3Qgc3NyQ29udGV4dEtleSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgc3NyQ29udGV4dGAgOiBgYCk7XG5jb25zdCB1c2VTU1JDb250ZXh0ID0gKCkgPT4ge1xuICAgIHtcbiAgICAgICAgY29uc3QgY3R4ID0gaW5qZWN0KHNzckNvbnRleHRLZXkpO1xuICAgICAgICBpZiAoIWN0eCkge1xuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICAgICAgd2FybihgU2VydmVyIHJlbmRlcmluZyBjb250ZXh0IG5vdCBwcm92aWRlZC4gTWFrZSBzdXJlIHRvIG9ubHkgY2FsbCBgICtcbiAgICAgICAgICAgICAgICAgICAgYHVzZVNTUkNvbnRleHQoKSBjb25kaXRpb25hbGx5IGluIHRoZSBzZXJ2ZXIgYnVpbGQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN0eDtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBpc1NoYWxsb3codmFsdWUpIHtcbiAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNTaGFsbG93XCIgLyogUmVhY3RpdmVGbGFncy5JU19TSEFMTE9XICovXSk7XG59XG5cbmZ1bmN0aW9uIGluaXRDdXN0b21Gb3JtYXR0ZXIoKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXG4gICAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB2dWVTdHlsZSA9IHsgc3R5bGU6ICdjb2xvcjojM2JhNzc2JyB9O1xuICAgIGNvbnN0IG51bWJlclN0eWxlID0geyBzdHlsZTogJ2NvbG9yOiMwYjFiYzknIH07XG4gICAgY29uc3Qgc3RyaW5nU3R5bGUgPSB7IHN0eWxlOiAnY29sb3I6I2I2MmUyNCcgfTtcbiAgICBjb25zdCBrZXl3b3JkU3R5bGUgPSB7IHN0eWxlOiAnY29sb3I6IzlkMjg4YycgfTtcbiAgICAvLyBjdXN0b20gZm9ybWF0dGVyIGZvciBDaHJvbWVcbiAgICAvLyBodHRwczovL3d3dy5tYXR0emV1bmVydC5jb20vMjAxNi8wMi8xOS9jdXN0b20tY2hyb21lLWRldnRvb2xzLW9iamVjdC1mb3JtYXR0ZXJzLmh0bWxcbiAgICBjb25zdCBmb3JtYXR0ZXIgPSB7XG4gICAgICAgIGhlYWRlcihvYmopIHtcbiAgICAgICAgICAgIC8vIFRPRE8gYWxzbyBmb3JtYXQgQ29tcG9uZW50UHVibGljSW5zdGFuY2UgJiBjdHguc2xvdHMvYXR0cnMgaW4gc2V0dXBcbiAgICAgICAgICAgIGlmICghaXNPYmplY3Qob2JqKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iai5fX2lzVnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnZGl2JywgdnVlU3R5bGUsIGBWdWVJbnN0YW5jZWBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWYob2JqKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgICAgICB7fSxcbiAgICAgICAgICAgICAgICAgICAgWydzcGFuJywgdnVlU3R5bGUsIGdlblJlZkZsYWcob2JqKV0sXG4gICAgICAgICAgICAgICAgICAgICc8JyxcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0VmFsdWUob2JqLnZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgYD5gXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVhY3RpdmUob2JqKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgICAgICB7fSxcbiAgICAgICAgICAgICAgICAgICAgWydzcGFuJywgdnVlU3R5bGUsIGlzU2hhbGxvdyhvYmopID8gJ1NoYWxsb3dSZWFjdGl2ZScgOiAnUmVhY3RpdmUnXSxcbiAgICAgICAgICAgICAgICAgICAgJzwnLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRWYWx1ZShvYmopLFxuICAgICAgICAgICAgICAgICAgICBgPiR7aXNSZWFkb25seShvYmopID8gYCAocmVhZG9ubHkpYCA6IGBgfWBcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWFkb25seShvYmopKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgICAgICBbJ3NwYW4nLCB2dWVTdHlsZSwgaXNTaGFsbG93KG9iaikgPyAnU2hhbGxvd1JlYWRvbmx5JyA6ICdSZWFkb25seSddLFxuICAgICAgICAgICAgICAgICAgICAnPCcsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdFZhbHVlKG9iaiksXG4gICAgICAgICAgICAgICAgICAgICc+J1xuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzQm9keShvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBvYmogJiYgb2JqLl9faXNWdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGJvZHkob2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqICYmIG9iai5fX2lzVnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgICAgICAuLi5mb3JtYXRJbnN0YW5jZShvYmouJClcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBmb3JtYXRJbnN0YW5jZShpbnN0YW5jZSkge1xuICAgICAgICBjb25zdCBibG9ja3MgPSBbXTtcbiAgICAgICAgaWYgKGluc3RhbmNlLnR5cGUucHJvcHMgJiYgaW5zdGFuY2UucHJvcHMpIHtcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soJ3Byb3BzJywgdG9SYXcoaW5zdGFuY2UucHJvcHMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc3RhbmNlLnNldHVwU3RhdGUgIT09IEVNUFRZX09CSikge1xuICAgICAgICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jaygnc2V0dXAnLCBpbnN0YW5jZS5zZXR1cFN0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc3RhbmNlLmRhdGEgIT09IEVNUFRZX09CSikge1xuICAgICAgICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jaygnZGF0YScsIHRvUmF3KGluc3RhbmNlLmRhdGEpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSBleHRyYWN0S2V5cyhpbnN0YW5jZSwgJ2NvbXB1dGVkJyk7XG4gICAgICAgIGlmIChjb21wdXRlZCkge1xuICAgICAgICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jaygnY29tcHV0ZWQnLCBjb21wdXRlZCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluamVjdGVkID0gZXh0cmFjdEtleXMoaW5zdGFuY2UsICdpbmplY3QnKTtcbiAgICAgICAgaWYgKGluamVjdGVkKSB7XG4gICAgICAgICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKCdpbmplY3RlZCcsIGluamVjdGVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgYmxvY2tzLnB1c2goW1xuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZToga2V5d29yZFN0eWxlLnN0eWxlICsgJztvcGFjaXR5OjAuNjYnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnJCAoaW50ZXJuYWwpOiAnXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgWydvYmplY3QnLCB7IG9iamVjdDogaW5zdGFuY2UgfV1cbiAgICAgICAgXSk7XG4gICAgICAgIHJldHVybiBibG9ja3M7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlQmxvY2sodHlwZSwgdGFyZ2V0KSB7XG4gICAgICAgIHRhcmdldCA9IGV4dGVuZCh7fSwgdGFyZ2V0KTtcbiAgICAgICAgaWYgKCFPYmplY3Qua2V5cyh0YXJnZXQpLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHt9XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IHN0eWxlOiAnbGluZS1oZWlnaHQ6MS4yNWVtO21hcmdpbi1ib3R0b206MC42ZW0nIH0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ2NvbG9yOiM0NzY1ODInXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0eXBlXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICdwYWRkaW5nLWxlZnQ6MS4yNWVtJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLi4uT2JqZWN0LmtleXModGFyZ2V0KS5tYXAoa2V5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBbJ3NwYW4nLCBrZXl3b3JkU3R5bGUsIGtleSArICc6ICddLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0VmFsdWUodGFyZ2V0W2tleV0sIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdXG4gICAgICAgIF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHYsIGFzUmF3ID0gdHJ1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gWydzcGFuJywgbnVtYmVyU3R5bGUsIHZdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHN0cmluZ1N0eWxlLCBKU09OLnN0cmluZ2lmeSh2KV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHYgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIGtleXdvcmRTdHlsZSwgdl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QodikpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ29iamVjdCcsIHsgb2JqZWN0OiBhc1JhdyA/IHRvUmF3KHYpIDogdiB9XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCBzdHJpbmdTdHlsZSwgU3RyaW5nKHYpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBleHRyYWN0S2V5cyhpbnN0YW5jZSwgdHlwZSkge1xuICAgICAgICBjb25zdCBDb21wID0gaW5zdGFuY2UudHlwZTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oQ29tcCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHRyYWN0ZWQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5zdGFuY2UuY3R4KSB7XG4gICAgICAgICAgICBpZiAoaXNLZXlPZlR5cGUoQ29tcCwga2V5LCB0eXBlKSkge1xuICAgICAgICAgICAgICAgIGV4dHJhY3RlZFtrZXldID0gaW5zdGFuY2UuY3R4W2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4dHJhY3RlZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNLZXlPZlR5cGUoQ29tcCwga2V5LCB0eXBlKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBDb21wW3R5cGVdO1xuICAgICAgICBpZiAoKGlzQXJyYXkob3B0cykgJiYgb3B0cy5pbmNsdWRlcyhrZXkpKSB8fFxuICAgICAgICAgICAgKGlzT2JqZWN0KG9wdHMpICYmIGtleSBpbiBvcHRzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKENvbXAuZXh0ZW5kcyAmJiBpc0tleU9mVHlwZShDb21wLmV4dGVuZHMsIGtleSwgdHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChDb21wLm1peGlucyAmJiBDb21wLm1peGlucy5zb21lKG0gPT4gaXNLZXlPZlR5cGUobSwga2V5LCB0eXBlKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdlblJlZkZsYWcodikge1xuICAgICAgICBpZiAoaXNTaGFsbG93KHYpKSB7XG4gICAgICAgICAgICByZXR1cm4gYFNoYWxsb3dSZWZgO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2LmVmZmVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGBDb21wdXRlZFJlZmA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBSZWZgO1xuICAgIH1cbiAgICBpZiAod2luZG93LmRldnRvb2xzRm9ybWF0dGVycykge1xuICAgICAgICB3aW5kb3cuZGV2dG9vbHNGb3JtYXR0ZXJzLnB1c2goZm9ybWF0dGVyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMgPSBbZm9ybWF0dGVyXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHdpdGhNZW1vKG1lbW8sIHJlbmRlciwgY2FjaGUsIGluZGV4KSB7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGVbaW5kZXhdO1xuICAgIGlmIChjYWNoZWQgJiYgaXNNZW1vU2FtZShjYWNoZWQsIG1lbW8pKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICAgIGNvbnN0IHJldCA9IHJlbmRlcigpO1xuICAgIC8vIHNoYWxsb3cgY2xvbmVcbiAgICByZXQubWVtbyA9IG1lbW8uc2xpY2UoKTtcbiAgICByZXR1cm4gKGNhY2hlW2luZGV4XSA9IHJldCk7XG59XG5mdW5jdGlvbiBpc01lbW9TYW1lKGNhY2hlZCwgbWVtbykge1xuICAgIGNvbnN0IHByZXYgPSBjYWNoZWQubWVtbztcbiAgICBpZiAocHJldi5sZW5ndGggIT0gbWVtby5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGhhc0NoYW5nZWQocHJldltpXSwgbWVtb1tpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBtYWtlIHN1cmUgdG8gbGV0IHBhcmVudCBibG9jayB0cmFjayBpdCB3aGVuIHJldHVybmluZyBjYWNoZWRcbiAgICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiBjdXJyZW50QmxvY2spIHtcbiAgICAgICAgY3VycmVudEJsb2NrLnB1c2goY2FjaGVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8vIENvcmUgQVBJIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY29uc3QgdmVyc2lvbiA9IFwiMy4yLjQ1XCI7XG5jb25zdCBfc3NyVXRpbHMgPSB7XG4gICAgY3JlYXRlQ29tcG9uZW50SW5zdGFuY2UsXG4gICAgc2V0dXBDb21wb25lbnQsXG4gICAgcmVuZGVyQ29tcG9uZW50Um9vdCxcbiAgICBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UsXG4gICAgaXNWTm9kZSxcbiAgICBub3JtYWxpemVWTm9kZVxufTtcbi8qKlxuICogU1NSIHV0aWxzIGZvciBcXEB2dWUvc2VydmVyLXJlbmRlcmVyLiBPbmx5IGV4cG9zZWQgaW4gc3NyLXBvc3NpYmxlIGJ1aWxkcy5cbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBzc3JVdGlscyA9IChfc3NyVXRpbHMgKTtcbi8qKlxuICogQGludGVybmFsIG9ubHkgZXhwb3NlZCBpbiBjb21wYXQgYnVpbGRzXG4gKi9cbmNvbnN0IHJlc29sdmVGaWx0ZXIgPSBudWxsO1xuLyoqXG4gKiBAaW50ZXJuYWwgb25seSBleHBvc2VkIGluIGNvbXBhdCBidWlsZHMuXG4gKi9cbmNvbnN0IGNvbXBhdFV0aWxzID0gKG51bGwpO1xuXG5leHBvcnQgeyBCYXNlVHJhbnNpdGlvbiwgQ29tbWVudCwgRnJhZ21lbnQsIEtlZXBBbGl2ZSwgU3RhdGljLCBTdXNwZW5zZSwgVGVsZXBvcnQsIFRleHQsIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nLCBjYWxsV2l0aEVycm9ySGFuZGxpbmcsIGNsb25lVk5vZGUsIGNvbXBhdFV0aWxzLCBjb21wdXRlZCwgY3JlYXRlQmxvY2ssIGNyZWF0ZUNvbW1lbnRWTm9kZSwgY3JlYXRlRWxlbWVudEJsb2NrLCBjcmVhdGVCYXNlVk5vZGUgYXMgY3JlYXRlRWxlbWVudFZOb2RlLCBjcmVhdGVIeWRyYXRpb25SZW5kZXJlciwgY3JlYXRlUHJvcHNSZXN0UHJveHksIGNyZWF0ZVJlbmRlcmVyLCBjcmVhdGVTbG90cywgY3JlYXRlU3RhdGljVk5vZGUsIGNyZWF0ZVRleHRWTm9kZSwgY3JlYXRlVk5vZGUsIGRlZmluZUFzeW5jQ29tcG9uZW50LCBkZWZpbmVDb21wb25lbnQsIGRlZmluZUVtaXRzLCBkZWZpbmVFeHBvc2UsIGRlZmluZVByb3BzLCBkZXZ0b29scywgZ2V0Q3VycmVudEluc3RhbmNlLCBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4sIGd1YXJkUmVhY3RpdmVQcm9wcywgaCwgaGFuZGxlRXJyb3IsIGluaXRDdXN0b21Gb3JtYXR0ZXIsIGluamVjdCwgaXNNZW1vU2FtZSwgaXNSdW50aW1lT25seSwgaXNWTm9kZSwgbWVyZ2VEZWZhdWx0cywgbWVyZ2VQcm9wcywgbmV4dFRpY2ssIG9uQWN0aXZhdGVkLCBvbkJlZm9yZU1vdW50LCBvbkJlZm9yZVVubW91bnQsIG9uQmVmb3JlVXBkYXRlLCBvbkRlYWN0aXZhdGVkLCBvbkVycm9yQ2FwdHVyZWQsIG9uTW91bnRlZCwgb25SZW5kZXJUcmFja2VkLCBvblJlbmRlclRyaWdnZXJlZCwgb25TZXJ2ZXJQcmVmZXRjaCwgb25Vbm1vdW50ZWQsIG9uVXBkYXRlZCwgb3BlbkJsb2NrLCBwb3BTY29wZUlkLCBwcm92aWRlLCBwdXNoU2NvcGVJZCwgcXVldWVQb3N0Rmx1c2hDYiwgcmVnaXN0ZXJSdW50aW1lQ29tcGlsZXIsIHJlbmRlckxpc3QsIHJlbmRlclNsb3QsIHJlc29sdmVDb21wb25lbnQsIHJlc29sdmVEaXJlY3RpdmUsIHJlc29sdmVEeW5hbWljQ29tcG9uZW50LCByZXNvbHZlRmlsdGVyLCByZXNvbHZlVHJhbnNpdGlvbkhvb2tzLCBzZXRCbG9ja1RyYWNraW5nLCBzZXREZXZ0b29sc0hvb2ssIHNldFRyYW5zaXRpb25Ib29rcywgc3NyQ29udGV4dEtleSwgc3NyVXRpbHMsIHRvSGFuZGxlcnMsIHRyYW5zZm9ybVZOb2RlQXJncywgdXNlQXR0cnMsIHVzZVNTUkNvbnRleHQsIHVzZVNsb3RzLCB1c2VUcmFuc2l0aW9uU3RhdGUsIHZlcnNpb24sIHdhcm4sIHdhdGNoLCB3YXRjaEVmZmVjdCwgd2F0Y2hQb3N0RWZmZWN0LCB3YXRjaFN5bmNFZmZlY3QsIHdpdGhBc3luY0NvbnRleHQsIHdpdGhDdHgsIHdpdGhEZWZhdWx0cywgd2l0aERpcmVjdGl2ZXMsIHdpdGhNZW1vLCB3aXRoU2NvcGVJZCB9O1xuIiwiaW1wb3J0IHsgd2FybiwgY2FtZWxpemUsIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nLCBkZWZpbmVDb21wb25lbnQsIG5leHRUaWNrLCBjcmVhdGVWTm9kZSwgZ2V0Q3VycmVudEluc3RhbmNlLCB3YXRjaFBvc3RFZmZlY3QsIG9uTW91bnRlZCwgb25Vbm1vdW50ZWQsIEZyYWdtZW50LCBTdGF0aWMsIGgsIEJhc2VUcmFuc2l0aW9uLCB1c2VUcmFuc2l0aW9uU3RhdGUsIG9uVXBkYXRlZCwgdG9SYXcsIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbiwgc2V0VHJhbnNpdGlvbkhvb2tzLCByZXNvbHZlVHJhbnNpdGlvbkhvb2tzLCBjcmVhdGVSZW5kZXJlciwgaXNSdW50aW1lT25seSwgY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIgfSBmcm9tICdAdnVlL3J1bnRpbWUtY29yZSc7XG5leHBvcnQgKiBmcm9tICdAdnVlL3J1bnRpbWUtY29yZSc7XG5pbXBvcnQgeyBpc1N0cmluZywgaXNBcnJheSwgaHlwaGVuYXRlLCBjYXBpdGFsaXplLCBpc1NwZWNpYWxCb29sZWFuQXR0ciwgaW5jbHVkZUJvb2xlYW5BdHRyLCBpc09uLCBpc01vZGVsTGlzdGVuZXIsIGlzRnVuY3Rpb24sIGNhbWVsaXplIGFzIGNhbWVsaXplJDEsIHRvTnVtYmVyLCBleHRlbmQsIEVNUFRZX09CSiwgaXNPYmplY3QsIGludm9rZUFycmF5Rm5zLCBsb29zZUluZGV4T2YsIGlzU2V0LCBsb29zZUVxdWFsLCBpc0hUTUxUYWcsIGlzU1ZHVGFnIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5jb25zdCBzdmdOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG5jb25zdCBkb2MgPSAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogbnVsbCk7XG5jb25zdCB0ZW1wbGF0ZUNvbnRhaW5lciA9IGRvYyAmJiAvKiNfX1BVUkVfXyovIGRvYy5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuY29uc3Qgbm9kZU9wcyA9IHtcbiAgICBpbnNlcnQ6IChjaGlsZCwgcGFyZW50LCBhbmNob3IpID0+IHtcbiAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgYW5jaG9yIHx8IG51bGwpO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBjaGlsZCA9PiB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGNoaWxkLnBhcmVudE5vZGU7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZUVsZW1lbnQ6ICh0YWcsIGlzU1ZHLCBpcywgcHJvcHMpID0+IHtcbiAgICAgICAgY29uc3QgZWwgPSBpc1NWR1xuICAgICAgICAgICAgPyBkb2MuY3JlYXRlRWxlbWVudE5TKHN2Z05TLCB0YWcpXG4gICAgICAgICAgICA6IGRvYy5jcmVhdGVFbGVtZW50KHRhZywgaXMgPyB7IGlzIH0gOiB1bmRlZmluZWQpO1xuICAgICAgICBpZiAodGFnID09PSAnc2VsZWN0JyAmJiBwcm9wcyAmJiBwcm9wcy5tdWx0aXBsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgcHJvcHMubXVsdGlwbGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9LFxuICAgIGNyZWF0ZVRleHQ6IHRleHQgPT4gZG9jLmNyZWF0ZVRleHROb2RlKHRleHQpLFxuICAgIGNyZWF0ZUNvbW1lbnQ6IHRleHQgPT4gZG9jLmNyZWF0ZUNvbW1lbnQodGV4dCksXG4gICAgc2V0VGV4dDogKG5vZGUsIHRleHQpID0+IHtcbiAgICAgICAgbm9kZS5ub2RlVmFsdWUgPSB0ZXh0O1xuICAgIH0sXG4gICAgc2V0RWxlbWVudFRleHQ6IChlbCwgdGV4dCkgPT4ge1xuICAgICAgICBlbC50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgfSxcbiAgICBwYXJlbnROb2RlOiBub2RlID0+IG5vZGUucGFyZW50Tm9kZSxcbiAgICBuZXh0U2libGluZzogbm9kZSA9PiBub2RlLm5leHRTaWJsaW5nLFxuICAgIHF1ZXJ5U2VsZWN0b3I6IHNlbGVjdG9yID0+IGRvYy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSxcbiAgICBzZXRTY29wZUlkKGVsLCBpZCkge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoaWQsICcnKTtcbiAgICB9LFxuICAgIC8vIF9fVU5TQUZFX19cbiAgICAvLyBSZWFzb246IGlubmVySFRNTC5cbiAgICAvLyBTdGF0aWMgY29udGVudCBoZXJlIGNhbiBvbmx5IGNvbWUgZnJvbSBjb21waWxlZCB0ZW1wbGF0ZXMuXG4gICAgLy8gQXMgbG9uZyBhcyB0aGUgdXNlciBvbmx5IHVzZXMgdHJ1c3RlZCB0ZW1wbGF0ZXMsIHRoaXMgaXMgc2FmZS5cbiAgICBpbnNlcnRTdGF0aWNDb250ZW50KGNvbnRlbnQsIHBhcmVudCwgYW5jaG9yLCBpc1NWRywgc3RhcnQsIGVuZCkge1xuICAgICAgICAvLyA8cGFyZW50PiBiZWZvcmUgfCBmaXJzdCAuLi4gbGFzdCB8IGFuY2hvciA8L3BhcmVudD5cbiAgICAgICAgY29uc3QgYmVmb3JlID0gYW5jaG9yID8gYW5jaG9yLnByZXZpb3VzU2libGluZyA6IHBhcmVudC5sYXN0Q2hpbGQ7XG4gICAgICAgIC8vICM1MzA4IGNhbiBvbmx5IHRha2UgY2FjaGVkIHBhdGggaWY6XG4gICAgICAgIC8vIC0gaGFzIGEgc2luZ2xlIHJvb3Qgbm9kZVxuICAgICAgICAvLyAtIG5leHRTaWJsaW5nIGluZm8gaXMgc3RpbGwgYXZhaWxhYmxlXG4gICAgICAgIGlmIChzdGFydCAmJiAoc3RhcnQgPT09IGVuZCB8fCBzdGFydC5uZXh0U2libGluZykpIHtcbiAgICAgICAgICAgIC8vIGNhY2hlZFxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHN0YXJ0LmNsb25lTm9kZSh0cnVlKSwgYW5jaG9yKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT09IGVuZCB8fCAhKHN0YXJ0ID0gc3RhcnQubmV4dFNpYmxpbmcpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZyZXNoIGluc2VydFxuICAgICAgICAgICAgdGVtcGxhdGVDb250YWluZXIuaW5uZXJIVE1MID0gaXNTVkcgPyBgPHN2Zz4ke2NvbnRlbnR9PC9zdmc+YCA6IGNvbnRlbnQ7XG4gICAgICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRlbXBsYXRlQ29udGFpbmVyLmNvbnRlbnQ7XG4gICAgICAgICAgICBpZiAoaXNTVkcpIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgb3V0ZXIgc3ZnIHdyYXBwZXJcbiAgICAgICAgICAgICAgICBjb25zdCB3cmFwcGVyID0gdGVtcGxhdGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICB3aGlsZSAod3JhcHBlci5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlLmFwcGVuZENoaWxkKHdyYXBwZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRlbXBsYXRlLnJlbW92ZUNoaWxkKHdyYXBwZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSh0ZW1wbGF0ZSwgYW5jaG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLy8gZmlyc3RcbiAgICAgICAgICAgIGJlZm9yZSA/IGJlZm9yZS5uZXh0U2libGluZyA6IHBhcmVudC5maXJzdENoaWxkLFxuICAgICAgICAgICAgLy8gbGFzdFxuICAgICAgICAgICAgYW5jaG9yID8gYW5jaG9yLnByZXZpb3VzU2libGluZyA6IHBhcmVudC5sYXN0Q2hpbGRcbiAgICAgICAgXTtcbiAgICB9XG59O1xuXG4vLyBjb21waWxlciBzaG91bGQgbm9ybWFsaXplIGNsYXNzICsgOmNsYXNzIGJpbmRpbmdzIG9uIHRoZSBzYW1lIGVsZW1lbnRcbi8vIGludG8gYSBzaW5nbGUgYmluZGluZyBbJ3N0YXRpY0NsYXNzJywgZHluYW1pY11cbmZ1bmN0aW9uIHBhdGNoQ2xhc3MoZWwsIHZhbHVlLCBpc1NWRykge1xuICAgIC8vIGRpcmVjdGx5IHNldHRpbmcgY2xhc3NOYW1lIHNob3VsZCBiZSBmYXN0ZXIgdGhhbiBzZXRBdHRyaWJ1dGUgaW4gdGhlb3J5XG4gICAgLy8gaWYgdGhpcyBpcyBhbiBlbGVtZW50IGR1cmluZyBhIHRyYW5zaXRpb24sIHRha2UgdGhlIHRlbXBvcmFyeSB0cmFuc2l0aW9uXG4gICAgLy8gY2xhc3NlcyBpbnRvIGFjY291bnQuXG4gICAgY29uc3QgdHJhbnNpdGlvbkNsYXNzZXMgPSBlbC5fdnRjO1xuICAgIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSA/IFt2YWx1ZSwgLi4udHJhbnNpdGlvbkNsYXNzZXNdIDogWy4uLnRyYW5zaXRpb25DbGFzc2VzXSkuam9pbignICcpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzU1ZHKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbC5jbGFzc05hbWUgPSB2YWx1ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBhdGNoU3R5bGUoZWwsIHByZXYsIG5leHQpIHtcbiAgICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xuICAgIGNvbnN0IGlzQ3NzU3RyaW5nID0gaXNTdHJpbmcobmV4dCk7XG4gICAgaWYgKG5leHQgJiYgIWlzQ3NzU3RyaW5nKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5leHQpIHtcbiAgICAgICAgICAgIHNldFN0eWxlKHN0eWxlLCBrZXksIG5leHRba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXYgJiYgIWlzU3RyaW5nKHByZXYpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcmV2KSB7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFN0eWxlKHN0eWxlLCBrZXksICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnREaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcbiAgICAgICAgaWYgKGlzQ3NzU3RyaW5nKSB7XG4gICAgICAgICAgICBpZiAocHJldiAhPT0gbmV4dCkge1xuICAgICAgICAgICAgICAgIHN0eWxlLmNzc1RleHQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZXYpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbmRpY2F0ZXMgdGhhdCB0aGUgYGRpc3BsYXlgIG9mIHRoZSBlbGVtZW50IGlzIGNvbnRyb2xsZWQgYnkgYHYtc2hvd2AsXG4gICAgICAgIC8vIHNvIHdlIGFsd2F5cyBrZWVwIHRoZSBjdXJyZW50IGBkaXNwbGF5YCB2YWx1ZSByZWdhcmRsZXNzIG9mIHRoZSBgc3R5bGVgXG4gICAgICAgIC8vIHZhbHVlLCB0aHVzIGhhbmRpbmcgb3ZlciBjb250cm9sIHRvIGB2LXNob3dgLlxuICAgICAgICBpZiAoJ192b2QnIGluIGVsKSB7XG4gICAgICAgICAgICBzdHlsZS5kaXNwbGF5ID0gY3VycmVudERpc3BsYXk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBzZW1pY29sb25SRSA9IC9bXlxcXFxdO1xccyokLztcbmNvbnN0IGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG5mdW5jdGlvbiBzZXRTdHlsZShzdHlsZSwgbmFtZSwgdmFsKSB7XG4gICAgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgICAgICB2YWwuZm9yRWFjaCh2ID0+IHNldFN0eWxlKHN0eWxlLCBuYW1lLCB2KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAodmFsID09IG51bGwpXG4gICAgICAgICAgICB2YWwgPSAnJztcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgaWYgKHNlbWljb2xvblJFLnRlc3QodmFsKSkge1xuICAgICAgICAgICAgICAgIHdhcm4oYFVuZXhwZWN0ZWQgc2VtaWNvbG9uIGF0IHRoZSBlbmQgb2YgJyR7bmFtZX0nIHN0eWxlIHZhbHVlOiAnJHt2YWx9J2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoJy0tJykpIHtcbiAgICAgICAgICAgIC8vIGN1c3RvbSBwcm9wZXJ0eSBkZWZpbml0aW9uXG4gICAgICAgICAgICBzdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcHJlZml4ZWQgPSBhdXRvUHJlZml4KHN0eWxlLCBuYW1lKTtcbiAgICAgICAgICAgIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcbiAgICAgICAgICAgICAgICAvLyAhaW1wb3J0YW50XG4gICAgICAgICAgICAgICAgc3R5bGUuc2V0UHJvcGVydHkoaHlwaGVuYXRlKHByZWZpeGVkKSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3R5bGVbcHJlZml4ZWRdID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcbmNvbnN0IHByZWZpeENhY2hlID0ge307XG5mdW5jdGlvbiBhdXRvUHJlZml4KHN0eWxlLCByYXdOYW1lKSB7XG4gICAgY29uc3QgY2FjaGVkID0gcHJlZml4Q2FjaGVbcmF3TmFtZV07XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cbiAgICBsZXQgbmFtZSA9IGNhbWVsaXplKHJhd05hbWUpO1xuICAgIGlmIChuYW1lICE9PSAnZmlsdGVyJyAmJiBuYW1lIGluIHN0eWxlKSB7XG4gICAgICAgIHJldHVybiAocHJlZml4Q2FjaGVbcmF3TmFtZV0gPSBuYW1lKTtcbiAgICB9XG4gICAgbmFtZSA9IGNhcGl0YWxpemUobmFtZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwcmVmaXhlZCA9IHByZWZpeGVzW2ldICsgbmFtZTtcbiAgICAgICAgaWYgKHByZWZpeGVkIGluIHN0eWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHByZWZpeENhY2hlW3Jhd05hbWVdID0gcHJlZml4ZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByYXdOYW1lO1xufVxuXG5jb25zdCB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuZnVuY3Rpb24gcGF0Y2hBdHRyKGVsLCBrZXksIHZhbHVlLCBpc1NWRywgaW5zdGFuY2UpIHtcbiAgICBpZiAoaXNTVkcgJiYga2V5LnN0YXJ0c1dpdGgoJ3hsaW5rOicpKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXkuc2xpY2UoNiwga2V5Lmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIG5vdGUgd2UgYXJlIG9ubHkgY2hlY2tpbmcgYm9vbGVhbiBhdHRyaWJ1dGVzIHRoYXQgZG9uJ3QgaGF2ZSBhXG4gICAgICAgIC8vIGNvcnJlc3BvbmRpbmcgZG9tIHByb3Agb2YgdGhlIHNhbWUgbmFtZSBoZXJlLlxuICAgICAgICBjb25zdCBpc0Jvb2xlYW4gPSBpc1NwZWNpYWxCb29sZWFuQXR0cihrZXkpO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCAoaXNCb29sZWFuICYmICFpbmNsdWRlQm9vbGVhbkF0dHIodmFsdWUpKSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBpc0Jvb2xlYW4gPyAnJyA6IHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gX19VTlNBRkVfX1xuLy8gZnVuY3Rpb25zLiBUaGUgdXNlciBpcyByZXNwb25zaWJsZSBmb3IgdXNpbmcgdGhlbSB3aXRoIG9ubHkgdHJ1c3RlZCBjb250ZW50LlxuZnVuY3Rpb24gcGF0Y2hET01Qcm9wKGVsLCBrZXksIHZhbHVlLCBcbi8vIHRoZSBmb2xsb3dpbmcgYXJncyBhcmUgcGFzc2VkIG9ubHkgZHVlIHRvIHBvdGVudGlhbCBpbm5lckhUTUwvdGV4dENvbnRlbnRcbi8vIG92ZXJyaWRpbmcgZXhpc3RpbmcgVk5vZGVzLCBpbiB3aGljaCBjYXNlIHRoZSBvbGQgdHJlZSBtdXN0IGJlIHByb3Blcmx5XG4vLyB1bm1vdW50ZWQuXG5wcmV2Q2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbikge1xuICAgIGlmIChrZXkgPT09ICdpbm5lckhUTUwnIHx8IGtleSA9PT0gJ3RleHRDb250ZW50Jykge1xuICAgICAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4ocHJldkNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbFtrZXldID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gJ3ZhbHVlJyAmJlxuICAgICAgICBlbC50YWdOYW1lICE9PSAnUFJPR1JFU1MnICYmXG4gICAgICAgIC8vIGN1c3RvbSBlbGVtZW50cyBtYXkgdXNlIF92YWx1ZSBpbnRlcm5hbGx5XG4gICAgICAgICFlbC50YWdOYW1lLmluY2x1ZGVzKCctJykpIHtcbiAgICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcbiAgICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZC5cbiAgICAgICAgZWwuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG4gICAgICAgIGlmIChlbC52YWx1ZSAhPT0gbmV3VmFsdWUgfHxcbiAgICAgICAgICAgIC8vICM0OTU2OiBhbHdheXMgc2V0IGZvciBPUFRJT04gZWxlbWVudHMgYmVjYXVzZSBpdHMgdmFsdWUgZmFsbHMgYmFjayB0b1xuICAgICAgICAgICAgLy8gdGV4dENvbnRlbnQgaWYgbm8gdmFsdWUgYXR0cmlidXRlIGlzIHByZXNlbnQuIEFuZCBzZXR0aW5nIC52YWx1ZSBmb3JcbiAgICAgICAgICAgIC8vIE9QVElPTiBoYXMgbm8gc2lkZSBlZmZlY3RcbiAgICAgICAgICAgIGVsLnRhZ05hbWUgPT09ICdPUFRJT04nKSB7XG4gICAgICAgICAgICBlbC52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBuZWVkUmVtb3ZlID0gZmFsc2U7XG4gICAgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgZWxba2V5XTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgLy8gZS5nLiA8c2VsZWN0IG11bHRpcGxlPiBjb21waWxlcyB0byB7IG11bHRpcGxlOiAnJyB9XG4gICAgICAgICAgICB2YWx1ZSA9IGluY2x1ZGVCb29sZWFuQXR0cih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT0gbnVsbCAmJiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gZS5nLiA8ZGl2IDppZD1cIm51bGxcIj5cbiAgICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgICAgICBuZWVkUmVtb3ZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgLy8gZS5nLiA8aW1nIDp3aWR0aD1cIm51bGxcIj5cbiAgICAgICAgICAgIHZhbHVlID0gMDtcbiAgICAgICAgICAgIG5lZWRSZW1vdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHNvbWUgcHJvcGVydGllcyBwZXJmb3JtIHZhbHVlIHZhbGlkYXRpb24gYW5kIHRocm93LFxuICAgIC8vIHNvbWUgcHJvcGVydGllcyBoYXMgZ2V0dGVyLCBubyBzZXR0ZXIsIHdpbGwgZXJyb3IgaW4gJ3VzZSBzdHJpY3QnXG4gICAgLy8gZWcuIDxzZWxlY3QgOnR5cGU9XCJudWxsXCI+PC9zZWxlY3Q+IDxzZWxlY3QgOndpbGxWYWxpZGF0ZT1cIm51bGxcIj48L3NlbGVjdD5cbiAgICB0cnkge1xuICAgICAgICBlbFtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGRvIG5vdCB3YXJuIGlmIHZhbHVlIGlzIGF1dG8tY29lcmNlZCBmcm9tIG51bGxpc2ggdmFsdWVzXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIW5lZWRSZW1vdmUpIHtcbiAgICAgICAgICAgIHdhcm4oYEZhaWxlZCBzZXR0aW5nIHByb3AgXCIke2tleX1cIiBvbiA8JHtlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCl9PjogYCArXG4gICAgICAgICAgICAgICAgYHZhbHVlICR7dmFsdWV9IGlzIGludmFsaWQuYCwgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmVlZFJlbW92ZSAmJiBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihlbCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBwYXRjaEV2ZW50KGVsLCByYXdOYW1lLCBwcmV2VmFsdWUsIG5leHRWYWx1ZSwgaW5zdGFuY2UgPSBudWxsKSB7XG4gICAgLy8gdmVpID0gdnVlIGV2ZW50IGludm9rZXJzXG4gICAgY29uc3QgaW52b2tlcnMgPSBlbC5fdmVpIHx8IChlbC5fdmVpID0ge30pO1xuICAgIGNvbnN0IGV4aXN0aW5nSW52b2tlciA9IGludm9rZXJzW3Jhd05hbWVdO1xuICAgIGlmIChuZXh0VmFsdWUgJiYgZXhpc3RpbmdJbnZva2VyKSB7XG4gICAgICAgIC8vIHBhdGNoXG4gICAgICAgIGV4aXN0aW5nSW52b2tlci52YWx1ZSA9IG5leHRWYWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IFtuYW1lLCBvcHRpb25zXSA9IHBhcnNlTmFtZShyYXdOYW1lKTtcbiAgICAgICAgaWYgKG5leHRWYWx1ZSkge1xuICAgICAgICAgICAgLy8gYWRkXG4gICAgICAgICAgICBjb25zdCBpbnZva2VyID0gKGludm9rZXJzW3Jhd05hbWVdID0gY3JlYXRlSW52b2tlcihuZXh0VmFsdWUsIGluc3RhbmNlKSk7XG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBuYW1lLCBpbnZva2VyLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleGlzdGluZ0ludm9rZXIpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZVxuICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgZXhpc3RpbmdJbnZva2VyLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGludm9rZXJzW3Jhd05hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3Qgb3B0aW9uc01vZGlmaWVyUkUgPSAvKD86T25jZXxQYXNzaXZlfENhcHR1cmUpJC87XG5mdW5jdGlvbiBwYXJzZU5hbWUobmFtZSkge1xuICAgIGxldCBvcHRpb25zO1xuICAgIGlmIChvcHRpb25zTW9kaWZpZXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgbGV0IG07XG4gICAgICAgIHdoaWxlICgobSA9IG5hbWUubWF0Y2gob3B0aW9uc01vZGlmaWVyUkUpKSkge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgbmFtZS5sZW5ndGggLSBtWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICBvcHRpb25zW21bMF0udG9Mb3dlckNhc2UoKV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50ID0gbmFtZVsyXSA9PT0gJzonID8gbmFtZS5zbGljZSgzKSA6IGh5cGhlbmF0ZShuYW1lLnNsaWNlKDIpKTtcbiAgICByZXR1cm4gW2V2ZW50LCBvcHRpb25zXTtcbn1cbi8vIFRvIGF2b2lkIHRoZSBvdmVyaGVhZCBvZiByZXBlYXRlZGx5IGNhbGxpbmcgRGF0ZS5ub3coKSwgd2UgY2FjaGVcbi8vIGFuZCB1c2UgdGhlIHNhbWUgdGltZXN0YW1wIGZvciBhbGwgZXZlbnQgbGlzdGVuZXJzIGF0dGFjaGVkIGluIHRoZSBzYW1lIHRpY2suXG5sZXQgY2FjaGVkTm93ID0gMDtcbmNvbnN0IHAgPSAvKiNfX1BVUkVfXyovIFByb21pc2UucmVzb2x2ZSgpO1xuY29uc3QgZ2V0Tm93ID0gKCkgPT4gY2FjaGVkTm93IHx8IChwLnRoZW4oKCkgPT4gKGNhY2hlZE5vdyA9IDApKSwgKGNhY2hlZE5vdyA9IERhdGUubm93KCkpKTtcbmZ1bmN0aW9uIGNyZWF0ZUludm9rZXIoaW5pdGlhbFZhbHVlLCBpbnN0YW5jZSkge1xuICAgIGNvbnN0IGludm9rZXIgPSAoZSkgPT4ge1xuICAgICAgICAvLyBhc3luYyBlZGdlIGNhc2UgdnVlanMvdnVlIzY1NjZcbiAgICAgICAgLy8gaW5uZXIgY2xpY2sgZXZlbnQgdHJpZ2dlcnMgcGF0Y2gsIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgLy8gYXR0YWNoZWQgdG8gb3V0ZXIgZWxlbWVudCBkdXJpbmcgcGF0Y2gsIGFuZCB0cmlnZ2VyZWQgYWdhaW4uIFRoaXNcbiAgICAgICAgLy8gaGFwcGVucyBiZWNhdXNlIGJyb3dzZXJzIGZpcmUgbWljcm90YXNrIHRpY2tzIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24uXG4gICAgICAgIC8vIHRoaXMgbm8gbG9uZ2VyIGhhcHBlbnMgZm9yIHRlbXBsYXRlcyBpbiBWdWUgMywgYnV0IGNvdWxkIHN0aWxsIGJlXG4gICAgICAgIC8vIHRoZW9yZXRpY2FsbHkgcG9zc2libGUgZm9yIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxuICAgICAgICAvLyB0aGUgc29sdXRpb246IHdlIHNhdmUgdGhlIHRpbWVzdGFtcCB3aGVuIGEgaGFuZGxlciBpcyBhdHRhY2hlZCxcbiAgICAgICAgLy8gYW5kIGFsc28gYXR0YWNoIHRoZSB0aW1lc3RhbXAgdG8gYW55IGV2ZW50IHRoYXQgd2FzIGhhbmRsZWQgYnkgdnVlXG4gICAgICAgIC8vIGZvciB0aGUgZmlyc3QgdGltZSAodG8gYXZvaWQgaW5jb25zaXN0ZW50IGV2ZW50IHRpbWVzdGFtcCBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgLy8gb3IgZXZlbnRzIGZpcmVkIGZyb20gaWZyYW1lcywgZS5nLiAjMjUxMylcbiAgICAgICAgLy8gVGhlIGhhbmRsZXIgd291bGQgb25seSBmaXJlIGlmIHRoZSBldmVudCBwYXNzZWQgdG8gaXQgd2FzIGZpcmVkXG4gICAgICAgIC8vIEFGVEVSIGl0IHdhcyBhdHRhY2hlZC5cbiAgICAgICAgaWYgKCFlLl92dHMpIHtcbiAgICAgICAgICAgIGUuX3Z0cyA9IERhdGUubm93KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZS5fdnRzIDw9IGludm9rZXIuYXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhwYXRjaFN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihlLCBpbnZva2VyLnZhbHVlKSwgaW5zdGFuY2UsIDUgLyogRXJyb3JDb2Rlcy5OQVRJVkVfRVZFTlRfSEFORExFUiAqLywgW2VdKTtcbiAgICB9O1xuICAgIGludm9rZXIudmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgaW52b2tlci5hdHRhY2hlZCA9IGdldE5vdygpO1xuICAgIHJldHVybiBpbnZva2VyO1xufVxuZnVuY3Rpb24gcGF0Y2hTdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oZSwgdmFsdWUpIHtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxTdG9wID0gZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb247XG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID0gKCkgPT4ge1xuICAgICAgICAgICAgb3JpZ2luYWxTdG9wLmNhbGwoZSk7XG4gICAgICAgICAgICBlLl9zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChmbiA9PiAoZSkgPT4gIWUuX3N0b3BwZWQgJiYgZm4gJiYgZm4oZSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cblxuY29uc3QgbmF0aXZlT25SRSA9IC9eb25bYS16XS87XG5jb25zdCBwYXRjaFByb3AgPSAoZWwsIGtleSwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIGlzU1ZHID0gZmFsc2UsIHByZXZDaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKSA9PiB7XG4gICAgaWYgKGtleSA9PT0gJ2NsYXNzJykge1xuICAgICAgICBwYXRjaENsYXNzKGVsLCBuZXh0VmFsdWUsIGlzU1ZHKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XG4gICAgICAgIHBhdGNoU3R5bGUoZWwsIHByZXZWYWx1ZSwgbmV4dFZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNPbihrZXkpKSB7XG4gICAgICAgIC8vIGlnbm9yZSB2LW1vZGVsIGxpc3RlbmVyc1xuICAgICAgICBpZiAoIWlzTW9kZWxMaXN0ZW5lcihrZXkpKSB7XG4gICAgICAgICAgICBwYXRjaEV2ZW50KGVsLCBrZXksIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBwYXJlbnRDb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGtleVswXSA9PT0gJy4nXG4gICAgICAgID8gKChrZXkgPSBrZXkuc2xpY2UoMSkpLCB0cnVlKVxuICAgICAgICA6IGtleVswXSA9PT0gJ14nXG4gICAgICAgICAgICA/ICgoa2V5ID0ga2V5LnNsaWNlKDEpKSwgZmFsc2UpXG4gICAgICAgICAgICA6IHNob3VsZFNldEFzUHJvcChlbCwga2V5LCBuZXh0VmFsdWUsIGlzU1ZHKSkge1xuICAgICAgICBwYXRjaERPTVByb3AoZWwsIGtleSwgbmV4dFZhbHVlLCBwcmV2Q2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIDxpbnB1dCB2LW1vZGVsIHR5cGU9XCJjaGVja2JveFwiPiB3aXRoXG4gICAgICAgIC8vIDp0cnVlLXZhbHVlICYgOmZhbHNlLXZhbHVlXG4gICAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIGRvbSBwcm9wZXJ0aWVzIHNpbmNlIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmVcbiAgICAgICAgLy8gc3RyaW5naWZpZWQuXG4gICAgICAgIGlmIChrZXkgPT09ICd0cnVlLXZhbHVlJykge1xuICAgICAgICAgICAgZWwuX3RydWVWYWx1ZSA9IG5leHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdmYWxzZS12YWx1ZScpIHtcbiAgICAgICAgICAgIGVsLl9mYWxzZVZhbHVlID0gbmV4dFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHBhdGNoQXR0cihlbCwga2V5LCBuZXh0VmFsdWUsIGlzU1ZHKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gc2hvdWxkU2V0QXNQcm9wKGVsLCBrZXksIHZhbHVlLCBpc1NWRykge1xuICAgIGlmIChpc1NWRykge1xuICAgICAgICAvLyBtb3N0IGtleXMgbXVzdCBiZSBzZXQgYXMgYXR0cmlidXRlIG9uIHN2ZyBlbGVtZW50cyB0byB3b3JrXG4gICAgICAgIC8vIC4uLmV4Y2VwdCBpbm5lckhUTUwgJiB0ZXh0Q29udGVudFxuICAgICAgICBpZiAoa2V5ID09PSAnaW5uZXJIVE1MJyB8fCBrZXkgPT09ICd0ZXh0Q29udGVudCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9yIG5hdGl2ZSBvbmNsaWNrIHdpdGggZnVuY3Rpb24gdmFsdWVzXG4gICAgICAgIGlmIChrZXkgaW4gZWwgJiYgbmF0aXZlT25SRS50ZXN0KGtleSkgJiYgaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gdGhlc2UgYXJlIGVudW1lcmF0ZWQgYXR0cnMsIGhvd2V2ZXIgdGhlaXIgY29ycmVzcG9uZGluZyBET00gcHJvcGVydGllc1xuICAgIC8vIGFyZSBhY3R1YWxseSBib29sZWFucyAtIHRoaXMgbGVhZHMgdG8gc2V0dGluZyBpdCB3aXRoIGEgc3RyaW5nIFwiZmFsc2VcIlxuICAgIC8vIHZhbHVlIGxlYWRpbmcgaXQgdG8gYmUgY29lcmNlZCB0byBgdHJ1ZWAsIHNvIHdlIG5lZWQgdG8gYWx3YXlzIHRyZWF0XG4gICAgLy8gdGhlbSBhcyBhdHRyaWJ1dGVzLlxuICAgIC8vIE5vdGUgdGhhdCBgY29udGVudEVkaXRhYmxlYCBkb2Vzbid0IGhhdmUgdGhpcyBwcm9ibGVtOiBpdHMgRE9NXG4gICAgLy8gcHJvcGVydHkgaXMgYWxzbyBlbnVtZXJhdGVkIHN0cmluZyB2YWx1ZXMuXG4gICAgaWYgKGtleSA9PT0gJ3NwZWxsY2hlY2snIHx8IGtleSA9PT0gJ2RyYWdnYWJsZScgfHwga2V5ID09PSAndHJhbnNsYXRlJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vICMxNzg3LCAjMjg0MCBmb3JtIHByb3BlcnR5IG9uIGZvcm0gZWxlbWVudHMgaXMgcmVhZG9ubHkgYW5kIG11c3QgYmUgc2V0IGFzXG4gICAgLy8gYXR0cmlidXRlLlxuICAgIGlmIChrZXkgPT09ICdmb3JtJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vICMxNTI2IDxpbnB1dCBsaXN0PiBtdXN0IGJlIHNldCBhcyBhdHRyaWJ1dGVcbiAgICBpZiAoa2V5ID09PSAnbGlzdCcgJiYgZWwudGFnTmFtZSA9PT0gJ0lOUFVUJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vICMyNzY2IDx0ZXh0YXJlYSB0eXBlPiBtdXN0IGJlIHNldCBhcyBhdHRyaWJ1dGVcbiAgICBpZiAoa2V5ID09PSAndHlwZScgJiYgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIG5hdGl2ZSBvbmNsaWNrIHdpdGggc3RyaW5nIHZhbHVlLCBtdXN0IGJlIHNldCBhcyBhdHRyaWJ1dGVcbiAgICBpZiAobmF0aXZlT25SRS50ZXN0KGtleSkgJiYgaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGtleSBpbiBlbDtcbn1cblxuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRWxlbWVudChvcHRpb25zLCBoeWRyYXRlKSB7XG4gICAgY29uc3QgQ29tcCA9IGRlZmluZUNvbXBvbmVudChvcHRpb25zKTtcbiAgICBjbGFzcyBWdWVDdXN0b21FbGVtZW50IGV4dGVuZHMgVnVlRWxlbWVudCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGluaXRpYWxQcm9wcykge1xuICAgICAgICAgICAgc3VwZXIoQ29tcCwgaW5pdGlhbFByb3BzLCBoeWRyYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBWdWVDdXN0b21FbGVtZW50LmRlZiA9IENvbXA7XG4gICAgcmV0dXJuIFZ1ZUN1c3RvbUVsZW1lbnQ7XG59XG5jb25zdCBkZWZpbmVTU1JDdXN0b21FbGVtZW50ID0gKChvcHRpb25zKSA9PiB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBkZWZpbmVDdXN0b21FbGVtZW50KG9wdGlvbnMsIGh5ZHJhdGUpO1xufSk7XG5jb25zdCBCYXNlQ2xhc3MgPSAodHlwZW9mIEhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJyA/IEhUTUxFbGVtZW50IDogY2xhc3Mge1xufSk7XG5jbGFzcyBWdWVFbGVtZW50IGV4dGVuZHMgQmFzZUNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihfZGVmLCBfcHJvcHMgPSB7fSwgaHlkcmF0ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9kZWYgPSBfZGVmO1xuICAgICAgICB0aGlzLl9wcm9wcyA9IF9wcm9wcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbnVtYmVyUHJvcHMgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5zaGFkb3dSb290ICYmIGh5ZHJhdGUpIHtcbiAgICAgICAgICAgIGh5ZHJhdGUodGhpcy5fY3JlYXRlVk5vZGUoKSwgdGhpcy5zaGFkb3dSb290KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgdGhpcy5zaGFkb3dSb290KSB7XG4gICAgICAgICAgICAgICAgd2FybihgQ3VzdG9tIGVsZW1lbnQgaGFzIHByZS1yZW5kZXJlZCBkZWNsYXJhdGl2ZSBzaGFkb3cgcm9vdCBidXQgaXMgbm90IGAgK1xuICAgICAgICAgICAgICAgICAgICBgZGVmaW5lZCBhcyBoeWRyYXRhYmxlLiBVc2UgXFxgZGVmaW5lU1NSQ3VzdG9tRWxlbWVudFxcYC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9kZWYuX19hc3luY0xvYWRlcikge1xuICAgICAgICAgICAgICAgIC8vIGZvciBzeW5jIGNvbXBvbmVudCBkZWZzIHdlIGNhbiBpbW1lZGlhdGVseSByZXNvbHZlIHByb3BzXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZVByb3BzKHRoaXMuX2RlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy5faW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZXNvbHZlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZURlZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZW5kZXIobnVsbCwgdGhpcy5zaGFkb3dSb290KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiByZXNvbHZlIGlubmVyIGNvbXBvbmVudCBkZWZpbml0aW9uIChoYW5kbGUgcG9zc2libGUgYXN5bmMgY29tcG9uZW50KVxuICAgICAqL1xuICAgIF9yZXNvbHZlRGVmKCkge1xuICAgICAgICB0aGlzLl9yZXNvbHZlZCA9IHRydWU7XG4gICAgICAgIC8vIHNldCBpbml0aWFsIGF0dHJzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRBdHRyKHRoaXMuYXR0cmlidXRlc1tpXS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3YXRjaCBmdXR1cmUgYXR0ciBjaGFuZ2VzXG4gICAgICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKG11dGF0aW9ucyA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG0gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0QXR0cihtLmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5vYnNlcnZlKHRoaXMsIHsgYXR0cmlidXRlczogdHJ1ZSB9KTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZSA9IChkZWYsIGlzQXN5bmMgPSBmYWxzZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBwcm9wcywgc3R5bGVzIH0gPSBkZWY7XG4gICAgICAgICAgICAvLyBjYXN0IE51bWJlci10eXBlIHByb3BzIHNldCBiZWZvcmUgcmVzb2x2ZVxuICAgICAgICAgICAgbGV0IG51bWJlclByb3BzO1xuICAgICAgICAgICAgaWYgKHByb3BzICYmICFpc0FycmF5KHByb3BzKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wdCA9IHByb3BzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHQgPT09IE51bWJlciB8fCAob3B0ICYmIG9wdC50eXBlID09PSBOdW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5IGluIHRoaXMuX3Byb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvcHNba2V5XSA9IHRvTnVtYmVyKHRoaXMuX3Byb3BzW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgKG51bWJlclByb3BzIHx8IChudW1iZXJQcm9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCkpKVtjYW1lbGl6ZSQxKGtleSldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX251bWJlclByb3BzID0gbnVtYmVyUHJvcHM7XG4gICAgICAgICAgICBpZiAoaXNBc3luYykge1xuICAgICAgICAgICAgICAgIC8vIGRlZmluaW5nIGdldHRlci9zZXR0ZXJzIG9uIHByb3RvdHlwZVxuICAgICAgICAgICAgICAgIC8vIGZvciBzeW5jIGRlZnMsIHRoaXMgYWxyZWFkeSBoYXBwZW5lZCBpbiB0aGUgY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlUHJvcHMoZGVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFwcGx5IENTU1xuICAgICAgICAgICAgdGhpcy5fYXBwbHlTdHlsZXMoc3R5bGVzKTtcbiAgICAgICAgICAgIC8vIGluaXRpYWwgcmVuZGVyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYXN5bmNEZWYgPSB0aGlzLl9kZWYuX19hc3luY0xvYWRlcjtcbiAgICAgICAgaWYgKGFzeW5jRGVmKSB7XG4gICAgICAgICAgICBhc3luY0RlZigpLnRoZW4oZGVmID0+IHJlc29sdmUoZGVmLCB0cnVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMuX2RlZik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3Jlc29sdmVQcm9wcyhkZWYpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gZGVmO1xuICAgICAgICBjb25zdCBkZWNsYXJlZFByb3BLZXlzID0gaXNBcnJheShwcm9wcykgPyBwcm9wcyA6IE9iamVjdC5rZXlzKHByb3BzIHx8IHt9KTtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIHByb3BzIHNldCBwcmUtdXBncmFkZSBvciBjb25uZWN0XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMpKSB7XG4gICAgICAgICAgICBpZiAoa2V5WzBdICE9PSAnXycgJiYgZGVjbGFyZWRQcm9wS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0UHJvcChrZXksIHRoaXNba2V5XSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGRlZmluaW5nIGdldHRlci9zZXR0ZXJzIG9uIHByb3RvdHlwZVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBkZWNsYXJlZFByb3BLZXlzLm1hcChjYW1lbGl6ZSQxKSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFByb3Aoa2V5KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldCh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UHJvcChrZXksIHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3NldEF0dHIoa2V5KSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKGtleSk7XG4gICAgICAgIGNvbnN0IGNhbWVsS2V5ID0gY2FtZWxpemUkMShrZXkpO1xuICAgICAgICBpZiAodGhpcy5fbnVtYmVyUHJvcHMgJiYgdGhpcy5fbnVtYmVyUHJvcHNbY2FtZWxLZXldKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRQcm9wKGNhbWVsS2V5LCB2YWx1ZSwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfZ2V0UHJvcChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BzW2tleV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9zZXRQcm9wKGtleSwgdmFsLCBzaG91bGRSZWZsZWN0ID0gdHJ1ZSwgc2hvdWxkVXBkYXRlID0gdHJ1ZSkge1xuICAgICAgICBpZiAodmFsICE9PSB0aGlzLl9wcm9wc1trZXldKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9wc1trZXldID0gdmFsO1xuICAgICAgICAgICAgaWYgKHNob3VsZFVwZGF0ZSAmJiB0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVmbGVjdFxuICAgICAgICAgICAgaWYgKHNob3VsZFJlZmxlY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGh5cGhlbmF0ZShrZXkpLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGh5cGhlbmF0ZShrZXkpLCB2YWwgKyAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoaHlwaGVuYXRlKGtleSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfdXBkYXRlKCkge1xuICAgICAgICByZW5kZXIodGhpcy5fY3JlYXRlVk5vZGUoKSwgdGhpcy5zaGFkb3dSb290KTtcbiAgICB9XG4gICAgX2NyZWF0ZVZOb2RlKCkge1xuICAgICAgICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKHRoaXMuX2RlZiwgZXh0ZW5kKHt9LCB0aGlzLl9wcm9wcykpO1xuICAgICAgICBpZiAoIXRoaXMuX2luc3RhbmNlKSB7XG4gICAgICAgICAgICB2bm9kZS5jZSA9IGluc3RhbmNlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLmlzQ0UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIEhNUlxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuY2VSZWxvYWQgPSBuZXdTdHlsZXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWx3YXlzIHJlc2V0IHN0eWxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0eWxlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0eWxlcy5mb3JFYWNoKHMgPT4gdGhpcy5zaGFkb3dSb290LnJlbW92ZUNoaWxkKHMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdHlsZXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5U3R5bGVzKG5ld1N0eWxlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzcGF0Y2ggPSAoZXZlbnQsIGFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChldmVudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiBhcmdzXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIGludGVyY2VwdCBlbWl0XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZW1pdCA9IChldmVudCwgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBkaXNwYXRjaCBib3RoIHRoZSByYXcgYW5kIGh5cGhlbmF0ZWQgdmVyc2lvbnMgb2YgYW4gZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gbWF0Y2ggVnVlIGJlaGF2aW9yXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKGV2ZW50LCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGh5cGhlbmF0ZShldmVudCkgIT09IGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChoeXBoZW5hdGUoZXZlbnQpLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gbG9jYXRlIG5lYXJlc3QgVnVlIGN1c3RvbSBlbGVtZW50IHBhcmVudCBmb3IgcHJvdmlkZS9pbmplY3RcbiAgICAgICAgICAgICAgICBsZXQgcGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgICAgICB3aGlsZSAoKHBhcmVudCA9XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCAmJiAocGFyZW50LnBhcmVudE5vZGUgfHwgcGFyZW50Lmhvc3QpKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgVnVlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UucGFyZW50ID0gcGFyZW50Ll9pbnN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnByb3ZpZGVzID0gcGFyZW50Ll9pbnN0YW5jZS5wcm92aWRlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm5vZGU7XG4gICAgfVxuICAgIF9hcHBseVN0eWxlcyhzdHlsZXMpIHtcbiAgICAgICAgaWYgKHN0eWxlcykge1xuICAgICAgICAgICAgc3R5bGVzLmZvckVhY2goY3NzID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgICAgICAgICBzLnRleHRDb250ZW50ID0gY3NzO1xuICAgICAgICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZChzKTtcbiAgICAgICAgICAgICAgICAvLyByZWNvcmQgZm9yIEhNUlxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuX3N0eWxlcyB8fCAodGhpcy5fc3R5bGVzID0gW10pKS5wdXNoKHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiB1c2VDc3NNb2R1bGUobmFtZSA9ICckc3R5bGUnKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGB1c2VDc3NNb2R1bGUgbXVzdCBiZSBjYWxsZWQgaW5zaWRlIHNldHVwKClgKTtcbiAgICAgICAgICAgIHJldHVybiBFTVBUWV9PQko7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kdWxlcyA9IGluc3RhbmNlLnR5cGUuX19jc3NNb2R1bGVzO1xuICAgICAgICBpZiAoIW1vZHVsZXMpIHtcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGBDdXJyZW50IGluc3RhbmNlIGRvZXMgbm90IGhhdmUgQ1NTIG1vZHVsZXMgaW5qZWN0ZWQuYCk7XG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfT0JKO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vZCA9IG1vZHVsZXNbbmFtZV07XG4gICAgICAgIGlmICghbW9kKSB7XG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgICAgICB3YXJuKGBDdXJyZW50IGluc3RhbmNlIGRvZXMgbm90IGhhdmUgQ1NTIG1vZHVsZSBuYW1lZCBcIiR7bmFtZX1cIi5gKTtcbiAgICAgICAgICAgIHJldHVybiBFTVBUWV9PQko7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZDtcbiAgICB9XG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIFNGQydzIENTUyB2YXJpYWJsZSBpbmplY3Rpb24gZmVhdHVyZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHVzZUNzc1ZhcnMoZ2V0dGVyKSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICB3YXJuKGB1c2VDc3NWYXJzIGlzIGNhbGxlZCB3aXRob3V0IGN1cnJlbnQgYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZS5gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB1cGRhdGVUZWxlcG9ydHMgPSAoaW5zdGFuY2UudXQgPSAodmFycyA9IGdldHRlcihpbnN0YW5jZS5wcm94eSkpID0+IHtcbiAgICAgICAgQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGBbZGF0YS12LW93bmVyPVwiJHtpbnN0YW5jZS51aWR9XCJdYCkpLmZvckVhY2gobm9kZSA9PiBzZXRWYXJzT25Ob2RlKG5vZGUsIHZhcnMpKTtcbiAgICB9KTtcbiAgICBjb25zdCBzZXRWYXJzID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB2YXJzID0gZ2V0dGVyKGluc3RhbmNlLnByb3h5KTtcbiAgICAgICAgc2V0VmFyc09uVk5vZGUoaW5zdGFuY2Uuc3ViVHJlZSwgdmFycyk7XG4gICAgICAgIHVwZGF0ZVRlbGVwb3J0cyh2YXJzKTtcbiAgICB9O1xuICAgIHdhdGNoUG9zdEVmZmVjdChzZXRWYXJzKTtcbiAgICBvbk1vdW50ZWQoKCkgPT4ge1xuICAgICAgICBjb25zdCBvYiA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHNldFZhcnMpO1xuICAgICAgICBvYi5vYnNlcnZlKGluc3RhbmNlLnN1YlRyZWUuZWwucGFyZW50Tm9kZSwgeyBjaGlsZExpc3Q6IHRydWUgfSk7XG4gICAgICAgIG9uVW5tb3VudGVkKCgpID0+IG9iLmRpc2Nvbm5lY3QoKSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzZXRWYXJzT25WTm9kZSh2bm9kZSwgdmFycykge1xuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxMjggLyogU2hhcGVGbGFncy5TVVNQRU5TRSAqLykge1xuICAgICAgICBjb25zdCBzdXNwZW5zZSA9IHZub2RlLnN1c3BlbnNlO1xuICAgICAgICB2bm9kZSA9IHN1c3BlbnNlLmFjdGl2ZUJyYW5jaDtcbiAgICAgICAgaWYgKHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggJiYgIXN1c3BlbnNlLmlzSHlkcmF0aW5nKSB7XG4gICAgICAgICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldFZhcnNPblZOb2RlKHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCwgdmFycyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBkcmlsbCBkb3duIEhPQ3MgdW50aWwgaXQncyBhIG5vbi1jb21wb25lbnQgdm5vZGVcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50KSB7XG4gICAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50LnN1YlRyZWU7XG4gICAgfVxuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxIC8qIFNoYXBlRmxhZ3MuRUxFTUVOVCAqLyAmJiB2bm9kZS5lbCkge1xuICAgICAgICBzZXRWYXJzT25Ob2RlKHZub2RlLmVsLCB2YXJzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodm5vZGUudHlwZSA9PT0gRnJhZ21lbnQpIHtcbiAgICAgICAgdm5vZGUuY2hpbGRyZW4uZm9yRWFjaChjID0+IHNldFZhcnNPblZOb2RlKGMsIHZhcnMpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodm5vZGUudHlwZSA9PT0gU3RhdGljKSB7XG4gICAgICAgIGxldCB7IGVsLCBhbmNob3IgfSA9IHZub2RlO1xuICAgICAgICB3aGlsZSAoZWwpIHtcbiAgICAgICAgICAgIHNldFZhcnNPbk5vZGUoZWwsIHZhcnMpO1xuICAgICAgICAgICAgaWYgKGVsID09PSBhbmNob3IpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBlbCA9IGVsLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0VmFyc09uTm9kZShlbCwgdmFycykge1xuICAgIGlmIChlbC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YXJzKSB7XG4gICAgICAgICAgICBzdHlsZS5zZXRQcm9wZXJ0eShgLS0ke2tleX1gLCB2YXJzW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xuY29uc3QgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG4vLyBET00gVHJhbnNpdGlvbiBpcyBhIGhpZ2hlci1vcmRlci1jb21wb25lbnQgYmFzZWQgb24gdGhlIHBsYXRmb3JtLWFnbm9zdGljXG4vLyBiYXNlIFRyYW5zaXRpb24gY29tcG9uZW50LCB3aXRoIERPTS1zcGVjaWZpYyBsb2dpYy5cbmNvbnN0IFRyYW5zaXRpb24gPSAocHJvcHMsIHsgc2xvdHMgfSkgPT4gaChCYXNlVHJhbnNpdGlvbiwgcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhwcm9wcyksIHNsb3RzKTtcblRyYW5zaXRpb24uZGlzcGxheU5hbWUgPSAnVHJhbnNpdGlvbic7XG5jb25zdCBET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzID0ge1xuICAgIG5hbWU6IFN0cmluZyxcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgY3NzOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9LFxuICAgIGR1cmF0aW9uOiBbU3RyaW5nLCBOdW1iZXIsIE9iamVjdF0sXG4gICAgZW50ZXJGcm9tQ2xhc3M6IFN0cmluZyxcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gICAgYXBwZWFyRnJvbUNsYXNzOiBTdHJpbmcsXG4gICAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXG4gICAgbGVhdmVGcm9tQ2xhc3M6IFN0cmluZyxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgbGVhdmVUb0NsYXNzOiBTdHJpbmdcbn07XG5jb25zdCBUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzID0gKFRyYW5zaXRpb24ucHJvcHMgPVxuICAgIC8qI19fUFVSRV9fKi8gZXh0ZW5kKHt9LCBCYXNlVHJhbnNpdGlvbi5wcm9wcywgRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycykpO1xuLyoqXG4gKiAjMzIyNyBJbmNvbWluZyBob29rcyBtYXkgYmUgbWVyZ2VkIGludG8gYXJyYXlzIHdoZW4gd3JhcHBpbmcgVHJhbnNpdGlvblxuICogd2l0aCBjdXN0b20gSE9Dcy5cbiAqL1xuY29uc3QgY2FsbEhvb2sgPSAoaG9vaywgYXJncyA9IFtdKSA9PiB7XG4gICAgaWYgKGlzQXJyYXkoaG9vaykpIHtcbiAgICAgICAgaG9vay5mb3JFYWNoKGggPT4gaCguLi5hcmdzKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhvb2spIHtcbiAgICAgICAgaG9vayguLi5hcmdzKTtcbiAgICB9XG59O1xuLyoqXG4gKiBDaGVjayBpZiBhIGhvb2sgZXhwZWN0cyBhIGNhbGxiYWNrICgybmQgYXJnKSwgd2hpY2ggbWVhbnMgdGhlIHVzZXJcbiAqIGludGVuZHMgdG8gZXhwbGljaXRseSBjb250cm9sIHRoZSBlbmQgb2YgdGhlIHRyYW5zaXRpb24uXG4gKi9cbmNvbnN0IGhhc0V4cGxpY2l0Q2FsbGJhY2sgPSAoaG9vaykgPT4ge1xuICAgIHJldHVybiBob29rXG4gICAgICAgID8gaXNBcnJheShob29rKVxuICAgICAgICAgICAgPyBob29rLnNvbWUoaCA9PiBoLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICA6IGhvb2subGVuZ3RoID4gMVxuICAgICAgICA6IGZhbHNlO1xufTtcbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uUHJvcHMocmF3UHJvcHMpIHtcbiAgICBjb25zdCBiYXNlUHJvcHMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiByYXdQcm9wcykge1xuICAgICAgICBpZiAoIShrZXkgaW4gRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycykpIHtcbiAgICAgICAgICAgIGJhc2VQcm9wc1trZXldID0gcmF3UHJvcHNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocmF3UHJvcHMuY3NzID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gYmFzZVByb3BzO1xuICAgIH1cbiAgICBjb25zdCB7IG5hbWUgPSAndicsIHR5cGUsIGR1cmF0aW9uLCBlbnRlckZyb21DbGFzcyA9IGAke25hbWV9LWVudGVyLWZyb21gLCBlbnRlckFjdGl2ZUNsYXNzID0gYCR7bmFtZX0tZW50ZXItYWN0aXZlYCwgZW50ZXJUb0NsYXNzID0gYCR7bmFtZX0tZW50ZXItdG9gLCBhcHBlYXJGcm9tQ2xhc3MgPSBlbnRlckZyb21DbGFzcywgYXBwZWFyQWN0aXZlQ2xhc3MgPSBlbnRlckFjdGl2ZUNsYXNzLCBhcHBlYXJUb0NsYXNzID0gZW50ZXJUb0NsYXNzLCBsZWF2ZUZyb21DbGFzcyA9IGAke25hbWV9LWxlYXZlLWZyb21gLCBsZWF2ZUFjdGl2ZUNsYXNzID0gYCR7bmFtZX0tbGVhdmUtYWN0aXZlYCwgbGVhdmVUb0NsYXNzID0gYCR7bmFtZX0tbGVhdmUtdG9gIH0gPSByYXdQcm9wcztcbiAgICBjb25zdCBkdXJhdGlvbnMgPSBub3JtYWxpemVEdXJhdGlvbihkdXJhdGlvbik7XG4gICAgY29uc3QgZW50ZXJEdXJhdGlvbiA9IGR1cmF0aW9ucyAmJiBkdXJhdGlvbnNbMF07XG4gICAgY29uc3QgbGVhdmVEdXJhdGlvbiA9IGR1cmF0aW9ucyAmJiBkdXJhdGlvbnNbMV07XG4gICAgY29uc3QgeyBvbkJlZm9yZUVudGVyLCBvbkVudGVyLCBvbkVudGVyQ2FuY2VsbGVkLCBvbkxlYXZlLCBvbkxlYXZlQ2FuY2VsbGVkLCBvbkJlZm9yZUFwcGVhciA9IG9uQmVmb3JlRW50ZXIsIG9uQXBwZWFyID0gb25FbnRlciwgb25BcHBlYXJDYW5jZWxsZWQgPSBvbkVudGVyQ2FuY2VsbGVkIH0gPSBiYXNlUHJvcHM7XG4gICAgY29uc3QgZmluaXNoRW50ZXIgPSAoZWwsIGlzQXBwZWFyLCBkb25lKSA9PiB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJUb0NsYXNzIDogZW50ZXJUb0NsYXNzKTtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhckFjdGl2ZUNsYXNzIDogZW50ZXJBY3RpdmVDbGFzcyk7XG4gICAgICAgIGRvbmUgJiYgZG9uZSgpO1xuICAgIH07XG4gICAgY29uc3QgZmluaXNoTGVhdmUgPSAoZWwsIGRvbmUpID0+IHtcbiAgICAgICAgZWwuX2lzTGVhdmluZyA9IGZhbHNlO1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlRnJvbUNsYXNzKTtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgICBkb25lICYmIGRvbmUoKTtcbiAgICB9O1xuICAgIGNvbnN0IG1ha2VFbnRlckhvb2sgPSAoaXNBcHBlYXIpID0+IHtcbiAgICAgICAgcmV0dXJuIChlbCwgZG9uZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaG9vayA9IGlzQXBwZWFyID8gb25BcHBlYXIgOiBvbkVudGVyO1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZSA9ICgpID0+IGZpbmlzaEVudGVyKGVsLCBpc0FwcGVhciwgZG9uZSk7XG4gICAgICAgICAgICBjYWxsSG9vayhob29rLCBbZWwsIHJlc29sdmVdKTtcbiAgICAgICAgICAgIG5leHRGcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhckZyb21DbGFzcyA6IGVudGVyRnJvbUNsYXNzKTtcbiAgICAgICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyVG9DbGFzcyA6IGVudGVyVG9DbGFzcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNFeHBsaWNpdENhbGxiYWNrKGhvb2spKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgZW50ZXJEdXJhdGlvbiwgcmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gZXh0ZW5kKGJhc2VQcm9wcywge1xuICAgICAgICBvbkJlZm9yZUVudGVyKGVsKSB7XG4gICAgICAgICAgICBjYWxsSG9vayhvbkJlZm9yZUVudGVyLCBbZWxdKTtcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgZW50ZXJGcm9tQ2xhc3MpO1xuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBlbnRlckFjdGl2ZUNsYXNzKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25CZWZvcmVBcHBlYXIoZWwpIHtcbiAgICAgICAgICAgIGNhbGxIb29rKG9uQmVmb3JlQXBwZWFyLCBbZWxdKTtcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYXBwZWFyRnJvbUNsYXNzKTtcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYXBwZWFyQWN0aXZlQ2xhc3MpO1xuICAgICAgICB9LFxuICAgICAgICBvbkVudGVyOiBtYWtlRW50ZXJIb29rKGZhbHNlKSxcbiAgICAgICAgb25BcHBlYXI6IG1ha2VFbnRlckhvb2sodHJ1ZSksXG4gICAgICAgIG9uTGVhdmUoZWwsIGRvbmUpIHtcbiAgICAgICAgICAgIGVsLl9pc0xlYXZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZSA9ICgpID0+IGZpbmlzaExlYXZlKGVsLCBkb25lKTtcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVGcm9tQ2xhc3MpO1xuICAgICAgICAgICAgLy8gZm9yY2UgcmVmbG93IHNvICotbGVhdmUtZnJvbSBjbGFzc2VzIGltbWVkaWF0ZWx5IHRha2UgZWZmZWN0ICgjMjU5MylcbiAgICAgICAgICAgIGZvcmNlUmVmbG93KCk7XG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgICAgICAgbmV4dEZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWVsLl9pc0xlYXZpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FuY2VsbGVkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUZyb21DbGFzcyk7XG4gICAgICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICAgICAgICAgIGlmICghaGFzRXhwbGljaXRDYWxsYmFjayhvbkxlYXZlKSkge1xuICAgICAgICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGxlYXZlRHVyYXRpb24sIHJlc29sdmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FsbEhvb2sob25MZWF2ZSwgW2VsLCByZXNvbHZlXSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRW50ZXJDYW5jZWxsZWQoZWwpIHtcbiAgICAgICAgICAgIGZpbmlzaEVudGVyKGVsLCBmYWxzZSk7XG4gICAgICAgICAgICBjYWxsSG9vayhvbkVudGVyQ2FuY2VsbGVkLCBbZWxdKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25BcHBlYXJDYW5jZWxsZWQoZWwpIHtcbiAgICAgICAgICAgIGZpbmlzaEVudGVyKGVsLCB0cnVlKTtcbiAgICAgICAgICAgIGNhbGxIb29rKG9uQXBwZWFyQ2FuY2VsbGVkLCBbZWxdKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25MZWF2ZUNhbmNlbGxlZChlbCkge1xuICAgICAgICAgICAgZmluaXNoTGVhdmUoZWwpO1xuICAgICAgICAgICAgY2FsbEhvb2sob25MZWF2ZUNhbmNlbGxlZCwgW2VsXSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUR1cmF0aW9uKGR1cmF0aW9uKSB7XG4gICAgaWYgKGR1cmF0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KGR1cmF0aW9uKSkge1xuICAgICAgICByZXR1cm4gW051bWJlck9mKGR1cmF0aW9uLmVudGVyKSwgTnVtYmVyT2YoZHVyYXRpb24ubGVhdmUpXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG4gPSBOdW1iZXJPZihkdXJhdGlvbik7XG4gICAgICAgIHJldHVybiBbbiwgbl07XG4gICAgfVxufVxuZnVuY3Rpb24gTnVtYmVyT2YodmFsKSB7XG4gICAgY29uc3QgcmVzID0gdG9OdW1iZXIodmFsKTtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKVxuICAgICAgICB2YWxpZGF0ZUR1cmF0aW9uKHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRHVyYXRpb24odmFsKSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHdhcm4oYDx0cmFuc2l0aW9uPiBleHBsaWNpdCBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBgICtcbiAgICAgICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeSh2YWwpfS5gKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgICAgICB3YXJuKGA8dHJhbnNpdGlvbj4gZXhwbGljaXQgZHVyYXRpb24gaXMgTmFOIC0gYCArXG4gICAgICAgICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgY2xzKSB7XG4gICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChjID0+IGMgJiYgZWwuY2xhc3NMaXN0LmFkZChjKSk7XG4gICAgKGVsLl92dGMgfHxcbiAgICAgICAgKGVsLl92dGMgPSBuZXcgU2V0KCkpKS5hZGQoY2xzKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgY2xzKSB7XG4gICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChjID0+IGMgJiYgZWwuY2xhc3NMaXN0LnJlbW92ZShjKSk7XG4gICAgY29uc3QgeyBfdnRjIH0gPSBlbDtcbiAgICBpZiAoX3Z0Yykge1xuICAgICAgICBfdnRjLmRlbGV0ZShjbHMpO1xuICAgICAgICBpZiAoIV92dGMuc2l6ZSkge1xuICAgICAgICAgICAgZWwuX3Z0YyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG5leHRGcmFtZShjYikge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYik7XG4gICAgfSk7XG59XG5sZXQgZW5kSWQgPSAwO1xuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzKGVsLCBleHBlY3RlZFR5cGUsIGV4cGxpY2l0VGltZW91dCwgcmVzb2x2ZSkge1xuICAgIGNvbnN0IGlkID0gKGVsLl9lbmRJZCA9ICsrZW5kSWQpO1xuICAgIGNvbnN0IHJlc29sdmVJZk5vdFN0YWxlID0gKCkgPT4ge1xuICAgICAgICBpZiAoaWQgPT09IGVsLl9lbmRJZCkge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpZiAoZXhwbGljaXRUaW1lb3V0KSB7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KHJlc29sdmVJZk5vdFN0YWxlLCBleHBsaWNpdFRpbWVvdXQpO1xuICAgIH1cbiAgICBjb25zdCB7IHR5cGUsIHRpbWVvdXQsIHByb3BDb3VudCB9ID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IGVuZEV2ZW50ID0gdHlwZSArICdlbmQnO1xuICAgIGxldCBlbmRlZCA9IDA7XG4gICAgY29uc3QgZW5kID0gKCkgPT4ge1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGVuZEV2ZW50LCBvbkVuZCk7XG4gICAgICAgIHJlc29sdmVJZk5vdFN0YWxlKCk7XG4gICAgfTtcbiAgICBjb25zdCBvbkVuZCA9IChlKSA9PiB7XG4gICAgICAgIGlmIChlLnRhcmdldCA9PT0gZWwgJiYgKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcbiAgICAgICAgICAgIGVuZCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICAgICAgICBlbmQoKTtcbiAgICAgICAgfVxuICAgIH0sIHRpbWVvdXQgKyAxKTtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKGVuZEV2ZW50LCBvbkVuZCk7XG59XG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKSB7XG4gICAgY29uc3Qgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgIC8vIEpTRE9NIG1heSByZXR1cm4gdW5kZWZpbmVkIGZvciB0cmFuc2l0aW9uIHByb3BlcnRpZXNcbiAgICBjb25zdCBnZXRTdHlsZVByb3BlcnRpZXMgPSAoa2V5KSA9PiAoc3R5bGVzW2tleV0gfHwgJycpLnNwbGl0KCcsICcpO1xuICAgIGNvbnN0IHRyYW5zaXRpb25EZWxheXMgPSBnZXRTdHlsZVByb3BlcnRpZXMoYCR7VFJBTlNJVElPTn1EZWxheWApO1xuICAgIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbnMgPSBnZXRTdHlsZVByb3BlcnRpZXMoYCR7VFJBTlNJVElPTn1EdXJhdGlvbmApO1xuICAgIGNvbnN0IHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcbiAgICBjb25zdCBhbmltYXRpb25EZWxheXMgPSBnZXRTdHlsZVByb3BlcnRpZXMoYCR7QU5JTUFUSU9OfURlbGF5YCk7XG4gICAgY29uc3QgYW5pbWF0aW9uRHVyYXRpb25zID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke0FOSU1BVElPTn1EdXJhdGlvbmApO1xuICAgIGNvbnN0IGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcbiAgICBsZXQgdHlwZSA9IG51bGw7XG4gICAgbGV0IHRpbWVvdXQgPSAwO1xuICAgIGxldCBwcm9wQ291bnQgPSAwO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcbiAgICAgICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICAgICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICAgICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuICAgICAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgICAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICAgICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgICAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgICAgIHR5cGUgPVxuICAgICAgICAgICAgdGltZW91dCA+IDBcbiAgICAgICAgICAgICAgICA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dFxuICAgICAgICAgICAgICAgICAgICA/IFRSQU5TSVRJT05cbiAgICAgICAgICAgICAgICAgICAgOiBBTklNQVRJT05cbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIHByb3BDb3VudCA9IHR5cGVcbiAgICAgICAgICAgID8gdHlwZSA9PT0gVFJBTlNJVElPTlxuICAgICAgICAgICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgICAgIDogMDtcbiAgICB9XG4gICAgY29uc3QgaGFzVHJhbnNmb3JtID0gdHlwZSA9PT0gVFJBTlNJVElPTiAmJlxuICAgICAgICAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvLnRlc3QoZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke1RSQU5TSVRJT059UHJvcGVydHlgKS50b1N0cmluZygpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlLFxuICAgICAgICB0aW1lb3V0LFxuICAgICAgICBwcm9wQ291bnQsXG4gICAgICAgIGhhc1RyYW5zZm9ybVxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRUaW1lb3V0KGRlbGF5cywgZHVyYXRpb25zKSB7XG4gICAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubWF4KC4uLmR1cmF0aW9ucy5tYXAoKGQsIGkpID0+IHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSkpKTtcbn1cbi8vIE9sZCB2ZXJzaW9ucyBvZiBDaHJvbWl1bSAoYmVsb3cgNjEuMC4zMTYzLjEwMCkgZm9ybWF0cyBmbG9hdGluZyBwb2ludGVyXG4vLyBudW1iZXJzIGluIGEgbG9jYWxlLWRlcGVuZGVudCB3YXksIHVzaW5nIGEgY29tbWEgaW5zdGVhZCBvZiBhIGRvdC5cbi8vIElmIGNvbW1hIGlzIG5vdCByZXBsYWNlZCB3aXRoIGEgZG90LCB0aGUgaW5wdXQgd2lsbCBiZSByb3VuZGVkIGRvd25cbi8vIChpLmUuIGFjdGluZyBhcyBhIGZsb29yIGZ1bmN0aW9uKSBjYXVzaW5nIHVuZXhwZWN0ZWQgYmVoYXZpb3JzXG5mdW5jdGlvbiB0b01zKHMpIHtcbiAgICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpLnJlcGxhY2UoJywnLCAnLicpKSAqIDEwMDA7XG59XG4vLyBzeW5jaHJvbm91c2x5IGZvcmNlIGxheW91dCB0byBwdXQgZWxlbWVudHMgaW50byBhIGNlcnRhaW4gc3RhdGVcbmZ1bmN0aW9uIGZvcmNlUmVmbG93KCkge1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcbn1cblxuY29uc3QgcG9zaXRpb25NYXAgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgbmV3UG9zaXRpb25NYXAgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgVHJhbnNpdGlvbkdyb3VwSW1wbCA9IHtcbiAgICBuYW1lOiAnVHJhbnNpdGlvbkdyb3VwJyxcbiAgICBwcm9wczogLyojX19QVVJFX18qLyBleHRlbmQoe30sIFRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMsIHtcbiAgICAgICAgdGFnOiBTdHJpbmcsXG4gICAgICAgIG1vdmVDbGFzczogU3RyaW5nXG4gICAgfSksXG4gICAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHVzZVRyYW5zaXRpb25TdGF0ZSgpO1xuICAgICAgICBsZXQgcHJldkNoaWxkcmVuO1xuICAgICAgICBsZXQgY2hpbGRyZW47XG4gICAgICAgIG9uVXBkYXRlZCgoKSA9PiB7XG4gICAgICAgICAgICAvLyBjaGlsZHJlbiBpcyBndWFyYW50ZWVkIHRvIGV4aXN0IGFmdGVyIGluaXRpYWwgcmVuZGVyXG4gICAgICAgICAgICBpZiAoIXByZXZDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtb3ZlQ2xhc3MgPSBwcm9wcy5tb3ZlQ2xhc3MgfHwgYCR7cHJvcHMubmFtZSB8fCAndid9LW1vdmVgO1xuICAgICAgICAgICAgaWYgKCFoYXNDU1NUcmFuc2Zvcm0ocHJldkNoaWxkcmVuWzBdLmVsLCBpbnN0YW5jZS52bm9kZS5lbCwgbW92ZUNsYXNzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuICAgICAgICAgICAgLy8gaW4gZWFjaCBpdGVyYXRpb24gLSB3aGljaCBoZWxwcyBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcuXG4gICAgICAgICAgICBwcmV2Q2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XG4gICAgICAgICAgICBwcmV2Q2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG4gICAgICAgICAgICBjb25zdCBtb3ZlZENoaWxkcmVuID0gcHJldkNoaWxkcmVuLmZpbHRlcihhcHBseVRyYW5zbGF0aW9uKTtcbiAgICAgICAgICAgIC8vIGZvcmNlIHJlZmxvdyB0byBwdXQgZXZlcnl0aGluZyBpbiBwb3NpdGlvblxuICAgICAgICAgICAgZm9yY2VSZWZsb3coKTtcbiAgICAgICAgICAgIG1vdmVkQ2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbCA9IGMuZWw7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBlbC5zdHlsZTtcbiAgICAgICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgICAgICAgc3R5bGUudHJhbnNmb3JtID0gc3R5bGUud2Via2l0VHJhbnNmb3JtID0gc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XG4gICAgICAgICAgICAgICAgY29uc3QgY2IgPSAoZWwuX21vdmVDYiA9IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlICYmIGUudGFyZ2V0ICE9PSBlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBjYik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBjYik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByYXdQcm9wcyA9IHRvUmF3KHByb3BzKTtcbiAgICAgICAgICAgIGNvbnN0IGNzc1RyYW5zaXRpb25Qcm9wcyA9IHJlc29sdmVUcmFuc2l0aW9uUHJvcHMocmF3UHJvcHMpO1xuICAgICAgICAgICAgbGV0IHRhZyA9IHJhd1Byb3BzLnRhZyB8fCBGcmFnbWVudDtcbiAgICAgICAgICAgIHByZXZDaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICAgICAgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0ID8gZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKHNsb3RzLmRlZmF1bHQoKSkgOiBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5rZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3MoY2hpbGQsIHJlc29sdmVUcmFuc2l0aW9uSG9va3MoY2hpbGQsIGNzc1RyYW5zaXRpb25Qcm9wcywgc3RhdGUsIGluc3RhbmNlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKGA8VHJhbnNpdGlvbkdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IHByZXZDaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKGNoaWxkLCByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKGNoaWxkLCBjc3NUcmFuc2l0aW9uUHJvcHMsIHN0YXRlLCBpbnN0YW5jZSkpO1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQoY2hpbGQsIGNoaWxkLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUodGFnLCBudWxsLCBjaGlsZHJlbik7XG4gICAgICAgIH07XG4gICAgfVxufTtcbmNvbnN0IFRyYW5zaXRpb25Hcm91cCA9IFRyYW5zaXRpb25Hcm91cEltcGw7XG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyhjKSB7XG4gICAgY29uc3QgZWwgPSBjLmVsO1xuICAgIGlmIChlbC5fbW92ZUNiKSB7XG4gICAgICAgIGVsLl9tb3ZlQ2IoKTtcbiAgICB9XG4gICAgaWYgKGVsLl9lbnRlckNiKSB7XG4gICAgICAgIGVsLl9lbnRlckNiKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24oYykge1xuICAgIG5ld1Bvc2l0aW9uTWFwLnNldChjLCBjLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbn1cbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24oYykge1xuICAgIGNvbnN0IG9sZFBvcyA9IHBvc2l0aW9uTWFwLmdldChjKTtcbiAgICBjb25zdCBuZXdQb3MgPSBuZXdQb3NpdGlvbk1hcC5nZXQoYyk7XG4gICAgY29uc3QgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xuICAgIGNvbnN0IGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gICAgaWYgKGR4IHx8IGR5KSB7XG4gICAgICAgIGNvbnN0IHMgPSBjLmVsLnN0eWxlO1xuICAgICAgICBzLnRyYW5zZm9ybSA9IHMud2Via2l0VHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke2R4fXB4LCR7ZHl9cHgpYDtcbiAgICAgICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICAgICAgICByZXR1cm4gYztcbiAgICB9XG59XG5mdW5jdGlvbiBoYXNDU1NUcmFuc2Zvcm0oZWwsIHJvb3QsIG1vdmVDbGFzcykge1xuICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xuICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcbiAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAvLyBpcyBhcHBsaWVkLlxuICAgIGNvbnN0IGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gICAgaWYgKGVsLl92dGMpIHtcbiAgICAgICAgZWwuX3Z0Yy5mb3JFYWNoKGNscyA9PiB7XG4gICAgICAgICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGMgPT4gYyAmJiBjbG9uZS5jbGFzc0xpc3QucmVtb3ZlKGMpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1vdmVDbGFzcy5zcGxpdCgvXFxzKy8pLmZvckVhY2goYyA9PiBjICYmIGNsb25lLmNsYXNzTGlzdC5hZGQoYykpO1xuICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgY29uc3QgY29udGFpbmVyID0gKHJvb3Qubm9kZVR5cGUgPT09IDEgPyByb290IDogcm9vdC5wYXJlbnROb2RlKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgIGNvbnN0IHsgaGFzVHJhbnNmb3JtIH0gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XG4gICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICByZXR1cm4gaGFzVHJhbnNmb3JtO1xufVxuXG5jb25zdCBnZXRNb2RlbEFzc2lnbmVyID0gKHZub2RlKSA9PiB7XG4gICAgY29uc3QgZm4gPSB2bm9kZS5wcm9wc1snb25VcGRhdGU6bW9kZWxWYWx1ZSddIHx8XG4gICAgICAgIChmYWxzZSApO1xuICAgIHJldHVybiBpc0FycmF5KGZuKSA/IHZhbHVlID0+IGludm9rZUFycmF5Rm5zKGZuLCB2YWx1ZSkgOiBmbjtcbn07XG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQoZSkge1xuICAgIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kKGUpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICBpZiAodGFyZ2V0LmNvbXBvc2luZykge1xuICAgICAgICB0YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaW5wdXQnKSk7XG4gICAgfVxufVxuLy8gV2UgYXJlIGV4cG9ydGluZyB0aGUgdi1tb2RlbCBydW50aW1lIGRpcmVjdGx5IGFzIHZub2RlIGhvb2tzIHNvIHRoYXQgaXQgY2FuXG4vLyBiZSB0cmVlLXNoYWtlbiBpbiBjYXNlIHYtbW9kZWwgaXMgbmV2ZXIgdXNlZC5cbmNvbnN0IHZNb2RlbFRleHQgPSB7XG4gICAgY3JlYXRlZChlbCwgeyBtb2RpZmllcnM6IHsgbGF6eSwgdHJpbSwgbnVtYmVyIH0gfSwgdm5vZGUpIHtcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgICAgICBjb25zdCBjYXN0VG9OdW1iZXIgPSBudW1iZXIgfHwgKHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnR5cGUgPT09ICdudW1iZXInKTtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgbGF6eSA/ICdjaGFuZ2UnIDogJ2lucHV0JywgZSA9PiB7XG4gICAgICAgICAgICBpZiAoZS50YXJnZXQuY29tcG9zaW5nKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCBkb21WYWx1ZSA9IGVsLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHRyaW0pIHtcbiAgICAgICAgICAgICAgICBkb21WYWx1ZSA9IGRvbVZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYXN0VG9OdW1iZXIpIHtcbiAgICAgICAgICAgICAgICBkb21WYWx1ZSA9IHRvTnVtYmVyKGRvbVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsLl9hc3NpZ24oZG9tVmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRyaW0pIHtcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsICdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZWwudmFsdWUgPSBlbC52YWx1ZS50cmltKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxhenkpIHtcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsICdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsICdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxuICAgICAgICAgICAgLy8gc3dpdGNoaW5nIGZvY3VzIGJlZm9yZSBjb25maXJtaW5nIGNvbXBvc2l0aW9uIGNob2ljZVxuICAgICAgICAgICAgLy8gdGhpcyBhbHNvIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzb21lIGJyb3dzZXJzIGUuZy4gaU9TIENocm9tZVxuICAgICAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8vIHNldCB2YWx1ZSBvbiBtb3VudGVkIHNvIGl0J3MgYWZ0ZXIgbWluL21heCBmb3IgdHlwZT1cInJhbmdlXCJcbiAgICBtb3VudGVkKGVsLCB7IHZhbHVlIH0pIHtcbiAgICAgICAgZWwudmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcbiAgICB9LFxuICAgIGJlZm9yZVVwZGF0ZShlbCwgeyB2YWx1ZSwgbW9kaWZpZXJzOiB7IGxhenksIHRyaW0sIG51bWJlciB9IH0sIHZub2RlKSB7XG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICAgICAgLy8gYXZvaWQgY2xlYXJpbmcgdW5yZXNvbHZlZCB0ZXh0LiAjMjMwMlxuICAgICAgICBpZiAoZWwuY29tcG9zaW5nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZWwgJiYgZWwudHlwZSAhPT0gJ3JhbmdlJykge1xuICAgICAgICAgICAgaWYgKGxhenkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJpbSAmJiBlbC52YWx1ZS50cmltKCkgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChudW1iZXIgfHwgZWwudHlwZSA9PT0gJ251bWJlcicpICYmIHRvTnVtYmVyKGVsLnZhbHVlKSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcbiAgICAgICAgaWYgKGVsLnZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgZWwudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCB2TW9kZWxDaGVja2JveCA9IHtcbiAgICAvLyAjNDA5NiBhcnJheSBjaGVja2JveGVzIG5lZWQgdG8gYmUgZGVlcCB0cmF2ZXJzZWRcbiAgICBkZWVwOiB0cnVlLFxuICAgIGNyZWF0ZWQoZWwsIF8sIHZub2RlKSB7XG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsVmFsdWUgPSBlbC5fbW9kZWxWYWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRWYWx1ZSA9IGdldFZhbHVlKGVsKTtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrZWQgPSBlbC5jaGVja2VkO1xuICAgICAgICAgICAgY29uc3QgYXNzaWduID0gZWwuX2Fzc2lnbjtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KG1vZGVsVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBsb29zZUluZGV4T2YobW9kZWxWYWx1ZSwgZWxlbWVudFZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmb3VuZCA9IGluZGV4ICE9PSAtMTtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tlZCAmJiAhZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzaWduKG1vZGVsVmFsdWUuY29uY2F0KGVsZW1lbnRWYWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghY2hlY2tlZCAmJiBmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IFsuLi5tb2RlbFZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzaWduKGZpbHRlcmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1NldChtb2RlbFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsb25lZCA9IG5ldyBTZXQobW9kZWxWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkLmFkZChlbGVtZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkLmRlbGV0ZShlbGVtZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhc3NpZ24oY2xvbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFzc2lnbihnZXRDaGVja2JveFZhbHVlKGVsLCBjaGVja2VkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgLy8gc2V0IGluaXRpYWwgY2hlY2tlZCBvbiBtb3VudCB0byB3YWl0IGZvciB0cnVlLXZhbHVlL2ZhbHNlLXZhbHVlXG4gICAgbW91bnRlZDogc2V0Q2hlY2tlZCxcbiAgICBiZWZvcmVVcGRhdGUoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICAgICAgc2V0Q2hlY2tlZChlbCwgYmluZGluZywgdm5vZGUpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBzZXRDaGVja2VkKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB2bm9kZSkge1xuICAgIGVsLl9tb2RlbFZhbHVlID0gdmFsdWU7XG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGVsLmNoZWNrZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKSA+IC0xO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICAgICAgZWwuY2hlY2tlZCA9IHZhbHVlLmhhcyh2bm9kZS5wcm9wcy52YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgZ2V0Q2hlY2tib3hWYWx1ZShlbCwgdHJ1ZSkpO1xuICAgIH1cbn1cbmNvbnN0IHZNb2RlbFJhZGlvID0ge1xuICAgIGNyZWF0ZWQoZWwsIHsgdmFsdWUgfSwgdm5vZGUpIHtcbiAgICAgICAgZWwuY2hlY2tlZCA9IGxvb3NlRXF1YWwodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKTtcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgZWwuX2Fzc2lnbihnZXRWYWx1ZShlbCkpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGJlZm9yZVVwZGF0ZShlbCwgeyB2YWx1ZSwgb2xkVmFsdWUgfSwgdm5vZGUpIHtcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgICAgICBpZiAodmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICAgICAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IHZNb2RlbFNlbGVjdCA9IHtcbiAgICAvLyA8c2VsZWN0IG11bHRpcGxlPiB2YWx1ZSBuZWVkIHRvIGJlIGRlZXAgdHJhdmVyc2VkXG4gICAgZGVlcDogdHJ1ZSxcbiAgICBjcmVhdGVkKGVsLCB7IHZhbHVlLCBtb2RpZmllcnM6IHsgbnVtYmVyIH0gfSwgdm5vZGUpIHtcbiAgICAgICAgY29uc3QgaXNTZXRNb2RlbCA9IGlzU2V0KHZhbHVlKTtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkVmFsID0gQXJyYXkucHJvdG90eXBlLmZpbHRlclxuICAgICAgICAgICAgICAgIC5jYWxsKGVsLm9wdGlvbnMsIChvKSA9PiBvLnNlbGVjdGVkKVxuICAgICAgICAgICAgICAgIC5tYXAoKG8pID0+IG51bWJlciA/IHRvTnVtYmVyKGdldFZhbHVlKG8pKSA6IGdldFZhbHVlKG8pKTtcbiAgICAgICAgICAgIGVsLl9hc3NpZ24oZWwubXVsdGlwbGVcbiAgICAgICAgICAgICAgICA/IGlzU2V0TW9kZWxcbiAgICAgICAgICAgICAgICAgICAgPyBuZXcgU2V0KHNlbGVjdGVkVmFsKVxuICAgICAgICAgICAgICAgICAgICA6IHNlbGVjdGVkVmFsXG4gICAgICAgICAgICAgICAgOiBzZWxlY3RlZFZhbFswXSk7XG4gICAgICAgIH0pO1xuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgfSxcbiAgICAvLyBzZXQgdmFsdWUgaW4gbW91bnRlZCAmIHVwZGF0ZWQgYmVjYXVzZSA8c2VsZWN0PiByZWxpZXMgb24gaXRzIGNoaWxkcmVuXG4gICAgLy8gPG9wdGlvbj5zLlxuICAgIG1vdW50ZWQoZWwsIHsgdmFsdWUgfSkge1xuICAgICAgICBzZXRTZWxlY3RlZChlbCwgdmFsdWUpO1xuICAgIH0sXG4gICAgYmVmb3JlVXBkYXRlKGVsLCBfYmluZGluZywgdm5vZGUpIHtcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgIH0sXG4gICAgdXBkYXRlZChlbCwgeyB2YWx1ZSB9KSB7XG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSkge1xuICAgIGNvbnN0IGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcbiAgICBpZiAoaXNNdWx0aXBsZSAmJiAhaXNBcnJheSh2YWx1ZSkgJiYgIWlzU2V0KHZhbHVlKSkge1xuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgIHdhcm4oYDxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD4gZXhwZWN0cyBhbiBBcnJheSBvciBTZXQgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBgICtcbiAgICAgICAgICAgICAgICBgYnV0IGdvdCAke09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpfS5gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgICAgIGNvbnN0IG9wdGlvblZhbHVlID0gZ2V0VmFsdWUob3B0aW9uKTtcbiAgICAgICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgb3B0aW9uVmFsdWUpID4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB2YWx1ZS5oYXMob3B0aW9uVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpXG4gICAgICAgICAgICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzTXVsdGlwbGUgJiYgZWwuc2VsZWN0ZWRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgIH1cbn1cbi8vIHJldHJpZXZlIHJhdyB2YWx1ZSBzZXQgdmlhIDp2YWx1ZSBiaW5kaW5nc1xuZnVuY3Rpb24gZ2V0VmFsdWUoZWwpIHtcbiAgICByZXR1cm4gJ192YWx1ZScgaW4gZWwgPyBlbC5fdmFsdWUgOiBlbC52YWx1ZTtcbn1cbi8vIHJldHJpZXZlIHJhdyB2YWx1ZSBmb3IgdHJ1ZS12YWx1ZSBhbmQgZmFsc2UtdmFsdWUgc2V0IHZpYSA6dHJ1ZS12YWx1ZSBvciA6ZmFsc2UtdmFsdWUgYmluZGluZ3NcbmZ1bmN0aW9uIGdldENoZWNrYm94VmFsdWUoZWwsIGNoZWNrZWQpIHtcbiAgICBjb25zdCBrZXkgPSBjaGVja2VkID8gJ190cnVlVmFsdWUnIDogJ19mYWxzZVZhbHVlJztcbiAgICByZXR1cm4ga2V5IGluIGVsID8gZWxba2V5XSA6IGNoZWNrZWQ7XG59XG5jb25zdCB2TW9kZWxEeW5hbWljID0ge1xuICAgIGNyZWF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBudWxsLCAnY3JlYXRlZCcpO1xuICAgIH0sXG4gICAgbW91bnRlZChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICAgICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIG51bGwsICdtb3VudGVkJyk7XG4gICAgfSxcbiAgICBiZWZvcmVVcGRhdGUoZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUpIHtcbiAgICAgICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSwgJ2JlZm9yZVVwZGF0ZScpO1xuICAgIH0sXG4gICAgdXBkYXRlZChlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSkge1xuICAgICAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCAndXBkYXRlZCcpO1xuICAgIH1cbn07XG5mdW5jdGlvbiByZXNvbHZlRHluYW1pY01vZGVsKHRhZ05hbWUsIHR5cGUpIHtcbiAgICBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICAgICAgY2FzZSAnU0VMRUNUJzpcbiAgICAgICAgICAgIHJldHVybiB2TW9kZWxTZWxlY3Q7XG4gICAgICAgIGNhc2UgJ1RFWFRBUkVBJzpcbiAgICAgICAgICAgIHJldHVybiB2TW9kZWxUZXh0O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdk1vZGVsQ2hlY2tib3g7XG4gICAgICAgICAgICAgICAgY2FzZSAncmFkaW8nOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdk1vZGVsUmFkaW87XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZNb2RlbFRleHQ7XG4gICAgICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSwgaG9vaykge1xuICAgIGNvbnN0IG1vZGVsVG9Vc2UgPSByZXNvbHZlRHluYW1pY01vZGVsKGVsLnRhZ05hbWUsIHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnR5cGUpO1xuICAgIGNvbnN0IGZuID0gbW9kZWxUb1VzZVtob29rXTtcbiAgICBmbiAmJiBmbihlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSk7XG59XG4vLyBTU1Igdm5vZGUgdHJhbnNmb3Jtcywgb25seSB1c2VkIHdoZW4gdXNlciBpbmNsdWRlcyBjbGllbnQtb3JpZW50ZWQgcmVuZGVyXG4vLyBmdW5jdGlvbiBpbiBTU1JcbmZ1bmN0aW9uIGluaXRWTW9kZWxGb3JTU1IoKSB7XG4gICAgdk1vZGVsVGV4dC5nZXRTU1JQcm9wcyA9ICh7IHZhbHVlIH0pID0+ICh7IHZhbHVlIH0pO1xuICAgIHZNb2RlbFJhZGlvLmdldFNTUlByb3BzID0gKHsgdmFsdWUgfSwgdm5vZGUpID0+IHtcbiAgICAgICAgaWYgKHZub2RlLnByb3BzICYmIGxvb3NlRXF1YWwodm5vZGUucHJvcHMudmFsdWUsIHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgY2hlY2tlZDogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2TW9kZWxDaGVja2JveC5nZXRTU1JQcm9wcyA9ICh7IHZhbHVlIH0sIHZub2RlKSA9PiB7XG4gICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKHZub2RlLnByb3BzICYmIGxvb3NlSW5kZXhPZih2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjaGVja2VkOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAodm5vZGUucHJvcHMgJiYgdmFsdWUuaGFzKHZub2RlLnByb3BzLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgY2hlY2tlZDogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2TW9kZWxEeW5hbWljLmdldFNTUlByb3BzID0gKGJpbmRpbmcsIHZub2RlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygdm5vZGUudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2RlbFRvVXNlID0gcmVzb2x2ZUR5bmFtaWNNb2RlbChcbiAgICAgICAgLy8gcmVzb2x2ZUR5bmFtaWNNb2RlbCBleHBlY3RzIGFuIHVwcGVyY2FzZSB0YWcgbmFtZSwgYnV0IHZub2RlLnR5cGUgaXMgbG93ZXJjYXNlXG4gICAgICAgIHZub2RlLnR5cGUudG9VcHBlckNhc2UoKSwgdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudHlwZSk7XG4gICAgICAgIGlmIChtb2RlbFRvVXNlLmdldFNTUlByb3BzKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kZWxUb1VzZS5nZXRTU1JQcm9wcyhiaW5kaW5nLCB2bm9kZSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5jb25zdCBzeXN0ZW1Nb2RpZmllcnMgPSBbJ2N0cmwnLCAnc2hpZnQnLCAnYWx0JywgJ21ldGEnXTtcbmNvbnN0IG1vZGlmaWVyR3VhcmRzID0ge1xuICAgIHN0b3A6IGUgPT4gZS5zdG9wUHJvcGFnYXRpb24oKSxcbiAgICBwcmV2ZW50OiBlID0+IGUucHJldmVudERlZmF1bHQoKSxcbiAgICBzZWxmOiBlID0+IGUudGFyZ2V0ICE9PSBlLmN1cnJlbnRUYXJnZXQsXG4gICAgY3RybDogZSA9PiAhZS5jdHJsS2V5LFxuICAgIHNoaWZ0OiBlID0+ICFlLnNoaWZ0S2V5LFxuICAgIGFsdDogZSA9PiAhZS5hbHRLZXksXG4gICAgbWV0YTogZSA9PiAhZS5tZXRhS2V5LFxuICAgIGxlZnQ6IGUgPT4gJ2J1dHRvbicgaW4gZSAmJiBlLmJ1dHRvbiAhPT0gMCxcbiAgICBtaWRkbGU6IGUgPT4gJ2J1dHRvbicgaW4gZSAmJiBlLmJ1dHRvbiAhPT0gMSxcbiAgICByaWdodDogZSA9PiAnYnV0dG9uJyBpbiBlICYmIGUuYnV0dG9uICE9PSAyLFxuICAgIGV4YWN0OiAoZSwgbW9kaWZpZXJzKSA9PiBzeXN0ZW1Nb2RpZmllcnMuc29tZShtID0+IGVbYCR7bX1LZXlgXSAmJiAhbW9kaWZpZXJzLmluY2x1ZGVzKG0pKVxufTtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3Qgd2l0aE1vZGlmaWVycyA9IChmbiwgbW9kaWZpZXJzKSA9PiB7XG4gICAgcmV0dXJuIChldmVudCwgLi4uYXJncykgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZ3VhcmQgPSBtb2RpZmllckd1YXJkc1ttb2RpZmllcnNbaV1dO1xuICAgICAgICAgICAgaWYgKGd1YXJkICYmIGd1YXJkKGV2ZW50LCBtb2RpZmllcnMpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm4oZXZlbnQsIC4uLmFyZ3MpO1xuICAgIH07XG59O1xuLy8gS2VwdCBmb3IgMi54IGNvbXBhdC5cbi8vIE5vdGU6IElFMTEgY29tcGF0IGZvciBgc3BhY2ViYXJgIGFuZCBgZGVsYCBpcyByZW1vdmVkIGZvciBub3cuXG5jb25zdCBrZXlOYW1lcyA9IHtcbiAgICBlc2M6ICdlc2NhcGUnLFxuICAgIHNwYWNlOiAnICcsXG4gICAgdXA6ICdhcnJvdy11cCcsXG4gICAgbGVmdDogJ2Fycm93LWxlZnQnLFxuICAgIHJpZ2h0OiAnYXJyb3ctcmlnaHQnLFxuICAgIGRvd246ICdhcnJvdy1kb3duJyxcbiAgICBkZWxldGU6ICdiYWNrc3BhY2UnXG59O1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCB3aXRoS2V5cyA9IChmbiwgbW9kaWZpZXJzKSA9PiB7XG4gICAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgICAgICBpZiAoISgna2V5JyBpbiBldmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBldmVudEtleSA9IGh5cGhlbmF0ZShldmVudC5rZXkpO1xuICAgICAgICBpZiAobW9kaWZpZXJzLnNvbWUoayA9PiBrID09PSBldmVudEtleSB8fCBrZXlOYW1lc1trXSA9PT0gZXZlbnRLZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4oZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbmNvbnN0IHZTaG93ID0ge1xuICAgIGJlZm9yZU1vdW50KGVsLCB7IHZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XG4gICAgICAgIGVsLl92b2QgPSBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgICAgIGlmICh0cmFuc2l0aW9uICYmIHZhbHVlKSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldERpc3BsYXkoZWwsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbW91bnRlZChlbCwgeyB2YWx1ZSB9LCB7IHRyYW5zaXRpb24gfSkge1xuICAgICAgICBpZiAodHJhbnNpdGlvbiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgdHJhbnNpdGlvbi5lbnRlcihlbCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHVwZGF0ZWQoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XG4gICAgICAgIGlmICghdmFsdWUgPT09ICFvbGRWYWx1ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xuICAgICAgICAgICAgICAgIHNldERpc3BsYXkoZWwsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5sZWF2ZShlbCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXREaXNwbGF5KGVsLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXREaXNwbGF5KGVsLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGJlZm9yZVVubW91bnQoZWwsIHsgdmFsdWUgfSkge1xuICAgICAgICBzZXREaXNwbGF5KGVsLCB2YWx1ZSk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIHNldERpc3BsYXkoZWwsIHZhbHVlKSB7XG4gICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX3ZvZCA6ICdub25lJztcbn1cbi8vIFNTUiB2bm9kZSB0cmFuc2Zvcm1zLCBvbmx5IHVzZWQgd2hlbiB1c2VyIGluY2x1ZGVzIGNsaWVudC1vcmllbnRlZCByZW5kZXJcbi8vIGZ1bmN0aW9uIGluIFNTUlxuZnVuY3Rpb24gaW5pdFZTaG93Rm9yU1NSKCkge1xuICAgIHZTaG93LmdldFNTUlByb3BzID0gKHsgdmFsdWUgfSkgPT4ge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdHlsZTogeyBkaXNwbGF5OiAnbm9uZScgfSB9O1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuY29uc3QgcmVuZGVyZXJPcHRpb25zID0gLyojX19QVVJFX18qLyBleHRlbmQoeyBwYXRjaFByb3AgfSwgbm9kZU9wcyk7XG4vLyBsYXp5IGNyZWF0ZSB0aGUgcmVuZGVyZXIgLSB0aGlzIG1ha2VzIGNvcmUgcmVuZGVyZXIgbG9naWMgdHJlZS1zaGFrYWJsZVxuLy8gaW4gY2FzZSB0aGUgdXNlciBvbmx5IGltcG9ydHMgcmVhY3Rpdml0eSB1dGlsaXRpZXMgZnJvbSBWdWUuXG5sZXQgcmVuZGVyZXI7XG5sZXQgZW5hYmxlZEh5ZHJhdGlvbiA9IGZhbHNlO1xuZnVuY3Rpb24gZW5zdXJlUmVuZGVyZXIoKSB7XG4gICAgcmV0dXJuIChyZW5kZXJlciB8fFxuICAgICAgICAocmVuZGVyZXIgPSBjcmVhdGVSZW5kZXJlcihyZW5kZXJlck9wdGlvbnMpKSk7XG59XG5mdW5jdGlvbiBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpIHtcbiAgICByZW5kZXJlciA9IGVuYWJsZWRIeWRyYXRpb25cbiAgICAgICAgPyByZW5kZXJlclxuICAgICAgICA6IGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyKHJlbmRlcmVyT3B0aW9ucyk7XG4gICAgZW5hYmxlZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgcmV0dXJuIHJlbmRlcmVyO1xufVxuLy8gdXNlIGV4cGxpY2l0IHR5cGUgY2FzdHMgaGVyZSB0byBhdm9pZCBpbXBvcnQoKSBjYWxscyBpbiByb2xsZWQtdXAgZC50c1xuY29uc3QgcmVuZGVyID0gKCguLi5hcmdzKSA9PiB7XG4gICAgZW5zdXJlUmVuZGVyZXIoKS5yZW5kZXIoLi4uYXJncyk7XG59KTtcbmNvbnN0IGh5ZHJhdGUgPSAoKC4uLmFyZ3MpID0+IHtcbiAgICBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpLmh5ZHJhdGUoLi4uYXJncyk7XG59KTtcbmNvbnN0IGNyZWF0ZUFwcCA9ICgoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IGFwcCA9IGVuc3VyZVJlbmRlcmVyKCkuY3JlYXRlQXBwKC4uLmFyZ3MpO1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgaW5qZWN0TmF0aXZlVGFnQ2hlY2soYXBwKTtcbiAgICAgICAgaW5qZWN0Q29tcGlsZXJPcHRpb25zQ2hlY2soYXBwKTtcbiAgICB9XG4gICAgY29uc3QgeyBtb3VudCB9ID0gYXBwO1xuICAgIGFwcC5tb3VudCA9IChjb250YWluZXJPclNlbGVjdG9yKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG5vcm1hbGl6ZUNvbnRhaW5lcihjb250YWluZXJPclNlbGVjdG9yKTtcbiAgICAgICAgaWYgKCFjb250YWluZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGFwcC5fY29tcG9uZW50O1xuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oY29tcG9uZW50KSAmJiAhY29tcG9uZW50LnJlbmRlciAmJiAhY29tcG9uZW50LnRlbXBsYXRlKSB7XG4gICAgICAgICAgICAvLyBfX1VOU0FGRV9fXG4gICAgICAgICAgICAvLyBSZWFzb246IHBvdGVudGlhbCBleGVjdXRpb24gb2YgSlMgZXhwcmVzc2lvbnMgaW4gaW4tRE9NIHRlbXBsYXRlLlxuICAgICAgICAgICAgLy8gVGhlIHVzZXIgbXVzdCBtYWtlIHN1cmUgdGhlIGluLURPTSB0ZW1wbGF0ZSBpcyB0cnVzdGVkLiBJZiBpdCdzXG4gICAgICAgICAgICAvLyByZW5kZXJlZCBieSB0aGUgc2VydmVyLCB0aGUgdGVtcGxhdGUgc2hvdWxkIG5vdCBjb250YWluIGFueSB1c2VyIGRhdGEuXG4gICAgICAgICAgICBjb21wb25lbnQudGVtcGxhdGUgPSBjb250YWluZXIuaW5uZXJIVE1MO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNsZWFyIGNvbnRlbnQgYmVmb3JlIG1vdW50aW5nXG4gICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgY29uc3QgcHJveHkgPSBtb3VudChjb250YWluZXIsIGZhbHNlLCBjb250YWluZXIgaW5zdGFuY2VvZiBTVkdFbGVtZW50KTtcbiAgICAgICAgaWYgKGNvbnRhaW5lciBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoJ3YtY2xvYWsnKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2RhdGEtdi1hcHAnLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3h5O1xuICAgIH07XG4gICAgcmV0dXJuIGFwcDtcbn0pO1xuY29uc3QgY3JlYXRlU1NSQXBwID0gKCguLi5hcmdzKSA9PiB7XG4gICAgY29uc3QgYXBwID0gZW5zdXJlSHlkcmF0aW9uUmVuZGVyZXIoKS5jcmVhdGVBcHAoLi4uYXJncyk7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICBpbmplY3ROYXRpdmVUYWdDaGVjayhhcHApO1xuICAgICAgICBpbmplY3RDb21waWxlck9wdGlvbnNDaGVjayhhcHApO1xuICAgIH1cbiAgICBjb25zdCB7IG1vdW50IH0gPSBhcHA7XG4gICAgYXBwLm1vdW50ID0gKGNvbnRhaW5lck9yU2VsZWN0b3IpID0+IHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lck9yU2VsZWN0b3IpO1xuICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbW91bnQoY29udGFpbmVyLCB0cnVlLCBjb250YWluZXIgaW5zdGFuY2VvZiBTVkdFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGFwcDtcbn0pO1xuZnVuY3Rpb24gaW5qZWN0TmF0aXZlVGFnQ2hlY2soYXBwKSB7XG4gICAgLy8gSW5qZWN0IGBpc05hdGl2ZVRhZ2BcbiAgICAvLyB0aGlzIGlzIHVzZWQgZm9yIGNvbXBvbmVudCBuYW1lIHZhbGlkYXRpb24gKGRldiBvbmx5KVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLCAnaXNOYXRpdmVUYWcnLCB7XG4gICAgICAgIHZhbHVlOiAodGFnKSA9PiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWR1RhZyh0YWcpLFxuICAgICAgICB3cml0YWJsZTogZmFsc2VcbiAgICB9KTtcbn1cbi8vIGRldiBvbmx5XG5mdW5jdGlvbiBpbmplY3RDb21waWxlck9wdGlvbnNDaGVjayhhcHApIHtcbiAgICBpZiAoaXNSdW50aW1lT25seSgpKSB7XG4gICAgICAgIGNvbnN0IGlzQ3VzdG9tRWxlbWVudCA9IGFwcC5jb25maWcuaXNDdXN0b21FbGVtZW50O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBwLmNvbmZpZywgJ2lzQ3VzdG9tRWxlbWVudCcsIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNDdXN0b21FbGVtZW50O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCgpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGBUaGUgXFxgaXNDdXN0b21FbGVtZW50XFxgIGNvbmZpZyBvcHRpb24gaXMgZGVwcmVjYXRlZC4gVXNlIGAgK1xuICAgICAgICAgICAgICAgICAgICBgXFxgY29tcGlsZXJPcHRpb25zLmlzQ3VzdG9tRWxlbWVudFxcYCBpbnN0ZWFkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY29tcGlsZXJPcHRpb25zID0gYXBwLmNvbmZpZy5jb21waWxlck9wdGlvbnM7XG4gICAgICAgIGNvbnN0IG1zZyA9IGBUaGUgXFxgY29tcGlsZXJPcHRpb25zXFxgIGNvbmZpZyBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyBgICtcbiAgICAgICAgICAgIGBhIGJ1aWxkIG9mIFZ1ZS5qcyB0aGF0IGluY2x1ZGVzIHRoZSBydW50aW1lIGNvbXBpbGVyIChha2EgXCJmdWxsIGJ1aWxkXCIpLiBgICtcbiAgICAgICAgICAgIGBTaW5jZSB5b3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQsIFxcYGNvbXBpbGVyT3B0aW9uc1xcYCBgICtcbiAgICAgICAgICAgIGBtdXN0IGJlIHBhc3NlZCB0byBcXGBAdnVlL2NvbXBpbGVyLWRvbVxcYCBpbiB0aGUgYnVpbGQgc2V0dXAgaW5zdGVhZC5cXG5gICtcbiAgICAgICAgICAgIGAtIEZvciB2dWUtbG9hZGVyOiBwYXNzIGl0IHZpYSB2dWUtbG9hZGVyJ3MgXFxgY29tcGlsZXJPcHRpb25zXFxgIGxvYWRlciBvcHRpb24uXFxuYCArXG4gICAgICAgICAgICBgLSBGb3IgdnVlLWNsaTogc2VlIGh0dHBzOi8vY2xpLnZ1ZWpzLm9yZy9ndWlkZS93ZWJwYWNrLmh0bWwjbW9kaWZ5aW5nLW9wdGlvbnMtb2YtYS1sb2FkZXJcXG5gICtcbiAgICAgICAgICAgIGAtIEZvciB2aXRlOiBwYXNzIGl0IHZpYSBAdml0ZWpzL3BsdWdpbi12dWUgb3B0aW9ucy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aXRlanMvdml0ZS90cmVlL21haW4vcGFja2FnZXMvcGx1Z2luLXZ1ZSNleGFtcGxlLWZvci1wYXNzaW5nLW9wdGlvbnMtdG8tdnVlY29tcGlsZXItZG9tYDtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5jb25maWcsICdjb21waWxlck9wdGlvbnMnLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21waWxlck9wdGlvbnM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0KCkge1xuICAgICAgICAgICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICAgIGlmIChpc1N0cmluZyhjb250YWluZXIpKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGFpbmVyKTtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhcmVzKSB7XG4gICAgICAgICAgICB3YXJuKGBGYWlsZWQgdG8gbW91bnQgYXBwOiBtb3VudCB0YXJnZXQgc2VsZWN0b3IgXCIke2NvbnRhaW5lcn1cIiByZXR1cm5lZCBudWxsLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgd2luZG93LlNoYWRvd1Jvb3QgJiZcbiAgICAgICAgY29udGFpbmVyIGluc3RhbmNlb2Ygd2luZG93LlNoYWRvd1Jvb3QgJiZcbiAgICAgICAgY29udGFpbmVyLm1vZGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgIHdhcm4oYG1vdW50aW5nIG9uIGEgU2hhZG93Um9vdCB3aXRoIFxcYHttb2RlOiBcImNsb3NlZFwifVxcYCBtYXkgbGVhZCB0byB1bnByZWRpY3RhYmxlIGJ1Z3NgKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbn1cbmxldCBzc3JEaXJlY3RpdmVJbml0aWFsaXplZCA9IGZhbHNlO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgaW5pdERpcmVjdGl2ZXNGb3JTU1IgPSAoKSA9PiB7XG4gICAgICAgIGlmICghc3NyRGlyZWN0aXZlSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHNzckRpcmVjdGl2ZUluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGluaXRWTW9kZWxGb3JTU1IoKTtcbiAgICAgICAgICAgIGluaXRWU2hvd0ZvclNTUigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcblxuZXhwb3J0IHsgVHJhbnNpdGlvbiwgVHJhbnNpdGlvbkdyb3VwLCBWdWVFbGVtZW50LCBjcmVhdGVBcHAsIGNyZWF0ZVNTUkFwcCwgZGVmaW5lQ3VzdG9tRWxlbWVudCwgZGVmaW5lU1NSQ3VzdG9tRWxlbWVudCwgaHlkcmF0ZSwgaW5pdERpcmVjdGl2ZXNGb3JTU1IsIHJlbmRlciwgdXNlQ3NzTW9kdWxlLCB1c2VDc3NWYXJzLCB2TW9kZWxDaGVja2JveCwgdk1vZGVsRHluYW1pYywgdk1vZGVsUmFkaW8sIHZNb2RlbFNlbGVjdCwgdk1vZGVsVGV4dCwgdlNob3csIHdpdGhLZXlzLCB3aXRoTW9kaWZpZXJzIH07XG4iLCIvKipcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuICogaXMgaW4gdGhhdCBtYXAuXG4gKiBJTVBPUlRBTlQ6IGFsbCBjYWxscyBvZiB0aGlzIGZ1bmN0aW9uIG11c3QgYmUgcHJlZml4ZWQgd2l0aFxuICogXFwvXFwqI1xcX1xcX1BVUkVcXF9cXF9cXCpcXC9cbiAqIFNvIHRoYXQgcm9sbHVwIGNhbiB0cmVlLXNoYWtlIHRoZW0gaWYgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBtYWtlTWFwKHN0ciwgZXhwZWN0c0xvd2VyQ2FzZSkge1xuICAgIGNvbnN0IG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3QgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZSA/IHZhbCA9PiAhIW1hcFt2YWwudG9Mb3dlckNhc2UoKV0gOiB2YWwgPT4gISFtYXBbdmFsXTtcbn1cblxuLyoqXG4gKiBkZXYgb25seSBmbGFnIC0+IG5hbWUgbWFwcGluZ1xuICovXG5jb25zdCBQYXRjaEZsYWdOYW1lcyA9IHtcbiAgICBbMSAvKiBQYXRjaEZsYWdzLlRFWFQgKi9dOiBgVEVYVGAsXG4gICAgWzIgLyogUGF0Y2hGbGFncy5DTEFTUyAqL106IGBDTEFTU2AsXG4gICAgWzQgLyogUGF0Y2hGbGFncy5TVFlMRSAqL106IGBTVFlMRWAsXG4gICAgWzggLyogUGF0Y2hGbGFncy5QUk9QUyAqL106IGBQUk9QU2AsXG4gICAgWzE2IC8qIFBhdGNoRmxhZ3MuRlVMTF9QUk9QUyAqL106IGBGVUxMX1BST1BTYCxcbiAgICBbMzIgLyogUGF0Y2hGbGFncy5IWURSQVRFX0VWRU5UUyAqL106IGBIWURSQVRFX0VWRU5UU2AsXG4gICAgWzY0IC8qIFBhdGNoRmxhZ3MuU1RBQkxFX0ZSQUdNRU5UICovXTogYFNUQUJMRV9GUkFHTUVOVGAsXG4gICAgWzEyOCAvKiBQYXRjaEZsYWdzLktFWUVEX0ZSQUdNRU5UICovXTogYEtFWUVEX0ZSQUdNRU5UYCxcbiAgICBbMjU2IC8qIFBhdGNoRmxhZ3MuVU5LRVlFRF9GUkFHTUVOVCAqL106IGBVTktFWUVEX0ZSQUdNRU5UYCxcbiAgICBbNTEyIC8qIFBhdGNoRmxhZ3MuTkVFRF9QQVRDSCAqL106IGBORUVEX1BBVENIYCxcbiAgICBbMTAyNCAvKiBQYXRjaEZsYWdzLkRZTkFNSUNfU0xPVFMgKi9dOiBgRFlOQU1JQ19TTE9UU2AsXG4gICAgWzIwNDggLyogUGF0Y2hGbGFncy5ERVZfUk9PVF9GUkFHTUVOVCAqL106IGBERVZfUk9PVF9GUkFHTUVOVGAsXG4gICAgWy0xIC8qIFBhdGNoRmxhZ3MuSE9JU1RFRCAqL106IGBIT0lTVEVEYCxcbiAgICBbLTIgLyogUGF0Y2hGbGFncy5CQUlMICovXTogYEJBSUxgXG59O1xuXG4vKipcbiAqIERldiBvbmx5XG4gKi9cbmNvbnN0IHNsb3RGbGFnc1RleHQgPSB7XG4gICAgWzEgLyogU2xvdEZsYWdzLlNUQUJMRSAqL106ICdTVEFCTEUnLFxuICAgIFsyIC8qIFNsb3RGbGFncy5EWU5BTUlDICovXTogJ0RZTkFNSUMnLFxuICAgIFszIC8qIFNsb3RGbGFncy5GT1JXQVJERUQgKi9dOiAnRk9SV0FSREVEJ1xufTtcblxuY29uc3QgR0xPQkFMU19XSElURV9MSVNURUQgPSAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTixwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSwnICtcbiAgICAnZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSwnICtcbiAgICAnT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCxCaWdJbnQnO1xuY29uc3QgaXNHbG9iYWxseVdoaXRlbGlzdGVkID0gLyojX19QVVJFX18qLyBtYWtlTWFwKEdMT0JBTFNfV0hJVEVfTElTVEVEKTtcblxuY29uc3QgcmFuZ2UgPSAyO1xuZnVuY3Rpb24gZ2VuZXJhdGVDb2RlRnJhbWUoc291cmNlLCBzdGFydCA9IDAsIGVuZCA9IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAvLyBTcGxpdCB0aGUgY29udGVudCBpbnRvIGluZGl2aWR1YWwgbGluZXMgYnV0IGNhcHR1cmUgdGhlIG5ld2xpbmUgc2VxdWVuY2VcbiAgICAvLyB0aGF0IHNlcGFyYXRlZCBlYWNoIGxpbmUuIFRoaXMgaXMgaW1wb3J0YW50IGJlY2F1c2UgdGhlIGFjdHVhbCBzZXF1ZW5jZSBpc1xuICAgIC8vIG5lZWRlZCB0byBwcm9wZXJseSB0YWtlIGludG8gYWNjb3VudCB0aGUgZnVsbCBsaW5lIGxlbmd0aCBmb3Igb2Zmc2V0XG4gICAgLy8gY29tcGFyaXNvblxuICAgIGxldCBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvKFxccj9cXG4pLyk7XG4gICAgLy8gU2VwYXJhdGUgdGhlIGxpbmVzIGFuZCBuZXdsaW5lIHNlcXVlbmNlcyBpbnRvIHNlcGFyYXRlIGFycmF5cyBmb3IgZWFzaWVyIHJlZmVyZW5jaW5nXG4gICAgY29uc3QgbmV3bGluZVNlcXVlbmNlcyA9IGxpbmVzLmZpbHRlcigoXywgaWR4KSA9PiBpZHggJSAyID09PSAxKTtcbiAgICBsaW5lcyA9IGxpbmVzLmZpbHRlcigoXywgaWR4KSA9PiBpZHggJSAyID09PSAwKTtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY291bnQgKz1cbiAgICAgICAgICAgIGxpbmVzW2ldLmxlbmd0aCArXG4gICAgICAgICAgICAgICAgKChuZXdsaW5lU2VxdWVuY2VzW2ldICYmIG5ld2xpbmVTZXF1ZW5jZXNbaV0ubGVuZ3RoKSB8fCAwKTtcbiAgICAgICAgaWYgKGNvdW50ID49IHN0YXJ0KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaSAtIHJhbmdlOyBqIDw9IGkgKyByYW5nZSB8fCBlbmQgPiBjb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGogPCAwIHx8IGogPj0gbGluZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lID0gaiArIDE7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goYCR7bGluZX0keycgJy5yZXBlYXQoTWF0aC5tYXgoMyAtIFN0cmluZyhsaW5lKS5sZW5ndGgsIDApKX18ICAke2xpbmVzW2pdfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVMZW5ndGggPSBsaW5lc1tqXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3TGluZVNlcUxlbmd0aCA9IChuZXdsaW5lU2VxdWVuY2VzW2pdICYmIG5ld2xpbmVTZXF1ZW5jZXNbal0ubGVuZ3RoKSB8fCAwO1xuICAgICAgICAgICAgICAgIGlmIChqID09PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggdW5kZXJsaW5lXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhZCA9IHN0YXJ0IC0gKGNvdW50IC0gKGxpbmVMZW5ndGggKyBuZXdMaW5lU2VxTGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KDEsIGVuZCA+IGNvdW50ID8gbGluZUxlbmd0aCAtIHBhZCA6IGVuZCAtIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyAnICcucmVwZWF0KHBhZCkgKyAnXicucmVwZWF0KGxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChqID4gaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kID4gY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KE1hdGgubWluKGVuZCAtIGNvdW50LCBsaW5lTGVuZ3RoKSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArICdeJy5yZXBlYXQobGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnQgKz0gbGluZUxlbmd0aCArIG5ld0xpbmVTZXFMZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcy5qb2luKCdcXG4nKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGUodmFsdWUpIHtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgcmVzID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB2YWx1ZVtpXTtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBpc1N0cmluZyhpdGVtKVxuICAgICAgICAgICAgICAgID8gcGFyc2VTdHJpbmdTdHlsZShpdGVtKVxuICAgICAgICAgICAgICAgIDogbm9ybWFsaXplU3R5bGUoaXRlbSk7XG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW2tleV0gPSBub3JtYWxpemVkW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuY29uc3QgbGlzdERlbGltaXRlclJFID0gLzsoPyFbXihdKlxcKSkvZztcbmNvbnN0IHByb3BlcnR5RGVsaW1pdGVyUkUgPSAvOihbXl0rKS87XG5jb25zdCBzdHlsZUNvbW1lbnRSRSA9IC9cXC9cXCouKj9cXCpcXC8vZ3M7XG5mdW5jdGlvbiBwYXJzZVN0cmluZ1N0eWxlKGNzc1RleHQpIHtcbiAgICBjb25zdCByZXQgPSB7fTtcbiAgICBjc3NUZXh0XG4gICAgICAgIC5yZXBsYWNlKHN0eWxlQ29tbWVudFJFLCAnJylcbiAgICAgICAgLnNwbGl0KGxpc3REZWxpbWl0ZXJSRSlcbiAgICAgICAgLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICBjb25zdCB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyUkUpO1xuICAgICAgICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJldFt0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVN0eWxlKHN0eWxlcykge1xuICAgIGxldCByZXQgPSAnJztcbiAgICBpZiAoIXN0eWxlcyB8fCBpc1N0cmluZyhzdHlsZXMpKSB7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHN0eWxlcykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHN0eWxlc1trZXldO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0ga2V5LnN0YXJ0c1dpdGgoYC0tYCkgPyBrZXkgOiBoeXBoZW5hdGUoa2V5KTtcbiAgICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAvLyBvbmx5IHJlbmRlciB2YWxpZCB2YWx1ZXNcbiAgICAgICAgICAgIHJldCArPSBgJHtub3JtYWxpemVkS2V5fToke3ZhbHVlfTtgO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDbGFzcyh2YWx1ZSkge1xuICAgIGxldCByZXMgPSAnJztcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHJlcyA9IHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplQ2xhc3ModmFsdWVbaV0pO1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICByZXMgKz0gbm9ybWFsaXplZCArICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICByZXMgKz0gbmFtZSArICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzLnRyaW0oKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzKHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHsgY2xhc3M6IGtsYXNzLCBzdHlsZSB9ID0gcHJvcHM7XG4gICAgaWYgKGtsYXNzICYmICFpc1N0cmluZyhrbGFzcykpIHtcbiAgICAgICAgcHJvcHMuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhrbGFzcyk7XG4gICAgfVxuICAgIGlmIChzdHlsZSkge1xuICAgICAgICBwcm9wcy5zdHlsZSA9IG5vcm1hbGl6ZVN0eWxlKHN0eWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BzO1xufVxuXG4vLyBUaGVzZSB0YWcgY29uZmlncyBhcmUgc2hhcmVkIGJldHdlZW4gY29tcGlsZXItZG9tIGFuZCBydW50aW1lLWRvbSwgc28gdGhleVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50XG5jb25zdCBIVE1MX1RBR1MgPSAnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlciwnICtcbiAgICAnaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LG5hdixzZWN0aW9uLGRpdixkZCxkbCxkdCxmaWdjYXB0aW9uLCcgK1xuICAgICdmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCxhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSwnICtcbiAgICAnZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ1YnkscyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsJyArXG4gICAgJ3RpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLGVtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsJyArXG4gICAgJ2NhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucyxjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCwnICtcbiAgICAndGgsdHIsYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLCcgK1xuICAgICdvcHRpb24sb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSxkZXRhaWxzLGRpYWxvZyxtZW51LCcgK1xuICAgICdzdW1tYXJ5LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290Jztcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9FbGVtZW50XG5jb25zdCBTVkdfVEFHUyA9ICdzdmcsYW5pbWF0ZSxhbmltYXRlTW90aW9uLGFuaW1hdGVUcmFuc2Zvcm0sY2lyY2xlLGNsaXBQYXRoLGNvbG9yLXByb2ZpbGUsJyArXG4gICAgJ2RlZnMsZGVzYyxkaXNjYXJkLGVsbGlwc2UsZmVCbGVuZCxmZUNvbG9yTWF0cml4LGZlQ29tcG9uZW50VHJhbnNmZXIsJyArXG4gICAgJ2ZlQ29tcG9zaXRlLGZlQ29udm9sdmVNYXRyaXgsZmVEaWZmdXNlTGlnaHRpbmcsZmVEaXNwbGFjZW1lbnRNYXAsJyArXG4gICAgJ2ZlRGlzdGFuY2VMaWdodCxmZURyb3BTaGFkb3csZmVGbG9vZCxmZUZ1bmNBLGZlRnVuY0IsZmVGdW5jRyxmZUZ1bmNSLCcgK1xuICAgICdmZUdhdXNzaWFuQmx1cixmZUltYWdlLGZlTWVyZ2UsZmVNZXJnZU5vZGUsZmVNb3JwaG9sb2d5LGZlT2Zmc2V0LCcgK1xuICAgICdmZVBvaW50TGlnaHQsZmVTcGVjdWxhckxpZ2h0aW5nLGZlU3BvdExpZ2h0LGZlVGlsZSxmZVR1cmJ1bGVuY2UsZmlsdGVyLCcgK1xuICAgICdmb3JlaWduT2JqZWN0LGcsaGF0Y2gsaGF0Y2hwYXRoLGltYWdlLGxpbmUsbGluZWFyR3JhZGllbnQsbWFya2VyLG1hc2ssJyArXG4gICAgJ21lc2gsbWVzaGdyYWRpZW50LG1lc2hwYXRjaCxtZXNocm93LG1ldGFkYXRhLG1wYXRoLHBhdGgscGF0dGVybiwnICtcbiAgICAncG9seWdvbixwb2x5bGluZSxyYWRpYWxHcmFkaWVudCxyZWN0LHNldCxzb2xpZGNvbG9yLHN0b3Asc3dpdGNoLHN5bWJvbCwnICtcbiAgICAndGV4dCx0ZXh0UGF0aCx0aXRsZSx0c3Bhbix1bmtub3duLHVzZSx2aWV3JztcbmNvbnN0IFZPSURfVEFHUyA9ICdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGhyLGltZyxpbnB1dCxsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicic7XG4vKipcbiAqIENvbXBpbGVyIG9ubHkuXG4gKiBEbyBOT1QgdXNlIGluIHJ1bnRpbWUgY29kZSBwYXRocyB1bmxlc3MgYmVoaW5kIGAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylgIGZsYWcuXG4gKi9cbmNvbnN0IGlzSFRNTFRhZyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChIVE1MX1RBR1MpO1xuLyoqXG4gKiBDb21waWxlciBvbmx5LlxuICogRG8gTk9UIHVzZSBpbiBydW50aW1lIGNvZGUgcGF0aHMgdW5sZXNzIGJlaGluZCBgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpYCBmbGFnLlxuICovXG5jb25zdCBpc1NWR1RhZyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChTVkdfVEFHUyk7XG4vKipcbiAqIENvbXBpbGVyIG9ubHkuXG4gKiBEbyBOT1QgdXNlIGluIHJ1bnRpbWUgY29kZSBwYXRocyB1bmxlc3MgYmVoaW5kIGAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylgIGZsYWcuXG4gKi9cbmNvbnN0IGlzVm9pZFRhZyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChWT0lEX1RBR1MpO1xuXG4vKipcbiAqIE9uIHRoZSBjbGllbnQgd2Ugb25seSBuZWVkIHRvIG9mZmVyIHNwZWNpYWwgY2FzZXMgZm9yIGJvb2xlYW4gYXR0cmlidXRlcyB0aGF0XG4gKiBoYXZlIGRpZmZlcmVudCBuYW1lcyBmcm9tIHRoZWlyIGNvcnJlc3BvbmRpbmcgZG9tIHByb3BlcnRpZXM6XG4gKiAtIGl0ZW1zY29wZSAtPiBOL0FcbiAqIC0gYWxsb3dmdWxsc2NyZWVuIC0+IGFsbG93RnVsbHNjcmVlblxuICogLSBmb3Jtbm92YWxpZGF0ZSAtPiBmb3JtTm9WYWxpZGF0ZVxuICogLSBpc21hcCAtPiBpc01hcFxuICogLSBub21vZHVsZSAtPiBub01vZHVsZVxuICogLSBub3ZhbGlkYXRlIC0+IG5vVmFsaWRhdGVcbiAqIC0gcmVhZG9ubHkgLT4gcmVhZE9ubHlcbiAqL1xuY29uc3Qgc3BlY2lhbEJvb2xlYW5BdHRycyA9IGBpdGVtc2NvcGUsYWxsb3dmdWxsc2NyZWVuLGZvcm1ub3ZhbGlkYXRlLGlzbWFwLG5vbW9kdWxlLG5vdmFsaWRhdGUscmVhZG9ubHlgO1xuY29uc3QgaXNTcGVjaWFsQm9vbGVhbkF0dHIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoc3BlY2lhbEJvb2xlYW5BdHRycyk7XG4vKipcbiAqIFRoZSBmdWxsIGxpc3QgaXMgbmVlZGVkIGR1cmluZyBTU1IgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBpbml0aWFsIG1hcmt1cC5cbiAqL1xuY29uc3QgaXNCb29sZWFuQXR0ciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChzcGVjaWFsQm9vbGVhbkF0dHJzICtcbiAgICBgLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjb250cm9scyxkZWZhdWx0LGRlZmVyLGRpc2FibGVkLGhpZGRlbixgICtcbiAgICBgbG9vcCxvcGVuLHJlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxgICtcbiAgICBgY2hlY2tlZCxtdXRlZCxtdWx0aXBsZSxzZWxlY3RlZGApO1xuLyoqXG4gKiBCb29sZWFuIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGlmIHRoZSB2YWx1ZSBpcyB0cnV0aHkgb3IgJycuXG4gKiBlLmcuIGA8c2VsZWN0IG11bHRpcGxlPmAgY29tcGlsZXMgdG8gYHsgbXVsdGlwbGU6ICcnIH1gXG4gKi9cbmZ1bmN0aW9uIGluY2x1ZGVCb29sZWFuQXR0cih2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlIHx8IHZhbHVlID09PSAnJztcbn1cbmNvbnN0IHVuc2FmZUF0dHJDaGFyUkUgPSAvWz4vPVwiJ1xcdTAwMDlcXHUwMDBhXFx1MDAwY1xcdTAwMjBdLztcbmNvbnN0IGF0dHJWYWxpZGF0aW9uQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGlzU1NSU2FmZUF0dHJOYW1lKG5hbWUpIHtcbiAgICBpZiAoYXR0clZhbGlkYXRpb25DYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICByZXR1cm4gYXR0clZhbGlkYXRpb25DYWNoZVtuYW1lXTtcbiAgICB9XG4gICAgY29uc3QgaXNVbnNhZmUgPSB1bnNhZmVBdHRyQ2hhclJFLnRlc3QobmFtZSk7XG4gICAgaWYgKGlzVW5zYWZlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYHVuc2FmZSBhdHRyaWJ1dGUgbmFtZTogJHtuYW1lfWApO1xuICAgIH1cbiAgICByZXR1cm4gKGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV0gPSAhaXNVbnNhZmUpO1xufVxuY29uc3QgcHJvcHNUb0F0dHJNYXAgPSB7XG4gICAgYWNjZXB0Q2hhcnNldDogJ2FjY2VwdC1jaGFyc2V0JyxcbiAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgaHRtbEZvcjogJ2ZvcicsXG4gICAgaHR0cEVxdWl2OiAnaHR0cC1lcXVpdidcbn07XG4vKipcbiAqIEtub3duIGF0dHJpYnV0ZXMsIHRoaXMgaXMgdXNlZCBmb3Igc3RyaW5naWZpY2F0aW9uIG9mIHJ1bnRpbWUgc3RhdGljIG5vZGVzXG4gKiBzbyB0aGF0IHdlIGRvbid0IHN0cmluZ2lmeSBiaW5kaW5ncyB0aGF0IGNhbm5vdCBiZSBzZXQgZnJvbSBIVE1MLlxuICogRG9uJ3QgYWxzbyBmb3JnZXQgdG8gYWxsb3cgYGRhdGEtKmAgYW5kIGBhcmlhLSpgIVxuICogR2VuZXJhdGVkIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9BdHRyaWJ1dGVzXG4gKi9cbmNvbnN0IGlzS25vd25IdG1sQXR0ciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChgYWNjZXB0LGFjY2VwdC1jaGFyc2V0LGFjY2Vzc2tleSxhY3Rpb24sYWxpZ24sYWxsb3csYWx0LGFzeW5jLGAgK1xuICAgIGBhdXRvY2FwaXRhbGl6ZSxhdXRvY29tcGxldGUsYXV0b2ZvY3VzLGF1dG9wbGF5LGJhY2tncm91bmQsYmdjb2xvcixgICtcbiAgICBgYm9yZGVyLGJ1ZmZlcmVkLGNhcHR1cmUsY2hhbGxlbmdlLGNoYXJzZXQsY2hlY2tlZCxjaXRlLGNsYXNzLGNvZGUsYCArXG4gICAgYGNvZGViYXNlLGNvbG9yLGNvbHMsY29sc3Bhbixjb250ZW50LGNvbnRlbnRlZGl0YWJsZSxjb250ZXh0bWVudSxjb250cm9scyxgICtcbiAgICBgY29vcmRzLGNyb3Nzb3JpZ2luLGNzcCxkYXRhLGRhdGV0aW1lLGRlY29kaW5nLGRlZmF1bHQsZGVmZXIsZGlyLGRpcm5hbWUsYCArXG4gICAgYGRpc2FibGVkLGRvd25sb2FkLGRyYWdnYWJsZSxkcm9wem9uZSxlbmN0eXBlLGVudGVya2V5aGludCxmb3IsZm9ybSxgICtcbiAgICBgZm9ybWFjdGlvbixmb3JtZW5jdHlwZSxmb3JtbWV0aG9kLGZvcm1ub3ZhbGlkYXRlLGZvcm10YXJnZXQsaGVhZGVycyxgICtcbiAgICBgaGVpZ2h0LGhpZGRlbixoaWdoLGhyZWYsaHJlZmxhbmcsaHR0cC1lcXVpdixpY29uLGlkLGltcG9ydGFuY2UsaW50ZWdyaXR5LGAgK1xuICAgIGBpc21hcCxpdGVtcHJvcCxrZXl0eXBlLGtpbmQsbGFiZWwsbGFuZyxsYW5ndWFnZSxsb2FkaW5nLGxpc3QsbG9vcCxsb3csYCArXG4gICAgYG1hbmlmZXN0LG1heCxtYXhsZW5ndGgsbWlubGVuZ3RoLG1lZGlhLG1pbixtdWx0aXBsZSxtdXRlZCxuYW1lLG5vdmFsaWRhdGUsYCArXG4gICAgYG9wZW4sb3B0aW11bSxwYXR0ZXJuLHBpbmcscGxhY2Vob2xkZXIscG9zdGVyLHByZWxvYWQscmFkaW9ncm91cCxyZWFkb25seSxgICtcbiAgICBgcmVmZXJyZXJwb2xpY3kscmVsLHJlcXVpcmVkLHJldmVyc2VkLHJvd3Mscm93c3BhbixzYW5kYm94LHNjb3BlLHNjb3BlZCxgICtcbiAgICBgc2VsZWN0ZWQsc2hhcGUsc2l6ZSxzaXplcyxzbG90LHNwYW4sc3BlbGxjaGVjayxzcmMsc3JjZG9jLHNyY2xhbmcsc3Jjc2V0LGAgK1xuICAgIGBzdGFydCxzdGVwLHN0eWxlLHN1bW1hcnksdGFiaW5kZXgsdGFyZ2V0LHRpdGxlLHRyYW5zbGF0ZSx0eXBlLHVzZW1hcCxgICtcbiAgICBgdmFsdWUsd2lkdGgsd3JhcGApO1xuLyoqXG4gKiBHZW5lcmF0ZWQgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlXG4gKi9cbmNvbnN0IGlzS25vd25TdmdBdHRyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGB4bWxucyxhY2NlbnQtaGVpZ2h0LGFjY3VtdWxhdGUsYWRkaXRpdmUsYWxpZ25tZW50LWJhc2VsaW5lLGFscGhhYmV0aWMsYW1wbGl0dWRlLGAgK1xuICAgIGBhcmFiaWMtZm9ybSxhc2NlbnQsYXR0cmlidXRlTmFtZSxhdHRyaWJ1dGVUeXBlLGF6aW11dGgsYmFzZUZyZXF1ZW5jeSxgICtcbiAgICBgYmFzZWxpbmUtc2hpZnQsYmFzZVByb2ZpbGUsYmJveCxiZWdpbixiaWFzLGJ5LGNhbGNNb2RlLGNhcC1oZWlnaHQsY2xhc3MsYCArXG4gICAgYGNsaXAsY2xpcFBhdGhVbml0cyxjbGlwLXBhdGgsY2xpcC1ydWxlLGNvbG9yLGNvbG9yLWludGVycG9sYXRpb24sYCArXG4gICAgYGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyxjb2xvci1wcm9maWxlLGNvbG9yLXJlbmRlcmluZyxgICtcbiAgICBgY29udGVudFNjcmlwdFR5cGUsY29udGVudFN0eWxlVHlwZSxjcm9zc29yaWdpbixjdXJzb3IsY3gsY3ksZCxkZWNlbGVyYXRlLGAgK1xuICAgIGBkZXNjZW50LGRpZmZ1c2VDb25zdGFudCxkaXJlY3Rpb24sZGlzcGxheSxkaXZpc29yLGRvbWluYW50LWJhc2VsaW5lLGR1cixkeCxgICtcbiAgICBgZHksZWRnZU1vZGUsZWxldmF0aW9uLGVuYWJsZS1iYWNrZ3JvdW5kLGVuZCxleHBvbmVudCxmaWxsLGZpbGwtb3BhY2l0eSxgICtcbiAgICBgZmlsbC1ydWxlLGZpbHRlcixmaWx0ZXJSZXMsZmlsdGVyVW5pdHMsZmxvb2QtY29sb3IsZmxvb2Qtb3BhY2l0eSxgICtcbiAgICBgZm9udC1mYW1pbHksZm9udC1zaXplLGZvbnQtc2l6ZS1hZGp1c3QsZm9udC1zdHJldGNoLGZvbnQtc3R5bGUsYCArXG4gICAgYGZvbnQtdmFyaWFudCxmb250LXdlaWdodCxmb3JtYXQsZnJvbSxmcixmeCxmeSxnMSxnMixnbHlwaC1uYW1lLGAgK1xuICAgIGBnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsLGdseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsLGdseXBoUmVmLGAgK1xuICAgIGBncmFkaWVudFRyYW5zZm9ybSxncmFkaWVudFVuaXRzLGhhbmdpbmcsaGVpZ2h0LGhyZWYsaHJlZmxhbmcsaG9yaXotYWR2LXgsYCArXG4gICAgYGhvcml6LW9yaWdpbi14LGlkLGlkZW9ncmFwaGljLGltYWdlLXJlbmRlcmluZyxpbixpbjIsaW50ZXJjZXB0LGssazEsazIsazMsYCArXG4gICAgYGs0LGtlcm5lbE1hdHJpeCxrZXJuZWxVbml0TGVuZ3RoLGtlcm5pbmcsa2V5UG9pbnRzLGtleVNwbGluZXMsa2V5VGltZXMsYCArXG4gICAgYGxhbmcsbGVuZ3RoQWRqdXN0LGxldHRlci1zcGFjaW5nLGxpZ2h0aW5nLWNvbG9yLGxpbWl0aW5nQ29uZUFuZ2xlLGxvY2FsLGAgK1xuICAgIGBtYXJrZXItZW5kLG1hcmtlci1taWQsbWFya2VyLXN0YXJ0LG1hcmtlckhlaWdodCxtYXJrZXJVbml0cyxtYXJrZXJXaWR0aCxgICtcbiAgICBgbWFzayxtYXNrQ29udGVudFVuaXRzLG1hc2tVbml0cyxtYXRoZW1hdGljYWwsbWF4LG1lZGlhLG1ldGhvZCxtaW4sbW9kZSxgICtcbiAgICBgbmFtZSxudW1PY3RhdmVzLG9mZnNldCxvcGFjaXR5LG9wZXJhdG9yLG9yZGVyLG9yaWVudCxvcmllbnRhdGlvbixvcmlnaW4sYCArXG4gICAgYG92ZXJmbG93LG92ZXJsaW5lLXBvc2l0aW9uLG92ZXJsaW5lLXRoaWNrbmVzcyxwYW5vc2UtMSxwYWludC1vcmRlcixwYXRoLGAgK1xuICAgIGBwYXRoTGVuZ3RoLHBhdHRlcm5Db250ZW50VW5pdHMscGF0dGVyblRyYW5zZm9ybSxwYXR0ZXJuVW5pdHMscGluZyxgICtcbiAgICBgcG9pbnRlci1ldmVudHMscG9pbnRzLHBvaW50c0F0WCxwb2ludHNBdFkscG9pbnRzQXRaLHByZXNlcnZlQWxwaGEsYCArXG4gICAgYHByZXNlcnZlQXNwZWN0UmF0aW8scHJpbWl0aXZlVW5pdHMscixyYWRpdXMscmVmZXJyZXJQb2xpY3kscmVmWCxyZWZZLHJlbCxgICtcbiAgICBgcmVuZGVyaW5nLWludGVudCxyZXBlYXRDb3VudCxyZXBlYXREdXIscmVxdWlyZWRFeHRlbnNpb25zLHJlcXVpcmVkRmVhdHVyZXMsYCArXG4gICAgYHJlc3RhcnQscmVzdWx0LHJvdGF0ZSxyeCxyeSxzY2FsZSxzZWVkLHNoYXBlLXJlbmRlcmluZyxzbG9wZSxzcGFjaW5nLGAgK1xuICAgIGBzcGVjdWxhckNvbnN0YW50LHNwZWN1bGFyRXhwb25lbnQsc3BlZWQsc3ByZWFkTWV0aG9kLHN0YXJ0T2Zmc2V0LGAgK1xuICAgIGBzdGREZXZpYXRpb24sc3RlbWgsc3RlbXYsc3RpdGNoVGlsZXMsc3RvcC1jb2xvcixzdG9wLW9wYWNpdHksYCArXG4gICAgYHN0cmlrZXRocm91Z2gtcG9zaXRpb24sc3RyaWtldGhyb3VnaC10aGlja25lc3Msc3RyaW5nLHN0cm9rZSxgICtcbiAgICBgc3Ryb2tlLWRhc2hhcnJheSxzdHJva2UtZGFzaG9mZnNldCxzdHJva2UtbGluZWNhcCxzdHJva2UtbGluZWpvaW4sYCArXG4gICAgYHN0cm9rZS1taXRlcmxpbWl0LHN0cm9rZS1vcGFjaXR5LHN0cm9rZS13aWR0aCxzdHlsZSxzdXJmYWNlU2NhbGUsYCArXG4gICAgYHN5c3RlbUxhbmd1YWdlLHRhYmluZGV4LHRhYmxlVmFsdWVzLHRhcmdldCx0YXJnZXRYLHRhcmdldFksdGV4dC1hbmNob3IsYCArXG4gICAgYHRleHQtZGVjb3JhdGlvbix0ZXh0LXJlbmRlcmluZyx0ZXh0TGVuZ3RoLHRvLHRyYW5zZm9ybSx0cmFuc2Zvcm0tb3JpZ2luLGAgK1xuICAgIGB0eXBlLHUxLHUyLHVuZGVybGluZS1wb3NpdGlvbix1bmRlcmxpbmUtdGhpY2tuZXNzLHVuaWNvZGUsdW5pY29kZS1iaWRpLGAgK1xuICAgIGB1bmljb2RlLXJhbmdlLHVuaXRzLXBlci1lbSx2LWFscGhhYmV0aWMsdi1oYW5naW5nLHYtaWRlb2dyYXBoaWMsYCArXG4gICAgYHYtbWF0aGVtYXRpY2FsLHZhbHVlcyx2ZWN0b3ItZWZmZWN0LHZlcnNpb24sdmVydC1hZHYteSx2ZXJ0LW9yaWdpbi14LGAgK1xuICAgIGB2ZXJ0LW9yaWdpbi15LHZpZXdCb3gsdmlld1RhcmdldCx2aXNpYmlsaXR5LHdpZHRoLHdpZHRocyx3b3JkLXNwYWNpbmcsYCArXG4gICAgYHdyaXRpbmctbW9kZSx4LHgtaGVpZ2h0LHgxLHgyLHhDaGFubmVsU2VsZWN0b3IseGxpbms6YWN0dWF0ZSx4bGluazphcmNyb2xlLGAgK1xuICAgIGB4bGluazpocmVmLHhsaW5rOnJvbGUseGxpbms6c2hvdyx4bGluazp0aXRsZSx4bGluazp0eXBlLHhtbDpiYXNlLHhtbDpsYW5nLGAgK1xuICAgIGB4bWw6c3BhY2UseSx5MSx5Mix5Q2hhbm5lbFNlbGVjdG9yLHosem9vbUFuZFBhbmApO1xuXG5jb25zdCBlc2NhcGVSRSA9IC9bXCInJjw+XS87XG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cmluZykge1xuICAgIGNvbnN0IHN0ciA9ICcnICsgc3RyaW5nO1xuICAgIGNvbnN0IG1hdGNoID0gZXNjYXBlUkUuZXhlYyhzdHIpO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbGV0IGh0bWwgPSAnJztcbiAgICBsZXQgZXNjYXBlZDtcbiAgICBsZXQgaW5kZXg7XG4gICAgbGV0IGxhc3RJbmRleCA9IDA7XG4gICAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgc3dpdGNoIChzdHIuY2hhckNvZGVBdChpbmRleCkpIHtcbiAgICAgICAgICAgIGNhc2UgMzQ6IC8vIFwiXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmcXVvdDsnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzODogLy8gJlxuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAnJmFtcDsnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOTogLy8gJ1xuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAnJiMzOTsnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2MDogLy8gPFxuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAnJmx0Oyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDYyOiAvLyA+XG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmZ3Q7JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgICAgICAgIGh0bWwgKz0gc3RyLnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgaHRtbCArPSBlc2NhcGVkO1xuICAgIH1cbiAgICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc2xpY2UobGFzdEluZGV4LCBpbmRleCkgOiBodG1sO1xufVxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1Mi9zeW50YXguaHRtbCNjb21tZW50c1xuY29uc3QgY29tbWVudFN0cmlwUkUgPSAvXi0/Pnw8IS0tfC0tPnwtLSE+fDwhLSQvZztcbmZ1bmN0aW9uIGVzY2FwZUh0bWxDb21tZW50KHNyYykge1xuICAgIHJldHVybiBzcmMucmVwbGFjZShjb21tZW50U3RyaXBSRSwgJycpO1xufVxuXG5mdW5jdGlvbiBsb29zZUNvbXBhcmVBcnJheXMoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZXF1YWwgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBlcXVhbCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBlcXVhbCA9IGxvb3NlRXF1YWwoYVtpXSwgYltpXSk7XG4gICAgfVxuICAgIHJldHVybiBlcXVhbDtcbn1cbmZ1bmN0aW9uIGxvb3NlRXF1YWwoYSwgYikge1xuICAgIGlmIChhID09PSBiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgYVZhbGlkVHlwZSA9IGlzRGF0ZShhKTtcbiAgICBsZXQgYlZhbGlkVHlwZSA9IGlzRGF0ZShiKTtcbiAgICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgICAgIHJldHVybiBhVmFsaWRUeXBlICYmIGJWYWxpZFR5cGUgPyBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKCkgOiBmYWxzZTtcbiAgICB9XG4gICAgYVZhbGlkVHlwZSA9IGlzU3ltYm9sKGEpO1xuICAgIGJWYWxpZFR5cGUgPSBpc1N5bWJvbChiKTtcbiAgICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgICAgIHJldHVybiBhID09PSBiO1xuICAgIH1cbiAgICBhVmFsaWRUeXBlID0gaXNBcnJheShhKTtcbiAgICBiVmFsaWRUeXBlID0gaXNBcnJheShiKTtcbiAgICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgICAgIHJldHVybiBhVmFsaWRUeXBlICYmIGJWYWxpZFR5cGUgPyBsb29zZUNvbXBhcmVBcnJheXMoYSwgYikgOiBmYWxzZTtcbiAgICB9XG4gICAgYVZhbGlkVHlwZSA9IGlzT2JqZWN0KGEpO1xuICAgIGJWYWxpZFR5cGUgPSBpc09iamVjdChiKTtcbiAgICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZjogdGhpcyBpZiB3aWxsIHByb2JhYmx5IG5ldmVyIGJlIGNhbGxlZCAqL1xuICAgICAgICBpZiAoIWFWYWxpZFR5cGUgfHwgIWJWYWxpZFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhS2V5c0NvdW50ID0gT2JqZWN0LmtleXMoYSkubGVuZ3RoO1xuICAgICAgICBjb25zdCBiS2V5c0NvdW50ID0gT2JqZWN0LmtleXMoYikubGVuZ3RoO1xuICAgICAgICBpZiAoYUtleXNDb3VudCAhPT0gYktleXNDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGEpIHtcbiAgICAgICAgICAgIGNvbnN0IGFIYXNLZXkgPSBhLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICAgICAgICBjb25zdCBiSGFzS2V5ID0gYi5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgICAgICAgICAgaWYgKChhSGFzS2V5ICYmICFiSGFzS2V5KSB8fFxuICAgICAgICAgICAgICAgICghYUhhc0tleSAmJiBiSGFzS2V5KSB8fFxuICAgICAgICAgICAgICAgICFsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYik7XG59XG5mdW5jdGlvbiBsb29zZUluZGV4T2YoYXJyLCB2YWwpIHtcbiAgICByZXR1cm4gYXJyLmZpbmRJbmRleChpdGVtID0+IGxvb3NlRXF1YWwoaXRlbSwgdmFsKSk7XG59XG5cbi8qKlxuICogRm9yIGNvbnZlcnRpbmcge3sgaW50ZXJwb2xhdGlvbiB9fSB2YWx1ZXMgdG8gZGlzcGxheWVkIHN0cmluZ3MuXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCB0b0Rpc3BsYXlTdHJpbmcgPSAodmFsKSA9PiB7XG4gICAgcmV0dXJuIGlzU3RyaW5nKHZhbClcbiAgICAgICAgPyB2YWxcbiAgICAgICAgOiB2YWwgPT0gbnVsbFxuICAgICAgICAgICAgPyAnJ1xuICAgICAgICAgICAgOiBpc0FycmF5KHZhbCkgfHxcbiAgICAgICAgICAgICAgICAoaXNPYmplY3QodmFsKSAmJlxuICAgICAgICAgICAgICAgICAgICAodmFsLnRvU3RyaW5nID09PSBvYmplY3RUb1N0cmluZyB8fCAhaXNGdW5jdGlvbih2YWwudG9TdHJpbmcpKSlcbiAgICAgICAgICAgICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgcmVwbGFjZXIsIDIpXG4gICAgICAgICAgICAgICAgOiBTdHJpbmcodmFsKTtcbn07XG5jb25zdCByZXBsYWNlciA9IChfa2V5LCB2YWwpID0+IHtcbiAgICAvLyBjYW4ndCB1c2UgaXNSZWYgaGVyZSBzaW5jZSBAdnVlL3NoYXJlZCBoYXMgbm8gZGVwc1xuICAgIGlmICh2YWwgJiYgdmFsLl9fdl9pc1JlZikge1xuICAgICAgICByZXR1cm4gcmVwbGFjZXIoX2tleSwgdmFsLnZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNNYXAodmFsKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW2BNYXAoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwuZW50cmllcygpXS5yZWR1Y2UoKGVudHJpZXMsIFtrZXksIHZhbF0pID0+IHtcbiAgICAgICAgICAgICAgICBlbnRyaWVzW2Ake2tleX0gPT5gXSA9IHZhbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cmllcztcbiAgICAgICAgICAgIH0sIHt9KVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1NldCh2YWwpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbYFNldCgke3ZhbC5zaXplfSlgXTogWy4uLnZhbC52YWx1ZXMoKV1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNPYmplY3QodmFsKSAmJiAhaXNBcnJheSh2YWwpICYmICFpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufTtcblxuY29uc3QgRU1QVFlfT0JKID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXG4gICAgPyBPYmplY3QuZnJlZXplKHt9KVxuICAgIDoge307XG5jb25zdCBFTVBUWV9BUlIgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBPYmplY3QuZnJlZXplKFtdKSA6IFtdO1xuY29uc3QgTk9PUCA9ICgpID0+IHsgfTtcbi8qKlxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cbiAqL1xuY29uc3QgTk8gPSAoKSA9PiBmYWxzZTtcbmNvbnN0IG9uUkUgPSAvXm9uW15hLXpdLztcbmNvbnN0IGlzT24gPSAoa2V5KSA9PiBvblJFLnRlc3Qoa2V5KTtcbmNvbnN0IGlzTW9kZWxMaXN0ZW5lciA9IChrZXkpID0+IGtleS5zdGFydHNXaXRoKCdvblVwZGF0ZTonKTtcbmNvbnN0IGV4dGVuZCA9IE9iamVjdC5hc3NpZ247XG5jb25zdCByZW1vdmUgPSAoYXJyLCBlbCkgPT4ge1xuICAgIGNvbnN0IGkgPSBhcnIuaW5kZXhPZihlbCk7XG4gICAgaWYgKGkgPiAtMSkge1xuICAgICAgICBhcnIuc3BsaWNlKGksIDEpO1xuICAgIH1cbn07XG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5jb25zdCBoYXNPd24gPSAodmFsLCBrZXkpID0+IGhhc093blByb3BlcnR5LmNhbGwodmFsLCBrZXkpO1xuY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5jb25zdCBpc01hcCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSAnW29iamVjdCBNYXBdJztcbmNvbnN0IGlzU2V0ID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09ICdbb2JqZWN0IFNldF0nO1xuY29uc3QgaXNEYXRlID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09ICdbb2JqZWN0IERhdGVdJztcbmNvbnN0IGlzRnVuY3Rpb24gPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nO1xuY29uc3QgaXNTdHJpbmcgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbmNvbnN0IGlzU3ltYm9sID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N5bWJvbCc7XG5jb25zdCBpc09iamVjdCA9ICh2YWwpID0+IHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JztcbmNvbnN0IGlzUHJvbWlzZSA9ICh2YWwpID0+IHtcbiAgICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC50aGVuKSAmJiBpc0Z1bmN0aW9uKHZhbC5jYXRjaCk7XG59O1xuY29uc3Qgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuY29uc3QgdG9UeXBlU3RyaW5nID0gKHZhbHVlKSA9PiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbmNvbnN0IHRvUmF3VHlwZSA9ICh2YWx1ZSkgPT4ge1xuICAgIC8vIGV4dHJhY3QgXCJSYXdUeXBlXCIgZnJvbSBzdHJpbmdzIGxpa2UgXCJbb2JqZWN0IFJhd1R5cGVdXCJcbiAgICByZXR1cm4gdG9UeXBlU3RyaW5nKHZhbHVlKS5zbGljZSg4LCAtMSk7XG59O1xuY29uc3QgaXNQbGFpbk9iamVjdCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSAnW29iamVjdCBPYmplY3RdJztcbmNvbnN0IGlzSW50ZWdlcktleSA9IChrZXkpID0+IGlzU3RyaW5nKGtleSkgJiZcbiAgICBrZXkgIT09ICdOYU4nICYmXG4gICAga2V5WzBdICE9PSAnLScgJiZcbiAgICAnJyArIHBhcnNlSW50KGtleSwgMTApID09PSBrZXk7XG5jb25zdCBpc1Jlc2VydmVkUHJvcCA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChcbi8vIHRoZSBsZWFkaW5nIGNvbW1hIGlzIGludGVudGlvbmFsIHNvIGVtcHR5IHN0cmluZyBcIlwiIGlzIGFsc28gaW5jbHVkZWRcbicsa2V5LHJlZixyZWZfZm9yLHJlZl9rZXksJyArXG4gICAgJ29uVm5vZGVCZWZvcmVNb3VudCxvblZub2RlTW91bnRlZCwnICtcbiAgICAnb25Wbm9kZUJlZm9yZVVwZGF0ZSxvblZub2RlVXBkYXRlZCwnICtcbiAgICAnb25Wbm9kZUJlZm9yZVVubW91bnQsb25Wbm9kZVVubW91bnRlZCcpO1xuY29uc3QgaXNCdWlsdEluRGlyZWN0aXZlID0gLyojX19QVVJFX18qLyBtYWtlTWFwKCdiaW5kLGNsb2FrLGVsc2UtaWYsZWxzZSxmb3IsaHRtbCxpZixtb2RlbCxvbixvbmNlLHByZSxzaG93LHNsb3QsdGV4dCxtZW1vJyk7XG5jb25zdCBjYWNoZVN0cmluZ0Z1bmN0aW9uID0gKGZuKSA9PiB7XG4gICAgY29uc3QgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJldHVybiAoKHN0cikgPT4ge1xuICAgICAgICBjb25zdCBoaXQgPSBjYWNoZVtzdHJdO1xuICAgICAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSk7XG4gICAgfSk7XG59O1xuY29uc3QgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgY2FtZWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgKF8sIGMpID0+IChjID8gYy50b1VwcGVyQ2FzZSgpIDogJycpKTtcbn0pO1xuY29uc3QgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBoeXBoZW5hdGUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnLSQxJykudG9Mb3dlckNhc2UoKSk7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGNhcGl0YWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKSk7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHRvSGFuZGxlcktleSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4gc3RyID8gYG9uJHtjYXBpdGFsaXplKHN0cil9YCA6IGBgKTtcbi8vIGNvbXBhcmUgd2hldGhlciBhIHZhbHVlIGhhcyBjaGFuZ2VkLCBhY2NvdW50aW5nIGZvciBOYU4uXG5jb25zdCBoYXNDaGFuZ2VkID0gKHZhbHVlLCBvbGRWYWx1ZSkgPT4gIU9iamVjdC5pcyh2YWx1ZSwgb2xkVmFsdWUpO1xuY29uc3QgaW52b2tlQXJyYXlGbnMgPSAoZm5zLCBhcmcpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmbnNbaV0oYXJnKTtcbiAgICB9XG59O1xuY29uc3QgZGVmID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZVxuICAgIH0pO1xufTtcbmNvbnN0IHRvTnVtYmVyID0gKHZhbCkgPT4ge1xuICAgIGNvbnN0IG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gICAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcbn07XG5sZXQgX2dsb2JhbFRoaXM7XG5jb25zdCBnZXRHbG9iYWxUaGlzID0gKCkgPT4ge1xuICAgIHJldHVybiAoX2dsb2JhbFRoaXMgfHxcbiAgICAgICAgKF9nbG9iYWxUaGlzID1cbiAgICAgICAgICAgIHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgID8gZ2xvYmFsVGhpc1xuICAgICAgICAgICAgICAgIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgID8gc2VsZlxuICAgICAgICAgICAgICAgICAgICA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHdpbmRvd1xuICAgICAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZ2xvYmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7fSkpO1xufTtcbmNvbnN0IGlkZW50UkUgPSAvXltfJGEtekEtWlxceEEwLVxcdUZGRkZdW18kYS16QS1aMC05XFx4QTAtXFx1RkZGRl0qJC87XG5mdW5jdGlvbiBnZW5Qcm9wc0FjY2Vzc0V4cChuYW1lKSB7XG4gICAgcmV0dXJuIGlkZW50UkUudGVzdChuYW1lKVxuICAgICAgICA/IGBfX3Byb3BzLiR7bmFtZX1gXG4gICAgICAgIDogYF9fcHJvcHNbJHtKU09OLnN0cmluZ2lmeShuYW1lKX1dYDtcbn1cblxuZXhwb3J0IHsgRU1QVFlfQVJSLCBFTVBUWV9PQkosIE5PLCBOT09QLCBQYXRjaEZsYWdOYW1lcywgY2FtZWxpemUsIGNhcGl0YWxpemUsIGRlZiwgZXNjYXBlSHRtbCwgZXNjYXBlSHRtbENvbW1lbnQsIGV4dGVuZCwgZ2VuUHJvcHNBY2Nlc3NFeHAsIGdlbmVyYXRlQ29kZUZyYW1lLCBnZXRHbG9iYWxUaGlzLCBoYXNDaGFuZ2VkLCBoYXNPd24sIGh5cGhlbmF0ZSwgaW5jbHVkZUJvb2xlYW5BdHRyLCBpbnZva2VBcnJheUZucywgaXNBcnJheSwgaXNCb29sZWFuQXR0ciwgaXNCdWlsdEluRGlyZWN0aXZlLCBpc0RhdGUsIGlzRnVuY3Rpb24sIGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCwgaXNIVE1MVGFnLCBpc0ludGVnZXJLZXksIGlzS25vd25IdG1sQXR0ciwgaXNLbm93blN2Z0F0dHIsIGlzTWFwLCBpc01vZGVsTGlzdGVuZXIsIGlzT2JqZWN0LCBpc09uLCBpc1BsYWluT2JqZWN0LCBpc1Byb21pc2UsIGlzUmVzZXJ2ZWRQcm9wLCBpc1NTUlNhZmVBdHRyTmFtZSwgaXNTVkdUYWcsIGlzU2V0LCBpc1NwZWNpYWxCb29sZWFuQXR0ciwgaXNTdHJpbmcsIGlzU3ltYm9sLCBpc1ZvaWRUYWcsIGxvb3NlRXF1YWwsIGxvb3NlSW5kZXhPZiwgbWFrZU1hcCwgbm9ybWFsaXplQ2xhc3MsIG5vcm1hbGl6ZVByb3BzLCBub3JtYWxpemVTdHlsZSwgb2JqZWN0VG9TdHJpbmcsIHBhcnNlU3RyaW5nU3R5bGUsIHByb3BzVG9BdHRyTWFwLCByZW1vdmUsIHNsb3RGbGFnc1RleHQsIHN0cmluZ2lmeVN0eWxlLCB0b0Rpc3BsYXlTdHJpbmcsIHRvSGFuZGxlcktleSwgdG9OdW1iZXIsIHRvUmF3VHlwZSwgdG9UeXBlU3RyaW5nIH07XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJhcHBcIj5cbiAgICA8QXBwSW5wdXQgdi1tb2RlbD1cImlucHV0VmFsdWVcIiBAaW5wdXQ9XCJoYW5kbGVySW5wdXRcIiAvPlxuICAgIHt7IGlucHV0VmFsdWUgfX1cbiAgICA8ZGl2PlxuICAgICAgPEFwcEl0ZW0gOnJlc3VsdD1cImRhdGFcIiAvPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQgbGFuZz1cInRzXCIgc2V0dXA+XG5pbXBvcnQgeyByZWYsIHJlYWN0aXZlIH0gZnJvbSAndnVlJztcblxuaW1wb3J0IEFwcElucHV0IGZyb20gJy4vQXBwSW5wdXQudnVlJztcblxuaW1wb3J0IEFwcEl0ZW0gZnJvbSAnLi9BcHBJdGVtJztcblxuY29uc3QgaW5wdXRWYWx1ZSA9IHJlZignJyk7XG5jb25zdCBpbnB1dEl0ZW1zID0gcmVhY3RpdmUoW10pO1xuY29uc3QgZGF0YSA9IHtcbiAgaWQ6IDEyLFxuICB0ZXh0OiAnSGVsbG8gd29ybGQhISEnLFxufTtcblxuY29uc3QgaGFuZGxlcklucHV0ID0gKGU6IFBvaW50ZXJFdmVudCkgPT4ge1xuICBjb25zdCB7IHZhbHVlIH0gPSBlLnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50O1xuXG4gIC8vIGlucHV0VmFsdWUudmFsdWUgPSB2YWx1ZTtcbiAgaW5wdXRJdGVtcy5wdXNoKHtcbiAgICBpZDogRGF0ZS5ub3coKSxcbiAgICB0ZXh0OiB2YWx1ZSxcbiAgfSk7XG59O1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiIHNjb3BlZD5cbi5hcHAge1xufVxuPC9zdHlsZT5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdj5cbiAgICB7eyByZXN1bHQgfX1cbiAgICA8ZGl2Pnt7IHJlc3VsdC5pZCB9fTwvZGl2PlxuICAgIDxkaXY+e3sgcmVzdWx0LnRleHQgfX08L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0IGxhbmc9XCJ0c1wiIHNldHVwPlxuaW1wb3J0IHsgZGVmaW5lUHJvcHMsIHJlYWN0aXZlIH0gZnJvbSAndnVlJztcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgcmVzdWx0OiB7XG4gICAgaWQ6IG51bWJlcjtcbiAgICB0ZXh0OiBzdHJpbmc7XG4gIH07XG59XG5cbmNvbnN0IHByb3BzID0gZGVmaW5lUHJvcHM8UHJvcHM+KCk7XG5jb25zdCByZXN1bHQgPSByZWFjdGl2ZShwcm9wcy5yZXN1bHQpO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiIHNjb3BlZD48L3N0eWxlPlxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwiYXBwXCI+XG4gICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgLz5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0IGxhbmc9XCJ0c1wiIHNldHVwPjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIiBzY29wZWQ+XG4uYXBwLWlucHV0IHtcbn1cbjwvc3R5bGU+XG4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIHJ1bnRpbWUgaGVscGVyIGZvciBzZXR0aW5nIHByb3BlcnRpZXMgb24gY29tcG9uZW50c1xuLy8gaW4gYSB0cmVlLXNoYWthYmxlIHdheVxuZXhwb3J0cy5kZWZhdWx0ID0gKHNmYywgcHJvcHMpID0+IHtcbiAgICBjb25zdCB0YXJnZXQgPSBzZmMuX192Y2NPcHRzIHx8IHNmYztcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgcHJvcHMpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuIiwiaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSBcIi4vQXBwLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD03ZTdmMDA2YyZzY29wZWQ9dHJ1ZSZ0cz10cnVlXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vQXBwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10cyZzZXR1cD10cnVlXCJcbmV4cG9ydCAqIGZyb20gXCIuL0FwcC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9dHMmc2V0dXA9dHJ1ZVwiXG5cbmltcG9ydCBcIi4vQXBwLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTdlN2YwMDZjJmxhbmc9c2NzcyZzY29wZWQ9dHJ1ZVwiXG5cbmltcG9ydCBleHBvcnRDb21wb25lbnQgZnJvbSBcIi9ob21lL2dvb2RsdWNrL0Rvd25sb2Fkcy90eXBlLXZ1ZS9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2V4cG9ydEhlbHBlci5qc1wiXG5jb25zdCBfX2V4cG9ydHNfXyA9IC8qI19fUFVSRV9fKi9leHBvcnRDb21wb25lbnQoc2NyaXB0LCBbWydyZW5kZXInLHJlbmRlcl0sWydfX3Njb3BlSWQnLFwiZGF0YS12LTdlN2YwMDZjXCJdLFsnX19maWxlJyxcInNyYy9hcHAvQXBwLnZ1ZVwiXV0pXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkge1xuICBfX2V4cG9ydHNfXy5fX2htcklkID0gXCI3ZTdmMDA2Y1wiXG4gIGNvbnN0IGFwaSA9IF9fVlVFX0hNUl9SVU5USU1FX19cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIWFwaS5jcmVhdGVSZWNvcmQoJzdlN2YwMDZjJywgX19leHBvcnRzX18pKSB7XG4gICAgYXBpLnJlbG9hZCgnN2U3ZjAwNmMnLCBfX2V4cG9ydHNfXylcbiAgfVxuICBcbiAgbW9kdWxlLmhvdC5hY2NlcHQoXCIuL0FwcC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9N2U3ZjAwNmMmc2NvcGVkPXRydWUmdHM9dHJ1ZVwiLCAoKSA9PiB7XG4gICAgYXBpLnJlcmVuZGVyKCc3ZTdmMDA2YycsIHJlbmRlcilcbiAgfSlcblxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IF9fZXhwb3J0c19fIiwiaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSBcIi4vQXBwSW5wdXQudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTQ0ZGZkNzUwJnNjb3BlZD10cnVlXCJcbmNvbnN0IHNjcmlwdCA9IHt9XG5cbmltcG9ydCBcIi4vQXBwSW5wdXQudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9NDRkZmQ3NTAmbGFuZz1zY3NzJnNjb3BlZD10cnVlXCJcblxuaW1wb3J0IGV4cG9ydENvbXBvbmVudCBmcm9tIFwiL2hvbWUvZ29vZGx1Y2svRG93bmxvYWRzL3R5cGUtdnVlL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvZXhwb3J0SGVscGVyLmpzXCJcbmNvbnN0IF9fZXhwb3J0c19fID0gLyojX19QVVJFX18qL2V4cG9ydENvbXBvbmVudChzY3JpcHQsIFtbJ3JlbmRlcicscmVuZGVyXSxbJ19fc2NvcGVJZCcsXCJkYXRhLXYtNDRkZmQ3NTBcIl0sWydfX2ZpbGUnLFwic3JjL2FwcC9BcHBJbnB1dC52dWVcIl1dKVxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgX19leHBvcnRzX18uX19obXJJZCA9IFwiNDRkZmQ3NTBcIlxuICBjb25zdCBhcGkgPSBfX1ZVRV9ITVJfUlVOVElNRV9fXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFhcGkuY3JlYXRlUmVjb3JkKCc0NGRmZDc1MCcsIF9fZXhwb3J0c19fKSkge1xuICAgIGFwaS5yZWxvYWQoJzQ0ZGZkNzUwJywgX19leHBvcnRzX18pXG4gIH1cbiAgXG4gIG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9BcHBJbnB1dC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NDRkZmQ3NTAmc2NvcGVkPXRydWVcIiwgKCkgPT4ge1xuICAgIGFwaS5yZXJlbmRlcignNDRkZmQ3NTAnLCByZW5kZXIpXG4gIH0pXG5cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBfX2V4cG9ydHNfXyIsImltcG9ydCB7IHJlbmRlciB9IGZyb20gXCIuL0FwcEl0ZW0udnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTRjOTY5NzA2JnRzPXRydWVcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9BcHBJdGVtLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10cyZzZXR1cD10cnVlXCJcbmV4cG9ydCAqIGZyb20gXCIuL0FwcEl0ZW0udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPXRzJnNldHVwPXRydWVcIlxuXG5pbXBvcnQgZXhwb3J0Q29tcG9uZW50IGZyb20gXCIvaG9tZS9nb29kbHVjay9Eb3dubG9hZHMvdHlwZS12dWUvbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9leHBvcnRIZWxwZXIuanNcIlxuY29uc3QgX19leHBvcnRzX18gPSAvKiNfX1BVUkVfXyovZXhwb3J0Q29tcG9uZW50KHNjcmlwdCwgW1sncmVuZGVyJyxyZW5kZXJdLFsnX19maWxlJyxcInNyYy9hcHAvQXBwSXRlbS52dWVcIl1dKVxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgX19leHBvcnRzX18uX19obXJJZCA9IFwiNGM5Njk3MDZcIlxuICBjb25zdCBhcGkgPSBfX1ZVRV9ITVJfUlVOVElNRV9fXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFhcGkuY3JlYXRlUmVjb3JkKCc0Yzk2OTcwNicsIF9fZXhwb3J0c19fKSkge1xuICAgIGFwaS5yZWxvYWQoJzRjOTY5NzA2JywgX19leHBvcnRzX18pXG4gIH1cbiAgXG4gIG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9BcHBJdGVtLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD00Yzk2OTcwNiZ0cz10cnVlXCIsICgpID0+IHtcbiAgICBhcGkucmVyZW5kZXIoJzRjOTY5NzA2JywgcmVuZGVyKVxuICB9KVxuXG59XG5cblxuZXhwb3J0IGRlZmF1bHQgX19leHBvcnRzX18iLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtMi51c2UhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFswXSEuL0FwcC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9dHMmc2V0dXA9dHJ1ZVwiOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC0yLnVzZSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzBdIS4vQXBwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10cyZzZXR1cD10cnVlXCIiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtMi51c2UhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFswXSEuL0FwcEl0ZW0udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPXRzJnNldHVwPXRydWVcIjsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtMi51c2UhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFswXSEuL0FwcEl0ZW0udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPXRzJnNldHVwPXRydWVcIiIsImltcG9ydCAqIGFzIHJ1bnRpbWVEb20gZnJvbSAnQHZ1ZS9ydW50aW1lLWRvbSc7XG5pbXBvcnQgeyBpbml0Q3VzdG9tRm9ybWF0dGVyLCB3YXJuLCByZWdpc3RlclJ1bnRpbWVDb21waWxlciB9IGZyb20gJ0B2dWUvcnVudGltZS1kb20nO1xuZXhwb3J0ICogZnJvbSAnQHZ1ZS9ydW50aW1lLWRvbSc7XG5pbXBvcnQgeyBjb21waWxlIH0gZnJvbSAnQHZ1ZS9jb21waWxlci1kb20nO1xuaW1wb3J0IHsgaXNTdHJpbmcsIE5PT1AsIGV4dGVuZCwgZ2VuZXJhdGVDb2RlRnJhbWUgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmZ1bmN0aW9uIGluaXREZXYoKSB7XG4gICAge1xuICAgICAgICBpbml0Q3VzdG9tRm9ybWF0dGVyKCk7XG4gICAgfVxufVxuXG4vLyBUaGlzIGVudHJ5IGlzIHRoZSBcImZ1bGwtYnVpbGRcIiB0aGF0IGluY2x1ZGVzIGJvdGggdGhlIHJ1bnRpbWVcbmlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICBpbml0RGV2KCk7XG59XG5jb25zdCBjb21waWxlQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gY29tcGlsZVRvRnVuY3Rpb24odGVtcGxhdGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIWlzU3RyaW5nKHRlbXBsYXRlKSkge1xuICAgICAgICBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAgICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuaW5uZXJIVE1MO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4oYGludmFsaWQgdGVtcGxhdGUgb3B0aW9uOiBgLCB0ZW1wbGF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gTk9PUDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBrZXkgPSB0ZW1wbGF0ZTtcbiAgICBjb25zdCBjYWNoZWQgPSBjb21waWxlQ2FjaGVba2V5XTtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZVswXSA9PT0gJyMnKSB7XG4gICAgICAgIGNvbnN0IGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0ZW1wbGF0ZSk7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWVsKSB7XG4gICAgICAgICAgICB3YXJuKGBUZW1wbGF0ZSBlbGVtZW50IG5vdCBmb3VuZCBvciBpcyBlbXB0eTogJHt0ZW1wbGF0ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBfX1VOU0FGRV9fXG4gICAgICAgIC8vIFJlYXNvbjogcG90ZW50aWFsIGV4ZWN1dGlvbiBvZiBKUyBleHByZXNzaW9ucyBpbiBpbi1ET00gdGVtcGxhdGUuXG4gICAgICAgIC8vIFRoZSB1c2VyIG11c3QgbWFrZSBzdXJlIHRoZSBpbi1ET00gdGVtcGxhdGUgaXMgdHJ1c3RlZC4gSWYgaXQncyByZW5kZXJlZFxuICAgICAgICAvLyBieSB0aGUgc2VydmVyLCB0aGUgdGVtcGxhdGUgc2hvdWxkIG5vdCBjb250YWluIGFueSB1c2VyIGRhdGEuXG4gICAgICAgIHRlbXBsYXRlID0gZWwgPyBlbC5pbm5lckhUTUwgOiBgYDtcbiAgICB9XG4gICAgY29uc3Qgb3B0cyA9IGV4dGVuZCh7XG4gICAgICAgIGhvaXN0U3RhdGljOiB0cnVlLFxuICAgICAgICBvbkVycm9yOiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBvbkVycm9yIDogdW5kZWZpbmVkLFxuICAgICAgICBvbldhcm46IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGUgPT4gb25FcnJvcihlLCB0cnVlKSA6IE5PT1BcbiAgICB9LCBvcHRpb25zKTtcbiAgICBpZiAoIW9wdHMuaXNDdXN0b21FbGVtZW50ICYmIHR5cGVvZiBjdXN0b21FbGVtZW50cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgb3B0cy5pc0N1c3RvbUVsZW1lbnQgPSB0YWcgPT4gISFjdXN0b21FbGVtZW50cy5nZXQodGFnKTtcbiAgICB9XG4gICAgY29uc3QgeyBjb2RlIH0gPSBjb21waWxlKHRlbXBsYXRlLCBvcHRzKTtcbiAgICBmdW5jdGlvbiBvbkVycm9yKGVyciwgYXNXYXJuaW5nID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGFzV2FybmluZ1xuICAgICAgICAgICAgPyBlcnIubWVzc2FnZVxuICAgICAgICAgICAgOiBgVGVtcGxhdGUgY29tcGlsYXRpb24gZXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YDtcbiAgICAgICAgY29uc3QgY29kZUZyYW1lID0gZXJyLmxvYyAmJlxuICAgICAgICAgICAgZ2VuZXJhdGVDb2RlRnJhbWUodGVtcGxhdGUsIGVyci5sb2Muc3RhcnQub2Zmc2V0LCBlcnIubG9jLmVuZC5vZmZzZXQpO1xuICAgICAgICB3YXJuKGNvZGVGcmFtZSA/IGAke21lc3NhZ2V9XFxuJHtjb2RlRnJhbWV9YCA6IG1lc3NhZ2UpO1xuICAgIH1cbiAgICAvLyBUaGUgd2lsZGNhcmQgaW1wb3J0IHJlc3VsdHMgaW4gYSBodWdlIG9iamVjdCB3aXRoIGV2ZXJ5IGV4cG9ydFxuICAgIC8vIHdpdGgga2V5cyB0aGF0IGNhbm5vdCBiZSBtYW5nbGVkLCBhbmQgY2FuIGJlIHF1aXRlIGhlYXZ5IHNpemUtd2lzZS5cbiAgICAvLyBJbiB0aGUgZ2xvYmFsIGJ1aWxkIHdlIGtub3cgYFZ1ZWAgaXMgYXZhaWxhYmxlIGdsb2JhbGx5IHNvIHdlIGNhbiBhdm9pZFxuICAgIC8vIHRoZSB3aWxkY2FyZCBvYmplY3QuXG4gICAgY29uc3QgcmVuZGVyID0gKG5ldyBGdW5jdGlvbignVnVlJywgY29kZSkocnVudGltZURvbSkpO1xuICAgIHJlbmRlci5fcmMgPSB0cnVlO1xuICAgIHJldHVybiAoY29tcGlsZUNhY2hlW2tleV0gPSByZW5kZXIpO1xufVxucmVnaXN0ZXJSdW50aW1lQ29tcGlsZXIoY29tcGlsZVRvRnVuY3Rpb24pO1xuXG5leHBvcnQgeyBjb21waWxlVG9GdW5jdGlvbiBhcyBjb21waWxlIH07XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJpbXBvcnQgJy4vdnVlLXNoaW0uZC50cyc7XG5pbXBvcnQgJy4vc2Nzcy9tYWluLnNjc3MnO1xuaW1wb3J0IHsgY3JlYXRlQXBwIH0gZnJvbSAndnVlJztcblxuaW1wb3J0IEFwcCBmcm9tICcuL2FwcC9BcHAudnVlJztcblxuY3JlYXRlQXBwKHtcbiAgY29tcG9uZW50czoge1xuICAgICd2dWUtdGVzdCc6IEFwcCxcbiAgfSxcbiAgdGVtcGxhdGU6ICc8dnVlLXRlc3QgLz4nLFxufSkubW91bnQoJyNhcHAnKTtcbiJdLCJuYW1lcyI6WyJyZWYiLCJyZWFjdGl2ZSIsIkFwcElucHV0IiwiQXBwSXRlbSIsImlucHV0VmFsdWUiLCJpbnB1dEl0ZW1zIiwiZGF0YSIsImlkIiwidGV4dCIsImhhbmRsZXJJbnB1dCIsImUiLCJ0YXJnZXQiLCJ2YWx1ZSIsInB1c2giLCJEYXRlIiwibm93IiwicmVzdWx0IiwicHJvcHMiLCJfY3JlYXRlRWxlbWVudEJsb2NrIiwiX2hvaXN0ZWRfMSIsIl9jcmVhdGVWTm9kZSIsIiRzZXR1cCIsIm9uSW5wdXQiLCJfY3JlYXRlRWxlbWVudFZOb2RlIiwidHlwZSIsIl9ob2lzdGVkXzIiLCJjcmVhdGVBcHAiLCJBcHAiLCJjb21wb25lbnRzIiwidGVtcGxhdGUiLCJtb3VudCJdLCJzb3VyY2VSb290IjoiIn0=